{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Tema 1. Introducci\u00f3 a la programaci\u00f3 Introducci\u00f3 Un programa \u00e9s: Segons el diccionari normatiu valenci\u00e0 (DNV) Conjunt d'instruccions detallades i codificades que es donen a un sistema inform\u00e0tic perqu\u00e8 execute unes determinades operacions. Segons el Termcat: Conjunt de dades i d'instruccions codificades que s\u00f3n l'expressi\u00f3 completa d'un procediment que pot executar un sistema inform\u00e0tic. Per tant programar podrien dir que \u00e9s l\u2019acci\u00f3 d\u2019elaborar un programa. En altres paraules un programa \u00e9s un conjunt d\u2019instruccions escrites en un llenguatge de programaci\u00f3 que s\u2019utilitzen per donar ordres o indicacions a un ordinador. En aquest primer tema, veure una s\u00e8rie de conceptes b\u00e0sics que seran necessaris per entendre que \u00e9s la programaci\u00f3. Conceptes b\u00e0sics Algorisme vs Programa Un algorisme \u00e9s un conjunt ordenat i finti d\u2019operacions o instruccions a seguir que permeten trobar la soluci\u00f3 a un problema. Per exemple: algorisme de la suma, la resta, la multiplicaci\u00f3 o la divisi\u00f3. Per tal de fer una suma de xifres de m\u00e9s d\u2019un digit cadascuna, el que es diu comunament sumar portant, hem de seguir unes \u2018instruccions\u2019 que si les realitzem de forma correcta, obtenim el resultat. Doncs b\u00e9, eixes \u2018instruccions\u2019 serien l\u2019algorisme. Un programa no \u00e9s m\u00e9s que un algorisme les \u2018instruccions\u2019 del qual les executa un ordinadorEn realitat aquesta fase Caracter\u00edstiques d'un programa Un algorisme posteriorment convertit a programa ha de complir una s\u00e8rie de caracter\u00edstiques: - Finit: ha de comen\u00e7ar i acabar. - Llegible: un programa s'escriu una vegada per\u00f2 es llig moltes. - Modificable: ha de poder evolucionar. - Eficient: No utilitza m\u00e9s recursos dels necessaris - Modular: s'ha de dividir en parts el qual millora la legibilitat. - Estructurat Llenguatges de programaci\u00f3 De la mateixa manera que dues persones es comuniquen entre s\u00ed utilitzant un llenguatge natural, una persona es comunica amb una m\u00e0quina utilitzant un llenguatge de programaci\u00f3. Evidentment, un llenguatge de programaci\u00f3 ha de ser m\u00e9s simple i gens ambigu al contrari de com passa amb els llenguatges naturals. Els llenguatges de programaci\u00f3 solen complir les seg\u00fcents caracter\u00edstiques: - Existeix un nombre finit de paraules reservades que podem usar: for, var, int, while... \u00c9s a dir, un llenguatge de programaci\u00f3 t\u00e9 un conjunt l\u00e8xic de paraules amb un significat associat com passa amb els llenguatges naturals. - Les frases com a combinaci\u00f3 de diferents paraules amb les que ens comuniquem en llenguatge natural es diuen instruccions - Cada instrucci\u00f3 finalitza d\u2019una manera concreta, per exemple, utilitzant un \u2018;\u2019 per tal que la m\u00e0quina sapiga quan acaba una instrucci\u00f3 i comen\u00e7a una altra. Classificaci\u00f3 Els llenguatges de programaci\u00f3 es poden classificar segons diversos criteris Proximitat a la m\u00e0quina Les m\u00e0quines en realitat nom\u00e9s entenen 0 i 1, hi han llenguatges de programaci\u00f3 molts pr\u00f2xims a aquest tipus de codificaci\u00f3 bin\u00e0ria per\u00f2 que s\u00f3n complicats d\u2019entendre per un \u00e9sser hum\u00e0. D\u2019una altra banda existeixen llenguatges que utilitzen un conjunt de paraules reservades que fan que siga m\u00e9s f\u00e0cil d\u2019entendre per una persona. Al final de tot aquest llenguatge m\u00e9s pr\u00f2xim al llenguatge hum\u00e0 acaba convertint-se en una seq\u00fc\u00e8ncia de 0 i 1 la m\u00e0quina pot entendre en el proc\u00e9s de compilaci\u00f3 que veurem m\u00e9s endavant. - Llenguatges de baix nivell: s\u00f3n els llenguatges m\u00e9s pr\u00f2xims al llenguatge m\u00e0quina com per exemple el llenguatge assemblador. - Llenguatges de nivell mitj\u00e0: llenguatges que s\u2019aproximen un poc m\u00e9s al llenguatge natural utilitzant una s\u00e8rie de paraules reservades que s\u2019utilitzen en llenguatge natural com per exemple el llenguatge C - Llenguatges d\u2019alt nivell: Els m\u00e9s pr\u00f2xims al llenguatge natural per\u00f2 sense ambig\u00fcitats. Proposit del llenguatge \u00c9s a dir segons quins tipus de programes poden generar - Llenguatges de prop\u00f2sit general que s\u00f3n capa\u00e7os de crear qualsevol tipus de programa. Llenguatge C - Llenguatges de prop\u00f2sit espec\u00edfic que es dissenyen per trEn realitat aquesta faselenguatges de programaci\u00f3, aquests han anat evolucionant i adaptant-se a les noves caracter\u00edstiques tant f\u00edsiques com d\u2019\u00fas del maquinari i els dispositius. - Primera Generaci\u00f3: llenguatges m\u00e0quina i llenguatges assemblador. Anys 40 \u2013 50. En aquesta \u00e8poca s\u2019usaven targetes perforades i es http://127.0.0.1:8000/programava utilitzant seq\u00fcencies d\u2019uns i zeros indicant quin c\u00e0lcul havien de realitzar els programes. Els llenguatges assemblador afegeixen la primera capa d\u2019abstracci\u00f3 sobre el binari de forma que una s\u00e8rie d\u2019instruccions simples s\u00f3n despr\u00e9s tradu\u00efdes a binari per la mateixa m\u00e0quina. Aquestes instruccions estaven directament relacionades amb el processador, \u00e9s a dir, cada processador tenia el seu conjunt d'instruccions propi. - Segona Generaci\u00f3: Apareixen els llenguatges de nivell mitj\u00e0 i els primers compiladors, que per que ho entenem de moment, s\u00f3n els encarregats de traduir d\u2019un llenguatge de programaci\u00f3 a llenguatge m\u00e0quina o binari. Exemple de llenguatge de nivell mitj\u00e0: FORTRAN (FORmula TRANSlating system) de l\u2019any 1956 - Tercera Generaci\u00f3: Apareix la programaci\u00f3 estructurada, ja no nom\u00e9s s\u2019utilitzen els llenguatges de programaci\u00f3 per realitzar c\u00e0lculs matem\u00e0tics com fins ara. Apareix tamb\u00e9 l\u2019\u00fas de variables, subprogrames, estructures etc.. En aquesta generaci\u00f3 podem trobar llenguatges de programaci\u00f3 com C, Pascal o Modula. - Quarta Generaci\u00f3: En aquesta generaci\u00f3 trobarem llenguatges desenvolupats per crear un determinat tipus de programari, es configuren per tasques molt concretes. - Cinquena Generaci\u00f3: on estarien els llenguatges dissenyats per afrontar la intel\u00b7lig\u00e8ncia artificial com per exemple Prolog. Comen\u00e7a tamb\u00e9 a posar-se en pr\u00e0ctica la programaci\u00f3 orientada a objectes com a nou paradigma de programaci\u00f3. - Generaci\u00f3 Visual: nascuda a principis dels anys 90 i com a conseq\u00fc\u00e8ncia de la necessitat de usar interf\u00edcies cada vegada m\u00e9s amigables i f\u00e0cils. Forma d'execuci\u00f3 Com havien dit abans, abans d\u2019executar un programa escrit en un llenguatge de programaci\u00f3 qualsevol, s\u2019ha de traduir al llenguatge que pot entendre la m\u00e0quina, binari. Aquest proc\u00e9s es pot fer de dues formes: - Llenguatges compilats: per tal de compilar un programa es realitzen les seg\u00fcents tasques: an\u00e0lisi l\u00e8xic, sint\u00e0ctic i sem\u00e0ntic del programa, traducci\u00f3 a codi objecte, enlla\u00e7 amb altres llibreries i creaci\u00f3 de l\u2019executable. - Llenguatges interpretats: Aquest tipus de codis es lligen,Un diagrama de flux \u00e9s una representaci\u00f3 gr\u00e0fica d'un algorisme. S'utilitza en disciplines com la programaci\u00f3 inform\u00e0tica, l'economia, els processos industrials o la psicologia cognitiva. Aquests diagrames utilitzen s\u00edmbols amb significats ben definits que representen els passos de l'algorisme, i representen el flux d'execuci\u00f3 mitjan\u00e7ant fletxes que connecten els punts d'inici i de finalitzaci\u00f3. Un diagrama de flux sempre t\u00e9 un \u00fanic punt d'inici i un \u00fanic punt de finalitzaci\u00f3. A m\u00e9s, tot cam\u00ed d'execuci\u00f3 ha de permetre arribar des de l'inici fins al final. Les seg\u00fcents s\u00f3n accions pr\u00e8vies a la realitzaci\u00f3 del diagrama de flux: Identificar les idees principals que s'han d'incloure en el diagrama de flux. Han d'estar presents el propietari o responsable del proc\u00e9s, els propietaris o responsables del proc\u00e9s anterior i posterior i d'altres processos interrelacionats, aix\u00ed com les terceres parts interessades. Definir qu\u00e8 s'espera obtenir del diagrama de flux. Identificar qui ho far\u00e0 servir i com. Establir el nivell de detall requerit. Determinar els l\u00edmits del proc\u00e9s a descriure. Els passos a seguir per construir el diagrama de flux s\u00f3n: Establir l'abast del proc\u00e9s a descriure. D'aquesta manera quedar\u00e0 fixat el comen\u00e7ament i el final del diagrama. Sovint el comen\u00e7ament \u00e9s la sortida del proc\u00e9s previ i el final l'entrada al proc\u00e9s seg\u00fcent. Identificar i llistar les principals activitats/subprocessos que estan incloses en el proc\u00e9s a descriure i el seu ordre cronol\u00f2gic. Si el nivell de detall definit inclou activitats menors, llistar-les tamb\u00e9. Identificar i llistar els punts de decisi\u00f3. Construir el diagrama respectant la seq\u00fc\u00e8ncia cronol\u00f2gica i assignant els corresponents s\u00edmbols. Assignar un t\u00edtol al diagrama i verificar que estigui complet i descrigui amb exactitud el proc\u00e9s escollit.s a la m\u00e0quina i els declaratius que plantegen una s\u00e8rie de regles sobre les quals es construeix la soluci\u00f3. Aquests \u00faltims s\u2019utilitzen en Intel\u00b7lig\u00e8ncia artificial. Paradigma de programaci\u00f3 Programaci\u00f3 estructurada: Utilitzen les estructures b\u00e0siques de programaci\u00f3: seq\u00fcencial, alternativa i iterativa combinats amb la programaci\u00f3 modular per dissenyar programes. Programaci\u00f3 orientada a objectes: Entenen els programes com un conjunt d\u2019objectes que tenen unes caracter\u00edstiques pr\u00f2pies, uns m\u00e8todes i que interactuen amb els altres objectes que formen part del sistema. Segons el nombre de processos \u00c9s a dir, si permeten la execuci\u00f3 concurrent, m\u00e9s d\u2019un proc\u00e9s al mateix temps o no. Per tant ens podem trobar: - Llenguatges de programaci\u00f3 concurrent que permeten la concurr\u00e8ncia - Llenguatges de programaci\u00f3 no concurrent. Segons interactivitat Si permeten la interacci\u00f3 amb l\u2019usuari o no. Visuals o no ten la programaci\u00f3 per reutilitzaci\u00f3 de components mitjan\u00e7ant drag and drop en un entorn gr\u00e0fic o no. Paraules reservades Els llenguatges de programaci\u00f3 utilitzen una s\u00e8rie de paraules o s\u00edmbols que fan una funci\u00f3 espec\u00edfica dins d\u2019un programa. A aquest conjunt de signes o combinaci\u00f3 d\u2019ells se les anomena paraules reservades. Aquestes paraules nom\u00e9s poden usar-se en un concepte determinat, mai lliurement per l\u2019usuari. Per exemple, el llenguatge C t\u00e9 com a paraules reservades if o while. Ambdues nom\u00e9s podran ser utilitzades en cas que es vullga iniciar una sent\u00e8ncia de control condicional o bucle. Fases de desenvolupament d'un programa A l\u2019hora d\u2019afrontar la realitzaci\u00f3 d\u2019un programa hem de tindre clar que hem de fer. \u00c9s un error comen\u00e7ar a crear programari a lo loco ja que nom\u00e9s conseguirem deicar a aquest menester m\u00e9s temps que el que es necessita. A m\u00e9s a m\u00e9s el proc\u00e9s de creaci\u00f3 d\u2019un programa no nom\u00e9s \u00e9s picar codi. D\u2019aquesta manera a l\u2019hora de construir un programa es deurien seguir una s\u00e8rie de fases o pautes: An\u00e0lisi del problema Estudi del problema, quina \u00e9s la seua finalitat, a qui va dirigit, quins elements ha d\u2019incloure, quines tasques ha de realitzar. En aquesta fase es realitzen entrevistes amb els usuaris o clients entre d\u2019altres t\u00e8cniques. La finalitat d\u2019aquesta fase \u00e9s fer un recull dels diferents requeriments que ha de tenir el nostre producte. Exemple: Imaginem que ens disposem a fer una aplicaci\u00f3 que gestione la fruteria del barri. En aquesta fase \u00e9s on hauriem d'esbrinar, entre altres coses: quins productes es venen, quin preu tenen, l'agenda de clients, quina informaci\u00f3 volem saber dels clients, quina informaci\u00f3 volem saber de prove\u00efdors etc. Suposem que ens farem c\u00e0rrec d'una part xicoteta d'aquesta aplicaci\u00f3: la introducci\u00f3 de tickets de compra nous . En aquesta fase podriem extreure que a un ticket de compra necessitaria que es reflexara la seg\u00fcent informaci\u00f3: - Data i hora de la compra. - Llista de productes comprats: producte, preu uniitari, quantitat i total. - Subtotal de la compra. - IVA i descomptes aplicats. - Total de la compra. Producte: Requeriments del sistema o aplicaci\u00f3. En base a la informaci\u00f3 que hem aconseguit per mitja d'entrevistes, enquestes etc.. En altres paraules: el que ha de fer la nostra aplicaci\u00f3, finalitat, objectius. Disseny de l'algorisme Es refereix a com anem a sol\u00b7lucionar els requeriments obtiguts a la fase anterior. En aquesta fase s'estudien possibles opcions d'implementaci\u00f3 per a l'aplicaci\u00f3 que hem de construir, aix\u00ed com decidir l'estructura general de la mateixa. El disseny \u00e9s una estapa complexa i el seu proc\u00e9s s'ha de realitzar d'una forma iterativa. Es possible que la soluci\u00f3 inicial no siga la m\u00e9s adequada, per tant en tal cas s'hauria de redefinir. Tammateix, hi ha cat\u00e0legs de patrons de disseny molt \u00fatils que recullen errades que altres han com\u00e9s per no caure a la mateixa trampa. Exemple: Continuant en la nostra aplicaci\u00f3 de la fruteria, en aquesta fase i una vegada acabada la fase d'an\u00e0lisi d'on s'obtenen els requeriments, hauriem de, per un costat triar el paradigma de programaci\u00f3 que escollirem: programaci\u00f3 estructurada o programaci\u00f3 orientada a objectes (Normalment aquest \u00faltim). El llenguatge de programaci\u00f3 a utilitzar. Una vegada ja ho hem triat, hem de decidir com el nostre programa va a complir amb els requeriments obtesos a la fase d'analisi, \u00e9s a dir, com crearem el nou ticket de compra, com afegirem els productes i com calcularem el preu final i imprimirem el document. Producte: Si hem triat el paradigma de programaci\u00f3 estructurada hauriem de dissenyar els diagramres flux de les diferents funcionalitats de l'aplicaci\u00f3, el pseudocodi, etc.. Per exemple en aquesta fase es dissenyaria l'alogorisme en pseudocodi o diagrama de flux on s'indique pas a pas com es faria la introducci\u00f3 d'un ticket nou. En canvi, si pel contrari escollim el paradigma de programaci\u00f3 orientada a objectes obtindriem casos d'\u00fas, diagrames de classes, diagrames de comportament en UML. Codificaci\u00f3 Ha arribat el moment de picar codi. A la fase de codificaci\u00f3, ens arriben els documents (pseudocodi, flux, diagrames de classes, UML) necessaris per poder comen\u00e7ar a programar. En aquesta fase hem d'escollir les eines (IDEs) adequades per poder desenvolupar el nostre projecte i tamb\u00e9 escollirem (va lligat en realitat) el llenguatge de programaci\u00f3 Exemple: seguint amb la fruteria i suposant que ens han passat un pseudocodi de la nostra apliaci\u00f3 de generaci\u00f3 de tickets, podriem per exemple triar l'IDE Visual Studio Code i C# com a llenguatge de programaci\u00f3 o l'IDE Eclipse i Java o Visual Studio i Java... Producte: El projecte amb tots els fitxers que tenen el codi desenvolupat aix\u00ed com tamb\u00e9 els executables o binaris ja compilats i funcionant. Prova i depuraci\u00f3 Com que errar es d'humans, la fase de proves del cicle de vida de programari busca detectar els errors comesos en les etapes anteriors per tal de poder corregir-los. Per supost, all\u00f2 ideal \u00e9s fer-ho abans que l'usuari final se'ls trobe. Es diu que una prova amb exit \u00e9s una prova que detecta algun error. Documentaci\u00f3 Aquesta \u00e9s la fase que a cap programador li agrada fer, per\u00f2 en realitat \u00e9s una fase que no est\u00e0 necess\u00e0riament al final del cicle de vida del programa, sino que es fa de forma transversal en totes les etapes del desenvolupament. Es considera documentaci\u00f3 des dels requeriments inicials al manual d'usuari passant per el pseudocodi, diagrames de classes i \u00fas, i tamb\u00e9 els comentaris que es posen al codi. Diagrames de flux Un diagrama de flux \u00e9s una representaci\u00f3 gr\u00e0fica d'un algorisme. S'utilitza en disciplines com la programaci\u00f3 inform\u00e0tica, l'economia, els processos industrials o la psicologia cognitiva. Aquests diagrames utilitzen s\u00edmbols amb significats ben definits que representen els passos de l'algorisme, i representen el flux d'execuci\u00f3 mitjan\u00e7ant fletxes que connecten els punts d'inici i de finalitzaci\u00f3. Un diagrama de flux sempre t\u00e9 un \u00fanic punt d'inici i un \u00fanic punt de finalitzaci\u00f3. A m\u00e9s, tot cam\u00ed d'execuci\u00f3 ha de permetre arribar des de l'inici fins al final. Les seg\u00fcents s\u00f3n accions pr\u00e8vies a la realitzaci\u00f3 del diagrama de flux: Identificar les idees principals que s'han d'incloure en el diagrama de flux. Han d'estar presents el propietari o responsable del proc\u00e9s, els propietaris o responsables del proc\u00e9s anterior i posterior i d'altres processos interrelacionats, aix\u00ed com les terceres parts interessades. Definir qu\u00e8 s'espera obtenir del diagrama de flux. Identificar qui ho far\u00e0 servir i com. Establir el nivell de detall requerit. Determinar els l\u00edmits del proc\u00e9s a descriure. Els passos a seguir per construir el diagrama de flux s\u00f3n: Establir l'abast del proc\u00e9s a descriure. D'aquesta manera quedar\u00e0 fixat el comen\u00e7ament i el final del diagrama. Sovint el comen\u00e7ament \u00e9s la sortida del proc\u00e9s previ i el final l'entrada al proc\u00e9s seg\u00fcent. Identificar i llistar les principals activitats/subprocessos que estan incloses en el proc\u00e9s a descriure i el seu ordre cronol\u00f2gic. Si el nivell de detall definit inclou activitats menors, llistar-les tamb\u00e9. Identificar i llistar els punts de decisi\u00f3. Construir el diagrama respectant la seq\u00fc\u00e8ncia cronol\u00f2gica i assignant els corresponents s\u00edmbols. Assignar un t\u00edtol al diagrama i verificar que estigui complet i descrigui amb exactitud el proc\u00e9s escollit. Simbologia i significat Oval o el\u00b7lipse: inici i final (obre i/o tanca el diagrama). Rectangle: activitat (representa l'execuci\u00f3 d'una o m\u00e9s activitats o procediments). Rombe: decisi\u00f3 (formula una pregunta o q\u00fcesti\u00f3). Cercle: connector (representa l'enlla\u00e7 d'activitats amb una altra dins d'un procediment). Triangle cap per avall: fitxer definitiu (guarda un document de forma permanent). Triangle cap per amunt: fitxer temporal (proporciona un temps per a l'emmagatzematge del document). Exemple. La nostra fruiteria A la imatge seg\u00fcent podem observar un exemple d'algorisme de creaci\u00f3 d'un nou ticket (nova compra). Expliquem breument el que fa aquest diagrama: primer crea un nou ticket i afegeix un nou element (fruta o verdura), aquesta acci\u00f3 \u00faltima es repeteix fins que acabe de comprar. Quan s'acaba d'afegir items al nou ticket, es calcula el preu final i s'imprimeix. Pseudocodi El pseudocodi (o fals llenguatge) \u00e9s una descripci\u00f3 a molt alt nivell de l'estructura d'un programa. Encara que utilitze estructures t\u00edpiques de la programaci\u00f3 es diu que \u00e9s a alt nivell perqu\u00e8 una persona amb pocs o sense coneixements inform\u00e0tics pugui entendre i interpretar la porci\u00f3 de codi que estigui llegint. Seguint amb l'exemple anterior, farem el mateix disseny fet amb diagrames de flux per\u00f2 aquesta vegada utilitzant pseudocodi. createTicket(); fer { afegirElement(); } mentre continue comprant calcularPreuFinal(); ImprimirTicket(); Proc\u00e9s de compilaci\u00f3 \u00c9s el proc\u00e9s pel qual es tradueixen les instruccions escrites en un determinat llenguatge de programaci\u00f3 a llenguatge m\u00e0quina. A m\u00e9s d'un traductor, es poden necessitar altres programes per crear un programa objecte executable. Un programa font es pot dividir en m\u00f2duls emmagatzemats en arxius diferents. La tasca de reunir el programa font sovint es confia a un programa diferent, anomenat preprocessador. El preprocessador tamb\u00e9 pot expandir abreviatures, crides a macros, a proposicions del llenguatge font. Normalment la creaci\u00f3 d'un programa executable (un t\u00edpic.exe per a Microsoft Windows o DOS) comporta dos passos. El primer pas es diu compilaci\u00f3 ( pr\u00f2piament dit) i tradueix el codi font escrit en un llenguatge de programaci\u00f3 emmagatzemat en un arxiu a codi de baix nivell (normalment en codi objecte, no directament a llenguatge m\u00e0quina). El segon pas es diu enlla\u00e7at en el qual s'enlla\u00e7a el codi de baix nivell generat de tots els fitxers i subprogrames que s'han enviat compilar i s'afegeix el codi de les funcions que hi ha a les biblioteques del compilador perqu\u00e8 l'executable pugui comunicar-se directament amb el sistema operatiu, traduint aix\u00ed finalment el codi objecte a codi m\u00e0quina, i generant un m\u00f2dul executable. Aquests dos passos es poden fer per separat, emmagatzemant el resultat de la fase de compilaci\u00f3 en arxius objectes (un t\u00edpic .obj per a Microsoft Windows, DOS o per a Unix ), per a enlla\u00e7ar-los en fases posteriors, o crear directament l'executable, amb la qual cosa la fase de compilaci\u00f3 s'emmagatzema nom\u00e9s temporalment. Un programa podria tenir parts escrites en diversos llenguatges (per exemple C, C + + i Asm), que es podrien compilar de forma independent i despr\u00e9s enlla\u00e7ar juntes per formar un \u00fanic m\u00f2dul executable.","title":"Tema 1. Introducci\u00f3 a la programaci\u00f3"},{"location":"#tema-1-introduccio-a-la-programacio","text":"","title":"Tema 1. Introducci\u00f3 a la programaci\u00f3"},{"location":"#introduccio","text":"Un programa \u00e9s: Segons el diccionari normatiu valenci\u00e0 (DNV) Conjunt d'instruccions detallades i codificades que es donen a un sistema inform\u00e0tic perqu\u00e8 execute unes determinades operacions. Segons el Termcat: Conjunt de dades i d'instruccions codificades que s\u00f3n l'expressi\u00f3 completa d'un procediment que pot executar un sistema inform\u00e0tic. Per tant programar podrien dir que \u00e9s l\u2019acci\u00f3 d\u2019elaborar un programa. En altres paraules un programa \u00e9s un conjunt d\u2019instruccions escrites en un llenguatge de programaci\u00f3 que s\u2019utilitzen per donar ordres o indicacions a un ordinador. En aquest primer tema, veure una s\u00e8rie de conceptes b\u00e0sics que seran necessaris per entendre que \u00e9s la programaci\u00f3.","title":"Introducci\u00f3"},{"location":"#conceptes-basics","text":"","title":"Conceptes b\u00e0sics"},{"location":"#algorisme-vs-programa","text":"Un algorisme \u00e9s un conjunt ordenat i finti d\u2019operacions o instruccions a seguir que permeten trobar la soluci\u00f3 a un problema. Per exemple: algorisme de la suma, la resta, la multiplicaci\u00f3 o la divisi\u00f3. Per tal de fer una suma de xifres de m\u00e9s d\u2019un digit cadascuna, el que es diu comunament sumar portant, hem de seguir unes \u2018instruccions\u2019 que si les realitzem de forma correcta, obtenim el resultat. Doncs b\u00e9, eixes \u2018instruccions\u2019 serien l\u2019algorisme. Un programa no \u00e9s m\u00e9s que un algorisme les \u2018instruccions\u2019 del qual les executa un ordinadorEn realitat aquesta fase","title":"Algorisme vs Programa"},{"location":"#caracteristiques-dun-programa","text":"Un algorisme posteriorment convertit a programa ha de complir una s\u00e8rie de caracter\u00edstiques: - Finit: ha de comen\u00e7ar i acabar. - Llegible: un programa s'escriu una vegada per\u00f2 es llig moltes. - Modificable: ha de poder evolucionar. - Eficient: No utilitza m\u00e9s recursos dels necessaris - Modular: s'ha de dividir en parts el qual millora la legibilitat. - Estructurat","title":"Caracter\u00edstiques d'un programa"},{"location":"#llenguatges-de-programacio","text":"De la mateixa manera que dues persones es comuniquen entre s\u00ed utilitzant un llenguatge natural, una persona es comunica amb una m\u00e0quina utilitzant un llenguatge de programaci\u00f3. Evidentment, un llenguatge de programaci\u00f3 ha de ser m\u00e9s simple i gens ambigu al contrari de com passa amb els llenguatges naturals. Els llenguatges de programaci\u00f3 solen complir les seg\u00fcents caracter\u00edstiques: - Existeix un nombre finit de paraules reservades que podem usar: for, var, int, while... \u00c9s a dir, un llenguatge de programaci\u00f3 t\u00e9 un conjunt l\u00e8xic de paraules amb un significat associat com passa amb els llenguatges naturals. - Les frases com a combinaci\u00f3 de diferents paraules amb les que ens comuniquem en llenguatge natural es diuen instruccions - Cada instrucci\u00f3 finalitza d\u2019una manera concreta, per exemple, utilitzant un \u2018;\u2019 per tal que la m\u00e0quina sapiga quan acaba una instrucci\u00f3 i comen\u00e7a una altra.","title":"Llenguatges de programaci\u00f3"},{"location":"#classificacio","text":"Els llenguatges de programaci\u00f3 es poden classificar segons diversos criteris","title":"Classificaci\u00f3"},{"location":"#proximitat-a-la-maquina","text":"Les m\u00e0quines en realitat nom\u00e9s entenen 0 i 1, hi han llenguatges de programaci\u00f3 molts pr\u00f2xims a aquest tipus de codificaci\u00f3 bin\u00e0ria per\u00f2 que s\u00f3n complicats d\u2019entendre per un \u00e9sser hum\u00e0. D\u2019una altra banda existeixen llenguatges que utilitzen un conjunt de paraules reservades que fan que siga m\u00e9s f\u00e0cil d\u2019entendre per una persona. Al final de tot aquest llenguatge m\u00e9s pr\u00f2xim al llenguatge hum\u00e0 acaba convertint-se en una seq\u00fc\u00e8ncia de 0 i 1 la m\u00e0quina pot entendre en el proc\u00e9s de compilaci\u00f3 que veurem m\u00e9s endavant. - Llenguatges de baix nivell: s\u00f3n els llenguatges m\u00e9s pr\u00f2xims al llenguatge m\u00e0quina com per exemple el llenguatge assemblador. - Llenguatges de nivell mitj\u00e0: llenguatges que s\u2019aproximen un poc m\u00e9s al llenguatge natural utilitzant una s\u00e8rie de paraules reservades que s\u2019utilitzen en llenguatge natural com per exemple el llenguatge C - Llenguatges d\u2019alt nivell: Els m\u00e9s pr\u00f2xims al llenguatge natural per\u00f2 sense ambig\u00fcitats.","title":"Proximitat a la m\u00e0quina"},{"location":"#proposit-del-llenguatge","text":"\u00c9s a dir segons quins tipus de programes poden generar - Llenguatges de prop\u00f2sit general que s\u00f3n capa\u00e7os de crear qualsevol tipus de programa. Llenguatge C - Llenguatges de prop\u00f2sit espec\u00edfic que es dissenyen per trEn realitat aquesta faselenguatges de programaci\u00f3, aquests han anat evolucionant i adaptant-se a les noves caracter\u00edstiques tant f\u00edsiques com d\u2019\u00fas del maquinari i els dispositius. - Primera Generaci\u00f3: llenguatges m\u00e0quina i llenguatges assemblador. Anys 40 \u2013 50. En aquesta \u00e8poca s\u2019usaven targetes perforades i es http://127.0.0.1:8000/programava utilitzant seq\u00fcencies d\u2019uns i zeros indicant quin c\u00e0lcul havien de realitzar els programes. Els llenguatges assemblador afegeixen la primera capa d\u2019abstracci\u00f3 sobre el binari de forma que una s\u00e8rie d\u2019instruccions simples s\u00f3n despr\u00e9s tradu\u00efdes a binari per la mateixa m\u00e0quina. Aquestes instruccions estaven directament relacionades amb el processador, \u00e9s a dir, cada processador tenia el seu conjunt d'instruccions propi. - Segona Generaci\u00f3: Apareixen els llenguatges de nivell mitj\u00e0 i els primers compiladors, que per que ho entenem de moment, s\u00f3n els encarregats de traduir d\u2019un llenguatge de programaci\u00f3 a llenguatge m\u00e0quina o binari. Exemple de llenguatge de nivell mitj\u00e0: FORTRAN (FORmula TRANSlating system) de l\u2019any 1956 - Tercera Generaci\u00f3: Apareix la programaci\u00f3 estructurada, ja no nom\u00e9s s\u2019utilitzen els llenguatges de programaci\u00f3 per realitzar c\u00e0lculs matem\u00e0tics com fins ara. Apareix tamb\u00e9 l\u2019\u00fas de variables, subprogrames, estructures etc.. En aquesta generaci\u00f3 podem trobar llenguatges de programaci\u00f3 com C, Pascal o Modula. - Quarta Generaci\u00f3: En aquesta generaci\u00f3 trobarem llenguatges desenvolupats per crear un determinat tipus de programari, es configuren per tasques molt concretes. - Cinquena Generaci\u00f3: on estarien els llenguatges dissenyats per afrontar la intel\u00b7lig\u00e8ncia artificial com per exemple Prolog. Comen\u00e7a tamb\u00e9 a posar-se en pr\u00e0ctica la programaci\u00f3 orientada a objectes com a nou paradigma de programaci\u00f3. - Generaci\u00f3 Visual: nascuda a principis dels anys 90 i com a conseq\u00fc\u00e8ncia de la necessitat de usar interf\u00edcies cada vegada m\u00e9s amigables i f\u00e0cils.","title":"Proposit del llenguatge"},{"location":"#forma-dexecucio","text":"Com havien dit abans, abans d\u2019executar un programa escrit en un llenguatge de programaci\u00f3 qualsevol, s\u2019ha de traduir al llenguatge que pot entendre la m\u00e0quina, binari. Aquest proc\u00e9s es pot fer de dues formes: - Llenguatges compilats: per tal de compilar un programa es realitzen les seg\u00fcents tasques: an\u00e0lisi l\u00e8xic, sint\u00e0ctic i sem\u00e0ntic del programa, traducci\u00f3 a codi objecte, enlla\u00e7 amb altres llibreries i creaci\u00f3 de l\u2019executable. - Llenguatges interpretats: Aquest tipus de codis es lligen,Un diagrama de flux \u00e9s una representaci\u00f3 gr\u00e0fica d'un algorisme. S'utilitza en disciplines com la programaci\u00f3 inform\u00e0tica, l'economia, els processos industrials o la psicologia cognitiva. Aquests diagrames utilitzen s\u00edmbols amb significats ben definits que representen els passos de l'algorisme, i representen el flux d'execuci\u00f3 mitjan\u00e7ant fletxes que connecten els punts d'inici i de finalitzaci\u00f3. Un diagrama de flux sempre t\u00e9 un \u00fanic punt d'inici i un \u00fanic punt de finalitzaci\u00f3. A m\u00e9s, tot cam\u00ed d'execuci\u00f3 ha de permetre arribar des de l'inici fins al final. Les seg\u00fcents s\u00f3n accions pr\u00e8vies a la realitzaci\u00f3 del diagrama de flux: Identificar les idees principals que s'han d'incloure en el diagrama de flux. Han d'estar presents el propietari o responsable del proc\u00e9s, els propietaris o responsables del proc\u00e9s anterior i posterior i d'altres processos interrelacionats, aix\u00ed com les terceres parts interessades. Definir qu\u00e8 s'espera obtenir del diagrama de flux. Identificar qui ho far\u00e0 servir i com. Establir el nivell de detall requerit. Determinar els l\u00edmits del proc\u00e9s a descriure. Els passos a seguir per construir el diagrama de flux s\u00f3n: Establir l'abast del proc\u00e9s a descriure. D'aquesta manera quedar\u00e0 fixat el comen\u00e7ament i el final del diagrama. Sovint el comen\u00e7ament \u00e9s la sortida del proc\u00e9s previ i el final l'entrada al proc\u00e9s seg\u00fcent. Identificar i llistar les principals activitats/subprocessos que estan incloses en el proc\u00e9s a descriure i el seu ordre cronol\u00f2gic. Si el nivell de detall definit inclou activitats menors, llistar-les tamb\u00e9. Identificar i llistar els punts de decisi\u00f3. Construir el diagrama respectant la seq\u00fc\u00e8ncia cronol\u00f2gica i assignant els corresponents s\u00edmbols. Assignar un t\u00edtol al diagrama i verificar que estigui complet i descrigui amb exactitud el proc\u00e9s escollit.s a la m\u00e0quina i els declaratius que plantegen una s\u00e8rie de regles sobre les quals es construeix la soluci\u00f3. Aquests \u00faltims s\u2019utilitzen en Intel\u00b7lig\u00e8ncia artificial.","title":"Forma d'execuci\u00f3"},{"location":"#paradigma-de-programacio","text":"Programaci\u00f3 estructurada: Utilitzen les estructures b\u00e0siques de programaci\u00f3: seq\u00fcencial, alternativa i iterativa combinats amb la programaci\u00f3 modular per dissenyar programes. Programaci\u00f3 orientada a objectes: Entenen els programes com un conjunt d\u2019objectes que tenen unes caracter\u00edstiques pr\u00f2pies, uns m\u00e8todes i que interactuen amb els altres objectes que formen part del sistema.","title":"Paradigma de programaci\u00f3"},{"location":"#segons-el-nombre-de-processos","text":"\u00c9s a dir, si permeten la execuci\u00f3 concurrent, m\u00e9s d\u2019un proc\u00e9s al mateix temps o no. Per tant ens podem trobar: - Llenguatges de programaci\u00f3 concurrent que permeten la concurr\u00e8ncia - Llenguatges de programaci\u00f3 no concurrent.","title":"Segons el nombre de processos"},{"location":"#segons-interactivitat","text":"Si permeten la interacci\u00f3 amb l\u2019usuari o no.","title":"Segons interactivitat"},{"location":"#visuals-o-no","text":"ten la programaci\u00f3 per reutilitzaci\u00f3 de components mitjan\u00e7ant drag and drop en un entorn gr\u00e0fic o no.","title":"Visuals o no"},{"location":"#paraules-reservades","text":"Els llenguatges de programaci\u00f3 utilitzen una s\u00e8rie de paraules o s\u00edmbols que fan una funci\u00f3 espec\u00edfica dins d\u2019un programa. A aquest conjunt de signes o combinaci\u00f3 d\u2019ells se les anomena paraules reservades. Aquestes paraules nom\u00e9s poden usar-se en un concepte determinat, mai lliurement per l\u2019usuari. Per exemple, el llenguatge C t\u00e9 com a paraules reservades if o while. Ambdues nom\u00e9s podran ser utilitzades en cas que es vullga iniciar una sent\u00e8ncia de control condicional o bucle.","title":"Paraules reservades"},{"location":"#fases-de-desenvolupament-dun-programa","text":"A l\u2019hora d\u2019afrontar la realitzaci\u00f3 d\u2019un programa hem de tindre clar que hem de fer. \u00c9s un error comen\u00e7ar a crear programari a lo loco ja que nom\u00e9s conseguirem deicar a aquest menester m\u00e9s temps que el que es necessita. A m\u00e9s a m\u00e9s el proc\u00e9s de creaci\u00f3 d\u2019un programa no nom\u00e9s \u00e9s picar codi. D\u2019aquesta manera a l\u2019hora de construir un programa es deurien seguir una s\u00e8rie de fases o pautes:","title":"Fases de desenvolupament d'un programa"},{"location":"#analisi-del-problema","text":"Estudi del problema, quina \u00e9s la seua finalitat, a qui va dirigit, quins elements ha d\u2019incloure, quines tasques ha de realitzar. En aquesta fase es realitzen entrevistes amb els usuaris o clients entre d\u2019altres t\u00e8cniques. La finalitat d\u2019aquesta fase \u00e9s fer un recull dels diferents requeriments que ha de tenir el nostre producte. Exemple: Imaginem que ens disposem a fer una aplicaci\u00f3 que gestione la fruteria del barri. En aquesta fase \u00e9s on hauriem d'esbrinar, entre altres coses: quins productes es venen, quin preu tenen, l'agenda de clients, quina informaci\u00f3 volem saber dels clients, quina informaci\u00f3 volem saber de prove\u00efdors etc. Suposem que ens farem c\u00e0rrec d'una part xicoteta d'aquesta aplicaci\u00f3: la introducci\u00f3 de tickets de compra nous . En aquesta fase podriem extreure que a un ticket de compra necessitaria que es reflexara la seg\u00fcent informaci\u00f3: - Data i hora de la compra. - Llista de productes comprats: producte, preu uniitari, quantitat i total. - Subtotal de la compra. - IVA i descomptes aplicats. - Total de la compra. Producte: Requeriments del sistema o aplicaci\u00f3. En base a la informaci\u00f3 que hem aconseguit per mitja d'entrevistes, enquestes etc.. En altres paraules: el que ha de fer la nostra aplicaci\u00f3, finalitat, objectius.","title":"An\u00e0lisi del problema"},{"location":"#disseny-de-lalgorisme","text":"Es refereix a com anem a sol\u00b7lucionar els requeriments obtiguts a la fase anterior. En aquesta fase s'estudien possibles opcions d'implementaci\u00f3 per a l'aplicaci\u00f3 que hem de construir, aix\u00ed com decidir l'estructura general de la mateixa. El disseny \u00e9s una estapa complexa i el seu proc\u00e9s s'ha de realitzar d'una forma iterativa. Es possible que la soluci\u00f3 inicial no siga la m\u00e9s adequada, per tant en tal cas s'hauria de redefinir. Tammateix, hi ha cat\u00e0legs de patrons de disseny molt \u00fatils que recullen errades que altres han com\u00e9s per no caure a la mateixa trampa. Exemple: Continuant en la nostra aplicaci\u00f3 de la fruteria, en aquesta fase i una vegada acabada la fase d'an\u00e0lisi d'on s'obtenen els requeriments, hauriem de, per un costat triar el paradigma de programaci\u00f3 que escollirem: programaci\u00f3 estructurada o programaci\u00f3 orientada a objectes (Normalment aquest \u00faltim). El llenguatge de programaci\u00f3 a utilitzar. Una vegada ja ho hem triat, hem de decidir com el nostre programa va a complir amb els requeriments obtesos a la fase d'analisi, \u00e9s a dir, com crearem el nou ticket de compra, com afegirem els productes i com calcularem el preu final i imprimirem el document. Producte: Si hem triat el paradigma de programaci\u00f3 estructurada hauriem de dissenyar els diagramres flux de les diferents funcionalitats de l'aplicaci\u00f3, el pseudocodi, etc.. Per exemple en aquesta fase es dissenyaria l'alogorisme en pseudocodi o diagrama de flux on s'indique pas a pas com es faria la introducci\u00f3 d'un ticket nou. En canvi, si pel contrari escollim el paradigma de programaci\u00f3 orientada a objectes obtindriem casos d'\u00fas, diagrames de classes, diagrames de comportament en UML.","title":"Disseny de l'algorisme"},{"location":"#codificacio","text":"Ha arribat el moment de picar codi. A la fase de codificaci\u00f3, ens arriben els documents (pseudocodi, flux, diagrames de classes, UML) necessaris per poder comen\u00e7ar a programar. En aquesta fase hem d'escollir les eines (IDEs) adequades per poder desenvolupar el nostre projecte i tamb\u00e9 escollirem (va lligat en realitat) el llenguatge de programaci\u00f3 Exemple: seguint amb la fruteria i suposant que ens han passat un pseudocodi de la nostra apliaci\u00f3 de generaci\u00f3 de tickets, podriem per exemple triar l'IDE Visual Studio Code i C# com a llenguatge de programaci\u00f3 o l'IDE Eclipse i Java o Visual Studio i Java... Producte: El projecte amb tots els fitxers que tenen el codi desenvolupat aix\u00ed com tamb\u00e9 els executables o binaris ja compilats i funcionant.","title":"Codificaci\u00f3"},{"location":"#prova-i-depuracio","text":"Com que errar es d'humans, la fase de proves del cicle de vida de programari busca detectar els errors comesos en les etapes anteriors per tal de poder corregir-los. Per supost, all\u00f2 ideal \u00e9s fer-ho abans que l'usuari final se'ls trobe. Es diu que una prova amb exit \u00e9s una prova que detecta algun error.","title":"Prova i depuraci\u00f3"},{"location":"#documentacio","text":"Aquesta \u00e9s la fase que a cap programador li agrada fer, per\u00f2 en realitat \u00e9s una fase que no est\u00e0 necess\u00e0riament al final del cicle de vida del programa, sino que es fa de forma transversal en totes les etapes del desenvolupament. Es considera documentaci\u00f3 des dels requeriments inicials al manual d'usuari passant per el pseudocodi, diagrames de classes i \u00fas, i tamb\u00e9 els comentaris que es posen al codi.","title":"Documentaci\u00f3"},{"location":"#diagrames-de-flux","text":"Un diagrama de flux \u00e9s una representaci\u00f3 gr\u00e0fica d'un algorisme. S'utilitza en disciplines com la programaci\u00f3 inform\u00e0tica, l'economia, els processos industrials o la psicologia cognitiva. Aquests diagrames utilitzen s\u00edmbols amb significats ben definits que representen els passos de l'algorisme, i representen el flux d'execuci\u00f3 mitjan\u00e7ant fletxes que connecten els punts d'inici i de finalitzaci\u00f3. Un diagrama de flux sempre t\u00e9 un \u00fanic punt d'inici i un \u00fanic punt de finalitzaci\u00f3. A m\u00e9s, tot cam\u00ed d'execuci\u00f3 ha de permetre arribar des de l'inici fins al final. Les seg\u00fcents s\u00f3n accions pr\u00e8vies a la realitzaci\u00f3 del diagrama de flux: Identificar les idees principals que s'han d'incloure en el diagrama de flux. Han d'estar presents el propietari o responsable del proc\u00e9s, els propietaris o responsables del proc\u00e9s anterior i posterior i d'altres processos interrelacionats, aix\u00ed com les terceres parts interessades. Definir qu\u00e8 s'espera obtenir del diagrama de flux. Identificar qui ho far\u00e0 servir i com. Establir el nivell de detall requerit. Determinar els l\u00edmits del proc\u00e9s a descriure. Els passos a seguir per construir el diagrama de flux s\u00f3n: Establir l'abast del proc\u00e9s a descriure. D'aquesta manera quedar\u00e0 fixat el comen\u00e7ament i el final del diagrama. Sovint el comen\u00e7ament \u00e9s la sortida del proc\u00e9s previ i el final l'entrada al proc\u00e9s seg\u00fcent. Identificar i llistar les principals activitats/subprocessos que estan incloses en el proc\u00e9s a descriure i el seu ordre cronol\u00f2gic. Si el nivell de detall definit inclou activitats menors, llistar-les tamb\u00e9. Identificar i llistar els punts de decisi\u00f3. Construir el diagrama respectant la seq\u00fc\u00e8ncia cronol\u00f2gica i assignant els corresponents s\u00edmbols. Assignar un t\u00edtol al diagrama i verificar que estigui complet i descrigui amb exactitud el proc\u00e9s escollit.","title":"Diagrames de flux"},{"location":"#simbologia-i-significat","text":"Oval o el\u00b7lipse: inici i final (obre i/o tanca el diagrama). Rectangle: activitat (representa l'execuci\u00f3 d'una o m\u00e9s activitats o procediments). Rombe: decisi\u00f3 (formula una pregunta o q\u00fcesti\u00f3). Cercle: connector (representa l'enlla\u00e7 d'activitats amb una altra dins d'un procediment). Triangle cap per avall: fitxer definitiu (guarda un document de forma permanent). Triangle cap per amunt: fitxer temporal (proporciona un temps per a l'emmagatzematge del document).","title":"Simbologia i significat"},{"location":"#exemple-la-nostra-fruiteria","text":"A la imatge seg\u00fcent podem observar un exemple d'algorisme de creaci\u00f3 d'un nou ticket (nova compra). Expliquem breument el que fa aquest diagrama: primer crea un nou ticket i afegeix un nou element (fruta o verdura), aquesta acci\u00f3 \u00faltima es repeteix fins que acabe de comprar. Quan s'acaba d'afegir items al nou ticket, es calcula el preu final i s'imprimeix.","title":"Exemple. La nostra fruiteria"},{"location":"#pseudocodi","text":"El pseudocodi (o fals llenguatge) \u00e9s una descripci\u00f3 a molt alt nivell de l'estructura d'un programa. Encara que utilitze estructures t\u00edpiques de la programaci\u00f3 es diu que \u00e9s a alt nivell perqu\u00e8 una persona amb pocs o sense coneixements inform\u00e0tics pugui entendre i interpretar la porci\u00f3 de codi que estigui llegint. Seguint amb l'exemple anterior, farem el mateix disseny fet amb diagrames de flux per\u00f2 aquesta vegada utilitzant pseudocodi. createTicket(); fer { afegirElement(); } mentre continue comprant calcularPreuFinal(); ImprimirTicket();","title":"Pseudocodi"},{"location":"#proces-de-compilacio","text":"\u00c9s el proc\u00e9s pel qual es tradueixen les instruccions escrites en un determinat llenguatge de programaci\u00f3 a llenguatge m\u00e0quina. A m\u00e9s d'un traductor, es poden necessitar altres programes per crear un programa objecte executable. Un programa font es pot dividir en m\u00f2duls emmagatzemats en arxius diferents. La tasca de reunir el programa font sovint es confia a un programa diferent, anomenat preprocessador. El preprocessador tamb\u00e9 pot expandir abreviatures, crides a macros, a proposicions del llenguatge font. Normalment la creaci\u00f3 d'un programa executable (un t\u00edpic.exe per a Microsoft Windows o DOS) comporta dos passos. El primer pas es diu compilaci\u00f3 ( pr\u00f2piament dit) i tradueix el codi font escrit en un llenguatge de programaci\u00f3 emmagatzemat en un arxiu a codi de baix nivell (normalment en codi objecte, no directament a llenguatge m\u00e0quina). El segon pas es diu enlla\u00e7at en el qual s'enlla\u00e7a el codi de baix nivell generat de tots els fitxers i subprogrames que s'han enviat compilar i s'afegeix el codi de les funcions que hi ha a les biblioteques del compilador perqu\u00e8 l'executable pugui comunicar-se directament amb el sistema operatiu, traduint aix\u00ed finalment el codi objecte a codi m\u00e0quina, i generant un m\u00f2dul executable. Aquests dos passos es poden fer per separat, emmagatzemant el resultat de la fase de compilaci\u00f3 en arxius objectes (un t\u00edpic .obj per a Microsoft Windows, DOS o per a Unix ), per a enlla\u00e7ar-los en fases posteriors, o crear directament l'executable, amb la qual cosa la fase de compilaci\u00f3 s'emmagatzema nom\u00e9s temporalment. Un programa podria tenir parts escrites en diversos llenguatges (per exemple C, C + + i Asm), que es podrien compilar de forma independent i despr\u00e9s enlla\u00e7ar juntes per formar un \u00fanic m\u00f2dul executable.","title":"Proc\u00e9s de compilaci\u00f3"},{"location":"Tema%205/","text":"Tipus Compostos de Dades Introducci\u00f3","title":"Tipus Compostos de Dades"},{"location":"Tema%205/#tipus-compostos-de-dades","text":"","title":"Tipus Compostos de Dades"},{"location":"Tema%205/#introduccio","text":"","title":"Introducci\u00f3"}]}