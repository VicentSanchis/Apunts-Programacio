{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CONTINGUTS DEL CURS","text":"Tema 1. Introducci\u00f3 Programaci\u00f3 <p>\u00cdNDEX</p> <ul> <li>1. Intrducci\u00f3: Hola m\u00f3n! Benvinguts al m\u00f3n de la programaci\u00f3.</li> <li>2. Conceptes b\u00e0sics: els essencials per poder programar.</li> <li>3. Fases de desenvolupament: an\u00e0lisi, disseny, codificaci\u00f3, prova i documentaci\u00f3.</li> <li>4. Proc\u00e9s de compilaci\u00f3: Convertir codi en executables.</li> <li>5. Entorns integrats de desenvolupament: aplicacions que faciliten la tasca de programar.</li> </ul> Tema 2. Programaci\u00f3 Estructurada <p>\u00cdNDEX</p> <ul> <li>1. Intrducci\u00f3: Qu\u00e8 \u00e9s la programaci\u00f3 estructurada i que suposa.</li> <li>2. Conceptes b\u00e0sics: all\u00f2 essencial per poder comen\u00e7ar a entendre la programaci\u00f3.</li> <li>3. Diagrames de flux: t\u00e8cnica gr\u00e0fica de disseny d'algorismes.</li> <li>4. Estructures: Estructures derivades del Teorema d'estructura</li> <li>5. Estructura seq\u00fcencial: una darrere de l'altra</li> <li>6. Estructura selecci\u00f3: estructura per poder triar diversos fluxos d'execuci\u00f3</li> <li>7. Estructura iterativa: estructura per poder repetir instruccions i fer bucles.</li> </ul> Tema 03. El llenguatge Java <p>\u00cdNDEX</p> <ul> <li>1. Introducci\u00f3: Com apliquem tot all\u00f2 vist als temes anteriors a un llenguatge de programaci\u00f3 concret com es Java?</li> <li>2. Dades, variables i identificadors: o com usem la informaci\u00f3 i les dades en un llenguatge de programaci\u00f3</li> <li>3. Paraules reservades: aquelles paraules o mots propietat del llenguatge de programaci\u00f3</li> <li>4. Tipus de dades: tipus d'informaci\u00f3 que pot usar el llenguatge i com</li> <li>5. Variables: contenidors d'informaci\u00f3 amb una etiqueta i un tipus de dades associats</li> <li>6. Constants: valors immutables durant l'execuci\u00f3 del programa</li> <li>7. Comentaris: text no compilable i part de la documentaci\u00f3 de les aplicacions</li> <li>8. Operadors i expressions: simbols utilitzats per fer operacions</li> <li>9. Operador assignaci\u00f3: per donar valor a les expressions</li> <li>10. Operadors aritm\u00e8tics: suma, resta, multiplicaci\u00f3, divisi\u00f3...</li> <li>11. Operadors relacionals: major, menor, igual...</li> <li>12. Operadors l\u00f2gics: and, or, not...</li> <li>13. Estructures en Java: agrupacions de diferents tipus de dades</li> <li>14. Eclipse: Entorn de programaci\u00f3 per a Java d'\u00fas general</li> <li>15. Processing IDE: Entorn de programaci\u00f3 orientat a l'art</li> </ul> Tema 04. Programaci\u00f3 Modular <p>\u00cdNDEX</p> <ul> <li>1. Introducci\u00f3: Qu\u00e8 \u00e9s el paradigma de programaci\u00f3 modular?</li> <li>2. Caracter\u00edstiques: propietats principals del paradigma</li> <li>3. Funcions en Java: Com dissenyar i utilitzar funcions en Java.</li> <li>4. Arguments i par\u00e0metres: Valors que es passen als m\u00e8todes o funcions en Java</li> <li>5. Declaraci\u00f3 i crida: Difer\u00e8ncies</li> <li>6. Valor i refer\u00e8ncia: par\u00e0metres modificable o no.</li> <li>7. Recursivitat: T\u00e8cnica de programaci\u00f3 modular.</li> </ul> Tema 05. Tipus Compostos de Dades <p>\u00cdNDEX</p> <ul> <li>1. Introducci\u00f3: que s\u00f3n el tipus compostos de dades.</li> <li>2. Arrays: declaraci\u00f3 i \u00fas, inicialitzaci\u00f3, bucles...</li> <li>3. Algorismes de recerca: per tal de buscar elements coincidents dins d'un array</li> <li>4. Algorismes d'ordneaci\u00f3: per ordenar un array segons algun criteri d'ordenaci\u00f3.</li> <li>5. Arrays multidimensionals: arrays amb tres o m\u00e9s dimensions.</li> <li>6. API de Java: tipus compostos de dades predefinits a Java.</li> </ul> Tema 06. Programaci\u00f3 Orientada a Objectes <p>\u00cdNDEX</p> <ul> <li>1. Introducci\u00f3: Qu\u00e8 \u00e9s el paradigma de programaci\u00f3 orientada a objectes?</li> <li>2. Caracter\u00edstiques: abstracci\u00f3, modularitat, encapsulament, jerarquia i polimorfisme</li> <li>3. Classes i objectes: Difer\u00e8ncia entre classes i objectes.</li> <li>4. Definci\u00f3 de classes en Java: Com declarar una classe en Java.</li> <li>5. Propietats i m\u00e8todes: Membre principals de les classes a Java.</li> <li>6. Instanciaci\u00f3 d'objectes: Com crear objectes a partir de les classes Java</li> <li>7. Constructors:  Funci\u00f3 principal per a la creaci\u00f3 d'objectes.</li> </ul> Tema 07. Her\u00e8ncia, polimorfisme i interf\u00edcies <p>\u00cdNDEX</p> <ul> <li>1. Introducci\u00f3: Her\u00e8ncia i polimorfisme: t\u00e8cniques molt potents de POO.</li> <li>2. Her\u00e8ncia: Mecanisme d'her\u00e8ncia en POO</li> <li>3. Disseny de superclasses: super classes o classes pares</li> <li>3. Disseny de subclasses: com fer classes derivades o sublclasses d'una superclasses</li> <li>4. Sobrec\u00e0rrega de constructors: un mateix constructor que realitza funcions diferents en diferent subclasses.</li> <li>5. Polimorfisme: les mateixes funcions realitzant tasques diferents</li> <li>6. Interf\u00edcies: prototips de funcions que serveixen per implementar classes noves.</li> </ul> Tema 08. Entrada, eixida i excepcions <p>\u00cdNDEX</p> <ul> <li>1. Introducci\u00f3: Com es realitza la comunicaci\u00f3 de Java amb dispositius externs</li> <li>2. Entrada i eixida b\u00e0siques: consola i ftixers b\u00e0sics.</li> <li>3. Flux a nivell de byte: Streams de comunicaci\u00f3 a nivell de byte o baix nivell.</li> <li>3. Flux a nivell de caracter: Streams de comunicaci\u00f3 a nivell de caracter o de nivell alt.</li> <li>4. Persist\u00e8ncia d'objectes: Com desar objectes i estat a dispositius externs o fitxers.</li> <li>5. Excepcions: Control d'errors en temps d'execuci\u00f3.</li> </ul> Tema 09. Gr\u00e0fics. Java Swing <p>\u00cdNDEX</p> <ul> <li>1. Introducci\u00f3: disseny de formularis a nivell gr\u00e0fic.</li> <li>2. Llibreria SWING: llibreria de disseny gr\u00e0fic amb Java</li> <li>3. JFrame i JPanel: Controls principals en la creaci\u00f3 d'aplicacions gr\u00e0fiques.</li> <li>3. Gestors de posicionament: controls que determinen la forma en la que es col\u00b7locaran els controls al formulari.</li> <li>4. Controls: JLable, JText...</li> <li>5. Taules: Com treballar amb taules i SWING</li> <li>6. Esdeveniments: Interacci\u00f3 amb l'usuari.</li> </ul> Tema 10. Acc\u00e9s a dades <p>\u00cdNDEX</p> <ul> <li>1. Introducci\u00f3: com treballar amb Java i bases de dades relacionals.</li> <li>2. Drivers: programari adicional necessari</li> <li>3. JDBC: Java Database Connectivity</li> <li>3. Connexi\u00f3 a la BD: Codi necessari per connectar a una BD</li> <li>4. Realitzaci\u00f3 de consultes: SQL, Insert, Update, Select ...</li> </ul>"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/","title":"Tema 1 - Introducci\u00f3 Programaci\u00f3","text":""},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#hola-mon","title":"Hola m\u00f3n!","text":"<p>Hola a tots i benvinguts al m\u00f3n de la programaci\u00f3. En aquest curs aprendrem com escriure codi utilitzant el llenguatge de programaci\u00f3 Java. Com podreu observar, programar b\u00e0sicament consisteix en poder comunicar-se amb una m\u00e0quina per tal que segueixca adequadament les instruccions que li donem, \u00e9s a dir, aprendre a programar \u00e9s aprendre un idioma nou, per\u00f2 no patiu, no es tracta d'un idioma com l'angl\u00e8s o el llenguatge musical, ja que per tal que aquesta comunicaci\u00f3 entre persona i m\u00e0quina siga eficient i efectiva, el llenguatge a aprendre ha de ser molt m\u00e9s simple i sobre tot lliure d'ambig\u00fcitats. </p> <p>Per\u00f2 no avancem aconteixements. Millor comencem pel principi. Qu\u00e8 \u00e9s un programa?</p> segons el DNV: Diccionari Normatiu Valencia <p>Conjunt d'instruccions detallades i codificades que es donen a un sistema inform\u00e0tic perqu\u00e8 execute unes determinades operacions</p> segons el Termcat: Centre de Terminologia en llengua catalana <p>Conjunt de dades i d'instruccions codificades que s\u00f3n l'expressi\u00f3 completa d'un procediment que pot executar un sistema inform\u00e0tic</p> Conclusi\u00f3 <p>Podr\u00edem dir que programar \u00e9s l\u2019acci\u00f3 d\u2019elaborar un programa.</p> <p>En altres paraules un programa \u00e9s un conjunt d\u2019instruccions escrites en un llenguatge de programaci\u00f3 que s\u2019utilitzen per donar ordres o indicacions a un ordinador.</p> <p>El m\u00e9s paregut a programar que hi ha en el m\u00f3n real seria elaborar un conjunt d'instruccions de tal forma que una altra persona siga capa\u00e7 de llegir, interpretar i executar satisfact\u00f2riament obtenint un resultat. Una recepta de cuina per exemple \u00e9s un conjunt d'instruccions que qualsevol \u00e9s capa\u00e7 de llegir, interpretar i executar obtenint al final un resultat.</p> <p>Si seguim la met\u00e0fora de la recepta i la comparem amb un model de comunicaci\u00f3 cl\u00e0ssica els elements que ens podem trobar s\u00f3n: </p> <ul> <li>Origen: persona que diu les instruccions o ordres, el que escriu la recepta.</li> <li>Dest\u00ed: persona que les ha de llegir, interpretar i executar, el cuiner i el llenguatge usat (valenci\u00e0)</li> <li>Canal: medi f\u00edsic pel qual es transmet el missatge. Aire, televisi\u00f3, tel\u00e8fon, internet...</li> <li>Missatge: f\u00e0cil no? La recepta.</li> </ul> <p>Observa l'esquema seg\u00fcent:</p> <p> </p> <p>Doncs b\u00e9, en inform\u00e0tica tindr\u00edem els mateixos elements on l'origen seria el programador, el dest\u00ed l'ordinador, el llenguate seria el llenguatge de programaci\u00f3 i el missatge seria el programa. </p> <p>Podriem concloure que aprendre a programar \u00e9s aprendre l'idioma que parlen els ordinadors per tal de poder comunicar-nos amb ells i donar-los ordres o instruccions.</p> <p>En aquest primer tema, veurem una s\u00e8rie de conceptes b\u00e0sics que seran necessaris per entendre que \u00e9s la programaci\u00f3.</p>"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#conceptes-basics","title":"Conceptes b\u00e0sics","text":"<p>Com ja hem explicat a la introducci\u00f3 d'aquest tema, programar consisteix en b\u00e0sicament donar ordres a un dispositiu mitjan\u00e7ant un algorisme en un llenguatge de programaci\u00f3 concret que a l'executar-se en una m\u00e0quina es converteix en programa. Veiem amb un poc m\u00e9s de detall aquestos conceptes:</p>"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#algorisme-vs-programa","title":"Algorisme vs Programa","text":"<p>Si el que farem en aquest curs \u00e9s programar, per qu\u00e8 parlem tant d'algorismes. Qu\u00e8 \u00e9s un algorisme? Quina difer\u00e8ncia hi ha entre un algorisme i un programa? En aquest primer tema treballarem tots aquestos conceptes.</p> <p>Definici\u00f3 d'algorisme</p> <p>Un algorisme \u00e9s un conjunt ordenat i finit d\u2019operacions o instruccions a seguir que permeten trobar la soluci\u00f3 a un problema. Per exemple: algorisme de la suma, la resta, la multiplicaci\u00f3 o la divisi\u00f3.</p> <p>Per tal de fer una suma de xifres de m\u00e9s d\u2019un digit cadascuna, el que es diu comunament sumar portant, hem de seguir unes instruccions que si les realitzem de forma correcta, obtenim el resultat. Doncs b\u00e9, eixes \u2018instruccions\u2019 serien l\u2019algorisme.</p> <p>Un programa no \u00e9s m\u00e9s que un algorisme les \u2018instruccions\u2019 del qual les executa un ordinador.</p>"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#caracteristiques","title":"Caracter\u00edstiques","text":"<p>Un algorisme posteriorment convertit a programa ha de complir una s\u00e8rie de caracter\u00edstiques:</p> <ul> <li>Finit: ha de comen\u00e7ar i acabar.</li> <li>Llegible: un programa s'escriu una vegada per\u00f2 es llig moltes.</li> <li>Modificable: ha de poder evolucionar.</li> <li>Eficient: No utilitza m\u00e9s recursos dels necessaris</li> <li>Modular: s'ha de dividir en parts el qual millora la legibilitat.</li> <li>Estructurat: utilitza les estructures del paradigma de la programaci\u00f3 estructurada.</li> </ul>"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#algorisme-del-sandwich-de-nutella","title":"Algorisme del sandwich de Nutella","text":"<p>Una de les dificultats inicials a l'hora d'aprendre a programar \u00e9s desfer-se de l'ambig\u00fcitat amb la s'utilitza el llenguatge natural, l'esser hum\u00e1 t\u00e9 la capacitat de contextualitzar i desambiguar per\u00f2 una m\u00e0quina no, per tant, \u00e9s necessari que el llenguatge amb el que es donen ordres a un ordinador, estiga lliure d'ambig\u00fcitat i siga el m\u00e9s exacte possible. </p> <p>A continuaci\u00f3 observa el seg\u00fcent v\u00eddeo on uns fills li donen instruccions \"precises\" al pare per tal que els faja un sandwich.</p> Activitat 101. Interpreta i reescriu l'algorisme <p>Fixa't en el v\u00eddeo anterior i escriu l'algorisme inicial que els xiquets per a que el pare els prepare un sandwich.  Observa el resultat de l'algorisme inicial i reescriu-lo per tal que el resultat final siga m\u00e9s adequat.</p> <p>En acabar, intenta escriure un breu document amb les instruccions necess\u00e0ries per elaborar alguna recepta simple tipus la del v\u00eddeo. Una vegada acabat l'algorisme, passa-la al teu company i anota les observacions de millora que et fa al respecte.</p>"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#llenguatges-programacio","title":"Llenguatges programaci\u00f3","text":"<p>De la mateixa manera que dues persones es comuniquen entre s\u00ed utilitzant un llenguatge natural, una persona es comunica amb una m\u00e0quina utilitzant un llenguatge de programaci\u00f3. Evidentment, un llenguatge de programaci\u00f3 ha de ser m\u00e9s simple i gens ambigu al contrari de com passa amb els llenguatges naturals. </p> <p>Els llenguatges de programaci\u00f3 solen complir les seg\u00fcents caracter\u00edstiques:</p> <ol> <li>Existeix un nombre finit de paraules reservades que podem usar: per, var, int, mentre, repetir... \u00c9s a dir, un llenguatge de programaci\u00f3 t\u00e9 un conjunt l\u00e8xic de paraules amb un significat associat com passa amb els llenguatges naturals.</li> <li>Les frases com a combinaci\u00f3 de diferents paraules amb les que ens comuniquem en llenguatge natural es diuen instruccions</li> <li>Cada instrucci\u00f3 finalitza d\u2019una manera concreta, per exemple, utilitzant un \u2018;\u2019 per tal que la m\u00e0quina sapiga quan acaba una instrucci\u00f3 i comen\u00e7a una altra.</li> </ol>"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#classificacio","title":"Classificaci\u00f3","text":"<p>Els llenguatges de programaci\u00f3 es poden classificar segons els seg\u00fcents criteris</p>"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#proximitat-a-la-maquina","title":"PROXIMITAT A LA M\u00c0QUINA","text":"<p>Les m\u00e0quines en realitat nom\u00e9s entenen 0 i 1, hi han llenguatges de programaci\u00f3 molts pr\u00f2xims a aquest tipus de codificaci\u00f3 bin\u00e0ria per\u00f2 que s\u00f3n complicats d\u2019entendre per un \u00e9sser hum\u00e0. D\u2019una altra banda existeixen llenguatges que utilitzen un conjunt de paraules reservades que fan que siga m\u00e9s f\u00e0cil d\u2019entendre per una persona. Al final de tot aquest llenguatge m\u00e9s pr\u00f2xim al llenguatge hum\u00e0 acaba convertint-se en una seq\u00fc\u00e8ncia de 0 i 1 la m\u00e0quina pot entendre en el proc\u00e9s de compilaci\u00f3 que veurem m\u00e9s endavant.</p> <ul> <li>Llenguatges de baix nivell: s\u00f3n els llenguatges m\u00e9s pr\u00f2xims al llenguatge m\u00e0quina com per exemple el llenguatge assemblador.</li> <li>Llenguatges de nivell mitj\u00e0: llenguatges que s\u2019aproximen un poc m\u00e9s al llenguatge natural utilitzant una s\u00e8rie de paraules reservades que s\u2019utilitzen en llenguatge natural com per exemple el llenguatge C</li> <li>Llenguatges d\u2019alt nivell: Els m\u00e9s pr\u00f2xims al llenguatge natural per\u00f2 sense ambig\u00fcitats.</li> </ul> <p> </p>"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#proposit-del-llenguatge","title":"PROPOSIT DEL LLENGUATGE","text":"<p>\u00c9s a dir segons quins tipus de programes poden generar, quina \u00e9s la seua finalitat.</p> <ul> <li>Llenguatges de prop\u00f2sit general: que s\u00f3n capa\u00e7os de crear qualsevol tipus de programa. Llenguatge C</li> <li>Llenguatges de prop\u00f2sit espec\u00edfic: que es dissenyen per trEn realitat aquesta faselenguatges de programaci\u00f3, aquests han anat evolucionant i adaptant-se a les noves caracter\u00edstiques tant f\u00edsiques com d\u2019\u00fas del maquinari i els dispositius.</li> </ul>"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#segons-generacio","title":"SEGONS GENERACI\u00d3","text":"<ul> <li>Primera Generaci\u00f3: llenguatges m\u00e0quina i llenguatges assemblador. Anys 40 \u2013 50. En aquesta \u00e8poca s\u2019usaven targetes perforades i es programava utilitzant seq\u00fcencies d\u2019uns i zeros indicant quin c\u00e0lcul havien de realitzar els programes. Els llenguatges assemblador afegeixen la primera capa d\u2019abstracci\u00f3 sobre el binari de forma que una s\u00e8rie d\u2019instruccions simples s\u00f3n despr\u00e9s tradu\u00efdes a binari per la mateixa m\u00e0quina. Aquestes instruccions estaven directament relacionades amb el processador, \u00e9s a dir, cada processador tenia el seu conjunt d'instruccions propi.</li> <li>Segona Generaci\u00f3: Apareixen els llenguatges de nivell mitj\u00e0 i els primers compiladors, que per que ho entenem de moment, s\u00f3n els encarregats de traduir d\u2019un llenguatge de programaci\u00f3 a llenguatge m\u00e0quina o binari. Exemple de llenguatge de nivell mitj\u00e0: FORTRAN (FORmula TRANSlating system) de l\u2019any 1956</li> <li>Tercera Generaci\u00f3: Apareix la programaci\u00f3 estructurada, ja no nom\u00e9s s\u2019utilitzen els llenguatges de programaci\u00f3 per realitzar c\u00e0lculs matem\u00e0tics com fins ara. Apareix tamb\u00e9 l\u2019\u00fas de variables, subprogrames, estructures etc.. En aquesta generaci\u00f3 podem trobar llenguatges de programaci\u00f3 com C, Pascal o Modula.</li> <li>Quarta Generaci\u00f3: En aquesta generaci\u00f3 trobarem llenguatges desenvolupats per crear un determinat tipus de programari, es configuren per tasques molt concretes.</li> <li>Cinquena Generaci\u00f3: on estarien els llenguatges dissenyats per afrontar la intel\u00b7lig\u00e8ncia artificial com per exemple Prolog. Comen\u00e7a tamb\u00e9 a posar-se en pr\u00e0ctica la programaci\u00f3 orientada a objectes com a nou paradigma de programaci\u00f3.</li> <li>Generaci\u00f3 Visual: nascuda a principis dels anys 90 i com a conseq\u00fc\u00e8ncia de la necessitat de usar interf\u00edcies cada vegada m\u00e9s amigables i f\u00e0cils.</li> </ul>"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#forma-dexecucio","title":"FORMA D'EXECUCI\u00d3","text":"<p>Com havien dit abans, abans d\u2019executar un programa escrit en un llenguatge de programaci\u00f3 qualsevol, s\u2019ha de traduir al llenguatge que pot entendre la m\u00e0quina, binari. Aquest proc\u00e9s es pot fer de dues formes:</p> <ul> <li> <p>Llenguatges compilats: per tal de compilar un programa es realitzen les seg\u00fcents tasques: an\u00e0lisi l\u00e8xic, sint\u00e0ctic i sem\u00e0ntic del programa, traducci\u00f3 a codi objecte, enlla\u00e7 amb altres llibreries i creaci\u00f3 de l\u2019executable. El proc\u00e9s de compilaci\u00f3 \u00e9s un proc\u00e9s de traducci\u00f3 del llenguatge d'alt nivell utilitzat al llenguatge m\u00e0quina que pot entendre l'ordinador.</p> </li> <li> <p>Llenguatges interpretats: Aquest tipus de codis es lligen,Un diagrama de flux \u00e9s una representaci\u00f3 gr\u00e0fica d'un algorisme. S'utilitza en disciplines com la programaci\u00f3 inform\u00e0tica, l'economia, els processos industrials o la psicologia cognitiva. Aquests diagrames utilitzen s\u00edmbols amb significats ben definits que representen els passos de l'algorisme, i representen el flux d'execuci\u00f3 mitjan\u00e7ant fletxes que connecten els punts d'inici i de finalitzaci\u00f3. Un diagrama de flux sempre t\u00e9 un \u00fanic punt d'inici i un \u00fanic punt de finalitzaci\u00f3. A m\u00e9s, tot cam\u00ed d'execuci\u00f3 ha de permetre arribar des de l'inici fins al final.</p> </li> </ul>"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#paradigma-de-programacio","title":"PARADIGMA DE PROGRAMACI\u00d3","text":"<ul> <li> <p>Programaci\u00f3 estructurada: Utilitzen les estructures b\u00e0siques de programaci\u00f3: seq\u00fcencial, alternativa i iterativa combinats amb la programaci\u00f3 modular per dissenyar programes. Els exemples podrien ser C i Pascal.</p> </li> <li> <p>Programaci\u00f3 orientada a objectes: Entenen els programes com un conjunt d\u2019objectes que tenen unes caracter\u00edstiques pr\u00f2pies, uns m\u00e8todes i que interactuen amb els altres objectes que formen part del sistema. Entre aquestos ens podrem trobar: C++ o Java</p> </li> </ul>"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#segons-nombre-de-processos","title":"SEGONS NOMBRE DE PROCESSOS","text":"<p>\u00c9s a dir, si permeten la execuci\u00f3 concurrent, m\u00e9s d\u2019un proc\u00e9s al mateix temps o no. Per tant ens podem trobar:</p> <ul> <li> <p>Llenguatges de programaci\u00f3 concurrents que permeten la concurr\u00e8ncia, \u00e9s a dir, aquells llenguatges de programaci\u00f3 que disposen de les eines necess\u00e0ries per definir i treballar amb diverses tasques (fils d'execuci\u00f3 o threads) dins del mateix programa. La concurr\u00e8ncia \u00e9s l'habilitat que t\u00e9 un ordinador per realitzar diverses tasques al mateix temps.</p> </li> <li> <p>Llenguatges de programaci\u00f3 no concurrents. Nom\u00e9s una tasca al mateix temps.</p> </li> </ul>"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#segons-interactivitat","title":"SEGONS INTERACTIVITAT","text":"<p>\u00c9s el procediment per escriure parts d'un programa mentre est\u00e0 actiu. Programaci\u00f3 interactiva. Modificaci\u00f3 d'un programa mentre aquest estiga actiu. El terme de programaci\u00f3 interactiva no t\u00e9 a veure amb l'estil en qu\u00e8 est\u00e0 escrit un programa, sin\u00f3 amb el proc\u00e9s d'escriptura del codi.</p>"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#visuals-o-no","title":"VISUALS O NO","text":"<p>Permeten la programaci\u00f3 per reutilitzaci\u00f3 de components mitjan\u00e7ant drag and drop en un entorn gr\u00e0fic o no. L'exemple m\u00e9s conegut \u00e9s l'Scratch.</p> Activitat 102. Busca i classifica llenguatges de programaci\u00f3 <p>Busca llenguatges de programaci\u00f3 que s'adequen a cadascuna de les categories que s'han descrit a l'apartat anterior. Per exemple:</p> <pre><code>1. Llenguatges de baix nivell: Ensamblador.\n2. Llenguatges de nivell mitja: C, Pascal\n</code></pre>"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#mapa-mental","title":"MAPA MENTAL","text":"mindmap     root ((LLENGUATGES))         Proximitat             baix             mitj\u00e0             alt         Proposit             general             espec\u00edfic         Execuci\u00f3             compilats             interpretats         Generaci\u00f3             1G             2G             3G             4G             5G             Gen Visual         Paradigma             estructurats             orientata a objectes         Processos             concurrents             No concurrents         Visuals             visuals             No visuals         Segons interactivitat             Interactius             No interactius"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#paraules-reservades","title":"Paraules reservades","text":"<p>Els llenguatges de programaci\u00f3 utilitzen una s\u00e8rie de paraules o s\u00edmbols que fan una funci\u00f3 espec\u00edfica dins d\u2019un programa.  A aquest conjunt de signes o combinaci\u00f3 d\u2019ells se les anomena paraules reservades. Aquestes paraules nom\u00e9s poden usar-se en un concepte determinat, mai lliurement per l\u2019usuari. Per exemple, el llenguatge C t\u00e9 com a paraules reservades if o while. Ambdues nom\u00e9s podran ser utilitzades en cas que es vullga iniciar una sent\u00e8ncia de control condicional o bucle.</p> <p>Paraules Reservades</p> <p>Les paraules reservades s\u00f3n identificadors o etiquetes reservades predefinides que tenen un significat especial i no es poden utilitzar com identificadors o etiquetes en els programes.</p>"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#fases-de-desenvolupament-duna-aplicacio","title":"Fases de desenvolupament d'una aplicaci\u00f3","text":"<p>A l\u2019hora d\u2019afrontar la realitzaci\u00f3 d\u2019un programa hem de tindre clar que hem de fer. \u00c9s un error comen\u00e7ar a crear programari a lo loco ja que nom\u00e9s conseguirem deicar a aquest menester m\u00e9s temps que el que es necessita. A m\u00e9s a m\u00e9s el proc\u00e9s de creaci\u00f3 d\u2019un programa no nom\u00e9s \u00e9s picar codi. D\u2019aquesta manera a l\u2019hora de construir un programa es deurien seguir una s\u00e8rie de fases o pautes.</p> <p>Aquestes fase s\u00f3n: an\u00e0lisi, disseny, codifiaci\u00f3, prova i documentaci\u00f3</p>"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#analisi-del-problema","title":"An\u00e0lisi del problema","text":"<p>Estudi del problema, quina \u00e9s la seua finalitat, a qui va dirigit, quins elements ha d\u2019incloure, quines tasques ha de realitzar. En aquesta fase es realitzen entrevistes amb els usuaris o clients entre d\u2019altres t\u00e8cniques. La finalitat d\u2019aquesta fase \u00e9s fer un recull dels diferents requeriments que ha de tenir el nostre producte. Per tant al final d'aquesta fase deuriem tindre una llista amb els requisits que ha de tindre la nostra aplicaci\u00f3. Aquesta fase respon al QU\u00c8 del nostre projecte, es a dir, s'intenta esbrinar qu\u00e8 \u00e9s el que realment es necessita i s'arriba a una comprensi\u00f3 adequada dels requeriments del sistema.</p> <p>FruitApp - An\u00e0lisi</p> <p>Imaginem que ens disposem a fer una aplicaci\u00f3 que gestione la fruteria del barri. En aquesta fase \u00e9s on hauriem d'esbrinar, entre altres coses: quins productes es venen, quin preu tenen, l'agenda de clients, quina informaci\u00f3 volem saber dels clients, quina informaci\u00f3 volem saber de prove\u00efdors etc. Suposem que ens farem c\u00e0rrec d'una part xicoteta d'aquesta aplicaci\u00f3: la introducci\u00f3 de tickets de compra nous. En aquesta fase, l'encarregat de la tenda, ens ha dit que necessitaria que els per cada client que compre es necessita un ticket, amb c\u00f2pia per al venedor, que mostrara el nom de la botiga, adre\u00e7a comopleta juntament amb la data i hora de la compra. A continuaci\u00f3 el ticket reflectir\u00e0 els productes que s'han comprat tenint en compte que s'ha de mostrar per cada producte: quantitat, nom del producte, preu per unitat i preu total (preu per unitat per quantitat). Finalment tamb\u00e9 ha de mostrar la base imponible, suma del total dels productes comprats, IVA (21%), descompte i preu total de la compra. Per acabar, al ticket tamb\u00e9 es reflectir\u00e0 la quantitat de diners rebuts per part del client i els diners que li hem tornat.</p> <p>Mira el seg\u00fcent exemple:</p> <p> </p> Producte - An\u00e0lisi <p>Requeriments del sistema o aplicaci\u00f3 en base a la informaci\u00f3 que hem aconseguit per mitjan\u00e7ant entrevistes, enquestes etc.. En altres paraules: el que ha de fer la nostra aplicaci\u00f3, finalitat, objectius. S'hauria de descriure detalladament el que realitza el sistema i com reacciona en les diferents situacions en les que ens podr\u00edem trobar.</p> <p>El producte d'aquesta fase podria ser per exemple una llista de requeriments a partir de la quan podrem comen\u00e7ar a treballar a la fase seg\u00fcent.</p> <pre><code>1. Els tiquets tindran una cap\u00e7alera amb la informaci\u00f3 de la botiga.\n2. En la cap\u00e7alera tamb\u00e9 es reflectir\u00e0 la data i hora en que s'ha fet la compra.\n3. Per cada producte que es compre, hem de coneixer el nom del producte, la quantitat, el preu unitari i el total.\n4. Cada l\u00ednia del tiquet nom\u00e9s mostra informaci\u00f3 relativa a un producte.\n5. Una vegada tancada la compra, es mostrar\u00e0 un footer que tindra: preu, IVA, descompte i preu final.\n6. El preu o base imponible \u00e9s la suma del total de cadascuna de les l\u00ednies de productes anteriors\n7. L'IVA \u00e9s del 21%\n8. El descompte \u00e9s un percentatge que s'aplica al preu total amb IVA i que podria anar des del 0% fins al 15%.\n9. Del c\u00e0lcul anterior obtindrem el preu total que ha de pagar el client.\n10. Es guardar\u00e0 informaci\u00f3 al sistema de la quantitat de diners que ha entregat el client.\n11. Al tiquet tamb\u00e9 es mostrar\u00e0 quin \u00e9s el canvi que se li ha tornat a client.\n12. Finalment el tiquet s'imprimir\u00e0 en paper per duplicat: un per al client i un per a la botiga.\n</code></pre>"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#disseny-de-lalgorisme","title":"Disseny de l'algorisme","text":"<p>Es refereix a com anem a sol\u00b7lucionar els requeriments obtiguts a la fase anterior. En aquesta fase s'estudien possibles opcions d'implementaci\u00f3 per a l'aplicaci\u00f3 que hem de construir, aix\u00ed com decidir l'estructura general de la mateixa. El disseny \u00e9s una etapa complexa i el seu proc\u00e9s s'ha de realitzar d'una forma iterativa.</p> <p>Es possible que la soluci\u00f3 inicial no siga la m\u00e9s adequada, per tant en tal cas s'hauria de redefinir. Tammateix, hi ha cat\u00e0legs de patrons de disseny molt \u00fatils que recullen errades que altres han com\u00e9s per no caure a la mateixa trampa. Aquesta fase respon al QUAN del nostre projecte.</p> <p>FruitApp - Disseny</p> <p>Continuant en la nostra aplicaci\u00f3 de la fruteria, en aquesta fase i una vegada acabada la fase d'an\u00e0lisi d'on s'obtenen els requeriments, hauriem de, per un costat triar el paradigma de programaci\u00f3 que escollirem: programaci\u00f3 estructurada o programaci\u00f3 orientada a objectes (Normalment aquest \u00faltim). El llenguatge de programaci\u00f3 a utilitzar. Una vegada ja ho hem triat, hem de decidir com el nostre programa va a complir amb els requeriments obtesos a la fase d'analisi, \u00e9s a dir, com crearem el nou ticket de compra, com afegirem els productes i com calcularem el preu final i imprimirem el document.</p> Producte - Disseny <p>Si hem triat el paradigma de programaci\u00f3 estructurada hauriem de dissenyar els diagramres flux de les diferents funcionalitats de l'aplicaci\u00f3, el pseudocodi, etc.. Aquestes funcionalitats s'hauran de deduir dels requeriments de la fase anterior.</p> <p>Per exemple, si utilitzem el paradigma de programaci\u00f3 estructurada, en aquesta fase es dissenyaria l'alogorisme en pseudocodi o diagrama de flux de cadascuna de les funcionalitats que ha de tindre la nostra aplicaci\u00f3. </p> <p>\u00c9s a dir, si FruitApp ha de poder, crear tickets nous, cobrar i calcular les tornes, hauriem de dissenyar dos diagrames de flux, un per a cada funcionalitat.</p> <p>En canvi, si pel contrari escollim el paradigma de programaci\u00f3 orientada a objectes obtindriem casos d'\u00fas, diagrames de classes, diagrames de comportament en UML. </p> <p>Un resultat possible d'aquesta fase \u00e9s l'algorisme que resol el problema. Seguint l'exemple de les receptes anteriors, una possible soluci\u00f3 a aquesta fase seria:</p> <pre><code>1. Obre un nou ticket.\n2. Agafa el primer producte que porta el client\n3. Selecciona el producte al sistema inform\u00e0tic.\n4. Pesa o compta la quantitat de producte que vol comprar.\n5. Introdueix les dades anteriors.\n6. Repeteix els passos 2, 3, 4 i 5 mentre queden productes per enregistrar.\n7. Aplica descompte en cas necessari.\n8. Tanca el ticket.\n9. Imprimeix el ticket.\n</code></pre>"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#codificacio","title":"Codificaci\u00f3","text":"<p>Ha arribat el moment de picar codi. A la fase de codificaci\u00f3, ens arriben els documents (pseudocodi, flux, diagrames de classes, UML) necessaris per poder comen\u00e7ar a programar. En aquesta fase hem d'escollir les eines (IDEs) adequades per poder desenvolupar el nostre projecte i tamb\u00e9 escollirem (va lligat en realitat) el llenguatge de programaci\u00f3 </p> <p>FruitApp - Codificaci\u00f3</p> <p>Seguint amb la fruteria i suposant que ens han passat un diagrama de flux, pseudocodi o diferents diagrames en UML de la nostra apliaci\u00f3 de generaci\u00f3 de tickets, podriem per exemple triar l'IDE Visual Studio Code i C# com a llenguatge de programaci\u00f3 o l'IDE Eclipse i Java o Visual Studio i Java, per despr\u00e9s, traduir de la t\u00e8cnica de disseny utilitzada a un llenguatge de programaci\u00f3 concret.</p> Producte - Codificaci\u00f3 <p>El projecte amb tots els fitxers que tenen el codi desenvolupat aix\u00ed com tamb\u00e9 els executables o binaris ja compilats i funcionant.</p> <pre><code>Ticket t = new Ticket();\nwhile(quedenProductesPerPesar) {\nProducte p = new Producte(\"Nom\");\np.pesa();\nt.afegir(p);\n}\nt.aplicaDescompte(10);\nt.close();\nt.print();\n</code></pre>"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#prova-i-depuracio","title":"Prova i depuraci\u00f3","text":"<p>Com que errar es d'humans, la fase de proves del cicle de vida de programari busca detectar els errors comesos en les etapes anteriors per tal de poder corregir-los. Per supost, all\u00f2 ideal \u00e9s fer-ho abans que l'usuari final se'ls trobe. Es diu que una prova amb exit \u00e9s una prova que detecta algun error.</p> <p>Seguint amb la nostra aplicaci\u00f3 podria passar que una vegada posada en marxa ens adonem que no hem contemplat la possibilitat d'esborrar l\u00ednies del ticket. Com ho solucionariem? Primer agafariem el diagrama de flux d'aquesta funci\u00f3 i el modificariem per tal que s'adapte a la nova realitat. Despr\u00e9s hauriem de modificar el codi a la fase de codificaci\u00f3 per tonar finalment a la fase de prova i depuraci\u00f3.</p>"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#documentacio","title":"Documentaci\u00f3","text":"<p>Aquesta \u00e9s la fase que a cap programador li agrada fer, per\u00f2 en realitat \u00e9s una fase que no est\u00e0 necess\u00e0riament al final del cicle de vida del programa, sino que es fa de forma transversal en totes les etapes del desenvolupament. </p> <p>Es considera documentaci\u00f3 des dels requeriments inicials al manual d'usuari passant per el pseudocodi, diagrames de classes i \u00fas, i tamb\u00e9 els comentaris que es posen al codi.</p> Activitat 103. Simula les fases de desenvolpament software <p>Imagina que tens el projecte d'una aplicaci\u00f3 t\u00e9 com a finalitat gestionar les diverses llistes de compra que poden haver a una casa. Simula que passes per cadascuna de les fases de desenvolupament de programari vistes a l'apartat anterior i genera tota la documentaci\u00f3 necess\u00e0ria.</p> <p>Considera que la fase d'an\u00e0lisi l'has de fer a partir d'aquest enunciat, \u00e9s a dir, els requeriments o requisits d'aquesta fase els haur\u00e0s de treure d'ac\u00ed.</p> <p>La idea \u00e9s tenir una app que controle les diverses llistes de compra que pots tindre a casa. B\u00e0sicament seria digitalitzar la t\u00edpica llibreta que hi ha, normalment, a la nevera on anotem aquelles coses que hem de comprar la propera vegada que anem al supermercat, per exemple: si estem cuinant i veiem que no hi ha: ous, sal o oli; o anotem a la llibreta per comprar-ho. O si estem posant la llavador i s'acaba el suavitzant, o anotem per tal d'enrecordar-nos de comprar-ho. </p> <p>Quan s'obre l'aplicaci\u00f3 m'apareix una primera pantalla amb les llistes, que es diferencien pel nom que tenen, de la compra que tinc. Una vegada seleccione la llista que vull, m'apareix un llistat amb els productes que tinc pendent per comprar. En aquesta mateixa pantalla he de poder afegir productes o esborrar-los si ja els he comprat.</p> <p>Com podeu observar \u00e9s una aplicaci\u00f3 relativament senzilla. A l'hora de fer aquesta activitat, vos aconselle que la mantingau all\u00f2 m\u00e9s senzilla possible per tal de poder fer-la correctament.</p>"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#proces-de-compilacio","title":"Proc\u00e9s de compilaci\u00f3","text":"<p>\u00c9s el proc\u00e9s pel qual es tradueixen les instruccions escrites en un determinat llenguatge de programaci\u00f3 a llenguatge m\u00e0quina. A m\u00e9s d'un  traductor, es poden necessitar altres programes per crear un programa  objecte executable. Un programa font es pot dividir en m\u00f2duls emmagatzemats en arxius diferents. La tasca de reunir el programa font sovint es confia a un programa diferent, anomenat preprocessador. El preprocessador tamb\u00e9 pot expandir abreviatures, crides a macros, a proposicions del llenguatge font.</p> <p>Normalment la creaci\u00f3 d'un programa executable (un t\u00edpic.exe per a Microsoft Windows o DOS) comporta dos passos. El primer pas es diu compilaci\u00f3 ( pr\u00f2piament dit) i tradueix el codi font escrit en un llenguatge de programaci\u00f3 emmagatzemat en un arxiu a codi de baix nivell (normalment en codi objecte, no directament a llenguatge m\u00e0quina). El segon pas es diu enlla\u00e7at en el qual s'enlla\u00e7a el codi de baix nivell generat de tots els fitxers i subprogrames que s'han enviat compilar i s'afegeix el codi de les funcions que hi ha a les biblioteques del compilador perqu\u00e8 l'executable pugui comunicar-se directament amb el sistema operatiu, traduint aix\u00ed finalment el codi objecte a codi m\u00e0quina, i generant un m\u00f2dul executable.</p> <p>Aquests dos passos es poden fer per separat, emmagatzemant el resultat de la fase de compilaci\u00f3 en arxius objectes (un t\u00edpic .obj per a Microsoft Windows, DOS o per a Unix ), per a enlla\u00e7ar-los en fases posteriors, o crear directament l'executable, amb la qual cosa la fase de compilaci\u00f3 s'emmagatzema nom\u00e9s temporalment. Un programa podria tenir parts escrites en diversos llenguatges (per exemple C, C + + i Asm), que es podrien compilar de forma independent i despr\u00e9s enlla\u00e7ar juntes per formar un \u00fanic m\u00f2dul executable. </p> <p> </p>"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#ides","title":"IDE's","text":"<p>Un entorn de desenvolupament integrat o IDE (de l'angl\u00e9s Integrated Development Environment) \u00e9s una enia inform\u00e0tica per al desenvolupament de programari de manera c\u00f2moda i r\u00e0pida. Aix\u00ed doncs \u00e9s un entorn de desenvolupament que agrupa diferents funcions en un sol programa, habitualment: editor de codi, compilador, depurador i un programa de disseny d'interf\u00edcie gr\u00e0fica.</p> <p>Els IDE estan dissenyats per maximitzar la productivitat del programador proporcionant components molt units amb interf\u00edcies d'usuari similars. Els IDE presenten un \u00fanic programa en qu\u00e8 es porta a terme tot el desenvolupament. Generalment, aquest programa sol oferir moltes caracter\u00edstiques per a la creaci\u00f3, modificaci\u00f3, compilaci\u00f3, implementaci\u00f3 i depuraci\u00f3 de programari.</p> <p>Durant el curs utilitzarem principalment dos IDEs: Processing IDE i Eclipse IDE. Una alternativa a Eclipse pot ser tamb\u00e9 Visual Studio Code</p>"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#processing-ide","title":"Processing IDE","text":"<p>Processing \u00e9s un llenguatge de programaci\u00f3 i entorn de desenvolupament integrat de codi obert basat en Java, de f\u00e0cil utilitzaci\u00f3, i que serveix com a mitj\u00e0 per a l'ensenyament i la producci\u00f3 de projectes multim\u00e8dia i interactius de disseny digital. Va ser iniciat per Ben Fry i Casey Reas, ambd\u00f3s membres d'Aesthetics and Computation Group del MIT Media Lab dirigit per John Maeda.1</p> <p>Un dels objectius declarats de Processing \u00e9s actuar com a eina perqu\u00e8 artistes, dissenyadors visuals i membres d'altres comunitats aliens al llenguatge de la programaci\u00f3, n'aprenguessin les bases a trav\u00e9s d'una mostra gr\u00e0fica instant\u00e0nia i visual de la informaci\u00f3. El llenguatge de Processing es basa en Java, tot i que fa servir una sintaxi simplificada i un model de programaci\u00f3 de gr\u00e0fics.</p>"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#caracteristiques_1","title":"Caracter\u00edstiques","text":"<p>Processing inclou una finestra visual com a complement al contorn de l'entorn de desenvolupament integrat (IDE) per organitzar-les als projectes.</p> <p>Cada esquema de Processing \u00e9s en realitat una subclasse de PApplet, un tipus Java que posa en funcionament la majoria de les caracter\u00edstiques del llenguatge del Processing.</p> <p>En programar a Processing, totes les classes addicionals definides seran tractades com a classes internes quan el codi es tradueix en pur Java abans de compilar. Aix\u00f2 vol dir que l'\u00fas de variables est\u00e0tiques i m\u00e8todes de les classes est\u00e0 prohibit llevat que s'indiqui espec\u00edficament a Processing qu\u00e8 vol el codi en mode pur Java.</p> <p>Processing tamb\u00e9 permet als usuaris crear les seves pr\u00f2pies classes de PApplet a la finestra. Aix\u00f2 permet que els tipus de dades complexes puguin incloure qualsevol nombre d'arguments i evita les limitacions a l'\u00fas de tipus de dades est\u00e0ndard com int (sencer), char (car\u00e0cters), float (nombre real) o color (RGB, hexadecimal ARGB).</p>"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#estructura-en-processing-ide","title":"Estructura en Processing IDE","text":"<p>Per tal de treballar amb les estructures b\u00e0siques del paradigma de programaci\u00f3 estructurada, utilitzarem Processing IDE que \u00e9s un IDE lleuger que ens permet programar en Java sense necessitat de fer estructures de classes molt complexes.</p> <p>Concretament Processing IDE \u00e9s un entorn integrat de desenvolupament juntament amb una llibreria gr\u00e0fica que inicialment es va construir per a arts electr\u00f2niques i disseny visual per tal de poder ensenyar els fonaments de la programaci\u00f3 a no-programadors en un context visual. \u00c9s per aix\u00f2 que aquesta eina ens resultar\u00e0 molt \u00fatil per tal d'aprendre els conceptes b\u00e0sics de la programaci\u00f3 estructurada.</p> <p>A continuaci\u00f3 vos mostrem un exemple d'estructura de programa en Processing IDE</p> <pre><code>// Refer\u00e8ncies a altres llibrerires.\n// Variables globals a l'aplicaci\u00f3.\n// Funci\u00f3 setup: nom\u00e9s s'executa una vegada a l'inici de l'execuci\u00f3.\nvoid setup () {  // Sent\u00e8ncies d'inicialitzaci\u00f3 de la nostra aplicaci\u00f3.\n}\n\n// Funci\u00f3 draw: s'executa 60 vegades per segon (60Hz freq\u00fcencia del monitor)\nvoid draw () { // Codi principal del programa.\n}\n\n// Declaraci\u00f3 d'altres funcions\n</code></pre> Activitat 104. Instal\u00b7la Processing IDE <p>Descarrega l'aplicaci\u00f3 Processing IDE de la seua p\u00e0gina oficial i instal\u00b7la-la al teu ordinador. Despr\u00e9s copia i apega qualsevol codi (compatible amb Processing IDE) que trobes per Internet i prova el que passa. Fes-li modificacions al codi per que actue de forma diferent a l'original.</p>"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#eclipse-ide","title":"Eclipse IDE","text":"<p>Eclipse \u00e9s una plataforma de programari compost per un conjunt d'eines de programaci\u00f3 de codi obert multiplataforma per desenvolupar el que el projecte anomena \"Aplicacions de Client Enriquit\", oposat a les aplicacions \"Client-lleui\u00e0\" basades en navegadors. Aquesta plataforma, t\u00edpicament ha estat usada per desenvolupar entorns de desenvolupament integrats (de l'angl\u00e8s IDE), com l'IDE de Java anomenat Java Development Toolkit (JDT) i el compilador (ECJ) que es lliura com a part d'Eclipse (i que s\u00f3n usats tamb\u00e9 per desenvolupar el mateix Eclipse).</p> <p>Eclipse tamb\u00e9 \u00e9s una comunitat d'usuaris, estenent constantment les \u00e0rees d'aplicaci\u00f3 cobertes. Un exemple \u00e9s el recentment creat Eclipse Modeling Project, cobrint gaireb\u00e9 totes les \u00e0rees de Model Driven Engineering.</p> <p>Eclipse va ser desenvolupat originalment per IBM com el successor de la seva fam\u00edlia d'eines per a VisualAge. Eclipse \u00e9s ara desenvolupat per la Fundaci\u00f3 Eclipse, una organitzaci\u00f3 independent sense \u00e0nim de lucre que fomenta una comunitat de codi obert i un conjunt de productes complementaris, capacitats i serveis.</p> <p>Eclipse va ser alliberat originalment sota la Common Public License, per\u00f2 despr\u00e9s va ser re-licenciado sota l'Eclipse Public License. La Free Software Foundation ha dit que ambdues llic\u00e8ncies s\u00f3n llic\u00e8ncies de programari lliure, per\u00f2 s\u00f3n incompatibles amb Llic\u00e8ncia p\u00fablica general de GNU (GNU GPL).</p>"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#estructura-dun-programa-en-java","title":"Estructura d'un programa en Java","text":"<p>El primer que s'ha de tenir en compte \u00e9s que tot programa escrit en Java ha de tindre almenys un main() a la classe principal per tal que s'execute. En resum, un programa escrit en Java ha de tindre:</p> <ul> <li>Declaracions d'importaci\u00f3 de paquets o inclusi\u00f3 d'altres llibreries.</li> <li>Declaracions de les classes que el formen.</li> <li>El m\u00e8tode main</li> <li>M\u00e8todes definits pels usuaris dins de les classes.</li> <li>Comentaris.</li> </ul> <pre><code>// Programa principal\n// Llibreries amb funcions d'entrada i eixida.\nimport java.io.*;\n\n// Nom de la classe principal\npublic class nomPrograma {    // Membres de la classe (una calculadora)\nCalculadora calc;         // M\u00e8tode principal main\npublic static void main (String [] args) { // Instruccions del m\u00e8tode principal.\ncalc = new Calculadora();              int result = calc.suma(10,20);\nSystem.out.println(\"Resultat: \" + result );\n}\n}\n\n// Una altra classe\nimport java.io.*;\n\n// Nom de la classe \npublic class Calculadora {            // M\u00e8tode de la classe\npublic int suma(int a, int b) {   return a + b;\n}\n}\n</code></pre> <p>Al programa anterior podem trobar una classe 'nomPrograma' que cont\u00e9 el m\u00e8tode principal main i que al mateix temps cont\u00e9 el conjunt d'instruccions que es van a executar seq\u00fcencialment al nostre programa. Aquesta classe nomPrograma t\u00e9 un memebre calc que \u00e9s un objecte (ja veurem classes i objectes m\u00e9s endavant) de tipus calculadora i que est\u00e0 definit m\u00e9s endavant amb la classe p\u00fablica calculadora. Les sent\u00e8ncies que executa el nostre programa d'exmemple s\u00f3n les seg\u00fcents:</p> <ul> <li>Instancia l'objecte calc (calc = new Calculadora()).</li> <li>Declara una variable de tipus enter result</li> <li>Crida al m\u00e8tode suma de l'objecte calc passant-li els par\u00e0metres 10 i 20</li> <li>Deposita el resultat que retorna el m\u00e8tode suma de la classe calc a la variable result</li> <li>Mostra per pantalla el resultat de la suma.</li> </ul> Activitat 105. Instal\u00b7la Eclipse IDE for Developers <p>Descarrega l'IDE d'Eclipse de la seua p\u00e0gina oficial i instal\u00b7la'l a la teua m\u00e0quina. Despr\u00e9s intenta crear un projecte amb una sola classe i prova d'executar.</p>"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/","title":"Tema 2 - Programaci\u00f3 Estructurada","text":""},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#introduccio","title":"Introducci\u00f3","text":"<p>Al inici dels temps del la inform\u00e0tica moderna  segona meitat dels segle XX i considerant ordinador programable aquell que seguia l'arquitectura de von Neumann, els primers programes s'escrivien en binari (llenguatge m\u00e0quina) en tarjetes perforades.</p> <p>Aquestes targetes perforades s'utilitzaven per escriure programes sencers amb una finalitat molt concreta. Les targetes s'utilitzaven com a entrada de dades a la m\u00e0quina que s'encarregava de llegir les instruccions escrites en binari, i una a una, carregar-les a mem\u00f2ria i executar-les. Un problema d'aquest incipient paradigma de programaci\u00f3 \u00e9s que cada conjunt d'instruccions \u00e9s espec\u00edfic a cada m\u00e0quina.</p> <p>Amb el temps i conforme augmenta la capacitat de computaci\u00f3 dels ordinadors i tamb\u00e9 la complexitat dels programes, les targetes deixen de ser funcionals i apareixen els primers llenguatges de programaci\u00f3 generalistes com FORTRAN, COBOL o LISP per\u00f2 aquestos encara no utilitzen el paradigma de programaci\u00f3 estructurada.</p> <p>A la decada dels anys 60, B\u00f6hm i Jacopini escriuen el teorema de la programaci\u00f3 estructurada, basant-se per supost en part en aquells llenguatges de programaci\u00f3 que ja exisitien, i arriben a la conclusi\u00f3 qu\u00e8: la sent\u00e8ncia GOTO era una sent\u00e8ncia considerada perjudicial per a la programaci\u00f3 i per entendre els programes escrits en qualsevol llenguatge i tamb\u00e9 que amb nom\u00e9s les estructures seq\u00fcencial, iterativa i condicional era suficient per escriure qualsevol programa.</p> <p>En aquest tema veurem quine s\u00f3n les estructures de control de la programaci\u00f3 estructurada i com s'utilitzen, aix\u00ed com tamb\u00e9 les seues corresponents representacions gr\u00e0fiques en programes escrits en diagrames de flux, pseudocodi o algun llenguatge de programaci\u00f3 d'alt nivell.</p> <p> </p>"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#conceptes-basics","title":"Conceptes b\u00e0sics","text":"<p>El teorema de el programa estructurat \u00e9s un resultat en la teoria de llenguatges de programaci\u00f3. Estableix que tota funci\u00f3 computable pot ser implementada en un llenguatge de programaci\u00f3 que combine nom\u00e9s tres estructures l\u00f2giques. Aquestes tres formes tamb\u00e9 anomenades estructures de control espec\u00edficament s\u00f3n:</p> <ul> <li>Seq\u00fc\u00e8ncia: execuci\u00f3 d'una instrucci\u00f3 despr\u00e9s d'una altra.</li> <li>Selecci\u00f3: execuci\u00f3 d'una de dues instruccions (o conjunts), segons el valor d'una variable booleana.</li> <li>Iteraci\u00f3: execuci\u00f3 d'una instrucci\u00f3 (o conjunt) mentre una variable booleana siga 'veritable'. Aquesta estructura l\u00f2gica tamb\u00e9 es coneix com a cicle o bucle.</li> </ul> <p>Aquest teorema demostra que la instrucci\u00f3 GOTO no \u00e9s estrictament necess\u00e0ria i que per a tot programa que l'utilitze existeix un altre equivalent que no fa \u00fas d'aquesta instrucci\u00f3.</p> <p>Els cient\u00edfics de la computaci\u00f3 usualment acrediten el teorema a un article de 1966 escrit per Corrado B\u00f6hm i Giuseppe Jacopini. No obstant aix\u00f2, David Harel va rastrejar els seus or\u00edgens fins a la descripci\u00f3 de 1946 de l'arquitectura de von Neumann i el teorema de la forma normal de Kleene.</p>"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#diagrames-de-flux","title":"Diagrames de flux","text":"<p>Abans d'entrar en el detall del que serien les estructures proposades en el teorema de programaci\u00f3 estructurada,  \u00e9s necessari que mirem amb detall una de les t\u00e8nciques de disseny d'algorismes m\u00e9s utilitzada i que ens servira per entendre un poc millor i de forma gr\u00e0fica que fa cada estructura.</p> <p>Un diagrama de flux \u00e9s una representaci\u00f3 gr\u00e0fica d'un algorisme. S'utilitza en disciplines com la programaci\u00f3 inform\u00e0tica, l'economia, els processos industrials o la psicologia cognitiva. Aquests diagrames utilitzen s\u00edmbols amb significats ben definits que representen els passos de l'algorisme, i representen el flux d'execuci\u00f3 mitjan\u00e7ant fletxes que connecten els punts d'inici i de finalitzaci\u00f3. Un diagrama de flux sempre t\u00e9 un \u00fanic punt d'inici i un \u00fanic punt de finalitzaci\u00f3. A m\u00e9s, tot cam\u00ed d'execuci\u00f3 ha de permetre arribar des de l'inici fins al final.</p> <p>Les seg\u00fcents s\u00f3n accions pr\u00e8vies a la realitzaci\u00f3 del diagrama de flux:</p> <ul> <li> <p>Identificar les idees principals que s'han d'incloure en el diagrama de flux. Han d'estar presents el propietari o responsable del proc\u00e9s, els propietaris o responsables del proc\u00e9s anterior i posterior i d'altres processos interrelacionats, aix\u00ed com les terceres parts interessades.</p> </li> <li> <p>Definir qu\u00e8 s'espera obtenir del diagrama de flux.</p> </li> <li>Identificar qui ho far\u00e0 servir i com.</li> <li>Establir el nivell de detall requerit.</li> <li>Determinar els l\u00edmits del proc\u00e9s a descriure.</li> </ul> <p>Els passos a seguir per construir el diagrama de flux s\u00f3n:</p> <ul> <li>Establir l'abast del proc\u00e9s a descriure. D'aquesta manera quedar\u00e0 fixat el comen\u00e7ament i el final del diagrama. Sovint el comen\u00e7ament \u00e9s la sortida del proc\u00e9s previ i el final l'entrada al proc\u00e9s seg\u00fcent.</li> <li>Identificar i llistar les principals activitats/subprocessos que estan incloses en el proc\u00e9s a descriure i el seu ordre cronol\u00f2gic.</li> <li>Si el nivell de detall definit inclou activitats menors, llistar-les tamb\u00e9.</li> <li>Identificar i llistar els punts de decisi\u00f3.</li> <li>Construir el diagrama respectant la seq\u00fc\u00e8ncia cronol\u00f2gica i assignant els corresponents s\u00edmbols.</li> <li>Assignar un t\u00edtol al diagrama i verificar que estigui complet i descrigui amb exactitud el proc\u00e9s escollit.</li> </ul>"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#simbologia-i-significat","title":"Simbologia i significat","text":"<ul> <li>Oval o el\u00b7lipse: inici i final (obre i/o tanca el diagrama).</li> <li>Rectangle: activitat (representa l'execuci\u00f3 d'una o m\u00e9s activitats o procediments).</li> <li>Rombe: decisi\u00f3 (formula una pregunta o q\u00fcesti\u00f3).</li> <li>Cercle: connector (representa l'enlla\u00e7 d'activitats amb una altra dins d'un procediment).</li> <li>Triangle cap per avall: fitxer definitiu (guarda un document de forma permanent).</li> <li>Triangle cap per amunt: fitxer temporal (proporciona un temps per a l'emmagatzematge del document).</li> </ul> <p>A l'esquema seg\u00fcent pots revisar la simbologia gr\u00e0fica que usarem en aquest curs per tal de representar diagrames de flux.</p> <p>S\u00edmbols dels diagrames de flux</p> graph LR     class B classNode     Ini((Ini))     style Ini fill:#0F0     Ini--&gt;|L\u00ednea de flux|A[/Entrada eixida/]     A--&gt;B[Procediment oInstrucci\u00f3]     B--&gt;C{Decisi\u00f3}     C--&gt;Fi((Fi))     style Fi fill:#F00"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#exemples","title":"Exemples","text":"<p>A continuaci\u00f3 vegem alguns exemples que ens ajudaran a entendre-ho millor. Et recomane que intentes dissenyar una soluci\u00f3 utilitzant la t\u00e8cnica dels diagrames de flux abans de mirar a la soluci\u00f3.</p> Exemple 1. La nostra fruiteria <p>Es pret\u00e9n implementar un algorisme que s'encarregue, de la forma m\u00e9s eficient possible, la creaci\u00f3 i impressi\u00f3 de tickets de compra per a tots els clients que entren a la nostra botiga. </p> <p>A la imatge seg\u00fcent podem observar un exemple d'algorisme de creaci\u00f3 d'un nou ticket (nova compra).</p> Soluci\u00f3 <p>Expliquem breument el que fa aquest diagrama: primer crea un nou ticket i afegeix un nou element (fruta o verdura), aquesta acci\u00f3 \u00faltima es repeteix fins que acabe de comprar. Quan s'acaba d'afegir items al nou ticket, es calcula el preu final i s'imprimeix.</p> graph LR     Id1((Inici))--&gt;B[Crear Ticket Nou];     style Id1 fill:#0F0;     B--&gt;C[Afegir Item];     C--&gt;D{Compraacabada?};     D--&gt;|NO|C;     D--&gt;|SI|E[Calcular Preu Final];     E--&gt;F[Imprimir];     F--&gt;Id2((Final));     style Id2 fill:#F00;  Exemple 2. Trobar les claus de casa <p>Imagineu que vull eixir de casa per\u00f2 no recorde on he posat les claus i sense elles no puc anar a cap lloc. Les he de buscar. El seg\u00fcent algorisme representat utilitzant un diagrama de flux, ens podria ajudar a trobar-les.</p> Soluci\u00f3 <p>La difer\u00e8ncia amb l'anterior \u00e9s que t\u00e9 text</p> graph LR     Id1((Inici))--&gt;B[Buscar on sempre];     style Id1 fill:#0F0;     B--&gt;P1(fa:fa-spinner);     P1--&gt;D{Trobades?};     D--&gt;|NO|C[Buscar altre lloc];     C--&gt;P1;     D--&gt;|SI|E[Eixir de casa];     E--&gt;Id2((Fi));     style Id2 fill:#F00;   Exemple 3. Com anar de l'ajuntament al passeig <p>Ens trobem a la pla\u00e7a de l'ajuntament i un visitant ens pregunta com arribar al passeig Cervantes. Oberva el seg\u00fcent diagrama de flux. Al tractar-se d'un exemple un poc m\u00e9s extens, primer descriurem les instruccions en llenguatge natural i despr\u00e9s farem el diagrama.</p> <ul> <li>Camina pel carrer major en direcci\u00f3 sud</li> <li>Quan arribes a l'encreuament amb el Carrer Ramon y Cajal gira a la dreta</li> <li>Camina fins la farmacia</li> <li>Quan arribes a la farm\u00e0cia gira a l'esquerra</li> <li>Caminar fins encreuament amb el carrer Moreral.</li> <li>Agafa el carrer moreral</li> <li>Al final del carrer moreral a l'esquerra.</li> </ul> Soluci\u00f3 <p>Una possible soluci\u00f3 a aquest problema podria ser:</p> graph LR      subgraph 1         Inici((Inici))--&gt;A[Caminar carrer major direcci\u00f3 sud];         style Inici fill:#0F0;         A--&gt;B{Hem arribat al Ram\u00f3n i Cajal?};         B--&gt;|NO|A;         B--&gt;|SI|C[Gira a la dreta];         C--&gt;D[Camina pel Ram\u00f3n i Cajal];      end      subgraph 2             D--&gt;E;         E{Hem arribat a la farmacia?}--&gt;|SI|F[Gira a l'esquerra];         E--&gt;|NO|C;         F--&gt;G[Camina pel Mestre Esteve];         G--&gt;H{Hem arribat alcarrer Moreral?}         H--&gt;|NO|G;         end      subgraph 3         H--&gt;|SI|I[Baixa pel carrer Moreral];         I--&gt;J{Has arribat al final del carrer?};         J--&gt;|SI|K[Gira a l'esquerra];         J--&gt;|NO|H;         K--&gt;L[Camina fins el Passeig];         L--&gt;Final((Fi));         style Final fill:#F00;     end   Exemple 4. Fer Zapping <ul> <li>Agafare el commandament</li> <li>Engegar la tele</li> <li>M'agrada el canal? </li> <li>Si no m'agrada canvie de canal</li> <li>Si s\u00ed que m'agrada, deixe el commandament i em pose comode.</li> </ul> Soluci\u00f3 graph LR     Ini((Inici))--&gt;A[Agafar Commandament TV];     style Ini fill:#0F0;     A--&gt;B[Engegar TV];     B--&gt;P1(fa:fa-spinner);     P1--&gt;C1{M'agrada el que fan?};     C1--&gt;|NO|C[Canvia de Canal];     C--&gt;P1;     C1--&gt;|SI|D[Posat Comode]     D--&gt;Fi((Fi));     style Fi fill:#F00;  Exemple 5. Adolesc\u00e8ncia (Spoiler: no t\u00e9 soluci\u00f3) <p>Durant l'adolesc\u00e8ncia cal marcar b\u00e9 les prioritats abans de les diversions. Tot adolescent abans de poder eixir amb els amics primer ha de fer els deures i despre\u015b tindre el quarto arreglat. Dissenya un algorisme que solucione aquest problema sense que l'adolescent haja de consultar a sa mare si pot eixir o no.</p> Soluci\u00f3 <p>graph LR     Ini((Inici))--&gt;A{Has fet  els deures?};     style Ini fill:#0F0;     A--&gt;|NO|B[Fes els deures];     B--&gt;A;     A--&gt;|SI|C{Has ordenatl'habitaci\u00f3?};     C--&gt;|NO|D[Ordena l'habitaci\u00f3];     C--&gt;|SI|E[Pots eixir];     E--&gt;Fi((Fi));     style Fi fill:#F00;  </p> Activitat 201. \u00das del transport p\u00fablic. <p>Acabes d'arribar a l'estaci\u00f3 del Nord de Val\u00e8ncia i necessites anar al Campus de tarongers, concretament a l'UPV, utilitzant els transports p\u00fablics de la ciutat. </p> <p>Per tal d'arribar a l'UPV hi han dues opcions: en autobus o en metro.</p> <p>Si agafes l'autob\u00fas, primer t'has de despla\u00e7ar caminant fins a la parada d'autobus que es troba a la Gran Via Marqu\u00e9s del Turia, trobar la marquesina i esperar a que arribe l'autob\u00fas amb el n\u00famero 93. Despr\u00e9s d'un trajecte d'uns 30 minuts quan arribes a la parada d'autobus del Campus de Tarongers, et baixes i ja estaries. </p> <p>Si pel contrari uses el metro pots agafar-lo directament des de la mateixa exidia de l'estaci\u00f3 del Nord baixant al metro. Una vegada al metro, has d'agafar la l\u00ednia roja (3) fins la parada de \"Vicent Saragoss\u00e0\". Arribats a la parada has de pujar a superf\u00edcie fins la parada del tramvia. Quan arribe el tramvia, has d'agafar el que va en direcci\u00f3 \"Doctor Lluch\" fins arribar a la parada de \"La Carrasca\". Baixes del tramvia i ja estaries.</p> <p>Utilitzant la t\u00e8cnica dels diagrames de flux, dissenya un algorisme que solucione el problema anterior. Et recomane que primer escriguen una seq\u00fc\u00e8ncia d'instruccions i despr\u00e9s ho passes a diagrama de flux.</p> <p>Els exemples de dissenys d'algorismes que hem vist abans, s\u00f3n exemples gr\u00e0fics per a la soluci\u00f3 de problemes quotidians on, normalment, serien v\u00e0lides tot tipus d'instruccions com per exmple: \"Camina cap al sud\", \"espera fins que arribe l'autobus\", \"busca\", \"ix de casa\" etc ..</p> <p>Per\u00f2 quan estem parlant d'ordinadors el conjunt d'instruccions amb el que ens podem comunicar amb la m\u00e0quina no \u00e9s el mateix que el llenguatge natural amb una persona amb totes les ambiguitats.  \u00c9s molt important que un llenguatge de programaci\u00f3, que \u00e9s la llengua amb la que ens comuniquem amb les m\u00e0quines, siga clar, conc\u00eds, simple i sobre totes les coses lliure d'ambig\u00fcuitats. Per exemple: la Thermomix \u00ae \u00e9s un dels robots de cuina m\u00e9s coneguts del mercat. Aquest robot t\u00e9 una interf\u00edcie molt senzilla formada per tres controls: Temps, Velocitat, Temperatura. Amb el temps podem establir el tems (segons) que estar\u00e0 la m\u00e0quina treballant, el control de velocitat determina la velocitat (0-10) a la que roden les aspes depenent si vols trituar molt els aliments o deixar-los sencers. Per \u00faltim la temperatura a la qual treballa el robot la podem regular des de 0 graus fins a 120.  Finalment ens quedaria nom\u00e9s el bot\u00f3 d'inici/parada que com b\u00e9 indica el que fa \u00e9s engegar quan est\u00e0 parada i parar quan est\u00e0 en marxa.  Com podeu observar les instruccions que se li poden donar a la Thermomix \u00ae a trav\u00e9s de la seua interf\u00edcie s\u00f3n molt reduides per\u00f2 si investigueu un poc per Internet trobareu que el total de receptes que es poden fer amb aquest set d'instruccions \u00e9s molt abundant.</p> Activitat 202. Recepta Thermomix\u00ae <p>Busca per Internet una recepta que t'agrade i amb la t\u00e8cnica abans vista dels diagrames de flux, dissenya un algorisme per al robot de cuina Thermomix \u00ae, tenint el seu repertori d'instruccions que hem vist abans. Recorda que depenent de la recepta que tries, pot ser que estiga dividida en parts i hi haja una part de l'algorisme on s'indiquen instruccions per al/la cuiner/a.</p>"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#estructures","title":"Estructures","text":"<p>Com ja hem anomenat als primers putns d'aquest tema, el teorema de la programaci\u00f3 estructurada preveu una s\u00e8rie d'estrucutures b\u00e0siques amb les quals es podr\u00eden codificar tots els algorismes sense necessitat d'usar cap sent\u00e8ncia GOTO o similar. Aquestes estructures s\u00f3n:</p> <ul> <li>Seq\u00fcencial: una sentencia s'executa despr\u00e8s d'acabar l'anterior.</li> <li>Condicional: s'avalua una condici\u00f3 i depenent del seu resultat s'executaran unes instruccions o altres.</li> <li>Repetitiva: repetici\u00f3 d'un grup d'instruccions que depenen d'una s\u00e8rie de condicions.</li> </ul> <p>Al final tot algorisme escrit en un llenguatge de programaci\u00f3 estrucuturada s'executa de forma seq\u00fcencial, \u00e9s a dir, es llig la primera sent\u00e8ncia s'executa i despr\u00e8s passem a la seg\u00fcent fins arribar al fif niatinal. Les estructures condicional i repetitiva es poden interpretar com estructures seq\u00fcencials amb algunes particularitats. L'estructura condicional potser s'execute o no i l'estructura repetitiva s'executara un nombre de vegades.</p> graph TD     A(Estructures de Control)--&gt;B(Seq\u00fcencial)     A(Estructures de Control)--&gt;C(condicional)     A(Estructures de Control)--&gt;D(Repetitiva)     A(Estructures de Control)--&gt;E(Salt)     C--&gt;F(if)     C--&gt;G(if else)     C--&gt;H(if niat)     C--&gt;I(switch)     D--&gt;J(while)     D--&gt;K(do while)     D--&gt;L(for)     E--&gt;M(break)     E--&gt;N(continue)"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#estructura-sequencial","title":"Estructura Seq\u00fcencial","text":"<p>Les ordres d'un programa s'executen per defecte en ordre seq\u00fcencial. El que significa que les instruccions s'executen, com hem comentat abans, una darrere de l'altra en el mateix ordre que apareixen escrites al programa.</p>  graph LR     id1((Inici))--&gt;Instrucci\u00f31;     style id1 fill:#0F0     Instrucci\u00f31--&gt;Instrucci\u00f32;     Instrucci\u00f32--&gt;Instrucci\u00f33;     Instrucci\u00f33--&gt;Instrucci\u00f34;     Instrucci\u00f34--&gt;Instrucci\u00f35;     Instrucci\u00f35--&gt;Instrucci\u00f36;     Instrucci\u00f36--&gt;id2([Fi]);     style id2 fill:#F00   <p>L'estructura seq\u00fcencial \u00e9s l'ordre natura d'execuci\u00f3. Les instruccions que formen part d'aquesta estructura s'executen en ordre una a continuaci\u00f3 de l'altra. Al final de cada instrucci\u00f3 hi ha un punt i coma per indicar-li al compilador el final de la sent\u00e8ncia individual. Les instruccions dintre d'una estructura seq\u00fcencial es solen agrupar en blocs ( {...} )</p> <pre><code>// Exemple de bloc - estructura seq\u00fcencial\n{\nInstrucci\u00f31;\nInstrucci\u00f32;\n...\nInstrucci\u00f3N;\n}\n</code></pre>"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#exemple-destructura-sequencial","title":"Exemple d'estructura seq\u00fcencial","text":"<p>Un exemple d'estructura seq\u00fcencial al m\u00f3n real seria com li podem donar ordres a alg\u00fa per tal que puga veure la tele. Seguint el nostre exemple, s'haurien de seguir els seg\u00fcents passos: agafar el commandament a dist\u00e0ncia, despr\u00e9s premer el bot\u00f3 ON/OFF per tal que s'engegue i finalment hauriem de escollir el canal que m\u00e9s ens agrade amb els controls pertinents del commandament a dist\u00e0ncia.</p> <pre><code>// Exemple d'estructura seq\u00fcencial.\n// Com engegar la TV\n{\nAgafarCommandament();\nPremerBotoOn();\nTriarCanal();\n}\n</code></pre> <p>En resum podr\u00edem dir que l'estructura seq\u00fcencial no \u00e9s m\u00e9s que un conjunt de sent\u00e8ncies o instruccions individuals agrupades.</p> Activitat 203: Millora el codi anterior. Estructura seq\u00fcencial. <p>La seq\u00fcencia d'instruccions anterior, \u00e9s molt simple i segurament no cobriria una soluci\u00f3 factible per els diversos escenaris en els que ens podriem trobar.</p> <p>Com milloraries el codi anterior per tal de fer-lo m\u00e9s eficient?  Escriu el codi utilitzant nom\u00e9s l'estructura seq\u00fcencial.</p>"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#estructures-de-seleccio","title":"Estructures de selecci\u00f3","text":"<p>\u00c9s una de les estructures que permeten modificar l'ordre d'execuci\u00f3 de les instruccions del programa. Una estructura condicional determina si s'executen unes accions o altres segons es compleixca o no una determinada condici\u00f3. La condici\u00f3 que es comprova per decidir si unes instruccions s'executen o no deu ser una expressi\u00f3 booleana, \u00e9s a dir, ha de donar com a resultat un valor boole\u00e0 true o false. </p> <p>En programaci\u00f3 estructurada ens podem trobar les seg\u00fcents:</p> <ul> <li>Selecci\u00f3 simple: si la condici\u00f3 s'acompleix, executa l'acci\u00f3, sino no fa res.</li> <li>Selecci\u00f3 doble: si la condici\u00f3 s'acompleix, executa una acci\u00f3 sino executa una altra acci\u00f3.</li> <li>Selecci\u00f3 multiple: davant una opci\u00f3 existeixen m\u00faltiples accions a realitzar.</li> <li>Operador condicional ?: expressi\u00f3 matem\u00e0tica que simula l'estructura condicional o de selecci\u00f3.</li> </ul>"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#seleccio-simple","title":"Selecci\u00f3 Simple","text":"<p>\u00c9s l'estructura condicional m\u00e9s simple en programaci\u00f3 estructurada. S'utilitza per determinar si una instrucci\u00f3 o bloc d'instruccions s'executa basat en una condici\u00f3. S'avalua la condici\u00f3 i si es true, s'executa la instrucci\u00f3 o bloc d'instruccions associat a la condici\u00f3.</p>     graph LR     id1((Inici))--&gt;Instrucci\u00f31;     style id1 fill:#0F0;     Instrucci\u00f31--&gt;Instrucci\u00f32;     Instrucci\u00f32--&gt;Cond1{Condici\u00f3};     Cond1--&gt;|SI|Instrucci\u00f33;     Instrucci\u00f33--&gt;Instrucci\u00f34;     Instrucci\u00f34--&gt;con1;     style con1 fill:#000;     Cond1--&gt;|NO|con1(fa:fa-spinner);     con1--&gt;Instrucci\u00f35;     Instrucci\u00f35--&gt;id2([Fi]);     style id2 fill:#F00;  <p>Si mirem b\u00e9 la imatge anterior, el codi que s'executaria seria:</p> <ol> <li>S'executa la instrucci\u00f3 1</li> <li>S'executa la instrucci\u00f3 2</li> <li>S'avalua a condici\u00f3</li> <li>Si s'acompleix: <ol> <li>S'executa la instrucci\u00f3 3</li> <li>S'executa la instruccio 4</li> </ol> </li> <li>S'executa la instrucci\u00f3 5</li> <li>S'acaba l'execuci\u00f3 de l'algorisme.</li> </ol> <p>En definitiva, al codi anterior podr\u00eden passar dues coses: que s'acompleixca la condici\u00f3 (true) o que no s'acompleixca (false). Si s'avalua true la condici\u00f3 el codi seria: Instrucci\u00f31, Instrucci\u00f32, Instrucci\u00f33, Instrucci\u00f34, Instrucci\u00f35 i Instrucci\u00f36. Pel contrari si s'avalua la condici\u00f3 a false, les instruccions a executar serien: Instrucci\u00f31, Instrucci\u00f32, Instrucci\u00f35 i Instrucci\u00f36. \u00c9s a dir, no s'executarien la 3 i la 4.</p> <p>El seu codi en pseudocodi seria:</p> <pre><code>    si (condicio) aleshores\ninstruccio\nfsi\n\n// O tamb\u00e9\nsi (condicio) aleshores\ninstruccio1\ninstruccio2\n...\ninstruccioN\nfsi\n</code></pre> <p>En el primer cas si quan s'avalua la condici\u00f3 aquesta \u00e9s veritat, s'executaria la instrucci\u00f3 si pel contrari la condici\u00f3 \u00e9s falsa, no es fa res.</p> <p>Al segon cas \u00e9s igual que el primer per\u00f2 en cas d'avaluar-se possitivament la condici\u00f3 no s'executaria una sola instrucci\u00f3 si no que s'executaria (seq\u00fcencialment) el bloc d'instruccions seg\u00fcent: instrucci\u00f31, instrucci\u00f32 fins instrucci\u00f3N.</p>"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#exemple-de-seleccio-simple","title":"Exemple de selecci\u00f3 simple","text":"<p>A continuaci\u00f3 expliquem un algorisme en el qual expliquem a alg\u00fa que ha de fer si plou a l'eixir de casa. B\u00e0sicament el que estem dient \u00e9s si est\u00e0 plovent que agafe el paraig\u00fces abans d'eixir de casa.</p> <pre><code>    // Exemple de selecci\u00f3 simple\nsi (plou) aleshores\nAgafaParaig\u00fces();\nfsi\nObrelaPorta();\nIxDeCasa();\n</code></pre> Activitat 204. Selecci\u00f3 Simple <p>Escriu un algorisme que simule una situaci\u00f3 al m\u00f3n real, diferent a l'exemple anterior, en el que utilitzes una estructura de selecci\u00f3 simple. Has de dissenyar el codi primer en diagrames de flux i despr\u00e9s en pseudocodi.</p>"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#seleccio-doble","title":"Selecci\u00f3 doble","text":"<p>Amb aquesta estructura condicional de la programaci\u00f3 estructurada es poden seguir camins distints depenent de si l'avaluaci\u00f3 de la condici\u00f3 \u00e9s true o false. En altres paraules, si la condici\u00f3 \u00e9s true, executaria una instrucci\u00f3 o bloc d'instruccions mentre que si s'avalua a false executaria una altra instrucci\u00f3 o bloc d'instruccions.</p> graph LR     id1((Inici))--&gt;Instrucci\u00f31;     style id1 fill:#0F0;     Instrucci\u00f31--&gt;Instrucci\u00f32     Instrucci\u00f32--&gt;C1{Condici\u00f3}     C1--&gt;|SI|Instrucci\u00f33;     Instrucci\u00f33--&gt;Instrucci\u00f34;     C1--&gt;|NO|Instrucci\u00f35;     Instrucci\u00f35--&gt;Instrucci\u00f36;     style con1 fill:#000;     Instrucci\u00f34--&gt;con1(fa:fa-spinner);     Instrucci\u00f36--&gt;con1;     con1--&gt;Instrucci\u00f37;     Instrucci\u00f37--&gt;Instrucci\u00f38;     Instrucci\u00f38--&gt;id2((FI));     style id2 fill:#F00  <p>El codi en pseudocodi del diagrama de flux anterior seria el seg\u00fcent:</p> <pre><code>instruccio1;\ninstruccio2;\nsi (condicio) aleshores\ninstruccio3;\ninstruccio4;\nsino\ninstruccio5;\ninstruccio6;\nfsi\ninstruccio7;\ninstruccio8;\n</code></pre> <p>Si ens fixem en el codi anterior, podem trobar dues seq\u00fc\u00e8ncies d'execucio d'instruccions depenenet si la condici\u00f3 del 'si' s'avalua 'veritable' o 'fals'. </p> <ul> <li>En el primer cas, amb la condici\u00f3 a 'true', s'executarien: instrucci\u00f31, instrucci\u00f32, instrucci\u00f33, instrucci\u00f34, instrucci\u00f37 i instrucci\u00f38.</li> <li>Mentre que si la condici\u00f3 del 'si' s'avaluara a 'false', les instruccions a executar serien: instrucci\u00f31, instrucci\u00f32, instrucci\u00f35, instrucci\u00f36, instrucci\u00f37 i instrucci\u00f38.</li> </ul>"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#exemple-de-seleccio-doble","title":"Exemple de selecci\u00f3 doble","text":"<p>Al seg\u00fcent exemple, utilitzarem l'estructura de selecci\u00f3 doble per tal de millorar l'exemple anterior de com entrar a casa amb les claus. Qu\u00e8 passaria si no tenim les claus de casa a la butxaca quan intentem entrar a casa? Que podriem fer? Fixa't en el seg\u00fcent codi.</p> <pre><code>// Exemple de selecci\u00f3 doble\nsi (plou) aleshores\nAgafaParaig\u00fces();\nsino\nPosatXancles();\nfsi\nObrelaPorta();\nIxDeCasa();\n</code></pre> Activitat 203. Selecci\u00f3 Doble <p>Seguint amb l'exemple de l'activitat 202, converteix el teu exemple, si es pot, en un algorisme que utlitze l'estructura de selecci\u00f3 doble. Igualment que a l'activitat anterior has de dissenyar el teu codi en diagrama de flux primer i despr\u00e9s en pseudocodi. En altres paraules, millora o amplia l'exemple de la vida real afegint-li les estructures noves.</p>"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#condicionals-niats","title":"Condicionals niats","text":"<p>Si volem avaluar m\u00e9s d'una condici\u00f3 al nostre codi, estariem parlant d'una estructura condicional m\u00faltiple que b\u00e0sicament consisteix en encadenar varios if..else. A continuaci\u00f3 es pot veure com seria un exemple de condicional m\u00faltiple en diagrama de flux.</p> graph LR     id1((Inici))--&gt;Instrucci\u00f31;     style id1 fill:#0F0;     Instrucci\u00f31--&gt;|NO|C1{Condici\u00f3 1};     C1--&gt;|NO|C2{Condici\u00f3 2};     C2--&gt;|NO|C3{Condici\u00f3 3};     C1--&gt;|SI|Instrucci\u00f32;     Instrucci\u00f32--&gt;Instrucci\u00f33;     C2--&gt;|SI|Instrucci\u00f34;     C3--&gt;|SI|Instrucci\u00f35;     Instrucci\u00f35--&gt;Instrucci\u00f36;     Instrucci\u00f36--&gt;Instrucci\u00f37;     style con1 fill:#000;     Instrucci\u00f33--&gt;con1(fa:fa-spinner);     Instrucci\u00f34--&gt;con1;     Instrucci\u00f37--&gt;con1;     con1--&gt;Instrucci\u00f310;     Instrucci\u00f310--&gt;Id2((FI));     style Id2 fill:#F00;  <p>El mateix exemple en pseudocodi que teniu a la imatge anterior seria:</p> <pre><code>instruccio1\n\nsi (condicio1) aleshores\ninstruccio2\ninstruccio3\n\nsino si (condicio2) aleshores\ninstruccio4\n\nsino si (condicio3) aleshores\ninstruccio5\ninstruccio6\ninstruccio7\nsino instruccio8\ninstruccio9\nfsi\ninstruccio10\n</code></pre> <p>Al codi anterior l'\u00fanic que s\u00ed sabem cert \u00e9s que s'executaran les instruccions 1, 2 i 10 i depenent de quina condici\u00f3 s'avalua a true s'executar\u00e0 algun bloc d'instruccions que estan dins de l'estructura condicional.</p>"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#exemple-destructura-condicional-niada","title":"Exemple d'estructura condicional niada","text":"<p>Un repatidor de Mirinda segueix el seg\u00fcent horari de feina: el dilluns reparteix a Pego, el dimarts a Oliva, el dimecres a Ondara, el dijous a El Verger i el divendres a Els poblets. Al seg\u00fcent algorisme utilitzarem els condicionals niats per dissenyar un algorisme que solucione el problema del repartidor de Mirinda.</p> <pre><code>// Exemple: El repartidor de Mirinda\nsi  huiEsDilluns  aleshores\nrepartirPego();\n\nsino si huiEsDimarts aleshores\nrepartir(Oliva();\n\nsino si huiEsDimecres aleshores\nrepartirOndara();fa:fa-spinner\n\nsino si huiEsDijous aleshores\nrepartirElVerger();\n\nsino si huiEsDivendres aleshores\nrepartirElsPoblets();\n\nsino\nNoEsTreballaHui();\n\nfsi\n</code></pre> Activitat 204. Condicional niada <p>M\u00e9s dif\u00edcil encara, modifica els exemples anteriors i per tal d'acoplar-hi al teu algorisme una estructura condicional niada.</p>"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#condicional-multiple","title":"Condicional m\u00faltiple","text":"<p>La sent\u00e8ncia de control 'switch' \u00e9s una altra forma de codificar la condici\u00f3 m\u00f9ltiple que hem vist a l'apartat anterior per\u00f2 m\u00e9s senzilla de visualitzar a primer cop d'ull. Fixa't en la imatge seg\u00fcent:</p> graph LR     id1((Inici))--&gt;Instrucci\u00f31;     style id1 fill:#F00;     Instrucci\u00f31--&gt;C1{Condici\u00f3 1};     C1--&gt;|A|Instrucci\u00f32;     C1--&gt;|B|Instrucci\u00f33;     C1--&gt;|C|Instrucci\u00f34;     style D fill:#000;     Instrucci\u00f32--&gt;D(fa:fa-spinner);     Instrucci\u00f33--&gt;D;     Instrucci\u00f34--&gt;D;     D--&gt;Instrucci\u00f35;     Instrucci\u00f35--&gt;id3((FI));      style id3 fill:#0F0;   <p>Al diagrama de flux anterior, s'avalua una condici\u00f3 (que pot resultar en m\u00e8s d'un cas diferent) i segons el resultat d'aquesta avaluaci\u00f3 de la condici\u00f3, realitzar\u00e0 una acci\u00f3 o una altra. Mira com s'escriuria el codi de la condicional m\u00faltiple.</p> <pre><code>enCasDe (expressi\u00f3) fer\ncas &lt;opcio1&gt;\nInstruccio1\nInstruccio2\n\ncas &lt;opcio2&gt; Instruccio3\nInstruccio4\n\nsino\nInstruccio5\nInstruccio6\nfiCas\n</code></pre> <p>L'exemple del repartidor ens serveriria per veure aquesta estructura. La condici\u00f3 a avaluar seria: **Quin dia es hu\u00ed?\". La resposta a aquesta pregunta, com tots podem intuir, pot donar diversos resultats, concretament 7: dilluns, dimarts, dimecres, dijous, divendres, dissabte o diumenge.  </p> <p>Ara es tractaria d'establir les accions a realitzar segons el resultat de l'avaluaci\u00f3 anterior com mostra el seg\u00fcent codi.</p> <pre><code>enCasDe (huiQuinDiaEs) fer\ncas &lt;Dilluns&gt;\nRepartirPego();\n\ncas &lt;Dimarts&gt; RepartirOliva();\n\ncas &lt;Dimecres&gt; RepartirOndara();\n\ncas &lt;Dijous&gt; RepartirElVerger();\n\ncas &lt;Divendres&gt; RepartirElsPoblets();\n\nsino\nHuiNoEsTreballa();\nfiCas\n</code></pre> Activitat 205. Estructura condicional m\u00faltiple. <p>Dissenya un algorisme que t'ajude a decidir quina roba posar-te abans d'eixir de casa en funci\u00f3 del temps que faja. Cal tenir en compte les seg\u00fcents consideracions geogr\u00e0fiques: estem a Pego i l'oratge pot ser molt variable. Es poden donar les seg\u00fcents condicions meteorol\u00f2giques: ploure a c\u00e0nters, fer un sol que bada penyes, fa frescoreta i tamb\u00e9 pot fer un fred que pela. El mateix programa l'has d'escriure utilitzant l'estructura encasde i la de selecci\u00f3 m\u00faltiple niada.</p>"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#estructures-de-repeticio","title":"Estructures de repetici\u00f3","text":"<p>Si les estructures condicionals serveixen per determinar quines instruccions o bloc d'instruccions s'executen, la programaci\u00f3 estructurada tamb\u00e9 disposa d'estrutctures repetitives o tamb\u00e9 anomenades bucles, que ens permeten executar una instrucci\u00f3 o bloc d'instruccions v\u00e0ries vegades.</p>"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#mentre","title":"mentre","text":"<p>Mentre la condici\u00f3 (tamb\u00e9 anomenada condici\u00f3 d'eixida) siga avaluada com a true, s'executar\u00eden les instruccions que hi ha dins del bucle while. </p> graph LR     Id1((Inici))--&gt;Instrucci\u00f31;     style Id1 fill:#0F0;     style D fill:#000;     Instrucci\u00f31--&gt;D(fa:fa-spinner);      D--&gt;C1{Condici\u00f3};     C1--&gt;|V|Instrucci\u00f32;     Instrucci\u00f32--&gt;P2((Fi));     style P2 fill:#F00;     C1--&gt;|F|D;  <p>En aquest tipus de bucle, el bloc d'instruccions del bucle while, es poden executar zero o m\u00e9s vegades.</p> <p>Els passos que representen el diagrama anterior s\u00f3n:</p> <ol> <li>S'executa la instrucci\u00f3 </li> <li>S'avalua la condici\u00f3 </li> <li>Si la condici\u00f3 \u00e9s true, s'executa el bloc d'instruccions del bucle i es torna a avaluar la condici\u00f3.</li> <li>En cas que la condici\u00f3 s'avalue com a false, passar\u00edem a executar la instrucci\u00f3 2.</li> </ol> <p>El codi escrit de l'estructura mentre explicada anteriorment seria:</p> <pre><code>mentre (condicio) fer\nInstruccio1\nInstruccio2\nfmentre\n</code></pre> Activitat 206: Obrir tots els calaixos. Mentre fer <p>Imagina que estas buscant el m\u00f2bil. Recordes que l'has guardat a un calaix de la teua habitaci\u00f3. El problema \u00e9s que a la teua habitaci\u00f3 entre armaris, escriptoris, tauletes de nit i altres mobles, hi ham m\u00e9s de 30 calaixos. Dissenya un codi en el que busques el m\u00f2bil obrint tots els calaixos fins que el trobes.</p>"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#repetir-mentre","title":"repetir .. mentre","text":"<p>Molt semblant al bucle while per\u00f2 amb la difer\u00e8ncia que el bloc s'instruccions que cont\u00e9 l'estructura s'executaria almenys una vegada ja que la condici\u00f3 d'eixida s'avalua despr\u00e9s d'executar les instruccions.</p> graph LR     Id1((Inici))--&gt;Instrucci\u00f31;     style Id1 fill:#F00;     style P1 fill:#000;     Instrucci\u00f31--&gt;P1(fa:fa-spinner);     P1--&gt;Instrucci\u00f32;     Instrucci\u00f32--&gt;C1{Condici\u00f3};     C1--&gt;|V|Instrucci\u00f33;     C1--&gt;|F|P1;     Instrucci\u00f33--&gt;Id2((Fi));     style Id2 fill:#0F0;   <p>Els passos que representen el diagrama anterior s\u00f3n:</p> <ol> <li>S'executa la instrucci\u00f3 1</li> <li>S'executen les instruccions que cont\u00e9 el bloc </li> <li>S'avalua la condici\u00f3 </li> <li>Si la condici\u00f3 \u00e9s true, s'executa el bloc d'instruccions del bucle i es torna a avaluar la condici\u00f3.</li> <li>En cas que la condici\u00f3 s'avalue com a false, passar\u00edem a executar la instrucci\u00f3 2.</li> </ol> <p>Exemple: Com far\u00edem el codi necessari per rec\u00f2rrer el nostre array de 100 elements fins trobar el n\u00famero que busquem?</p> <pre><code>fer\nInstruccio1\nInstruccio2\nmentre (condicio)\n</code></pre> Activitat 207. La formigonera. Fer mentre <p>Algorisme de la formigonera. Tenim una formigonera preparada amb l'aigua i el cement necessaris i nom\u00e9s ens faltaria posar-li l'arena necess\u00e0ria que est\u00e0 en un mont\u00f3 a prop de la formigonera. Disposem d'una pala per passar l'arena del mont\u00f3 a dins de la formigonera. Dissenya un algorisme que tire arena, pala a pala, dins de la formigonera fins que aquesta estiga plena.</p>"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#bucle-per","title":"bucle per","text":"<p>Aquesta estructura de repetici\u00f3 \u00e9s possiblement la m\u00e9s complicada de comprendre per\u00f2 tamb\u00e9 possiblement la m\u00e9s utilitzada. Aquesta estructura de control sol utilitzar-se la majoria de les vegades quan sabem la quantitat de vegades que es repetir\u00e0 la instrucci\u00f3 o conjunt d'instruccions que t\u00e9 dintre d'ella. Per\u00f2 mirem un exemple:</p> graph LR     Id1((Inici))--&gt;Instrucci\u00f31;     style Id1 fill:#0F0;     Instrucci\u00f31--&gt;Inicialitzaci\u00f3;     style D fill:#000;     Inicialitzaci\u00f3--&gt;D(fa:fa-spinner);      D--&gt;C1{Condici\u00f3}     C1--&gt;|NO|Instrucci\u00f32;     C1--&gt;|SI|Instruccions;     Instruccions--&gt;Actualitzaci\u00f3;     Actualitzaci\u00f3--&gt;D;     Instrucci\u00f32--&gt;Id3([Fi])     style Id3 fill:#F00;  <p>El diagrama anterior est\u00e0 executant les seg\u00fcents accions: </p> <ol> <li>Executem instrucci\u00f3 1 (aliena al bucle for)</li> <li>Inicialitzaci\u00f3</li> <li>Avaluaci\u00f3 de la condici\u00f3</li> <li>Si la condici\u00f3 \u00e9s true<ol> <li>Executem les instruccions del bucle for</li> <li>Actualitzem \u00edndex</li> </ol> </li> <li>Si la condici\u00f3 es false eixim del bucle i executem instrucci\u00f3 2</li> </ol> <p>Aquest mateix diagrama de flux es pot escriure en pseudocodi de la seg\u00fcent forma:</p> <pre><code>per i=0 mentre i &lt; 100 incrementa i en 1 fer\nInstruccio1\nInstruccio2\nfiper\n</code></pre> <p>Al codi anterior:</p> <ol> <li>Inicialitzaci\u00f3: int i = 0;</li> <li>Avaluaci\u00f3 de la condici\u00f3: \u00e9s mentre i &lt; 100 </li> <li>Instruccio1 i Instruccio2</li> <li>Actualitzaci\u00f3: incrementa i en 1</li> </ol> Activitat 208. Busca aigua. Bucle per <p>Dissenya un algorisme en diagrames de flux que busque la paraula \"aigua\" en qualsevol llibre en les 50 primeres p\u00e0gines. \u00c9s a dir, el nostre algorisme el que far\u00e0 ser\u00e0 llegir les 50 primeres p\u00e0gines d'un llibre qualsevol i comptar\u00e0 quantes vegades ha trobat la paraula aigua en total a les 50 p\u00e0gines.</p> <p>Has de dissenyar l'algorisme tant en diagrama de flux com en pseudocodi.</p>"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#activitats","title":"Activitats","text":"<p>Exposem a continaci\u00f3 algunes activitats per tal d'assolir els coneixements exposats als punts anteriors.</p> Activitat 209. Iniciar sessi\u00f3 a Facebook <p>Dibuixa un diagrama de flux per iniciar sessi\u00f3 en un compte de Facebook.</p> <ol> <li>Obrim el navegador web.</li> <li>Escrivim facebook.com</li> <li>Aquesta solicitud s'envia a Facebook i respon enviant-nos a la p\u00e0gina d'inici o login.</li> <li>Escrivim les nostres credencials, email i contrasenya i fem clic a inciar.</li> <li>Si es correcte es mostrar\u00e0 la p\u00e0gina del nostre perfil. En cas contrari, es produir\u00e0 un error i ens demanar\u00e0 una altra vegada usuari i contrasenya.</li> </ol> Soluci\u00f3 graph LR     Id1((Inici))--&gt;I1(Obre Navegador Web);     style Id1 fill:#0F0;     I1--&gt;I2[/Escriu URL/];     class I1 className;     I2--&gt;I3[/S'obre la p\u00e0gina/];     I3--&gt;I4[/Introdueix credencials/];     I4--&gt;I5{CredencialsCorrectes?};     I5--&gt;|NO|I3;     I5--&gt;|SI|I6(Pefil disponible);     I6--&gt;Id2((Fi));     style Id2 fill:#0F0;  Activitat 210. \u00c0rea d'un rectangle <p>Calcula l'\u00e0rea d'un rectangle donades les seues dimensions</p> <ol> <li>Inserim la base.</li> <li>Especifiquem l'al\u00e7ada.</li> <li>Calculem l'\u00e0rea: base per al\u00e7ada</li> <li>Mostrem el resultat per pantalla</li> </ol> Soluci\u00f3 graph LR     Ini((Inici))--&gt;A[/Introdueixla base/];     style Ini fill:#0F0;     A--&gt;B[/Introdueixl'altura/];     B--&gt;C[\u00c0rea=base*altura];     C--&gt;D[Mostra el resultat];     D--&gt;Fi((Fi));     style Fi fill:#F00;  Activitat 211. Hola m\u00f3n 10 vegades <p>Escriu el diagrama de flux necessari per imprimr per pantalla 10 vegades \"hola m\u00f3n\"</p> <p>Resolem aquesta activitat utilitzant el concepte bucle. Creem la variable \"cuenta\" i l'incialitzem a 0. Despr\u00e9s imprimim \"Hola m\u00f3n\" i incrementem la variable \"cuenta\" en uno.</p> <p>Verifiquem si \"cuenta\" encara \u00e9s menor que 10. En cas veritable, imprimim \"Hola m\u00f3n\" i tornem a incrementar. Quan la \"cuenta\" valga 10 eixim del programa.</p> <ol> <li>comptador = 0;</li> <li>Imprimir \"Hola m\u00f3n\"</li> <li>Incrementem cuenta</li> <li>Si comptador &lt; 10  tornem al pas 2 en cas contrari s'acaba l'execucui\u00f3</li> </ol> Soluci\u00f3 graph LR     Ini((Inici))--&gt;A[Compte=0];     style Ini fill:#0F0;     A--&gt;B[/Escriu: 'Hola m\u00f3n'/];     B--&gt;C[Compte=Compte + 1];     C--&gt;D{\u00c9s compteigual a 10};     D--&gt;|NO|B;     D--&gt;|SI|Fi((Fi));     style Fi fill:#F00;  Activitat 212. Preparar el t\u00e9 <p>Dibuixa el diagrama de flux amb els passos necessaris per preparar el t\u00e9.</p> <ol> <li>Comprar t\u00e9 i/o sucre. </li> <li>Tindre tassa i cullera.</li> <li>Posar a bollir aigua.</li> <li>Posar la bossa de t\u00e9 a la tassa.</li> <li>Posar aigua a la tassa amb la bossa (de t\u00e9).</li> <li>Esperar uns minuts a que es disolga el t\u00e9.</li> <li>Retirar la bossa (de t\u00e9)</li> <li>Vols sucre? Si la resposta \u00e9s s\u00ed, posar sucre i remenejar. Si la resposta \u00e9s no s'acabat el proc\u00e9s.</li> </ol> Soluci\u00f3 graph LR     Ini((Inici))--&gt;Z{Tens t\u00e9 i sucre o sucre?}             style Ini fill:#0F0;     Z--&gt;|NO|A[Comprar t\u00e9 i mel o sucre];     Z--&gt;|SI|B[Posar un cassetteamb aigua a bollir];     A--&gt;Z;     B--&gt;C[Esperar que l'aigua bullga];     C--&gt;D{Bull l'aigua?};     D--&gt;|SI|E[Posa la bolsetade t\u00e9 a la ta\u00e7a];     E--&gt;F[Posar l'aigua];     D--&gt;|NO|C;     F--&gt;BREAK1(fa:fa-spinner);     style BREAK1 fill:#F0F;  graph LR     BREAK2(fa:fa-spinner)--&gt;G[Esperar a que el t\u00e9 es dissolga];     style BREAK2 fill:#F0F;     G--&gt;H{S'ha dissolt el t\u00e9 al teu gust};     H--&gt;|NO|G;     H--&gt;|SI|I{Vols sucreo mel?};     I--&gt;|SUCRE|Y[Posa sucre al gust];     I--&gt;|MEL|R[Posa mel al gust];     Y--&gt;P2{fa:fa-spinner};J     R--&gt;P2;question     I--&gt;J{Est\u00e0 prou dol\u00e7?};     J--&gt;|NO|I;     J--&gt;|SI|K[Remenejar];     K--&gt;L{Est\u00e0 calent?};     L--&gt;|SI|M[Esperar];     M--&gt;K;     L--&gt;|NO|N[Beure];     N--&gt;Fin((Fi));     style Fin fill:#F00;  Activitat 213. N\u00famero major <p>Escriu el diagrama de flux de tal forma que donats dos n\u00fameros ens indique quin \u00e9s m\u00e9s gran.</p> <ol> <li>Introudir els valors A i B</li> <li>Llegir els seus valors</li> <li>Si A == B tornar al pas 1</li> <li>Si A &gt; B escriure per pantalla: \"A \u00e9s major que B\"</li> <li>En cas contrari escriure: \"B \u00e9s major que A\".</li> <li>Acabar el proc\u00e9s.</li> </ol> Soluci\u00f3 graph LR     Ini((Inici))--&gt;BREAK(fa:fa-spinner);     style Ini fill:#0F0;     BREAK--&gt;Z[/Introdueix dos nombres\\];             Z--&gt;A[/Llig A/];     A--&gt;B[/Llig B/];     B--&gt;C{\u00c9s A igual a B?};     C--&gt;|SI|BREAK;     C--&gt;|NO|D{\u00c9s A major que B?};     D--&gt;|SI|E[/A \u00e9s el major/];     D--&gt;|NO|F[/B \u00e9s el major/];     E--&gt;BREAK2(fa:fa-spinner);     F--&gt;BREAK2;     BREAK2--&gt;Fi((Fi));     style Fi fill:#F00;  Activitat 214. Suma dos n\u00fameros <p>Algorisme que demana dos n\u00fameros i els suma mostrant el resultat per pantalla.</p> <ol> <li>Declarem la variable suma i la inicialitzem a 0.</li> <li>Inserim dos n\u00fameros.</li> <li>Sumem els dos n\u00fameros i els afegim a suma.</li> <li>Mostrem suma per pantalla.</li> </ol> Soluci\u00f3 graph LR     Ini((Inici))--&gt;Z[Suma=0];     style Ini fill:#0F0;     Z--&gt;A[/Llig A/];     A--&gt;B[/Llig B/];     B--&gt;C[Suma=A+B];     C--&gt;D[/Mostrar Resultat/];     D--&gt;Fi((Fi));     style Fi fill:#F00;  Activitat 215. Llevar la fam <p>Ens trobem a casa i tenim fam. Qu\u00e8 fem?</p> <ol> <li>Preguntem si tenim fam.</li> <li>Si la resposta \u00e9s no s'acaba el procediment, ja estem satisfets.</li> <li>Si la resposta \u00e9s si busquem el menjar a la nevera.</li> <li>Si hi ha menjar a la nevera la calfem i mengem</li> <li>Si no hi ha res a la nevera,    </li> <li>Ini((Inici))--&gt;A[/Introdueix un nombre:/];</li> </ol> Soluci\u00f3 graph LR     Ini((Inici))--&gt;A{Tens fam?};     style Ini fill:#0F0;     A--&gt;|SI|B[Busca a la nevera];     A--&gt;|NO|C[Satisfet];     B--&gt;D{Hi ha menjar?};     D--&gt;|SI|BREAK(fa:fa-spinner);     BREAK--&gt;E[Calfar o preparar algo];     D--&gt;|NO|F[Anar a comprar];     F--&gt;BREAK;     E--&gt;G[Menjar];     G--&gt;Fi;      C--&gt;Fi((Fi));     style Fi fill:#F00;  Activitat 216. Par o impar <p>Algorisme que determina si el n\u00fameroJ que inserim \u00e9s parell o senar.</p> <ol> <li>Introduim un n\u00famero 'N'</li> <li>Si 'N' es divideix entre 2 i el residu \u00e9s 0 (N mod 2 = 0), aleshores 'N' \u00e9s parell.</li> <li>En cas contrari \u00e9s senar.</li> </ol> Soluci\u00f3 graph LR     Ini((Inici))--&gt;A[/Introdueix un nombre:/];     style Ini fill:#0F0;     A--&gt;B[/Llig N/];     B--&gt;C{\u00c9sN mod 2igual a 0?};     C--&gt;|SI|D[/N \u00e9s parell/];     E--&gt;P1(fa:fa-spinner);     C--&gt;|NO|E[/N no \u00e9s parell/];     D--&gt;P1;     P1--&gt;Fi((Fi));     style Fi fill:#F00;   Activitat 217. Agafar el paraig\u00fces <p>Algorisme per determinar quan ixc de casa si necessite o no agafar un paraig\u00fces.</p> <ol> <li>Comprovem si est\u00e0 plovent.</li> <li>Si la resposta \u00e9s No, eixim al carrer sense paraig\u00fces.</li> <li>Si la resposta \u00e9s S\u00ed, busquem el paraig\u00fces</li> <li>Si el trobem eixim al carrer</li> <li>En cas contrari tornem al pas 1.</li> </ol> Soluci\u00f3 graph LR Ini((Inici))--&gt;A{Est\u00e0 plovent?}; style Ini fill:#0F0; A--&gt;|SI|B[Busquem paraig\u00fces]; A--&gt;|NO|C[Eixim al carrer];  style Fi fill:#F00;  B--&gt;D{Hem trobat paraig\u00fces?}; D--&gt;|SI|C; D--&gt;|NO|A; C--&gt;Fi((Fi));  Activitat 218. Mitjana <p>Algorisme que calcula la mitjana d'un alumne amb tres notes i mostra per pantalla si est\u00e0 \"Aprovat\" o \"Susp\u00e9s\". La nota m\u00ednima per aprovar \u00e9s 11.</p> <ol> <li>Declarem les variables a utilitzar: Nota1, Nota2, Nota3, Mitjana.</li> <li>Inserim les notes per teclat.</li> <li>Calculem la mitjana</li> <li>Verifiquem si la mitjana \u00e9s major o igual a 5.</li> <li>Si \u00e9s major que 5, escrivim per pantalla \"Aprovat\"</li> <li>En cas contrari escrivim \"Susp\u00e9s\" </li> </ol> Soluci\u00f3 graph LR     Ini((Inici))--&gt;A[/IntrodueixNota 1:/];     style Ini fill:#0f0;     A--&gt;B[/Llig N1/];     B--&gt;C[/IntrodueixNota2:/];     C--&gt;D[/Llig N2/];     D--&gt;E[/IntrodueixNota3:/];     E--&gt;F[/Llig N3/];     F--&gt;G[Calcular mitjana];     G--&gt;H{\u00c9s la mitjanamajor o igual a 5};     H--&gt;|SI|I[/Has aprovat/];     H--&gt;|NO|J[/Has susp\u00e9s/];     I--&gt;K(fa:fa-spinner);     J--&gt;K;     K--&gt;Fi((Fi));     style Fi fill:#F00;"},{"location":"Tema%2003.%20El%20llenguatge%20Java/","title":"Tema 3. El llenguatge Java","text":""},{"location":"Tema%2003.%20El%20llenguatge%20Java/#introduccio","title":"Introducci\u00f3","text":"<p>Una vegada estudiat el teorema del programa estructurat juntamnet amb els diagrames de flux i psuedocodi, passem a veure aquestos conceptes te\u00f2rics en un llenguatge de programaci\u00f3 d'alt nivell concret com \u00e9s el llenguatge de programaci\u00f3 Java.</p> <p>El Java \u00e9s un llenguatge de programaci\u00f3 dissenyat el 1990 per James Gosling amb altres companys de Sun Microsystems a partir del llenguatge C. Des del seu naixement fou pensat com un llenguatge orientat a objectes. Entre el 13 de novembre de 2006 i el maig del 2007 Sun va alliberar parts de Java com a programari lliure de codi obert amb llic\u00e8ncia GPL. \u00c9s un dels llenguatges de programaci\u00f3 m\u00e9s utilitzats, i s'utilitza tant per aplicacions web com per aplicacions d'escriptori.</p> <p>El Java \u00e9s un llenguatge compilat amb una m\u00e0quina virtual d'intermediari i, per tant, pot semblar lent en comparaci\u00f3 amb altres llenguatges, per\u00f2 ofereix un \u00edndex de re-utilitzaci\u00f3 de codi molt elevat, sent possible trobar moltes llibreries lliures de Java. \u00c9s un llenguatge flexible i potent tot i la facilitat amb la qual es programa i dels resultats que ofereix. Un dels trets que el caracteritza i que el fa una eina molt valorada a l'hora de desenvolupar aplicacions distribu\u00efdes, \u00e9s el fet que \u00e9s un llenguatge multi-plataforma.</p> <p>Generalment els programes de Java es compilen en un bytecode (fitxer .class) que pot c\u00f3rrer en una M\u00e0quina Virtual Java. Sun Microsystems disposa de tres implementacions diferents de Java: J2SE per a aplicacions d'escriptori; J2EE per a aplicacions distribu\u00efdes i J2ME per a plataformes amb recursos m\u00e9s redu\u00efts com ara m\u00f2bils o PDAs. Per a cada una de les tres implementacions \u00e9s possible descarregar el JRE (entorn d'execuci\u00f3 Java) per a executar aplicacions o el SDK (Eines per al desenvolupament d'aplicacions) per a programar aplicacions en Java, aquest \u00faltim tamb\u00e9 inclou el JRE.</p>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#caracteristiques-de-java","title":"CARACTER\u00cdSTIQUES DE JAVA","text":"<ul> <li>Senzill: Java s'ha creat perqu\u00e8 sigui un llenguatge senzill amb una sintaxi elegant. \u00danicament consta de tres tipus de dades prim\u00e0ries, eliminant els punters i l'her\u00e8ncia m\u00faltiple</li> <li>Orientat a objectes: Java segueix els paradigmes de la programaci\u00f3 orientada a objectes, ja que la programaci\u00f3 amb Java se centralitza en la manipulaci\u00f3, creaci\u00f3 i construcci\u00f3 d'objectes.</li> <li>Distribu\u00eft: Java permet la construcci\u00f3 d'aplicacions distribu\u00efdes per mitj\u00e0 d'una col\u00b7lecci\u00f3 espec\u00edfica de classes.</li> <li>Interpretat: Es necessita un int\u00e8rpret per executar els programes de Java, aix\u00f2 alenteix als programes per\u00f2 els hi dona flexibilitat.</li> <li>Robust: Java \u00e9s un llenguatge robust i fiable, s'ha escrit pensant a poder verificar errors i est\u00e0 molt tipificat.</li> <li>Segur: Java t\u00e9 pocs problemes de seguretat, caracter\u00edstica molt important en les aplicacions distribu\u00efdes d'Internet.</li> <li>Arquitectura neutral: Java \u00e9s independent de la plataforma final on s'executar\u00e0 el programa.</li> <li>Portable: Java \u00e9s un llenguatge d'alt nivell i de plataforma independent, aix\u00f2 li dona portabilitat.</li> <li>Alt rendiment: Els compiladors Java han anat millorant les seves prestacions. Els nous compiladors coneguts com a JIT permeten un rendiment molt semblant als llenguatges convencionals compilats.</li> <li>Concurrent: Java permet l'execuci\u00f3 de m\u00faltiples fils d'execuci\u00f3, o diverses tasques de forma simult\u00e0nia.</li> <li>Din\u00e0mic: En temps d'execuci\u00f3, l'entorn Java es pot ampliar mitjan\u00e7ant enlla\u00e7os a classes que poden estar localitzades en servidors remots o en xarxa.</li> </ul> <p>Un programa desenvolupat amb Java no necessita compilar-se de nou per a poder executar-se en qualsevol de les plataformes que disposi d'una versi\u00f3 instal\u00b7lada de JRE prou actualitzada per al programa.</p> <p>En aquest tema veurem la sintaxis b\u00e0sica de Java: paraules reservades, dades, variables, constants, identificadors i com tamb\u00e9 es codifiquen les estructures de control vistes al tema anterior en llenguatge Java.</p>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#dades-variables-identificadors","title":"Dades, Variables, identificadors.","text":"<p>Eventualment la inform\u00e0tica el que tracta de fer \u00e9s interpretar i processar informaci\u00f3, per tant, el primer pas hauria de ser implementar el mecanisme que s'encarregue de representar la informaci\u00f3 tal i com la interpretem nosaltres al m\u00f3n real. </p> <p>La informaci\u00f3 en inform\u00e0tica \u00e9s el contingut d'una o m\u00e9s dades, fent abstracci\u00f3 de la representaci\u00f3 concreta que adopta.</p> <p>Dit d'una altra manera. Imagineu el caixer d'un supermercat. Al final del dia el treballador que est\u00e0 a c\u00e0rrec del caixer, treur\u00e0 tota la recaudaci\u00f3 del dia i la comptar\u00e0. En aquest cas la informaci\u00f3 seria la quantitat total de diners que s'han recaudat, i es representa en forma de dada num\u00e8rica utilitzant nombres i algun signe de puntuaci\u00f3, 1.200,45\u20ac seria la dada que representa la informaci\u00f3 que es vol saber al final del dia.</p> Qu\u00e8 s\u00f3n les Dades <p>Una dada \u00e9s \"la representaci\u00f3 convencional de la informaci\u00f3 en un format adequat perqu\u00e8 puga ser processada, comunicada o interpretada per mitjans manuals o autom\u00e0tics.\"</p> <p>Ara la q\u00fcesti\u00f3 \u00e9s com aquesta informaci\u00f3 que al m\u00f3n real es representa utilitzant n\u00fameros la podem representar en forma de dada per tal que una m\u00e0quina siga capa\u00e7 de processar.  En qualsevol llenguatge de programaci\u00f3, la informaci\u00f3 es pot representar de forma constant, amb literals per exemple, o de forma variable utilitzant identficadors.  Mirem a continuaci\u00f3 amb m\u00e9s detall aquestos conceptes.</p> Qu\u00e8 s\u00f3n les Variables <p>Una variable en el camp de les matem\u00e0tiques \u00e9s una quantitat que pot cr\u00e9ixer o decr\u00e9ixer d'una manera cont\u00ednua o discont\u00ednua. Mentre que en inform\u00e0tica \u00e9s un s\u00edmbol emprat en programaci\u00f3 per a emmagatzemar en mem\u00f2ria valors canviants.</p> <p>En resum, la realitat cont\u00e9 una informaci\u00f3 en forma de dada que representarem en un programa inform\u00e0tic de diverses formes, b\u00e9 a trav\u00e9s de literals o de variables a les quals accedirem utilitzant identificadors.</p> <p>Per\u00f2 no ens avancem encara i estudiem b\u00e9 qu\u00e8 \u00e9s un identificador. En tot llenguatge de programaci\u00f3 existeixen una s\u00e8rie d'elements com variables, constants, funcions, llibreries. Aquestos elements requereixen d'un nom per tal de distingir-lo de la resta. Aquestos noms es diuen identificadors</p> Qu\u00e8 s\u00f3n els identificadors <p>Un identificador \u00e9s una cadena alfan\u00famerica que representa o dona un nom a un element dins del nostre programa. Els identificadors de les variables s\u00f3n noms que s'inventa el programador i s'hauria de tindre en consideraci\u00f3 al seg\u00fcent m\u00e0xima: han de ser significatius</p> <p>En altres paraules, un identificador \u00e9s una etiqueta que podem utilitzar per anomenar \"coses\" en un programa inform\u00e0tic. Pel que fa al concepte de significatiu, vol dir que el nom que escollim per a l'etiqueta hauria de ser suficientment esclaridor per saber qu\u00e8 \u00e9s el que representa. Per exemple, si volem posar una etiquta (amb una enganxina) a una botella d'aigua que tenim a la nevera, una bona elecci\u00f3 seria: AIGUA.</p> <p>Una \u00faltima cosa, com en tot llenguatge de programaci\u00f3, Java t\u00e9 una s\u00e8rie de normes que hem de seguir per construir identificadors v\u00e0lids. LLig i revisa les normes de construcci\u00f3 d'identificadors de Java, que d'altra banda, s\u00f3n molt semblants a la majoria de llenguatges de programaci\u00f3.</p> <p>Normes per construir identificadors en Java</p> <p>Quan triem el nom per identificar a una variable, ha de ser significatiu, \u00e9s a dir, que el mateix identificador ja done alguna pista de que \u00e9s el que representa.</p> <ul> <li>1. Estan formats per caracters i/o digits.</li> <li>2. No poden comen\u00e7ar per digit.</li> <li>3. No poden usar els seg\u00fcents caracters especials: <code>+ - * / = % &amp; # ! ? ^ \u201c \u2018 ~ \\ | &lt; &gt; ( ) [ ] { } : ; . ,</code></li> <li>4. No poden ser cap paraula reservada de Java.</li> <li>5. Els identificadors de Java distingeixen entre maj\u00fascules i min\u00fascules (case sensitive).</li> <li>6. No hi ha l\u00edmit a la llarg\u00e0ria de l'identificador, per\u00f2 \u00e9s aconsellable utilitzar una grand\u00e0ria \u00f2ptima entre 4 i 15 caracters.</li> </ul> <p>Vejam a continuaci\u00f3 alguns exemples d'identificadors inventats per un programador qualsevol:</p>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#exemples-didentificadors","title":"Exemples d'identificadors","text":"<p>Observa la llista d'identificadors seg\u00fcents:</p>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#identificadors-correctes","title":"Identificadors Correctes","text":"<ul> <li>H0la: malgrat tindre un n\u00famero comen\u00e7a per un caracter alfanum\u00e8ric.</li> <li>$vicent: v\u00e0lid ja que el s\u00edmbol de dollar \u00e9s un caracter alfanum\u00e8ric v\u00e0lid per inicia un identificador.</li> <li>_strNom: els identificadors poden comen\u00e7ar per '_' \u00e9s m\u00e9s de vegades \u00e9s un convecionalisme per algun tipus concret de variable.</li> <li>_3variable: seria incorrecta si no tingu\u00e9s '_' com a primer caracter de l'identificador.</li> <li>VarTest: totalment correcta.</li> <li>variabletest: cap incorrecci\u00f3</li> <li>aci_tens_una_variable_valida_que_representa_un_enter: identificador totalment v\u00e0lid, altra cosa \u00e9s que els noms tan llargs siguen \u00fatils.</li> <li>valor_max: el subratllat tamb\u00e9 sol ser una t\u00e8cnica que s'utilitza per a serparar dues paraules que formen un identificador.</li> </ul>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#identificadors-incorrectes","title":"Identificadors Incorrectes","text":"<ul> <li>8exemple: comen\u00e7a per n\u00famero</li> <li>exa+mple: el signe + no est\u00e0 perm\u00e8s</li> <li>prova variable: espai en blanc</li> <li>esta_variable_no_es_valida_no_per_llarga_sino_per_este-guionet: a banda del gui\u00f3 del final tampoc \u00e9s massa aconsellable utilitzar noms tan llargs.</li> </ul> Activitat 301. Identificadors <p>Com ja hem explicat a l'apartat anterior, per formar un identificador s'han de seguir unes normes:</p> <p>Apartat 1. Revisa els identificadors seg\u00fcents i digues-me quins s\u00f3n v\u00e0lids i quins no. Si no s\u00f3n v\u00e0lids explica el motiu.</p> Identificador Es v\u00e0lid? Motiu Identificador Es v\u00e0lid? Motiu Registro1 1registro while $impuesto a\u00f1o primer apellido primer_apellido primer-apellido primerApellido Tom's C3PO 123# PesoM\u00e1ximo %descuento Weight $$precioM\u00e0ximo peso.maximo Precio___ matricula? Cu\u00e1ntoVale high bar\u00e7a pirag\u00fcista B_011 X012AB 70Libro nombre&amp;apellido 0X1A else <p>Apartat 2. Crea identificadors per als seg\u00fcents escenaris.</p> <ol> <li>Una etiqueta que identificar\u00e0 l'edat d'una persona: </li> <li>Un nom d'assignatura: </li> <li>Una mitjana aritm\u00e8tica de notes: </li> <li>La profunditat d'una piscina: </li> <li>Els litres d'aigua que hi han a la nevera: </li> <li>La dist\u00e0ncia al supermercat m\u00e9s pr\u00f2xim: </li> </ol> <p>Apartat 3. En aquest tema anem a fer un joc d'una boleta amb Processing IDE. En aquest joc anem a necessitar variables on emmagatzemarem informaci\u00f3 sobre:</p> <ol> <li>Posici\u00f3 de la boleta (coordenada X):</li> <li>Posici\u00f3 de la boleta (coordenada Y):</li> <li>Velocitat de la boleta:</li> <li>Direcci\u00f3 de la boleta (coordenada X):</li> <li>Direcci\u00f3 de la boleta (coordenada Y):</li> <li>Color RGB de la boleta:</li> </ol>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#paraules-reservades","title":"Paraules reservades","text":"<p>Uns dels principals identificadors que ens trobarem a tot llenguatge de programaci\u00f3 s\u00f3n les paraules reservades. Per entendre-ho, el conjunt de paraules reservades d'un llenguatge de programaci\u00f3 s\u00f3n el diccionari de totes les paraules que t\u00e9 aquest llenguatge. </p> <p>Aquetes paraules reservades no poden utilitzar-se per cap altra cosa m\u00e9s, per exemple, si Java t\u00e9 la paraula reservada public, el programador no podr\u00e0 crear cap variable utilitzant l'identificador public.</p> Paraules reservades abstract continue for new switch assert default goto package sychronized boolean do if private this break double implements protected throw byte else import public thows case enum instanceof return transient catch extends int short try char final interface static void finally long strictfp volatile const float native super while class <p>Paraules reservades en Processing IDE</p> <p>Com que Processing IDE no \u00e9s  m\u00e9s que una capa afegida a l'entorn de programaci\u00f3 en Java, t\u00e9 les mateixes paraules reservades que Java i a m\u00e9s afegeix les seg\u00fcents: setup, draw, mouseClicked, keyPressed, delay, background, size, clear, rect, ellipse, circle, triangle, pushMatris, popMatrix, translate, PVector, PImage etc..</p> <p>No existeix una taula on les pugam consultar totes, \u00e9s q\u00fcesti\u00f3 d'anar treballant amb Processing i aprendre-les conforme les anem utilitzant.</p> Activitat 302. Identifica i classifica identificadors <p>Llig el seg\u00fcent codi amb atenci\u00f3, localitza tots els identificadors i digues-me quins s\u00f3n paraules reservades i quins no. D'aquells que no s\u00f3n paraules reservades, quina informaci\u00f3 penses que volen representar?</p> <pre><code>    void setup () {\nsize(640,480);\n}\n\nvoid draw () {\nclear();\nbackground(255);\nfloat a = random(640);\nfloat b = random(480);\ndibuixaUnaBoleta(a,b);\ndelay(500);\n}\n\nvoid dibuixaUnaBoleta(float num1, float num2) {\nfill(0);\nellipse(a,b,30,30);\n}\n</code></pre>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#tipus-de-dades","title":"Tipus de dades","text":"<p>Fins ara tot ha girat al voltant d'informaci\u00f3, dades, identificadors, literals i variables, ja que s\u00f3n la base per poder representar la informaci\u00f3 i les dades d'un problema. Per\u00f2, quins tipus de dades es poden representar en Java?</p> <p>Tot llenguatge de programaci\u00f3 porta una s\u00e8rie de tipus de dades predefinits que es poden usar. Aquestos tipus de dades tamb\u00e9 es coneixen com a tipus primitius o tipus simples.. Java defineix 8 tipus diferents de dades: byte, short, int, long, char, float, double i boolean. Aquestos tipus es poden agrupar en quatre blocs:</p> <ul> <li>Nombres enters: on podem trobar el byte, short, long i int. Aquestos tipus admeten valors no fraccionables en parts m\u00e9s xicotetes que la unitat. Per exemple: 1, 3, 5, 15, 20, 132... </li> <li>Punt flotant: aquest grup inclou el float i el double on es representen els nombres decimals, \u00e9s a dir, aquells que s\u00ed admeten fraccions. Per exemple: 1.3, 5.802039, etc..</li> <li>Caracters: char representa a tot el conjunt de caracters del nostre sistema alfab\u00e8tic inclosos els s\u00edmbols. Per exmple: a, b, c, $, ?...</li> <li>Boole\u00e0: boolean \u00e9s un tipus especial que nom\u00e9s pot tindre dos possibles valors: true o false. Qu\u00e8 s\u00f3n els dos valors l\u00f2gics de l'algebra de George Boole.</li> </ul>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#taula-de-tipus-de-dades-en-java","title":"Taula de tipus de dades en Java","text":"Tipus Bytes Representaci\u00f3 Categoria byte 1 de -128 a 127 enter short 2 de -32.768, 32.767 enter int 4 de -2^31 a 2^31-1 enter long 8 de -2^63 a 2^63-1 enter float 4 de 1.4x10^-45 a 3.4028235x10^38 decimal double 8 de 4.9x10^-324 a 1.7976931348623157x10^308 decimal char 2 caracters UTF-16 caracter bool 1 true o false boole\u00e0 <p>En resum del que hem vist fins ara, el primer que s'ha d'establir en tot llenguatge de programaci\u00f3 d'alt nivell, s\u00f3n els mecanismes necessaris per tal de poder representar en totes les seues variants possibles la informaci\u00f3 del m\u00f3n real que volem informatitzar i processar. Aquestos mecanismes s\u00f3n: Tipus de dades, Identficadors, Paraules reservades i Variables</p>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#variables","title":"Variables","text":"<p>Al final tot programa s'encarrega de processar informaci\u00f3 i aquesta informaci\u00f3 ha d'estar disponible en algun lloc del nostre codi. Per exemple si volem fer un programa que sume dos n\u00fameros enters, haurem de tindre la informaci\u00f3 o el valor d'aquestos dos n\u00fameros en algun lloc. </p> <p>Una variable \u00e9s com un contenidor (una caixeta) que t\u00e9 associat un tipus de dades (int, float, double, char) i cont\u00e9 un valor, si es tracta d'una variable de tipus enter contindr\u00e0 un valor enter, si per contra es tracta d'una variable de tipus caracter contindr\u00e0 una lletra o s\u00edmbol alfanum\u00e8ric.</p> <p> </p> <p>La variable \u00e9s l'unitat b\u00e0sica d'emmagatzemament en Java. Una variable en java es defineix amb la combinaci\u00f3 d'un identificador i el seu tipus de dades. Mira els exemples a continuaci\u00f3:</p> <pre><code>// Declaraci\u00f3 d'una variable en Java\n// type identifier;\n// On type \u00e9s algun dels tipus de dades que hem vist a l'apartat anterior\n// i identifier \u00e9s l'identificador que volem utilitzar.\n// Per exemple:\nint a;  // Declaraci\u00f3 d'una variable entera amb nom a\nfloat b; // Variable flotant de nom b\nchar c;  // Variable caracter amb nom c\nint i = 0; // En aquesta declaraci\u00f3 s'inclou tamb\u00e9 la inicialitzaci\u00f3 del seu valor.\nlong j; </code></pre> <p>Les variables com a contenidors d'informaci\u00f3, poden variar (d'ahi el nom de variable) el seu valor durant l'execuci\u00f3 del programa.</p> <p> </p> <p>Per\u00f2 millor vegem un exemple, imaginem una aplicaci\u00f3 en la que volem controlar la posici\u00f3 d'un element qualsevol, per exemple un cercle a una pantalla 2D (o una boleta). Per determinar la poisci\u00f3 de qualsevol element en un escenari 2D necessitem dues coordenades: x i y. Les variables que podriem utiltizar serien dos variables de tipus enter on al seu nom s'indique clarament el que intenten representar. Si vullguerem fer un sistema on les posicions tingueren m\u00e9s precissi\u00f3, podriem usar floats en lloc d'ints.</p> <pre><code>int posX;           // Variables que representa la posici\u00f3 X de l'element.\nint posY;           // Variable que representa la posici\u00f3 Y de l'element.\n\nfloat posXPrecisa;  // Variable que representa la posici\u00f3 X de l'element amb precisi\u00f3 flotant.\nfloat posYPrecisa;  // Variable que representa la posici\u00f3 Y de l'element amb precisi\u00f3 flotant.\n</code></pre> <p>Observa el codi anterior i basant-se en la norma de creaci\u00f3 de variables type identifier; que hem vist abans, raona quins s\u00f3n els tipus de dades de les variables i quins els seus identificadors?</p> <p>Si hi han moltes variables que tenen el mateix tipus base, podem agrupar les declaracions per tipus separant els identificadors amb coma excepte a l'\u00faltim identificador, on a continuaci\u00f3 seguir\u00edem posat un punt i coma per indicar el final de la sent\u00e8ncia.</p> <pre><code>int a, b, c, d, e, f, g; // Declaracio de m\u00faltiples variables de tipus enter\nfloat m, n, o, p, q;     // Declaraci\u00f3 de m\u00faltiples variables de tipus flotant\n</code></pre> Activitat 303. Declaraci\u00f3 de variables <p>Seguint amb l'activitat de la boleta, llig el que hages respost a l'apartat 3 de l'activitat 301 i declara com consideres dins del bloc de \"Variables Globals\" els identificadors que hages triat com a variables amb el tipus base que trobes que es necessite.</p> <pre><code>// Variables Globals\n// Declara les variables a continuaci\u00f3 de l'exemple de velocitat\nint velocitat;  // Exemple de declaraci\u00f3 d'una variable 'velocitat'\n\nvoid setup () {\nsize(640,480);\n}\nvoid draw () {\nclear();\nbackground(255);\n}\n</code></pre> <p>Recorda que aqueta activitat l'has de fer amb Processing IDE. Guarda el fitxer resultant amb el nom seg\u00fcent: CognomNomAct303.pde que haur\u00e0s de lliurar per @ules.</p> <p>Per\u00f2 en programaci\u00f3 no nom\u00e9s es pot tractar la informaci\u00f3 mitjan\u00e7ant l'\u00fas de variables, tamb\u00e9 es poden emmagatzemar dades fent \u00fas dels literals. I qu\u00e8 s\u00f3n els literals?</p>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#literals","title":"Literals","text":"<p>Un literal \u00e9s, segons el termCAT,  una expressi\u00f3 o part d'una instrucci\u00f3 que representa expl\u00edcitament un valor. En altres paraules, mentre que les variables s\u00f3n cadenes alfanum\u00e8riques que representen un valor canviant, un literal \u00e9s una cadena alfanum\u00e8rica que representa exactament el que posa.  Des del punt de vista m\u00e9s espec\u00edfic de la inform\u00e0tica, un literal \u00e9s un valor alfanum\u00e8ric que s'utlitza com una constant, \u00e9s a dir, que el seu valor no varia durant l'execuci\u00f3 del programa.</p> <p>Per\u00f2 com podem distingir el tipus dels literals o si s\u00f3n correctes o no? Mirem primer quins tipus de terminals ens podem trobar en Java.</p> <ul> <li>Literals enters: existeixen tres formes de el valor d'un n\u00famero enter. Si s'escriu solament el n\u00famero, aquest representa una xifra en base decimal. Si t\u00e9 un 0 davant estem escrivint n\u00fameros en sistema octal i si t\u00e9 el prefix \"0x\" aleshores est\u00e0 representat en base hexadecimal. Finalment si el que volem \u00e9s representar un literal de tipus long ho farem afegint un caracter 'L' al final de la cadena num\u00e8rica.</li> <li>Literals decimals: Per representar literals en coma flotant podem utilitzar el '.' per exemple: 10.3, o la notaci\u00f3 cient\u00edfica com 10.3e+5 que seria l'equivalent a 10.3 per 10 elevat a 5.</li> <li>Literals caracters i cadenes: Un literal de tipus caracter emmagatzema un caracter Unicode. Aquest sistema de codificaci\u00f3 amplia les opcions que t\u00e9 la codificaci\u00f3 ASCCII per incluir altres alfabets. Podem escriure en grec, hebreu o vietnamita sense que el compilador proteste. Un literal de tipus char s'expressa envoltant el caracter entre cometes simples. Una altra manera de representar un caracter \u00e9s indicant el codi Unicode en hexadecimal, posant com a prefix la cadena \\u, tot entre cometes simples. D'aquesta forma el s\u00edmbol '@' s'escriuria: '\\u0040.</li> </ul> <p>Literal</p> <p>Un literal \u00e9s un valor que poden assignar a les variables o que es pot usar com a terme constant. Depenent del tipus de variable, podrem assignar uns valors o uns altres. Els literals poden ser: enters, decimals, caracter o cadena.</p> <ol> <li>Literals enters: 12, 2, -3, 12L (long), 0b101010 (bin\u00e0ria), 0x1a (hexadecimal), 0754 (octal)</li> <li>Literals decimals: 12.2, 12.2F, 12.2D (double).</li> <li>Literals car\u00e0cter: 'a', 'b', '$'.</li> <li>Literals cadena: \"Bela\", \"Ciao\".</li> </ol> Activitat 304. Literals num\u00e8rics <p>Indica quins literals s\u00f3n v\u00e0lids. Per cadascun dels literals m\u2019has d\u2019indicar si es v\u00e0lid o no aix\u00ed com tamb\u00e9 el tipus de dades t\u00e9 associat.</p> Literal Tipus V\u00e0lid Literal Tipus V\u00e0lid 0.5 .5 9.3e12 9.3e-12 12345678 12345_L 0.8E+0.8 0.8E 8 05_15 018CDF 0XBC5DA 0x87e3a 234567L 0_B11 010101 0_557 .00.8E2 .3e3f 0b111 12_234L 0Xabcd 0xabcEL _234 1010B 0x1010B 1_234.2E-2 1234.2EF 1234.2E3F 1_1.2e_2 0bABCDL 0X1A 0X12AL abcd 0125 .01011 3e12 3_e12 -3E-1_2 0.8E 0B1212 1_2_3 0xedad 0XBE2 101e2 B1101 1.34.5 12.3E4F 0X12AG Activitat 305. Literals caracter <p>Indica quins dels seg\u00fcents literals de tipus caracter s\u00f3n v\u00e0lids.</p> Literal V\u00e0lid Motiu Literal V\u00e0lid Motiu 'a' '$' '\\n' '/n' '\\' '\\\u00f1' \"T\" '\u00f1' 'xyz' '\\u0066' \"XYZ\" '4' '\\t' '\\b' k + '+' '?' '\u00e0' ':' Activitat 306. Literals String <p>Indica quins dels seg\u00fcents literals s\u00f3n literals de tipus string v\u00e0lid.</p> Literal V\u00e0lid Motiu Literal V\u00e0lid Motiu '8:15 PM' \"FP\" \"Roig i blau\" \" programaci\u00f3 \" \"Nom: \"programaci\u00f3 \"Java\"\" \"Capitol\\'3\\'\" programaci\u00f3 \"1.e3-1-2\" 'W' \"\" \"\\n\" \" \" \"\\b\" \"A\" \"4 + 5 * 2\""},{"location":"Tema%2003.%20El%20llenguatge%20Java/#declaracio-inicialitzacio-de-variables","title":"Declaraci\u00f3, inicialitzaci\u00f3 de variables","text":"<p>Cal diferenciar entre la declaraci\u00f3 d'una variable, quan li donen nom i el tipus base com hem fet a l'activitat 303, i la inicialitzaci\u00f3 d'aquesta mateixa, quan li donem valor. Si recordeu l'exemple al qual necessitavem dues variables per representar la posici\u00f3 d'un element en un escenari 2D, haviem declarat les variables de tipus enter posX i posY per\u00f2 no els hauriem donat cap valor incial.</p> <p>Si per declarar una variable \u00e9s necessari l'\u00fas d'un identificador que ens servir\u00e0 d'etiqueta per poder accedir a dita variable, per tal d'assingar-li un valor hem de fer \u00fas d'un literal.</p> <p>Per defecte Java inicialitzaria aquestes dues variables a zero, \u00e9s a dir, dins la caixa (contenidor) de cada variable, tindriem el valor zero si no s'indica el contrari.</p> Activitat 307. Inicialitzaci\u00f3 de variables <p>Seguint amb la boleta anem a assignar-li valors a les variables de l'activitat 303. Recorda que a aquesta activitat hem declarat totes les variables a la secci\u00f3 de 'Variables Globals' per tal que se li puga assignar valor des de qualsevol lloc. Ara haur\u00e0s de assignar-li un valor literal a cada identificador declarat com hem vist. Fixa't en l'exemple de posX.</p> <pre><code>// Variables Globals\nfloat posX, posY;\n\nvoid setup () {\nsize(640,480);\nposX = 320;\n}\nvoid draw () {\nclear();\nbackground(255);\n}\n</code></pre> <p>Guarda aquesta activitat amb el nom de: CognomNomAct307.pde per poder lliurar-lo a aules.</p>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#constants","title":"Constants","text":"<p>Les constants en Java (les no literals) s\u00f3n semblants a les variables, \u00e9s a dir, s\u00f3n contenidors d'informaci\u00f3, tenen un identificador i un tipus b\u00e0sic associat per\u00f2 el seu valor no canvia durant l'execuci\u00f3 del programa. L'\u00fas de les constants sol ser per a definir valors immutables dins d'un programa com per exemple en un tauler d'escacs el n\u00famero de files i columnes \u00e9s 8 sempre.</p> <p>Declaraci\u00f3 i inicialitzaci\u00f3 de constats</p> <p>Una de les peculiaritats de les constants, a banda que el seu valor no varia mentre s'executa el programa, \u00e9s que el seu valor s'ha de fer a la mateixa l\u00ednia que la declaraci\u00f3.</p> <p>Les constants en java es defineixen de la seg\u00fcent forma:</p> <pre><code>// Constant en java\nstatic final int totalFiles = 8; // totalFiles valdr\u00e0 8 durant tot el programa. \n</code></pre> Activitat 308. Utilitza les constants al joc de la boleta <p>La finalitat del joc de la boleta, a banda de aprendre java, \u00e9s simular les lleis de la gravetat amb una boleta. Dins de les lleis de la gravetat existeix una constant que \u00e9s la for\u00e7a de la gravetat (9,8m/s\u00b2).</p> <p>Declara una constant amb nom 'GRV', o algun altre identificador significatiu i assigna-li el valor de la gravetat. Prova diversos valors de la gravetat fins que trobes aquell que siga m\u00e9s adequat.</p> <pre><code>// Declara la constant a continuaci\u00f3\n\n// Variables globals    \nfloat posX, posY;\n\nvoid setup () {\nsize(640,480);\nposX = 320;\n}\nvoid draw () {\nclear();\nbackground(255);\n}\n</code></pre> <p>Qu\u00e8 passa si al m\u00e8tode draw intentes canviar-li el valor a alguna constant? Prova-ho.</p> <p>Has de desar aquesta activitat com a CognomNomAct308.pde abans d'entregar-la.</p>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#comentaris","title":"Comentaris","text":"<p>Els comentaris a qualsevol llenguatge de programaci\u00f3, s'utilitzen per fer que el codi siga m\u00e9s f\u00e0cil de llegir millorant aix\u00ed el manteniment. Els comentaris s\u00f3n totalment ignorats pel compilador. D'altre banda, els comentaris s\u00f3n part de la documentaci\u00f3 de tot programa. \u00c9s molt important escriure comentaris breus per\u00f2 significatius. Massa text als comentaris produir\u00e0 l'efecte contrari i deixar\u00e0 encara m\u00e9s il\u00b7legible el codi.</p> <p>Principi en programaci\u00f3</p> <p>\"Un programa s'escriu una vegada per\u00f2 es llig moltes vegades\"</p> <p>En java tenim tres tipus de comentaris:</p> <ul> <li>Comentaris en l\u00ednia: S'utilitzen per comentar parts concretes del codi</li> <li>Comentaris de v\u00e0ries l\u00ednies: Si un programador vol descriure m\u00e9s detalladament un codi m\u00e9s complex i no es pot utilitzar el comentari d'una l\u00ednia perqu\u00e8 requereix m\u00e9s text</li> <li>Comentaris de documentaci\u00f3: Aquest tipus de comentaris ajuda a l'hora de generar documentaci\u00f3 de forma automatitzada per alguns dels IDEs que s'utilitzen a l'actualitat o les enies que porten amb ells. Un exemple d'eina de generar documentaci\u00f3 de refer\u00e8ncia \u00e9s javadoc</li> </ul> <pre><code>// Comentari d'una sola l\u00ednia en Java\n\n/* Comentari de m\u00e9s d'una l\u00ednia\nlinia 1\nlinia 2\n...\nlinia final */\n\n/**\n* Troba la mitjana de tres n\u00fameros!\n* El programa FindAvg implementa una aplicacio que\n* simplement calcula la mitjana de tres enteros i els mostra\n* a la eixida per pantalla.\n*\n* @author  Aleix Caminou\n* @version 1.0\n* @since   2020-2-2\n*/\n</code></pre> Activitat 309. Comentaris al codi <p>Visita el seg\u00fcent lloc web sobre comentaris de java i despr\u00e9s amb el codi de l'\u00faltima activitat, posa els seg\u00fcents comentaris: </p> <ul> <li>Un comentari de documentaci\u00f3 a nivell de fitxer explicant que fa l'aplicaci\u00f3.</li> <li>Un comentari de documentaci\u00f3 per m\u00e8tode explicant que fa cada m\u00e8tode.</li> <li>Comentaris de l\u00ednia (tant simple com m\u00faltiple) als llocs que consideres que siga necessari.</li> </ul> <p>Recorda que has de guardar aquest fitxer com a CognomNomAct309.pde per lliurar-lo.</p>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#operadors-i-expressions","title":"Operadors i expressions","text":"<p>Ha arribat el moment de revisar el que hem vist. Fins ara hem vist les dades com a unitat d'emmagatzemament d'informaci\u00f3. Els diferents tipus de dades que ens proporciona Java, com les variables i les constants poden emmagatzemar dades que poden variar o no han de variar durant l'execuci\u00f3 del programa. I finalment tamb\u00e9 hem estudiat els literals i com construir identificadors per tal d'etiquetar distints elements dins del nostre programa.  En definitva em vist en detall com es pot representar tota classe d'informaci\u00f3 en un llenguatge de programaci\u00f3 com Java per\u00f2, com varem dir al primer tema, un programa inform\u00e0tic s'encarrega (entre d'altres) de processar l'informaci\u00f3. B\u00e9 doncs, nosaltres de moment nom\u00e9s hem estudiat els diferents mecanismes que proporciona Java per gestionar eixa informaci\u00f3 per\u00f2 no hem vist encara com la podem processar.  Per tal de poder processar la informaci\u00f3 haurem primer d'estudiar que s\u00f3n esl operadors i les expressions.</p>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#expressions","title":"Expressions","text":"<p>Una expressi\u00f3 \u00e9s una equaci\u00f3 matem\u00e0tica que representa un c\u00e0lcul, per exemple:</p> <p>Exemple d'expressions</p> <ul> <li>3x + 7z. </li> <li>2ab + a*a + 7</li> </ul> <p>L'expressi\u00f3 anterior la formen els seg\u00fcents elements: dos literals enters: 3 i 7; dos identificadors de variables (no sabem el tipus) x i z; i els simbols * i +.</p> <p>Al final tota operaci\u00f3 t\u00e9 un valor, per exemple, si x val 3 i z val 2, el resultat (valor) de l'expressi\u00f3 seria 23. Que consistiria en multiplicar (*) el literal '3' per el contingut de la variable amb identificador x i despr\u00e9s sumar-li (+) el resultat de la multiplicaci\u00f3 del literal 7 per el contingut de la variable z.</p> <p>Els simbols + i * que hem vist a l'expressi\u00f3 anterior, s\u00f3n els operadors, concretament * \u00e9s l'operador aritm\u00e8tic de multiplicaci\u00f3 i el s\u00edmbol + representa l'operador de suma. Per\u00f2 abans de passar als operadors aritm\u00e8tics, vejam abans l'operador assignaci\u00f3.</p>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#operador-assignacio","title":"Operador assignaci\u00f3","text":"<p>L'operador assignaci\u00f3 (=), com el seu nom indica, s'encarrega d'assignar-li a una variable el resultat d'una expressi\u00f3 matem\u00e0tica o el valor de una altra variable o un literal. S'ha de tenir en compte que el tipus de dades que representa b\u00e9 l'expressi\u00f3 matem\u00e0tica, el literal o l'altra variable han de coincidir als dos costats de l'operaci\u00f3 d'assignaci\u00f3.</p> <p>Com ja hem dit abans, l'operador assignaci\u00f3 en Java \u00e9s el s\u00edmbol '=' i s'utilitza de la seg\u00fcent forma:</p> <pre><code>// variable = expressi\u00f3\n// Seguint l'exemple anterior\nint x=3, y, z=2;\ny = 3*x + 7*z;\n</code></pre> <p>On l'operador '=' assignaria el valor de l'expressi\u00f3 '3x+2z' a la variable y, \u00e9s a dir, executada aquesta acci\u00f3 dins de la variable y haur\u00edem depositat el valor 23.</p> <p>Observa el codi escrit a continuaci\u00f3 on podr\u00e0s veure altres exemples d'\u00fas de l'operador assignaci\u00f3:</p> <pre><code>int a, b, c;\na = b = c = 10;\n// Tant a com b com c tindr\u00eden valor 10\n\nint i = 3;\ni = i * 3;\n// i valdria 9\n\nint j = 2;\nj *= 2;    // Aquesta manera peculiar d'usar l'operador assignaci\u00f3 \u00e9s el mateix que j = j * 2;\n</code></pre> <ul> <li>A la l\u00ednia 2 s'est\u00e0 assignant simult\u00e0niament el valor enter del literal 10 a les variables a, b i c.</li> <li>A la l\u00ednia 5 assignem el valor enter 3 a la variable amb identificador 'i' acabada de crear.</li> <li>A la l\u00ednia 6 assignem a la variable 'i' el seu propi valor multiplicat per 3. En altres paraules, tripliquem el valor inicial de 'i'.</li> <li>A la l\u00ednia 9 creem una variable de tipus enter amb identificador 'j' i li assignem el valor 2.</li> <li>A la l\u00ednia 10 dupliquem el valor inicial de 'j'.</li> </ul> Exemples d'operacions aritm\u00e8tiques <p>Escriu i executa el seg\u00fcent codi en Processing IDE i digues que \u00e9s el que mostra. </p> <pre><code>// Codi per a Processing IDE\nvoid setup() {\nint a = 20, b = 10, c, d, e = 10, f = 4, g = 9;\n\n\nc = b;\nSystem.out.println(\"Valor de c = \" + c); a = a + 1;\nb = b - 1;\ne = e * 2;\nf = f / 2;\nSystem.out.println(\"a,b,e,f = \" + a + \",\"\n+ b + \",\" + e + \",\" + f);\na = a - 1;\nb = b + 1;\ne = e / 2;\nf = f * 2;\n\na += 1;\nb -= 1;\ne *= 2;\nf /= 2;\nSystem.out.println(\"a,b,e,f (utilitzan operador curst)= \" + a + \",\" + b + \",\" + e + \",\" + f);\n}\n</code></pre>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#projecte-boleta","title":"Projecte Boleta","text":"<p>Abans de continuar amb l'exemple de la boleta anem a refrescar un poc la mem\u00f2ria sobre les fases de desenvolupament de programari que varem veure al primer tema i la t\u00e8cnica de disseny de diagrames de flux i la aplicarem al nostre projecte.</p> <p>1. Fase d'analisi o qu\u00e8 volem fer: Es pret\u00e8n fer una aplicaci\u00f3 amb una pantalla de temany 320 p\u00edxels d'ample  i 240 p\u00edxels d'alt amb fons blanc i una boleta de 20 p\u00edxels de diametre al mig de la pantalla en la seua posici\u00f3 inicial. Una vegada arranque l'aplicaci\u00f3 la boleta anir\u00e0 caiguent aplicant la llei de la gravetat tenint en compte que la seua velocitat incial \u00e9s zero. Quan arribe al terra, la bola desapareixer\u00e0 i s'acabar\u00e0 el programa.</p> <pre><code>- Requeriment 1: La pantalla de l'aplicaci\u00f3 \u00e9s de 320 p\u00edxels d'ample per 240 p\u00edxels d'alt.\n- Requeriment 2: La posici\u00f3 inicial de la boleta \u00e9s al mig de la pantalla (160,120)\n- Requeriment 3: La velocitat inicial de la boleta \u00e9s zero.\n- Requeriment 4: L'acceleraci\u00f3 de la boleta \u00e9s de 9,8 m/s\u00b2.\n- Requeriment 5: Quan la boleta toque terra anir\u00e0 desapareixent i acabar\u00e0 l'execuci\u00f3 del programa.\n</code></pre> <p>2. Fase de disseny: Basant-nos en l'especificaci\u00f3 de la fase d'analisi anterior i els requeriments que hem aonseguit treure, dissenyem el nostre algorisme utilitzant, per exemple, la t\u00e8cnica dels diagrames de flux. Un possible resultat podria ser el seg\u00fcent:</p> graph LR         Ini((Inici))--&gt;A[Establir Dimensions\\nAmple=320\\nAlt=240];         style Ini fill:#0F0;         A--&gt;B[Establir Posici\u00f3 Inicial\\nposX=160\\nposY=120];         B--&gt;C[GRV=0.098];         C--&gt;D[Dibuixar Bola];         D--&gt;E[Actualitzar Posici\u00f3 Bola];         E--draw: Bucle Joc--&gt;D;  <p>3. Fase d'implementaci\u00f3: Ara hem de passar el disseny a codi en Java. Coses a tenir en compte: </p> <ol> <li>Les dimensions de la boleta seran constants o variables?</li> <li>Els identificadors de la posici\u00f3 de la boleta s\u00f3n variables o constants?.</li> <li>La acceleraci\u00f3 \u00e9s una variable o una constant?</li> <li>Com puc dibuixar una boleta amb Processing IDE?</li> <li>Com s'actualitza la posici\u00f3 de la boleta?</li> <li>L'unitat de temps no \u00e9s el segon si no el frame. Com s\u00e9 en quin frame estic a l'actualitat?</li> <li>L'unitat de mesura no s\u00f3n els metres si no el p\u00edxel.</li> </ol> <p>En realitat, l'\u00fanica q\u00fcesti\u00f3 per a la que no tingau resposta \u00e9s la cinquena i \u00e9s en aquesta part on realment aplicarem operacions aritm\u00e8tiques per tal d'actualitzar la posici\u00f3 de la boleta. Per saber la posici\u00f3 de la boleta a cada frame utilitzarem les formules del MRUA per calcular la velocitat en tot moment i aix\u00ed poder actualitzar la posici\u00f3. </p> <p>Una \u00faltima consideraci\u00f3 \u00e9s que com que estem fent un simulador simple, no cal ser precisos amb les unitats de mesura i els seus valors, per exemple: la gravetat \u00e9s 9,88 metres per segon cada segon per\u00f2 per al nostre simulador anem a establir que la gravetat \u00e9s de 1 pixel per frame cada frame.</p> <p>Moviment Rectilini Uniformement Accelerat</p> <p>Amb les formules del MRUA podem saber en tot moment on es troba la boleta. Si a l'inici la boleta es troba en la posici\u00f3 y=120 i la velocitat inicial Vo=0, passat una unitat de temps (1 frame) la dist\u00e0ncia recorreguda per part de la boleta seria:</p> <pre><code>Frame 0\nVf = V0 + a*t\nVf = 0 + 1*t\nVf = 0\nPosY = PosY + Vf = 0\n</code></pre> <p>\u00c9s a dir, a l'instant zero la boleta es troba en la seua posici\u00f3 inicial i t\u00e9 una velocitat de 0 (pixels/frame). L\u00f2gic no?</p> <pre><code>Frame 1\nVf = V0 + a*t\nVf = 0 + 1*1\nVf = 1\nPosY = PosY + Vf = 1\n</code></pre> <pre><code>Frame 2\nVf = V0 + a*t\nVf = 1 + 1*1\nVf = 3\nPosY = PosY + Vf = 4\n</code></pre> <p>\u00c9s a dir, passada una unitat de temps (1 frame) la boleta haur\u00e0 recorregut 1 pixels. Continuem:</p> <pre><code>Frame 3\nVf = V0 + a*t\nVf = 3 + 1*2\nVf = 5\nPosY = Posy + Vf = 9\n</code></pre> <p>I ax\u00ed successivament fins que la boleta acabaria desapareguent per la part de baix de la nostra apliaci\u00f3.</p> Activitat 310. Fer caure la boleta <p>Escriu un programa en Java amb Processing IDE en base a les especificacions anteriors i que resolga el problema de la boleta. \u00c9s a dir, que a l'inici el programa dibuixe una boleta a la posici\u00f3 x=160 i y=120 i que com a conseq\u00fc\u00e8ncia de la for\u00e7a de la gravetat vaja caiguen fins desapareixer de lap pantalla.</p> <p>Les variables que determinen la posici\u00f3 x i y de la boleta han de tenir precisi\u00f3 flotant (float) ja que com has pogut observar a l'apartat del moviment rectilini uniformement accelerat, les distintes operacions que s'han de fer utilitzen decimals.</p> <p> </p> <p>Entrega un fitxer amb nom CognomNomAct310.pde per aules. </p>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#conversio-de-tipus","title":"Conversi\u00f3 de tipus","text":"<p>Hem dit que en una expressi\u00f3 d'assignaci\u00f3 de valors, els tipus de dades han de ser el mateix als dos costats de l'operaci\u00f3, per\u00f2, qu\u00e8 passa si aquestos no coincideixen? \u00c9s a dir, que passa si a una variable de tipus enter li assignem un nombre decmal? o un caracter? Amb Java \u00e9s possible transformar el tipus d'una variable o objecte en un altre diferent a l'original amb el que inicialment va ser declarat. Aquest procediment s'anomena \"Conversi\u00f3 de tipus\", encara que tamb\u00e9 podreu trobar aquest terme com a tipat o moldejat o casting i \u00e9s un mecanisme que hem de utilitzar amb cura ja que un mal \u00fas d'aquest \u00e9s una  font d'errors.</p> <p>En Java ens podem trobar dos escenaris diferents: un en el que els tipus que es volen convertir s\u00f3n compatibles, en aquest cas Java fa una conversi\u00f3 autom\u00e0tica o l'escenari al qual els dos tipus de dades de l'assignaci\u00f3 no s\u00f3n compatibles per la qual cosa haurem de for\u00e7ar aquesta conversi\u00f3 amb un casting.</p>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#conversio-automatica-de-tipus-o-ampliacio","title":"Conversi\u00f3 autom\u00e0tica de tipus o ampliaci\u00f3","text":"<p>La conversi\u00f3 autom\u00e0tica de tipuso ampliaci\u00f3 es produeix quan dos tipus de dades es converteixen autom\u00e0ticament. A\u00e7\u00f2 passa quan:</p> <ul> <li>Els dos tipus de dades s\u00f3n compatibles</li> <li>Quan assignem el valor de un tipus de dades m\u00e9s menut a un tipus de dades m\u00e9s gran.</li> <li>Tipus de dades ordenats per tamany: byte &lt; short &lt; int &lt; long &lt; float &lt; dobule</li> </ul> <p>Per exemple, en Java, els tipus de dades num\u00e8rics s\u00f3n compatibles entre s\u00ed, per\u00f2 no s'admet la conversi\u00f3 autom\u00e0tica de tipus num\u00e8ric a char o boolean. A m\u00e9s a m\u00e9s, char i boolean no s\u00f3n compatibles entre ells. Mira el codi a continuaci\u00f3 on es produeix una conversi\u00f3 autom\u00e0tica en Java.</p> <pre><code>    void draw()\n{\nint i = 100; // Conversi\u00f3 autom\u00e0tica de tipus\nlong l = i; // Conversi\u00f3 autom\u00e0tica de tipus\nfloat f = l; println(\"Valor Int \" + i);\nprintln(\"Valor Long \" + l);\nprintln(\"Valor Float \" + f);\n}\n</code></pre>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#conversio-explicita-de-tipus-o-casting","title":"Conversi\u00f3 explicita de tipus o casting","text":"<p>Si volem assignar un valor de tipus de dades m\u00e9s gran a un tipus de dades m\u00e9s xicotet, farem un casting o el que tamb\u00e9 es coneix com conversio de tipus explicit.</p> <ul> <li>Util per als tipus de dades incompatibles on la conversi\u00f3 autom\u00e0tica no es pot realitzar.</li> <li>char i int no s\u00f3n compatibles entre ells i donar\u00e0 un error de compilaci\u00f3.</li> <li>On necessitarem la conversi\u00f3 explicita: double &gt; float &gt; long &gt; int &gt; short &gt; byte</li> </ul> <p>Mira el seg\u00fcent codi on hi ha un cas de tipus incompatibles.</p> <pre><code>    void draw()\n{\nchar ch = 'c';\nint num = 88;\nch = num;\n}\n</code></pre> <p>L'exemple anterior donaria un error a la l\u00ednia 7 diguent que no es pot convertir d'int a char. Per tant com podriem fer aquesta conversi\u00f3 explicita?. Una possible forma d'evitar aquestos casos de tipus incompatibles \u00e9s la conversi\u00f3 explicita, on hem d'indicar al compilador especificament a quin tipus volem convertir.</p> <pre><code>    void draw()\n{\ndouble d = 100.04; //casting de tipo\nlong l = (long)d;\n\n//casting de tipo\nint i = (int)l; println(\"Valor Double \" + d);\n\n//parte fraccionaria perdida\nprintln(\"Valor Long \" + l); //parte fraccionaria perdida\nprintln(\"Valor Int \" + i); } </code></pre> <p>La eixida de l'execuci\u00f3 d'aquest codi seria: </p> <ul> <li>Valor Double 100.04</li> <li>Valor Long 100</li> <li>Valor Int 100</li> </ul> <p>Exemple de conversi\u00f3 de tipus</p> <p>Observa el seg\u00fcent codi i raona el que pot ser el seu resultat i anota'l. Despr\u00e9s c\u00f2pia el codi a un programa de Processing i executa'l. Compara el resultat del programa amb el que tu havies anotat. Qu\u00e8 est\u00e0 passant? Per qu\u00e8?</p> <pre><code>    void draw() { byte b; int i = 257; double d = 323.142;\nSystem.out.println(\"Conversion de int a byte.\"); //i%256\nb = (byte) i; System.out.println(\"i = \" + i + \" b = \" + b);\nSystem.out.println(\"\\nConversion de double a byte.\");\n\n//d%256\nb = (byte) d; System.out.println(\"d = \" + d + \" b= \" + b);\n}\n</code></pre> Activitat 311. Augmentem la precissi\u00f3 de la boleta <p>En aquesta activitat anem a fer que la boleta no aparega sempre a la posici\u00f3 x=160, y=120 si no que cada vegada que arranquem l'aplicaci\u00f3, aparega en un lloc diferent. </p> <p>Per tal d'aconseguir aquesta aleatorietat, utilitzarem la funci\u00f3 de Processing IDE random. </p> <p>A l'API de Processing, Processing Reference, entre altres tenim una funci\u00f3 random(low, high) que genera nombres aleatoris dintre del rang low-hight que se li passa per par\u00e0metre, \u00e9s a dir, si volem que aquesta funci\u00f3 ens torne un valor aleatori entre 0 i 100, haur\u00edem de cridar-la de la seg\u00fcent forma:</p> <pre><code>float f = random(100);   // Genera un nombre aleatori entre 0 i 100 i l'emmagatzema a f\nfloat m = random(50,90); // Genera un nombre aleatori entre 50 i 90 i l'emmagatzema a m\n</code></pre> <p>Primer fes que tant les variables que determinen la posici\u00f3 x i y de la boleta les genere la funci\u00f3 random i no siguen fixes.</p> <pre><code>// Per exmple\nposX = random(320);\n</code></pre> <p>Finalment fes que la gravetat tamb\u00e9 tinga major precissi\u00f3 i assigna-li un valor de 0.0098.</p>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#operadors-aritmetics","title":"Operadors aritm\u00e8tics","text":"<p>Els operador aritm\u00e8tics en Java serveixen per realitzar operacions b\u00e0siques algebraiques com: la suma, resta, multiplicaci\u00f3 o divisi\u00f3. Els resultats de tota expressi\u00f3 aritm\u00e8tica \u00e9s de tipus de dades num\u00e8ric, per tant, podr\u00e0 ser assignat a una variable num\u00e8rica o podra ser utilitzant en qualsevol altra operaci\u00f3 num\u00e8rica.  </p> <ul> <li>Suma: s\u00edmbol (+). Exemple: 4+5. Resultat 9.</li> <li>Resta: s\u00edmbol (-). Exemple: 5-2. Resultat 3.</li> <li>Multiplicaci\u00f3: s\u00edmbol (). Exemple: 37. Resultat 21.</li> <li>Divisi\u00f3 (Quocient): s\u00edmbol (/). Exemple: 8/4. Resultat 2.</li> <li>Divisi\u00f3 (Residu): s\u00edmbol (%). Exemple 10%2. Resultat 0.</li> </ul> Activitat 312. Executa el seg\u00fcent codi d'operadors aritm\u00e8tics <p>C\u00f2pia i compila el codi anterior i observa el que mostra pel terminal. Has de fer l'activitat amb Processing IDE</p> <pre><code>// OPERADORS ARITM\u00c8TICS\nvoid draw() {\nint a = 20, b = 10, c = 0, d = 20, e = 40, f = 30;\nString x = \"Thank\", y = \"You\";\n\nprintln(\"a + b = \"+(a + b));\nprintln(\"a - b = \"+(a - b));\nprintln(\"x + y = \"+x + y);\nprintln(\"a * b = \"+(a * b));\nprintln(\"a / b = \"+(a / b));\nprintln(\"a % b = \"+(a % b));\n}\n</code></pre>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#operadors-increment-i-decrement-unaris","title":"Operadors increment i decrement (unaris)","text":"<p>En programaci\u00f3 i com her\u00e8ncia de C i C++ existeixen els operadors increment (++) i decrement (--) que el que fan \u00e9s incrementar o decrementar en una unitat la variable a la qual s'apliquen. Aquestos operadors es diuen unaris perqu\u00e8 nom\u00e9s treballen sobre un sol operand. Encara que aquest operador s'aplique nom\u00e9s sobre un element, tamb\u00e9 es tractaria d'una expressi\u00f3 aritm\u00e8tica, per tant, tamb\u00e9 hauria de retornar un resultat n\u00fameric per ser utilitzat com a tal.</p> <pre><code>    int x = 10;\n// Postincrement o postdecrement\nx ++; // Aquest codi seria equivalent a x = x + 1;\nx --; // Aquest codi seria equivalent a x = x -1 ;\n</code></pre> <p>Aquestos operadors tamb\u00e9 es poden posar abans de la variable produint el mateix efecte</p> <pre><code>    int x = 10;\n// Preincrement o predecrement\n++ x; // Aquest codi seria equivalent a x = x + 1;\n-- x; // Aquest codi seria equivalent a x = x -1 ;\n</code></pre> <p>La difer\u00e8ncia essencial entre el postincrement i el preincrement \u00e9s que el contingut de la variable, el que tenim dins la caixeta, s'avalua abans (postincrement) o despr\u00e9s (preincrement) de sumar-li un al seu valor.</p> Activitat 313. Operadors postincrement i preincrement <p>Prova el codi seg\u00fcent i digues-me el que passa.</p> <pre><code>void draw() {\nint a = 20, b = 10, c = 0, d = 20, e = 40, f = 30;\nboolean condition = true;\n\nc = ++a;\nprintln(\"Valor de c (++a) = \" + c);\n\nc = b++;\nprintln(\"Valor de c (b++) = \" + c);\n\nc = --d;\nprintln(\"Valor de c (--d) = \" + c);\n\nc = e--;\nprintln(\"Valor de c (e--) = \" + c);\nprintln(\"Valor de !condition = \" + !condition);\n}\n</code></pre>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#operadors-relacionals","title":"Operadors relacionals","text":"<p>Com hem explicat en l'apartat sobre Tipus de dades, existeix en Java el tipus boolean que nom\u00e9s pot tenir valors true o false. Aquest tipus de dades est\u00e0 relacionat amb els operadors relacionals, ja que tota expressi\u00f3 relacional ha de donar com a resultat b\u00e9 true o false.</p> <p>Tant els operadors relacionals com els tipus de dades boolean, estan directament relacionats amb l'algebra de boole. A continuaci\u00f3 hi pots veure un resum de les operacions b\u00e0siques en l'algebra de boole:</p>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#negacio-operador-unari","title":"Negaci\u00f3. Operador unari","text":"A NOT 0 1 1 0"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#or-i-and-operadors-binaris","title":"OR i AND. Operadors binaris","text":"A B OR AND 0 0 0 0 1 0 1 0 0 1 1 0 1 1 1 1 <p>Els operadors relacionals a Java s\u00f3n:</p> <ul> <li>Igual que: == o igual a. Exemple d'\u00fas: a == b, compara si a i b s\u00f3n iguals o no.</li> <li>Distint de: != o distint de. Exemple d'\u00fas: a != b, comprova si a i b s\u00f3n distints.</li> <li>Major que: &gt; o major que. Exemple d'\u00fas: 'a&gt;b' comprova si a \u00e9s major que b.</li> <li>Menor que: &lt; o menor que. Exemple d'\u00fas: 'a&lt;b' comprova si a \u00e9s menor que b.</li> <li>Major o igual que: &gt;= o major igual que. Exemple d'\u00fas: 'a&gt;=b' comprova si a \u00e9s major o igual que b.</li> <li>Menor o igual que: &lt;= o menor igual que. Exemple d'\u00fas: 'a&lt;=b' comprova si a \u00e9s menor o igual que b.</li> </ul> <p>Aix\u00ed tenim que una expressi\u00f3 relacional, que com hem explicat ha de donar un resultat boole\u00e0, es podr\u00e0 utilitzar b\u00e9 en altres expressions relacionals o en avaluacions de condicions per a les estructures de control que veurem en pr\u00f2xims apartats.</p> Activitat 314. Copia i executa en Processing IDE <p>C\u00f2pia i executa el codi anterior en Processing i observa el que passa.</p> <pre><code>// Programa Java per mostrar operadors relacionals\nvoid draw() {\nint a = 20, b = 10;\nString x = \"Thank\", y = \"Thank\";\nint ar[] = { 1, 2, 3 };\nint br[] = { 1, 2, 3 };\nboolean condicion = true;\n\n// Diversos operadors relacionals\nprintln(\"a == b :\" + (a == b));\nprintln(\"a &lt; b :\" + (a &lt; b));\nprintln(\"a &lt;= b :\" + (a &lt;= b));\nprintln(\"a &gt; b :\" + (a &gt; b));\nprintln(\"a &gt;= b :\" + (a &gt;= b));\nprintln(\"a != b :\" + (a != b));\n\n// Els arrays no es poden comparar cma operadors relacionals perqu\u00e8 els objectes emmagatzemen refer\u00e8ncies i no el valor\nprintln(\"x == y : \" + (ar == br));\n\nprintln(\"condicion==true :\" + (condicion == true));\n}\n</code></pre>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#operadors-logics","title":"Operadors l\u00f2gics","text":"<p>Aquestos operador s'utilitzen per realitzar operacions l\u00f2giques AND i l\u00f2giques OR, \u00e9s a dir, la funci\u00f3 semblant a la port AND i la porta OR e l'electr\u00f2nica digital. Una cosa a dinre en compte \u00e9s que la segona condici\u00f3 no s'avalua si la primera \u00e9s falsa, \u00e9s a dir, t\u00e9 un efecte de curtcircuit. S'utilitza molt per provar varies condicions per prendre una decisi\u00f3.</p> <ul> <li>not (!): negaci\u00f3 l\u00f2gica.</li> <li>and (&amp;&amp;): and l\u00f2gic.</li> <li>or (||): or l\u00f2gic.</li> <li>or exclusivo (^): or exclusiu.</li> </ul> Activitat 315. Operadors l\u00f2gics <p>Prova i executa el codi anterior. Has de fer l'activitat en Processing IDE.</p> <pre><code>void setup() {\nprintln(\"TAULA DE BOOLE\");\nprintln(\"--------------\");\nprintln(\" OPERADOR &amp;&amp;\");\nprintln(\"--------------\");\nprintln(\" V  &amp;&amp;  V  = \" + (true&amp;&amp;true));\nprintln(\" V  &amp;&amp;  F  = \" + (true&amp;&amp;false));\nprintln(\" F  &amp;&amp;  V  = \" + (false&amp;&amp;true));\nprintln(\" F  &amp;&amp;  F  = \" + (false&amp;&amp;false));\nprintln(\"--------------\");\nprintln(\" OPERADOR ||\");\nprintln(\"--------------\");\nprintln(\" V  ||  V  = \" + (true||true));\nprintln(\" V  ||  F  = \" + (true||false));\nprintln(\" F  ||  V  = \" + (false||true));\nprintln(\" F  ||  F  = \" + (false||false));\nprintln(\"--------------\");\nprintln(\" OPERADOR !\");\nprintln(\"--------------\");\nprintln(\" !V  = \" + !true);\nprintln(\" !F  = \" + !false);\nprintln(\"--------------\");\n}\n</code></pre>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#operador-condicional-o-ternari","title":"Operador condicional o ternari","text":"<p>Java inclou un operador especial de tipus ternari que de vegades s'utilitza per substituir algunes estructures if then else. Aquest \u00e9s l'operador ? i la seua forma general \u00e9s:</p> <pre><code>expressio1 ? expressio2 : expressio 3;\n</code></pre> <p>Expressi\u00f3 1: \u00e9s l'expressi\u00f3 que avalua un valor boole\u00e0, d'aquesta forma, si l'expressi\u00f3 1 s'avalua com a true, s'executaria l'expressi\u00f3 2 mentre que si l'expressi\u00f3 1 s'avalua a false, s'executaria l'expressi\u00f3 3. Mira l'exemple seg\u00fcent:</p> <pre><code>// B\u00e0sicament el que faria aquesta espressi\u00f3 seria engegar l'aire condicionat si la temperatura \u00e9s superior a 25 graus.\n\ndouble temperatura;     // Variable que ens indica la temperatur ambient\nboolean AC_ON = false;  // Variable booleana que ens indica si l'aire condicionat est\u00e0 en marxa\ntemperatura &gt; 25 ? AC_ON = true : AC_ON = false;\n</code></pre>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#estructures","title":"Estructures","text":"<p>Com hem vist al tema 2, el teorema de la programaci\u00f3 estructurada preveu una s\u00e8rie d'estrucutures b\u00e0siques amb les quals es podr\u00eden codificar tots els algorismes sense necessitat d'usar cap sent\u00e8ncia GOTO o similar.</p> <p>En els pr\u00f2xims punts veurem com es codifiquen totes aquestes estructures en llenguatge Java.</p>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#estructura-sequencial","title":"Estructura Seq\u00fcencial","text":"<p>Les ordres d'un programa s'executen per defecte en ordre seq\u00fcencial. El que significa que les instruccions s'executen, com hem comentat abans, una darrere de l'altra en el mateix ordre que apareixen escrites al programa.</p>  graph LR     id1((Inici))--&gt;Instrucci\u00f31;     style id1 fill:#0F0     Instrucci\u00f31--&gt;Instrucci\u00f32;     Instrucci\u00f32--&gt;Instrucci\u00f33;     Instrucci\u00f33--&gt;id2([Fi]);     style id2 fill:#F00   <p>L'estructura seq\u00fcencial \u00e9s l'ordre natura d'execuci\u00f3. Les instruccions que formen part d'aquesta estructura s'executen en ordre una a continuaci\u00f3 de l'altra. Al final de cada instrucci\u00f3 hi ha un punt i coma per indicar-li al compilador el final de la sent\u00e8ncia individual. Les instruccions dintre d'una estructura seq\u00fcencial es solen agrupar en blocs ( {...} ) i es codifica de la seg\u00fcent manera:</p> <pre><code>// Exemple de bloc - estructura seq\u00fcencial\n{\nInstrucci\u00f31;\nInstrucci\u00f32;\n...\nInstrucci\u00f3N;\n}\n</code></pre> <p>Veiem a continuaci\u00f3 un exemple codificat en Java amb l'IDE de Processing.</p> Activitat 317. Dibuixa amb Processing IDE <p>Dibuixa amb processing IDE un punt, una l\u00ednia, un cercle i un quadrat copiant el codi que pots veure a continuaci\u00f3. Despr\u00e9s modifica alguns dels par\u00e0metres de les funcions point, line, ellipse i square i observa el que passa.</p> <pre><code>void setup () {\nsize(320,320);   // Estableix les dimensions de la nostra pantalla principal\nbackground(255); // Estableix el fons de la pantalla\nfill(0);         // Color amb el que es dibuixaran les figures.\n}\n\nvoid draw () {\npoint(10,10);            // Dibuixa un punt\nline(20,20,40,40);       // Dibuixa una l\u00ednia\nellipse(100,100,80,80);  // Dibuixa una el\u00b7lipse\nsquare(200,200,50);      // Dibuixa un quadrat\n}\n</code></pre> <p>Ara que ja has vist algunes de les funcions que ens ofereix l'API de Processing per tal de dibuixar, investiga quines altres funcions permet i aplica-les a la seg\u00fcent activitat.</p> Activitat 318. Dibuixa amb Processing IDE. Ampliaci\u00f3 <p>Utilitzant altres primitives de dibuix que ens proporciona l'API de Processing IDE, dibuixa alguna cosa concreta. Has de tindre en compte que la majoria de primitives (funcions) s\u00f3n geom\u00e8triques, per tant, et podries inspirirar en algun dibuix geom\u00e8tric. Pots buscar per Internet.</p>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#estructures-de-seleccio","title":"Estructures de selecci\u00f3","text":"<p>\u00c9s una de les estructures que permeten modificar l'ordre d'execuci\u00f3 de les instruccions del programa. Una estructura condicional determina si s'executen unes accions o altres segons es compleixca o no una determinada condici\u00f3. La condici\u00f3 que es comprova per decidir si unes instruccions s'executen o no deu ser una expressi\u00f3 booleana, \u00e9s a dir, ha de donar com a resultat un valor boole\u00e0 true o false. </p> <p>Com varem explicar al tema anterior, ens podem trobar les seg\u00fcents variants d'estructura de selecci\u00f3:</p> <ul> <li>Selecci\u00f3 simple</li> <li>Selecci\u00f3 doble</li> <li>Selecci\u00f3 multiple</li> <li>Operador condicional ?</li> </ul>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#seleccio-simple-if","title":"Selecci\u00f3 Simple - if","text":"<p>\u00c9s l'estructura condicional m\u00e9s simple en programaci\u00f3 estructurada. S'utilitza per determinar si una instrucci\u00f3 o bloc d'instruccions s'executa basat en una condici\u00f3. S'avalua la condici\u00f3 i si es true, s'executa la instrucci\u00f3 o bloc d'instruccions associat a la condici\u00f3.</p>     graph LR     id1((Inici))--&gt;Instrucci\u00f31;     style id1 fill:#0F0     Instrucci\u00f31--&gt;Instrucci\u00f32;     Instrucci\u00f32--&gt;Cond1{Condici\u00f3};     Cond1--&gt;|SI|Instrucci\u00f33;     Instrucci\u00f33--&gt;Instrucci\u00f34;     Instrucci\u00f34--&gt;Instrucci\u00f35;     Cond1--&gt;|NO|Instrucci\u00f35;     Instrucci\u00f35--&gt;id2([Fi]);     style id2 fill:#F00  <p>El seu codi en Java seria:</p> <pre><code>Instrucci\u00f31();\nInstrucci\u00f32();\n\nif (condicio) {\ninstrucci\u00f33;\nInstrucci\u00f34;\n}\nInstrucci\u00f35;\n</code></pre> <p>Al codi anterior s'executarien sempre les instruccions 1 i 2 abans d'avaluar-se la condici\u00f3, en cas que la condici\u00f3 fora avaluada com a true, s'executaria l'estructura seq\u00fcencial que cont\u00e9 les instruccions 3 i 4 i finalment s'executaria la instrucci\u00f3 5 en tot cas. </p> <p>Pel contrari si la condici\u00f3 s'avalua a false no s'executarien les instruccions que cont\u00e9, \u00e9s a dir, 3 i 4 i passaria directament a l'instrucci\u00f3 5.</p> <p>Continuema amb la boleta i ampliem funcionalitats i millorem el diagrama de flux de la fase de disseny</p> graph LR         Ini((Inici))--&gt;A[Establir Dimensions\\nAmple=320\\nAlt=240];         style Ini fill:#0F0;         A--&gt;B[Establir Posici\u00f3 Inicial\\nposX=160\\nposY=120];         B--&gt;C[Acceleraci\u00f3=1];         C--&gt;D[Dibuixar Bola];         D--&gt;E[Actualitzar Posici\u00f3 Bola];         E--&gt;F{Ha tocat terra?};         F--&gt;|SI|G[posX=0];         G--&gt;H[velocitat = 0];         H--&gt;D;         F--&gt;|NO|D;          Activitat 319. Que no desaparega la boleta <p>Hem d'aconseguir que la boleta no desaparega quan arribe a la part de baix de l'aplicaci\u00f3 sino torne a apareixer per dalt. Qu\u00e8 singfica que la boleta ha arribat al terra? o dit d'una altra manera, com sabem que la boleta ha arribat baix del tot? Per qu\u00e8 la el valor de la variable que indica la posici\u00f3 a l'eix Y de la boleta \u00e9s major que l'alt de la nostra aplicaci\u00f3, \u00e9s a dir: 240. Per tant podem deduir que: \"Si la posici\u00f3 Y de la boleta \u00e9s major que 240 aleshores la fem apareixer per dalt...\"</p> <p>Com podeu observar, l'afirmaci\u00f3 anterior \u00e9s un if, si posY \u00e9s major (&gt;) altura aleshores fes apareixer per dalt de nou la boleta. Per\u00f2 quines s\u00f3n les accions a realitzar per tal que la boleta aparega per dalt? tornar a posar la posici\u00f3 Y de la boleta a 0.</p> <p>Un problema que ens trobarem ac\u00ed \u00e9s que no podem ja utilitzar la variable de sistema frameCount ja que quan la boleta torne a apareixer per dalt el n\u00famero de frames (el que utilitzem com a unitat de temps) ha de comen\u00e7ar de zero una altra vegada. La soluci\u00f3 \u00e9s crear una variable numFrames com a global que s'inicialitze a zero al setup i cada vegada que haja d'apareixer per dalt, es torna a assignar un zero a aquesta variable.</p> <p>Tamb\u00e9 s'ha de reiniciar la velocitat a zero sino no parar\u00e0 d'accelerar.</p> <p><pre><code>    // Constants\nfinal static float GRV = 1;   // For\u00e7a de la gravetat\nfinal static int   TAM = 20;  // Tamany de la boleta\n\n// Variables Globals\nint   numFrames;\nfloat velocitat;              // Velocitat inicial de l'objecte quan arranquem el programa.\nfloat posX, posY;             // Variables que determinen la posici\u00f3 de la boleta en un escenari de dues dimensions\n\n// M\u00e8tode setup: inicialitza la nostra aplicaci\u00f3, dona valors inicials.\nvoid setup () {\nsize(320,240);               // Establir dimensions\nposX      = random(20,300);  // Establim posici\u00f3 X inicial\nposY      = random(20,220);  // Establim posici\u00f3 Y inicial\nvelocitat = 0;               // Establim la velocitat inicial\nnumFrames = 0;               // Variable necess\u00e0ria per controlar l'acceleraci\u00f3.\n}\n\n// Metode draw: bucle del joc, aquest m\u00e8tode s'executa de forma continua\nvoid draw () {\nclear();\nbackground(255);\nfill(0);\nellipse(posX,posY,TAM,TAM);\n\n// Actualitzem la posici\u00f3 utilitzant la velocitat\nposY = posY + velocitat;\nvelocitat = velocitat + G*numFrames;  // Vf = Vo + acc*temps;\nnumFrames ++;\n\n// Codi if que controle si ha arribat al terra o no.\n// if...\n}\n</code></pre> </p> Activitat 320. Correcci\u00f3 d'errades amb el depurador <p>Com haur\u00e0s vist quan has executat el codi, el comportament del que fa el nostre codi amb la boleta no \u00e9s el que esperavem, o almenys jo ho imaginava d'una altra manera. Revisa-ho i canvia alguns detalls. Fes una depuraci\u00f3 l\u00ednia a l\u00ednia del codi amb el Debugger de Processing IDE i deixa l'apliaci\u00f3 com a tu t'agradaria.</p> <p>Pista: igual quan torna a apareixer per dalt la velocitat no deuria ser zero...</p>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#seleccio-doble-if-else","title":"Selecci\u00f3 doble - if .. else","text":"<p>Amb aquesta estructura condicional de la programaci\u00f3 estructurada es poden seguir camins distints depenent de si l'avaluaci\u00f3 de la condici\u00f3 \u00e9s true o false. En altres paraules, si la condici\u00f3 \u00e9s true, executaria una instrucci\u00f3 o bloc d'instruccions mentre que si s'avalua a false executaria una altra instrucci\u00f3 o bloc d'instruccions.</p> <p>Observa el diagrama de flux seg\u00fcent:</p> graph LR     id1((Inici))--&gt;Instrucci\u00f31;     style id1 fill:#0F0;     Instrucci\u00f31--&gt;Instrucci\u00f32     Instrucci\u00f32--&gt;C1{Condici\u00f3}     C1--&gt;|SI|Instrucci\u00f33;     Instrucci\u00f33--&gt;Instrucci\u00f34;     C1--&gt;|NO|Instrucci\u00f35;     Instrucci\u00f35--&gt;Instrucci\u00f36;     Instrucci\u00f34--&gt;Instrucci\u00f37;     Instrucci\u00f36--&gt;Instrucci\u00f37;     Instrucci\u00f37--&gt;Instrucci\u00f38;     Instrucci\u00f38--&gt;id2((FI));     style id2 fill:#F00  <p>El seu codi en Java seria</p> <pre><code>instruccio1;\ninstruccio2;\nif (condicio) {\ninstruccio3;\ninstruccio4;\n}\nelse {\ninstruccio5;\ninstruccio6;\n}\ninstruccio7;\ninstruccio8;\n</code></pre> <p>Si ens fixem en el codi anterior, podem trobar dues seq\u00fc\u00e8ncies d'execucio d'instruccions depenenet si la condici\u00f3 del 'if' s'avalua 'true' o 'false'. En el primer cas, amb la condici\u00f3 a 'true', s'executarien: instrucci\u00f31, instrucci\u00f32, instrucci\u00f33, instrucci\u00f34, instrucci\u00f37 i instrucci\u00f38. Mentre que si la condici\u00f3 del 'if' s'avaluara a 'false', les instruccions a executar serien: instrucci\u00f31, instrucci\u00f32, instrucci\u00f35, instrucci\u00f36, instrucci\u00f37 i instrucci\u00f38.</p> <pre><code>    int hora;\n\nvoid setup () {\nsize (640,480);\n}\n\nvoid draw () {\nhora = (int)random(0,24);\n\nif ( hora &gt;= 12)\nprintln(\"Encara \u00e9s de mat\u00ed\");\nelse\nprintln(\"Ja \u00e9s de vesprada\");\n}\n</code></pre> <p>Continuem amb el Projecte Boleta. Per tal de treballar l'estructura condicional doble que acabem de veure ampliarem les funcionalitat de la nostra aplicaci\u00f3. Ara volem que quan la boleta toque terra siga de color roig i quan no estiga tocant, continue siguent negra.  </p> <p>El diagrama de flux amb els nous requeriments quedaria aix\u00ed:</p> graph LR         Ini((Inici))--&gt;A[Establir Dimensions\\nAmple=320\\nAlt=240];         style Ini fill:#0F0;         A--&gt;B[Establir Posici\u00f3 Inicial\\nposX=160\\nposY=120];         B--&gt;C[Acceleraci\u00f3=1];         C--&gt;D[Dibuixar Bola];         D--&gt;E[Actualitzar Posici\u00f3 Bola];         E--&gt;F{Ha tocat terra?};         F--&gt;|SI|G[posX=0\\nPintaRoig];         G--&gt;H[velocitat = 0];         H--&gt;D;         F--&gt;|NO|I[PintaNegre];         I--&gt;D;          Activitat 321. Boleta de dos colors <p>observa el diagrama de flux anterior i modifica el codi de l'activitat 319 per tal d'afegir-li les noves funcionalitats. Finalment l'aplicaci\u00f3 quearia de la seg\u00fcent forma:</p> <p> </p> <p>Ampliaci\u00f3: Fes que la boleta quan comence a apareixer per dalt siga totalment negra i poc a poc conforme va baixant vaja anant cap al color roig gradualment. Nom\u00e9s pots utilitzar les estructures que hem vist fins ara: seq\u00fcencial, if simple i if - else.</p> <p> </p>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#seleccio-niada-if-else-if-else","title":"Selecci\u00f3 niada - if else if else","text":"<p>Si volem avaluar m\u00e9s d'una condici\u00f3 al nostre codi, estariem parlant d'una estructura condicional m\u00faltiple que b\u00e0sicament consisteix en encadenar varios if..else. A continuaci\u00f3 es pot veure com seria un exemple de condicional m\u00faltiple en diagrama de flux.</p> graph LR     id1((Inici))--&gt;Instrucci\u00f31;     style id1 fill:#0F0;     Instrucci\u00f31--&gt;|NO|C1{Condici\u00f3 1};     C1--&gt;|NO|C2{Condici\u00f3 2};     C2--&gt;|NO|C3{Condici\u00f3 3};     C1--&gt;|SI|Instrucci\u00f32;     Instrucci\u00f32--&gt;Instrucci\u00f33;     C2--&gt;|SI|Instrucci\u00f34;     C3--&gt;|SI|Instrucci\u00f35;     Instrucci\u00f35--&gt;Instrucci\u00f36;     Instrucci\u00f36--&gt;Instrucci\u00f37;     Instrucci\u00f33--&gt;Instrucci\u00f310;     Instrucci\u00f34--&gt;Instrucci\u00f310;     Instrucci\u00f37--&gt;Instrucci\u00f310;     Instrucci\u00f310--&gt;Id2((FI));     style Id2 fill:#F00;  <p>El mateix exemple en Java que teniu a la imatge anterior seria:</p> <pre><code>instruccio1;\n\nif (condicio1) {\ninstruccio2;\ninstruccio3;\n}\nelse if (condicio2) {\ninstruccio4;\n}\nelse if (condicio3) {\ninstruccio5;\ninstruccio6;\ninstruccio7;\n}\nelse {\ninstruccio8;\ninstruccio9;\n}\ninstruccio10;\n</code></pre> <p>Al codi anterior l'\u00fanic que s\u00ed sabem cert \u00e9s que s'executaran les instruccions 1 i 2 i depenent de quina condici\u00f3 s'avalua a true s'executar\u00e0 algun bloc d'instruccions que estan dins de l'estructura condicional. Seguint amb l'exemple de l'hora que hem utilitzat als apartats anteriors veiem com es podria usar una condici\u00f3 m\u00faltiple amb if else:</p> Activitat 322. Copia i executa a Processing IDE <pre><code>void setup () {\nsize(640,480);\n}\n\nvoid draw() {\nint hora = (int)random(0,24);\n\nif (hora &gt;= 7 &amp;&amp; hora &lt;= 9)\nprintln(\"Eres matiner\");\n\nelse if (hora &gt; 9 &amp;&amp; hora &lt;= 12)\nprintln(\"Deuries haver esmorzat ja\");\n\nelse if (hora &gt; 12 &amp;&amp; hora &lt;= 15)\nprintln(\"Es hora de dinar si no has dinat\");\n\nelse if (hora &gt; 15 &amp;&amp; hora &lt;= 18)\nprintln(\"Si no has fet una migdiada oblidat\");\n\nelse\nprintln(\"Hora de la cervesa\");\n}\n</code></pre> <p>Copia i executa el codi a Processing IDE. Al final de cada cicle de la funci\u00f3 draw posa un delay de 1 segon per tal que ens done temps a veure el resultat. Recorda tamb\u00e9 de fer un clear() al principi de cada cicle de draw.</p> <p> </p> Activitat 323. Canvi de color de la boleta segons l'altura en la que es troba <p>Anem a fer que en el nostre projecte de la boleta que cau, aquesta canvie de color segons l'altura de la pantalla a la qual es troba. </p> <p>Tenint en compte que la nostra pantalla t\u00e9 una altura de 240 p\u00edxels, dividirem la nostra pantalla en 6 franges de 40 p\u00edxels d'altura cadascuna (6*40=240). Mentre la bola estiga passant per la primera franja (0-40) aquesta ser\u00e0 de color roig, a la segona franja (40-80) la pintarem de color taronja. A la tercera (80-120) groga, (120-160) verda, (160-200) blava i finalment a l'\u00faltima franja (200-240) ser\u00e0 de color morat.</p> <p>Traduit al llenguatge natural podria ser: si la posici\u00f3 (posY) de la boleta esta entre 0 i 40 pinta-la de roig, sino si la boleta esta entre 40 i 40 pinta-la de taronja sino si ....</p> <p>Al final el resultat de l'aplicaci\u00f3 podria ser el seg\u00fcent:</p> <p> </p> <p>Ampliaci\u00f3: Observa els codis rgb dels colors i intenta que el canvi de color de la boleta siga gradual i no de cop.</p>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#activitats-sobre-estructures-de-seleccio","title":"Activitats sobre estructures de selecci\u00f3","text":"<p>Mira i fes les seg\u00fcents activitats per tal de refor\u00e7ar els conceptes vistos sobre les diferents estructures de selecci\u00f3 de la programaci\u00f3 estructurada.</p> Activiat 324. Divisi\u00f3 <p>Escriu un programa en Processing IDE que genere aleat\u00f2riament dos nombres enters i que calcule la seua divisi\u00f3. El programa ens haur\u00e0 d'indicar si la divisi\u00f3 \u00e9s exacta qui \u00e9s el resultat i si no \u00e9s exacta quin \u00e9s el resultat i el residu.</p> <pre><code>// Estructura del codi que pots utilitzar.\nvoid setup () {\nsize(500,500); // Ens determina el tamany de la pantalla de la nostra aplicaci\u00f3.\ntextAlign(CENTER); // L'ancora del text ser\u00e0 el cetnre mateix.\n}\nvoid draw () {\nclear();  // Cada vegada que s'executa el draw (29 fps) s'esborra la pantalla.\nbackground(255); // Pinta el fons de blanc\nfill(0); // per tal que el text siga negre\n// Afig el codi ac\u00ed\n// Per escriure a la pantalla usa la funci\u00f3 text(String, int, int);\ndelay(1000); // Retr\u00e0s per tal que done temps a llegir el que escriu.\n}\n</code></pre> <p></p> <p>Com a apartat d'ampliaci\u00f3, podries fer que el tamany de la font fos un poc m\u00e9s gran.</p> Activitat 325. Divisi\u00f3 per zero <p>Si s'ha dona el cas, haur\u00e0s pogut comprovar que si el divisor \u00e9s 0 el programa dona error. Millora el programa anterior controlant el que passa quan es vol dividir per zero, mostrant un missatge en el cas que el n\u00famero pel qual s'intenta dividir siga zero.</p> <p></p> <p></p> Activitat 326. Major, menor o igual <p>Ecriu un programa en Processing que genere aleat\u00f2riament dos n\u00fameros i que diga quin \u00e9s el major, quin \u00e9s el menor o si s\u00f3n iguals.</p> <p></p> Activitat 327. Difer\u00e8ncia d'anys <p>Escriu un programa en Processing que donat l'any actual i un any qualsevol que es genere de forma aleat\u00f2ria amb la funci\u00f3 random i escriga quants anys han passat des d'eixe any o quants anys falten per arribar a eixe any.</p> <p></p> Activitat 328. Millora <p>Millora el programa anterior fent que quan la difer\u00e8ncia siga exactament un any, mostre una frase concreta: \"Nom\u00e9s queda un any\"</p> <p></p> Activitat 329. M\u00faltiples <p>Escriu un programa que genere dos n\u00fameros aleatoris entre el 0 i el 100 i escriga si el n\u00famero major \u00e9s multiple del menor. </p> <p></p> Activitat 330. Millor m\u00faltiples <p>Millora el programa anterior fent que el programa avise quan s'escriguen valors negatius o nuls.</p> Activitat 331. Comparador <p>Escriu un programa que donats 3 n\u00fameros (creats aleat\u00f2riament) ens diga si s\u00f3n els tres iguals, dos s\u00f3n iguals o cap \u00e9s igual.</p> <p></p> Activitat 332. Any bixest <p>Escriu un programa que genere un any aleatori de 0 a 2021 i ens diga si aquest \u00e9s bixest o no. Cal recordar que els anys bixests s\u00f3n m\u00faltiples de 4, per\u00f2 no s\u00f3n m\u00faltiples de 100 i s\u00ed s\u00f3n m\u00faltiples de 400. Per exemple: 2012 \u00e9s bixest, 2010 no ho \u00e9s, 2000 s\u00ed que ho es per\u00f2 1900 no ho \u00e9s. Pots basar-te en el seg\u00fcent codi.</p> <p> </p> <p></p> Activitat 333. C\u00e0lcul d'arees <p>Escriu un programa que primer demane si es vol calcular l'area d'un cercle (escrivint c o C) o d'un triangle (t o T). Si es tria el triangle s'haur\u00e0 de demanar la base i l'altura mentre que si es tria el cercle s'haur\u00e0 de demanar el radi. Aquest programa \u00e9s recomanable que es faja amb Eclipse IDE.</p> <p></p> Activitat 334. Canvi d'unitats <p>Escriu un programa que demane una dist\u00e0ncia en cent\u00edmetres i que escriga la mateixa dist\u00e0ncia en quilometres, metres i centimetres.</p>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#seleccio-multiple-switch-case","title":"Selecci\u00f3 m\u00faltiple - switch case","text":"<p>La sent\u00e8ncia de control 'switch' \u00e9s una altra forma de codificar la condici\u00f3 m\u00f9ltiple que hem vist a l'apartat anterior per\u00f2 m\u00e9s senzilla de visualitzar a primer cop d'ull. Fixa't en la imatge seg\u00fcent:</p> graph LR     id1((Inici))--&gt;Instrucci\u00f31;     style id1 fill:#F00;     Instrucci\u00f31--&gt;C1{Condici\u00f3 1};     C1--&gt;|A|Instrucci\u00f32;     C1--&gt;|B|Instrucci\u00f33;     C1--&gt;|C|Instrucci\u00f34;     Instrucci\u00f32--&gt;D(fa:fa-spinner);     Instrucci\u00f33--&gt;D;     Instrucci\u00f34--&gt;D;     D--&gt;Instrucci\u00f35;     Instrucci\u00f35--&gt;id3((FI));      style id3 fill:#0F0;   <p>I el codi en Java seria:</p> <pre><code>switch (condicio) {\ncase 1:\n// Instruccions\nbreak;\n\ncase 2:\n// INstrucciones 2\nbreak;\n\ndefault:\n// Instruccions per defecte\nbreak;\n}\n</code></pre> Activitat 335. Boleta amb cursors <p>Seguint amb l'exemple de la boleta en Processing IDE, completa el seg\u00fcent codi per tal que quan premem un cursor del nostre teclat, la boleta comence a menejar-se en eixa direcci\u00f3. A l'inici de l'aplicaci\u00f3, la boleta estar\u00e0 parada.</p> <pre><code>// Variables globals\nint posX, posY, vel;\n\n// Configuraci\u00f3 de l'aplicaci\u00f3 (nom\u00e9s s'executa una vegada al principi)\nvoid setup () {\nsize(640,480);  // Tamany de monitor est\u00e0ndard VGA\nposX = 320;\nposY = 240;\nvel  = 0;\n}\n\nvoid draw () {\nclear();\nbacground(255);\nellipse(posX, posY, 30, 30);\n\nif (posX &gt;= 640 )\nposX = 0;\n}\n\nvoid keyPressed() {\nswitch (keyCode) {\ncase UP:\n// Ac\u00ed anir\u00e0 el codi per que la boleta es meneje cap amunt\nbreak;\n\ncase DOWN:\n// Ac\u00ed anir\u00e0 el codi per que la boleta vaja cap avall.\nbreak;\n\ncase LEFT:\n// Codi per moure la boleta cap a l'esquerra.\nbreak;\n\ncase RIGHT:\n// Codi per moure la boleta cap a la dreta.\nbreak;\n}\n}\n</code></pre> <p>Un altre exemple m\u00e9s clar que diu el nom del mes a partir d'un n\u00famero entre 1 i 12</p> <pre><code>    //Programa que demana un numero i diu quin mes \u00e9s\n\n\nint mes;\nvoid setup () {\nsize(640,480);\n}\n\n\nmes = (int)random(1,13);\n\nswitch (mes) {  //inicio del switch\ncase 1: println(\"GENER\");\nbreak;\ncase 2: println(\"FEBRER\");\nbreak;\ncase 3: println(\"MAR\u00c7\");\nbreak;\ncase 4: println(\"ABRIL\");\nbreak;\ncase 5: println(\"MAIG\");\nbreak;\ncase 6: println(\"JUNY\");\nbreak;\ncase 7: println(\"JULIOL\");\nbreak;\ncase 8: println(\"AGOST\");\nbreak;\ncase 9: println(\"SETEMBRE\");\nbreak;\ncase 10: println(\"OCTUBRE\");\nbreak;\ncase 11: println(\"NOVEMBRE\");                                                         break;\ncase 12: println(\"DESEEMBRE\");\nbreak;\ndefault : println(\"No v\u00e0lid\");                        }\n</code></pre> Activitat 336. Copia i adapta el codi anterior <p>Escriu el programa anterior per a Processing i comprova que funciona. Afegeix el codi necessari per tal que a banda de dir-te quin mes \u00e9s, et diga tamb\u00e9 a quina estaci\u00f3 de l'any estem.</p> <p></p> <p>En l'exemple anterior el que s'ha fet ha sigut generar aleat\u00f2riament un n\u00famero enter entre 1 i 12 i despr\u00e9s mostrar per pantalla: primer el n\u00famero del mes i despr\u00e9s el nom.</p> Activitat 337. Dies de la setmana <p>Escriun un programa que donat un n\u00famero entre 1 i 7 et diga quin dia de la setmana \u00e9s. 1 Dilluns, 2 Dimarts etc..</p> <p></p> Activitat 338. if a switch <p>Observa el codi a continuaci\u00f3 que explica com es passa de if - else a stich - case i passa les activitats de l'apartat if..else a sent\u00e8ncies switch..case</p> <pre><code>// Exemple de switch convertit a if\nswitch(variable) {\ncase valor1:\n// Accions 1\nbreak;\ncase valor2:\n// Accions 2\nbreak;\ncase valor3:\n// Accions 3\nbreak;\ndefault:\n// Accions default\n}\n\n// El codi anterior utilitzant if\nif (variable == valor1 )\n// Accions 1\nelse if (variagble == valor2)\n// Accions 2\nelse if (variable == valor3)\n// Accions 3\nelse\n//Accions default\n</code></pre> Activitat 339. dies del mes <p>Escriu un programa que ens demane el mes i l'any i ens mostre per pantalla el total de dies que t\u00e9 eixe mes. </p> <p></p> Activitat 340. Figures geom\u00e8triques <p>Escriure un programa que demane primer de quina figura geom\u00e8trica es vol calcular el perimetre. Triangle (t), Quadrat (q), Cercle (c) o rectangle (r) i despr\u00e9s mostre el c\u00e0lcul corresponent.</p>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#estructures-de-repeticio","title":"Estructures de repetici\u00f3","text":"<p>Imaginem que tenim un vector d'enters de 100 elements i volem trobar un nombre concret. Usant les estrcutures condicionals ho podr\u00edem fer.</p> <pre><code>int [] arrayNumeros;               // Declarem un array d'enters\narrayNumeros = new int [100];      // Reservem espai en mem\u00f2ria per 100 elements\ninicialitzaNumeros(arrayNumeros);  // Emplenem de forma aleat\u00f2ria l'array\n\n// Comencem la recerca del n\u00famero 10 per exemple\nif ( array[0] == 10 )\nprintln(\"N\u00famero trobat a la posici\u00f3 0\");\n\nelse if (array[1] == 10)\nprintln(\"N\u00famero trobat a la posici\u00f3 1\");\n\nelse if (array[2] == 10)\nprintln(\"N\u00famero trobat a la posici\u00f3 2\");\n\nelse if (array[3] == 10)\nprintln(\"N\u00famero trobat a la posici\u00f3 3\");\n\nelse if (array[4] == 10)\nprintln(\"N\u00famero trobat a la posici\u00f3 4\");\n\nelse if (array[5] == 10)\nprintln(\"N\u00famero trobat a la posici\u00f3 5\");    // I aix\u00ed fins 100 ... \n</code></pre> <p>Com podeu observar, nom\u00e9s he necessitat escriure codi per als 5 primers elements del nostre array per adondar-me que aquest codi \u00e9s totalment ineficient i t\u00e9 un manteniment molt complicat. Imagineu un array amb 1000 elements i que ho hagurem de codificar com hem fet abans.</p> <p>Les estructures repetitives permetrien rec\u00f2rrer l'array de principi a final sense necessitat d'escriure tant de codi.</p> <p>Veiem els seg\u00fcents exemples.</p>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#while","title":"while","text":"<p>Mentre la condici\u00f3 (tamb\u00e9 anomenada condici\u00f3 d'eixida) siga avaluada com a true, s'executar\u00eden les instruccions que hi ha dins del bucle while. </p> graph LR     Id1((Inici))--&gt;Instrucci\u00f31;     style Id1 fill:#0F0;     Instrucci\u00f31--&gt;D(fa:fa-spinner);      D--&gt;C1{Condici\u00f3};     C1--&gt;|V|Instrucci\u00f32;     Instrucci\u00f32--&gt;P2((Fi));     style P2 fill:#F00;     C1--&gt;|F|D;  <p>En aquest tipus de bucle, el bloc d'instruccions del bucle while, es poden executar zero o m\u00e9s vegades.</p> <p>Els passos que representen el diagrama anterior s\u00f3n: 1. S'executa la instrucci\u00f3 1 2. S'avalua la condici\u00f3  3. Si la condici\u00f3 \u00e9s true, s'executa el bloc d'instruccions del bucle i es torna a avaluar la condici\u00f3. 4. En cas que la condici\u00f3 s'avalue com a false, passar\u00edem a executar la instrucci\u00f3 2.</p> <p>Com far\u00edem el codi necessari per rec\u00f2rrer el nostre array de 100 elements fins trobar el n\u00famero que busquem?. Mira el codi seg\u00fcent:</p> <pre><code>int i = 0;   // Inicialitzem una variable que ens servir\u00e0 de contador.\nwhile (i &lt; 100) {\nif (arrarNumeros[i] == 10)\nprintln(\"N\u00famero trobat a la posici\u00f3 \" + i);\ni ++; // Important incrementar el contador o entrar\u00edem en un bucle infinit.\n}\n</code></pre>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#do-while","title":"do .. while","text":"<p>Molt semblant al bucle while per\u00f2 amb la difer\u00e8ncia que el bloc s'instruccions que cont\u00e9 l'estructura s'executaria almenys una vegada ja que la condici\u00f3 d'eixida s'avalua despr\u00e9s d'executar les instruccions.</p> graph LR     Id1((Inici))--&gt;Instrucci\u00f31;     style Id1 fill:#F00;     Instrucci\u00f31--&gt;P1(fa:fa-spinner);     P1--&gt;Instrucci\u00f32;     Instrucci\u00f32--&gt;C1{Condici\u00f3};     C1--&gt;|V|Instrucci\u00f33;     C1--&gt;|F|P1;     Instrucci\u00f33--&gt;Id2((Fi));     style Id2 fill:#0F0;   <p>Els passos que representen el diagrama anterior s\u00f3n:</p> <ol> <li>S'executa la instrucci\u00f3 1</li> <li>S'executen les instruccions que cont\u00e9 el bloc </li> <li>S'avalua la condici\u00f3 </li> <li>Si la condici\u00f3 \u00e9s true, s'executa el bloc d'instruccions del bucle i es torna a avaluar la condici\u00f3.</li> <li>En cas que la condici\u00f3 s'avalue com a false, passar\u00edem a executar la instrucci\u00f3 2.</li> </ol> <p>A l'exemple seg\u00fcent podem veure el codi necessari per buscar un n\u00famero dins d'un array d'enters (Ja veurem m\u00e9s endavant que \u00e9s un array).</p> <pre><code>int i = 0;   // Inicialitzem una variable que ens servir\u00e0 de contador.\ndo {\nif (arrarNumeros[i] == 10)\nprintln(\"N\u00famero trobat a la posici\u00f3 \" + i);\ni ++; // Important incrementar el contador o entrar\u00edem en un bucle infinit.\n}\nwhile (i &lt; 100);\n</code></pre>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#bucle-for","title":"bucle for","text":"<p>La m\u00e9s complicada de comprendre per\u00f2 tamb\u00e9 possiblement la m\u00e9s utilitzada. Mirem un exemple.</p> graph LR     Id1((Inici))--&gt;Instrucci\u00f31;     style Id1 fill:#0F0;     Instrucci\u00f31--&gt;Inicialitzaci\u00f3;     Inicialitzaci\u00f3--&gt;D(fa:fa-spinner);      D--&gt;C1{Condici\u00f3}     C1--&gt;|NO|Instrucci\u00f32;     C1--&gt;|SI|Instruccions;     Instruccions--&gt;Actualitzaci\u00f3;     Actualitzaci\u00f3--&gt;D;     Instrucci\u00f32--&gt;Id3([Fi])     style Id3 fill:#F00;  <p>I els passos serien:</p> <ol> <li>Executem instrucci\u00f3 1 (aliena al bucle for)</li> <li>Inicialitzaci\u00f3</li> <li>Avaluaci\u00f3 de la condici\u00f3</li> <li>Si la condici\u00f3 \u00e9s true</li> <li>Executem les instruccions del bucle for</li> <li>Actualitzem \u00edndex</li> <li>Si la condici\u00f3 es false eixim del bucle i executem instrucci\u00f3 2</li> </ol> <pre><code>for (int i = 0; i &lt; 100; i ++ ) { if (arrarNumeros[i] == 10)\nprintln(\"N\u00famero trobat a la posici\u00f3 \" + i);\n}\n</code></pre> <p>Al codi anterior:</p> <ol> <li>Inicialitzaci\u00f3: int i = 0;</li> <li>Avaluaci\u00f3 de la condici\u00f3: \u00e9s i &lt; 100 ?</li> <li>Actualitzaci\u00f3: i ++</li> </ol> Activitat 342. Dibuixa amb bucles <p>Observa el seg\u00fcent codi i raona'l</p> <pre><code>void setup() {\nsize(320,240);\n}\n\nvoid draw () {\nfor (int i = 0; i &lt; 10; i ++) {\nfor (int j = 0; j &lt; i; j++ )\ncircle (10+j*20, 10+i*20, 20);\n}\n}\n</code></pre> <p>El resultat d'aquest codi seria: </p> Activitat 342. Dibuixa la piramid i la invertida <p>Fes un programa semblant al de l'activitat anterior per\u00f2 a la inversa, \u00e9s a dir, cinc cercles a la primera l\u00ednia, quatre a la segona, tres a la tercera, dos a la quarta i, finalment, un a la cinquena l\u00ednia.</p> <p></p> Activitat 343. Dibuixa les dues diagonals <p>Millora el programa anterior i fes que dibuixe les dues diagonals, des del punt (0,0) fins al (500,500) i l'altra que va des del punt (500,0) fins al (0,500). Si a una diagonal li dibuixes quadrats, a l'altra dibuixa-li cercles.</p> <p></p> Activitat 344. Dues diagonals 640x480 <p>Millora l'activitat anterior i dibuixa les dues diagonals per\u00f2 a una pantalla de 640 pixels per 480 pixels.</p>"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#ampliem-el-projecte-de-la-boleta","title":"Ampliem el projecte de la boleta","text":"Activitat 354. Utilitza estructures de repetici\u00f3 per dibuixar diverses boletes <p>Utilitzant les estrucutures de repetici\u00f3 vistes i basant-te en l'\u00faltima versi\u00f3 de la boleta i fes que es dibuixen 10 boletes en posicions aleatories i que comencen a caure.</p> Activitat 355. Que no caiguen fins que premes alguna tecla. (keyPressed) <p>Modifica l'activitat anterior per tal que les boletes no comencen a carue fins que premes una tecla.</p> Activitat 356. Boletes numerades <p>Associa cada una de les 10 boletes a un n\u00famero conecret (del 0 al 9) i fes que cada bolesta no comence a caure fins que es premi el nombre que est\u00e0 associat a cada boleta.</p> activitat 357. Boletes i quadrats <p>Modifica l'activitat 354 per tal que la nostra aplicaci\u00f3 dibuixe 4 boletes i 6 quadrats i comencen a caure.</p> <p>AMPLIACI\u00d3: Series capa\u00e7 de fer que els quadrats roten a l'eix z al mateix temps que cauen?</p>"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/","title":"Tema 4. Programaci\u00f3 Modular","text":""},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#introduccio","title":"Introducci\u00f3","text":"<p>Anem a entrar en un m\u00f3n que es basa en la m\u00e0xima: \"Divideix i vencer\u00e0s\". Si fem una analogia amb l'estrat\u00e8gia b\u00e8l\u00b7lica, podriem dir que en aquells casos que l'enemic \u00e9s molt gran per a les nostres possibilitats, seria interessant poder, d'alguna forma, dividir-lo en tro\u00e7os m\u00e9s xicotets de tal forma que el pugam afrontar.</p> <p>Qu\u00e8 \u00e9s?</p> <p>La programaci\u00f3 modular \u00e9s un paradigma de programaci\u00f3 que consisteix a dividir un programa en m\u00f2duls o subprogrames per tal de fer-lo m\u00e9s llegible i manejable</p> <p>Tamb\u00e9 podriem dir que \u00e9s una evoluci\u00f3 de la programaci\u00f3 estructurada per solucionar problemes de programaci\u00f3 m\u00e9s grans i complexos del que aquesta pot resoldre.</p> <p>En l'aplicar la programaci\u00f3 modular, un problema complex ha de ser dividit en diversos subproblemes m\u00e9s simples, i aquests al seu torn en altres subproblemes m\u00e9s simples encara. Aix\u00f2 s'ha de fer fins a obtenir subproblemes prou simples com per poder ser resolts f\u00e0cilment amb algun llenguatge de programaci\u00f3. Aquesta t\u00e8cnica es diu refinament successiu, divideix i vencer\u00e0s o an\u00e0lisi descendent (Top-Down).</p> <p>Un m\u00f2dul \u00e9s cadascuna de les parts d'un programa que resol un dels subproblemes en qu\u00e8 es divideix el problema complex original. Cadascun d'aquests m\u00f2duls t\u00e9 una tasca ben definida i alguns necessiten d'altres per poder operar. En cas que un m\u00f2dul necessiti d'un altre, pot comunicar-se amb aquest mitjan\u00e7ant una interf\u00edcie de comunicaci\u00f3 que tamb\u00e9 ha d'estar ben definida.</p> <p>Si b\u00e9 un m\u00f2dul es pot entendre com una part d'un programa en qualsevol de les seves formes i variats contextos, en la pr\u00e0ctica se'ls sol prendre com a sin\u00f2nims de procediments i funcions. Per\u00f2 no necess\u00e0ria ni estrictament un m\u00f2dul \u00e9s una funci\u00f3 o un procediment, ja que el mateix pot contenir molts d'ells. No s'ha de confondre el terme \"m\u00f2dul\" (en el sentit de programaci\u00f3 modular) amb termes com \"funci\u00f3\" o \"procediment\", propis de l'llenguatge que ho suporte.</p> White Stripes - Little Acorn (lletra) - Intro <p>When problems overwhelm us And sadness smothers us Where do we find the will and the courage to continue? Well, the answer may come in the carrying voice of a friend A chance encounter with a book Or from a personal faith For janette help came from her faith But it also came from a squirrel Shortly after her divorce Janette lost her father Then she lost her job She had mounthing money problems But Janette not only survived She worked her way out of despondency and now she says \"Life is good again\" How could this happen? She told me that late one autumn day when she was at her lowest She watched a squirrel storing up nuts for the winter One at a time he would take them to the nest And she thought, \"If that squirrel can take care of himself with the harsh winter coming on So can I Once I broke my problems into small pieces I was able to carry them Just like those acorns One at a time</p>"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#caracteristiques","title":"Caracter\u00edstiques","text":"<p>La modularitat en programaci\u00f3 es considera la capacitat que t\u00e9 un llenguatge concret en dividir-se en parts o subprogrames (m\u00f2duls). Cadascun dels m\u00f2duls o parts que formaran part d'aquest programa, tenen una funci\u00f3 particular, s\u00f3n semi-independents i incl\u00fas es poden trobar en fitxers f\u00edsics distints.</p> <p>No hem de pensar mai en un programa com un tot sino com un conjunt de m\u00f2duls relacionats entre si on cada m\u00f2dul desenvolupa una tasca molt concreta independentment de la resta i que tots junts formen el programa o aplicaci\u00f3.</p>"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#avantatges","title":"Avantatges","text":"<ul> <li>El codi resultant \u00e9s m\u00e9s net i f\u00e0cil d'entendre.</li> <li>Permet la divisi\u00f3 del treball.</li> <li>Es pot provar de forma independent, millorant aix\u00ed la recerca i correcci\u00f3 d'errades.</li> <li>Facilita la definici\u00f3 de variables al crear diversos \u00e0mbits.</li> </ul>"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#tipus-de-modularitat","title":"Tipus de modularitat","text":"<p>Depenent del nivell de detall amb el que es tracten els m\u00f2duls, podem distindir tres tipus:</p> <ul> <li>Llibreries: conjunt de funcions o de m\u00f2duls que comparteixen una finalitat.</li> <li>Classes: les classes s\u00f3n definicions de possibles objectes. Ja ho veurem amb m\u00e9s detall al tema de programaci\u00f3 orientada a objectes.</li> <li>Funcions o m\u00e8todes: codi que realitza un funci\u00f3 concreta. Una funci\u00f3 o m\u00e8tode pot estar associat tant a una llibreria com a un classe.</li> </ul> <p>Una funci\u00f3 \u00e9s un tro\u00e7 de codi que realitza una funci\u00f3 concreta i de vegades torna algun valor com a resultat. A banda, la t\u00e8cnica de programaci\u00f3 modular tamb\u00e9 aporta alguns dels fonaments de la programaci\u00f3 orientada a objectes com s\u00f3n: abstracci\u00f3, encapsulament i modularitat. </p> <p>Veiem amb m\u00e9s detall que \u00e9s cadascun:</p>"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#abstraccio","title":"Abstracci\u00f3","text":"<p>L'abstracci\u00f3 \u00e9s la capacitat de, observada una realitat, quedar-se amb all\u00f2 important o essencial i obviar el detall. Aquest concepte ser\u00e0 un concepte b\u00e0sic en l'evoluci\u00f3 de la programaci\u00f3 estructurada i modular cap a la programaci\u00f3 orientada a objectes. Per exemple, per saber conduir un cotxe no necessite saber al detall el funcionament del seu motor sino on est\u00e0 l'accelerador, el fre i el volant.</p>"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#encapsulament","title":"Encapsulament","text":"<p>L'encapsulament \u00e9s el proc\u00e9s d'emmagatzemar en un mateix compartiment els elements d'una abstracci\u00f3 que constitueixen la seua estructura i comportament. En altres paraules, l\u2019ocultaci\u00f3 d\u2019informaci\u00f3, de forma que les dades internes d\u2019un m\u00e8tode, funci\u00f3 o procediment estan ocultes al m\u00f3n exterior, nom\u00e9s es coneix d\u2019ell la seua ess\u00e8ncia, \u00e9s a dir, qu\u00e8 podem fer amb ell.</p> <p>Per exemple, amb freq\u00fc\u00e8ncia es desenvolupa codi font o projectes en els que utilitzem la classe out, m\u00e9s concretament el m\u00e8tode println. Out es troba dins de l\u2019espai de noms (namespace) System i no \u00e9s m\u00e9s que una classe d\u2019aquest paquet. Dit en altres paraules. Out \u00e9s una classe i println() \u00e9s un m\u00e8tode de la classe Out.</p>"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#modularitat","title":"Modularitat","text":"<p>Aquesta propietat fa refer\u00e8ncia a la forma en la que els elements en programaci\u00f3 orientada a objectes es troben organitzats en m\u00f2duls, facilitant aix\u00ed l\u2019encapsulament i abstracci\u00f3 de la informaci\u00f3.</p> <p>La modularitat permet dividir una aplicaci\u00f3 en parts. Aquestes parts han de ser   tan independents com puguen de la resta de m\u00f2duls aix\u00ed com tamb\u00e9 de l\u2019aplicaci\u00f3 principal. El motiu pel qual els m\u00f2duls han de ser el m\u00e9s independents possibles de l\u2019aplicaci\u00f3 \u00e9s perqu\u00e8 aix\u00ed es podran reutilitzar en altres aplicacions m\u00e9s endavant.</p>"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#funcions-en-java","title":"Funcions en Java","text":"<p>Una vegada vistos els fonaments de la programaci\u00f3 modular, augmentem el nivell de detall. A Java la modularitat s'implementa mitjan\u00e7ant l'\u00fas de funcions. Una funci\u00f3 en Java \u00e9s la concreci\u00f3 de la t\u00e8cnica de programaci\u00f3 modular, \u00e9s a dir, un metode o procediment \u00e9s un fragment de codi que realitza una funci\u00f3 concreta dins del nostre programa. </p> <p>Per\u00f2 com s'escriu una funci\u00f3 en Java:</p> <pre><code>[acces] [modificador] tipus nomFuncio([tipus nomArgument,[tipo nomArgument]...]) {\n\n/*\n        * Bloc d'instruccions\n    */\n\nreturn valor;\n}\n</code></pre> <p>Veiem i expliquem que significa cadascun dels elements que formen el codi anterior.</p> <p>Qu\u00e8 \u00e9s qu\u00e8</p> <p>Tots aquells elements que estan entre claudators s\u00f3n opcionals. On: </p> <ul> <li>Acc\u00e9s: public, protected, private o package</li> <li>Modificador: static o final</li> <li>Tipo: int, boolean, float o qualsevol tipus predefinit per l'usuari.</li> <li>nomFuncio: cadena alfanum\u00e8rica significativa que indique el que fa la funci\u00f3.</li> <li>nomArgument: par\u00e0metres que se li passen a la funci\u00f3. Aquestos par\u00e0metres funcionaran com variables locals a la funci\u00f3.</li> </ul> <p>Per acabar veiem exemples concrets de com s'implementen les funcions o m\u00e8todes en Java. La primera funci\u00f3 el que fa \u00e9s saludar dient \"Hola m\u00f3n\" cada vegada que s'utilitza. Las segona diu \"Hola\" junt amb el nom que es passa com argument i finalment la tercera funci\u00f3 el que fa \u00e9s agafar la cadena de caracters que se li passa per par\u00e0metre i la inverteix. Si no entens el que s\u00f3n par\u00e0metres i arguments, no et preocupes, ho veurem al punt seg\u00fcent. Mira el seg\u00fcent exemple:</p> <pre><code>// Funci\u00f3 simple \nvoid diguesHola () {\nSystem.out.println(\"Hola Mon\");\n}\n\n// Funci\u00f3 amb par\u00e0metres\nvoid sayMyName (String strNom) {\nSystem.out.println(\"Hola Mon: \" + strNom);\n}\n\n// Funci\u00f3 que torna algun valor\nString canviaNom (String strNom) {\nreturn strNom.reverse();\n}\n</code></pre> Activitat 401. Modularitza el seg\u00fcent codi <p>El seg\u00fcent codi per a Processing IDE dibuixa una taula de billar amb dues boles negres, dues banques i dues rotges. Modularitza el codi de tal forma que al m\u00e8tode draw nom\u00e9s hi haur\u00e0 crides a m\u00e8todes definits per tu, concretament els seg\u00fcents m\u00e8todes: </p> <ul> <li>dibuixarTaula.</li> <li>dibuixarBolesRotges.</li> <li>dibuixarBolesNegres.</li> <li>dibuixarBolesBlanques.</li> </ul> <p>Al codi teniu tamb\u00e9 el prototip de la funci\u00f3 dibuixarTaula() com a exemple.</p> <pre><code>    void setup () {\nsize(640, 480);\nbackground(255);\n}\n\nvoid draw () {\nstrokeWeight(20);\nstroke(170,120,20);\nfill(0,255,0);\nrect(30,30,500,330);\n\nfill(0);\nstrokeWeight(1);\nstroke(200);\ncircle(200,200,35);\ncircle(400,60,35);\n\nstroke(0);\nfill(255,0,0);\ncircle(100,100,35);\ncircle(350,330,35);\n\nfill(255,255,255);\ncircle(300,150,35);\ncircle(150,300,35); }\n\nvoid dibuixarTaula() {\n// Posa ac\u00ed el codi que dibuixaria la taula de billar.\n}\n</code></pre>"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#parametres-duna-funcio","title":"Par\u00e0metres d'una funci\u00f3","text":"<p>Les funcions o m\u00e8todes en Java no nom\u00e9s serveixen per poder dividir i simplificar el codi sino que tamb\u00e9 es poden parametritzar, \u00e9s a dir, se li poden passar arguments que b\u00e9 utilitzen en la seua l\u00f2gica interna o b\u00e9 modifiquen el comportament del m\u00e8tode en q\u00fcesti\u00f3.</p> <p>Qu\u00e8 \u00e9s un par\u00e0metre ?</p> <p>Els par\u00e0metres s\u00f3n una forma d'intercanviar informaci\u00f3 amb el m\u00e8tode en q\u00fcesti\u00f3. Poden servir per introduir dades per executar el m\u00e8tode (entrada) o per obtenir o modficar dades despr\u00e9s de la seua execuci\u00f3 (eixida).</p> <p>Hi ha alguns detalls al respecte dels par\u00e0metres d'una funci\u00f3:</p> <ul> <li>Una funci\u00f3 pot tindre una quantitat qualsevol de par\u00e0metres, \u00e9s a dir, poden tindre des de zero fins a un, dos, deu o cent par\u00e0metres. </li> <li>Encara que poden ser m\u00e9s, normalment no sol passar de cinc m\u00e0xim.</li> <li>Si la funci\u00f3 t\u00e9 m\u00e9s d'un par\u00e0metre cadascun d'ells ha d'anar separat per una coma.</li> <li>Els arguments d'una funci\u00f3 tamb\u00e9 tenen un tipus i nom que els identifica.</li> <li>El tipus dels arguments pot ser qualsevol i no ha de tindre relaci\u00f3 amb el tipus del m\u00e8tode.</li> <li>Al rebre un argument res ens obliga a fer \u00fas d'aquest dins del m\u00e8tode.</li> <li>Els par\u00e0metres poden passar-se per refer\u00e8ncia (es mantenen les modificacions que es facen dins del m\u00e8tode) o per valor (no afectarien les modificacions a l'element original).</li> </ul>"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#una-funcio-amb-parametres-en-java","title":"Una funci\u00f3 amb par\u00e0metres en Java","text":"<pre><code>void mostraBola(int posX, int posY, int tam) {\nfill(127);\nstroke(0);\nstrokeWeight(3);\nellipse(x,y,tam,tam);\n}\n</code></pre> <p>La funci\u00f3 anterior \u00e9s un m\u00e8tode, que si fem cas al nom, s'encarrega de dibuixar una bola. Aquesta funci\u00f3 t\u00e9 tres par\u00e0metres: </p> <ul> <li>Un enter anomenat posX que representa la posici\u00f3 x on es dibuixar\u00e0 la boleta</li> <li>Un enter amb nom posY que indica la posici\u00f3 y en la que es dibuixar\u00e0 la boleta</li> <li>Un \u00faltim enter que es diu tam que li dir\u00e0 a la funci\u00f3 quin ser\u00e0 el tamany de la boleta.</li> </ul> <p>Com ja s'ha comentat anteriorment, \u00e9s possible passar un o m\u00e9s valors a una funci\u00f3 quan es crida. Recordeu que un valor passat a una funci\u00f3 es diu argument. Dins la funci\u00f3, la variable que rep l'argument es diu par\u00e0metre. Els par\u00e0metres es declaren dins dels par\u00e8ntesis que segueixen a el nom de m\u00e8tode. </p> <p>Un par\u00e0metre est\u00e0 dins de l'abast de la seua funci\u00f3, i a banda de la seva tasca especial de rebre un argument, actua com qualsevol altra variable local.</p>"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#diferencia-entre-parametre-i-argument","title":"Difer\u00e8ncia entre par\u00e0metre i argument","text":"<p>Ac\u00ed hi ha un exemple simple de l'\u00fas de par\u00e0metres. Dins de la classe ComprobarNumero, el m\u00e8tode Espar () retorna true si el valor que es passa \u00e9s parell. Retorna false en cas contrari. Per tant, esParell() t\u00e9 un tipus de retorn boole\u00e0.</p> <pre><code>// Un exemple per diferenciar par\u00e0metre d'argument\n\nclass ComprovarNumero {\n\n// Retorna true si x es parell\nboolean esParell(int x){       if ((x%2)==0) return true;\nelse return false;\n}\n// A la interf\u00edcie del m\u00e8tode anterior, entre parentesis ens trobem el PAR\u00c0METRE int x. El nom del par\u00e0metre \u00e9s 'x'\n// mentre que el tipus del par\u00e0metre \u00e9s enter 'int'\n}\n\nclass ParametroDemo {\npublic static void main(String[] args) {\n\nComprobarNumero e = new ComprobarNumero();\n\nif (e.esParell(10))  // 10 \u00e9s l'argument usat en la crida a la funci\u00f3 esPar\nSystem.out.println(\"10 es par.\");\n\nif (e.esParell(9))   // 9 \u00e9s l'argument en aquesta crida\nSystem.out.println(\"9 es par.\");\n\nif (e.esParell(8))   // 8 \u00e9s l'argument ac\u00ed\nSystem.out.println(\"8 es par.\");\n}\n}\n</code></pre> <p>Com ja s'ha comentat anteriorment un m\u00e8tode pot tenir m\u00e9s d'un par\u00e0metre. Simplement declare cada par\u00e0metre, separant un el seg\u00fcent amb una coma. Per exemple, la classe Divisor defineix un m\u00e8tode anomenat esDivisor () que determina si el primer par\u00e0metre \u00e9s divisor de el segon.</p>"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#funcions-amb-mes-dun-parametre","title":"Funcions amb m\u00e9s d'un par\u00e0metre","text":"<pre><code>boolean esDivisor(int a, int b) {\nif ((b%a)==0) return true;\nelse return false;\n}\nclass DivisorDemo {\npublic static void main(String[] args) {\nDivisor x =new Divisor();\nif (x.esDivisor(2,20)) System.out.println(\"2 es Divisor de 20\");\nif (x.esDivisor(3,20)) System.out.println(\"3 es Divisor de 20\");\n}\n}\n</code></pre> Activitat 402. Executa en Eclipse IDE <p>Passa el codi anterior a Processing i executa'l. A banda del par\u00e0metre 'int x', observa el codi amb atenci\u00f3 i digues si hi ha alguna altra funci\u00f3 amb par\u00e0metres? Quins? </p> <p>Finalment dir que els arguments poden ser literals, que corresponguen amb el tipus del par\u00e0metre, o tamb\u00e9 poden ser variables, per\u00f2 que passa amb les variables que es passen com a argument si el par\u00e0metre al qual s'assignen \u00e9s modificat en temps d'execuci\u00f3? Es modifiquen tamb\u00e9? Mirem la difer\u00e8ncia entre valor i refer\u00e8ncia.</p>"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#pas-per-valor-i-pas-per-referencia","title":"Pas per valor i pas per refer\u00e8ncia","text":"<p>Entrem en m\u00e9s detall sobre els par\u00e0metres, que passa amb ells quan s'acaba l'execuci\u00f3 de la funci\u00f3 o m\u00e8tode si s\u00f3n variables locals?</p> <p>En resum el pas per valor significa que al m\u00e8tode, en la variable de l'argument li arriba una c\u00f2pia del valor en el cas que es tracte d'un tipus de dades primitiu, \u00e9s a dir, char, int, float, double, etc.. Mentre que el pas per refer\u00e8ncia en canvi, l'argument cont\u00e9 un punter amb l'adressa de mem\u00f2ria de la variable en q\u00fcesti\u00f3. </p> <p>Resum valor vs refer\u00e8ncia</p> <ul> <li>Pas per valor: Es crea una c\u00f2pia local de la variable dins de la funci\u00f3.      </li> <li>Pas per refer\u00e8ncia: Es maneja directament la variable, els canvis realitzats dins de la funci\u00f3 li afectaran tamb\u00e9 fora.     </li> </ul> <p>En resum, si es passa un argument per c\u00f2pia, tot all\u00f3 que es faja al par\u00e0metre dins del codi de la funci\u00f3 no afectar\u00e0 a l'original mentre que si, per contra, l'argument es passa per refer\u00e8ncia, totes aquelles accions que es realitzen sobre el par\u00e0metre li afectaran a l'argument original.</p> <p> </p> <p>Fixa't en el seg\u00fcent codi:</p> <pre><code>    public static void main(String[] args) {\n\nint x = 1;\nint y = 2;\nSystem.out.print(\"Valors de x i y abans de la modificaci\u00f3: \");\nSystem.out.println(\" x = \" + x + \" ; y = \" + y );\nmodificaTiupsPrimitius(x,y);\nSystem.out.print(\"Valors de x i y despr\u00e9s de la modificaci\u00f3: \");\nSystem.out.println(\" x = \" + x + \" ; y = \" + y );\n}\n\n\nprivate static void modificaTiupsPrimitius(int x, int y) {\nx = 5;\ny = 10;\n}\n</code></pre> Activitat 403. Pas per valor i pas per refer\u00e8ncia I <p>Copia el codi anterior en Eclipse IDE i respon a les seg\u00fcents q\u00fcestions:</p> <ul> <li>Quins s\u00f3n els par\u00e0metres i de quin tipus s\u00f3n els de la funci\u00f3 modificaTiupsPrimitius?</li> <li>Quantes vegades es crida a la funci\u00f3 modificaTiupsPrimitius?</li> <li>Quins argument es passen a cada crida?</li> <li>Qu\u00e8 passa i per qu\u00e8 a l'executar-se el codi anterior?</li> <li>Estan passant-se els arguments per valor o per refer\u00e8ncia?</li> </ul> <p>Ara mira el seg\u00fcent codi:</p> <pre><code>    public class PasReferencia {\n\npublic static void main(String [] args) {\nPersona persona = new Persona();\nmodificaPersona(persona);\nSystem.out.println(\"Nom: \" + persona.strNom);\nSystem.out.println(\"Cognom: \" + persona.strCognom);\nSystem.out.println(\"Edat: \" + persona.edat);\n}\n\nstatic void modificaPersona(Persona p) {\np.strNom = \"Manolo\";\np.strCognom = \"Unodos\";\np.edat = 18;\n}\n}\n\npublic class Persona {\nString strNom;\nString strCognom;\nint edat;\n}\n</code></pre> Activitat 404. Pas per valor i pas per refer\u00e8ncia II <p>Copia el codi anterior i respon a les seg\u00fcents q\u00fcestions:</p> <ul> <li>Quins s\u00f3n els par\u00e0metres i de quin tipus s\u00f3n els de la funci\u00f3 modificaPersona?</li> <li>Quantes vegades es crida a la funci\u00f3 modificaPersona?</li> <li>Quins argument es passen a cada crida?</li> <li>Qu\u00e8 passa i per qu\u00e8 a l'executar-se el codi anterior?</li> <li>Estan passant-se els arguments per valor o per refer\u00e8ncia?</li> </ul>"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#sobre-el-return","title":"Sobre el return","text":"<p>Com ja haur\u00e0s vist, hi ha algunes funcions que comencen per void i altres que tenen altres tipus... a\u00e7\u00f2 el que torna la funci\u00f3. B\u00e0sicament la difer\u00e8ncia entre una funci\u00f3 i un procediment des del punt de vista conceptual \u00e9s si el m\u00e8tode torna o no algun valor. Si torna \u00e9s un procediment sino \u00e9s una funci\u00f3, per\u00f2 aquesta \u00e9s nom\u00e9s un q\u00fcesti\u00f3 conceptual ja que des del punt de vista t\u00e8cnic (del codi) no hi practicament cap difer\u00e8ncia entre funci\u00f3 i procediment a banda del fet que retornen un valor en Java.</p> <p>Has de tenir en compte dues coses importants amb la sent\u00e8ncia return:</p> <ul> <li>Qualsevol instrucci\u00f3 que es trobe despr\u00e9s de l'execuci\u00f3 de return, NO ser\u00e0 executada.</li> <li>\u00c9s com\u00fa trobar funcions amb m\u00faltiples sent\u00e8ncies return al seu codi, com per exemple en sentencies condicionals, per\u00f2 una vegada el codi execute una sent\u00e8ncia return all\u00f2 que vinga despr\u00e9s no s'executar\u00e0.</li> <li>El tipus de valor que es torna en una funci\u00f3 ha de conicidir amb el tipus declarat a la funci\u00f3, \u00e9s a dir, si es declara int, el valor que ha de tornar ha de ser un nombre enter.</li> <li>En el cas de les funcions que no tornen res (void), tamb\u00e9 conegues com a procediments, poden usar la sent\u00e8ncia return per\u00f2 sense cap valor i nom\u00e9s s'usaria per acabar amb l'execuci\u00f3 de la funci\u00f3. </li> </ul>"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#funcions-i-procediments","title":"Funcions i procediments","text":"<pre><code>void setup () {\nsize(640,480);        }\n\nvoid draw () {\ndibuixaSol();\nint abs = calculaAbsolut(-10);\nprintln(\"Abs: \" + abs);\n}\n\nvoid dibuixaSol() {\nfill(255,0,0);\nstroke(0);\nstroweWeight(1);\ncircle(320,240,40);\n}\n\nint calculaAbsolut (int a) {\nif (a &lt; 0)\na = a * -1;\n\nreturn a;\n}\n</code></pre> Activitat 405. Revisa conceptes <p>\u00c9s el moment de revisar tots els conceptes vistos fins ara que no s\u00f3n pocs. Revisa el codi anterior i respon a les seg\u00daents q\u00fcestions:     - Quants m\u00e8todes hi han al codi?     - Quin nom tenen?     - Escriu el prototip (interf\u00edcie) de cadascun dels m\u00e8todes que has trobat.     - Per a cada m\u00e8tode respon: quants par\u00e0metres tenen? Quin \u00e9s el nom i tipus dels par\u00e0metres?     - Quins dels m\u00e8todes que has trobat s\u00f3n funcions i quins procediments? Raona la resposta.</p>"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#funcions-declaracio-i-crida","title":"Funcions: declaraci\u00f3 i crida","text":"<p>Hem vist ja la gran part t\u00e8cnica de com funcionen els m\u00e8todes en Java pel que fa a la part de sintaxis i les diferents paraules claus que s'utilitzen. En altres paraules, ja sabem construir funcions i procediments tant des del punt de vista t\u00e8cnic (com \u00e9s construiexen), com des del punt de vista sem\u00e0ntic (qu\u00e8 signifiquen) per\u00f2, com fem \u00fas d'aquestes funcions o procediments?</p> <p>Primer cal que distinguim entre la declaraci\u00f3 d'un m\u00e8tode i la crida a aquest.</p> <ul> <li>Declaraci\u00f3 d'un m\u00e8tode: definici\u00f3 del procediment o funci\u00f3 on s'inclou tant la cap\u00e7alera (interf\u00edcie o prototip) i el cos (codi de la funci\u00f3).</li> <li>Crida a un m\u00e8tode: \u00fas del m\u00e8tode per mitj\u00e0 d'una crida a aquest utilitzant el prototip i els par\u00e0metres en cas de tenir-los.</li> <li>Prototip, interf\u00edcie o signatura: la signatura d'un m\u00e8tode \u00e9s la combinaci\u00f3 de nom, tipus de par\u00e0metres, nom d'aquestos i ordre.</li> </ul> <p>Per tal d'utilitzar una funci\u00f3 o m\u00e8tode en Java hem de cridar a eixa funci\u00f3. Una funci\u00f3 en Java es crida utilitzant el nom del m\u00e8tode i entre par\u00e9ntesis s'han de passar els par\u00e0metres que s'indica a la declaraci\u00f3 de la funci\u00f3. Aquestos par\u00e0metres que es passen han de coincidir en n\u00famero, si la declaraci\u00f3 del funci\u00f3 t\u00e9 3 par\u00e0metres s'hauran de passar tres par\u00e0metres, i tamb\u00e9 han de coincidir en el t\u00edtol.  Per\u00f2 millor vegem un exemple:</p> <pre><code>// Declaraci\u00f3 de la funci\u00f3 holaMon\nvoid holaMon (String strNom) {\nSystem.out.println(\"Hola: \" + strNom);\n}\n\n// Declaraci\u00f3 del funci\u00f3 suma\nint suma (int a, int b) {\nint res = a + b;\nreturn res;\n}\n\n// Crida correcta a la funci\u00f3 holaMon\nholaMon(\"Batiste\");\n\n// Crida incorrecta a la funci\u00f3 holaMon\nholaMon();\nholaMon(\"Batiste\",\"Ceba\");\n\n// Crida correcta a suma\nint resultat = suma(10,5);\nsuma(10,5);\n\n// Crides incorrectes.\nint resultat = suma();\nsuma();\nint res = suma (10,3,10);\n</code></pre> Activitat 406. Copia i raona el codi anterior <p>C\u00f2pia el codi anterior, executa'l i raona el que est\u00e0 passant. Modifica el codi per tal que funcione correctament i mostre un resultat per pantalla.</p> Activitat 407. Crida als m\u00e8todes de forma correcta <p>A continuaci\u00f3 vos he deixat un codi amb 4 funcions. Observeu-les i despr\u00e9s feu \u00fas de totes elles des de la funci\u00f3 draw.</p> <pre><code>void setup () {\nsize(640,480);\n}\nvoid draw () {\n// Escriu el codi de les funcions ac\u00ed.\n}\n\nvoid fesAlgo() {\nprintln(\"Algo far\u00e9\");\n}\n\nvoid f2(int a) {\nif (a%2==0)\nprintln(\"El nombre \u00e9s parell\");\nelse\nprintln(\"El nombre no \u00e9s parell\");\n}\n\nvoid funcio3(int a, char c) {\nprintln(\"El caracter \u00e9s \" + c + \" mentre que el n\u00famero \u00e9s: \" + a);\n}\nint funcio4(int c) {\nint a = 0;\nfor (int i=0; i &lt; c; i ++)\na = a + 1 + 2*a;\n\nreturn a;\n}\nString funcio5(String str) {\nif (str == \"\" )\nreturn \"Buida\";\n\nreturn str.toUpperCase();\n}\n</code></pre>"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#detalls-per-cridar-funcions","title":"Detalls per cridar funcions","text":"<ul> <li>El nom ha de coincidir exactament al moment de cridar, \u00e9s l\u2019\u00fanica forma d\u2019identificar-lo.</li> <li>L\u2019ordre dels par\u00e0metres i el tipus ha de coincidir. </li> <li>Cal tindre cura en el moment d'enviar els par\u00e0metres, hem de fer-ho en el mateix ordre en que varen ser declarats i han de ser del mateix tipus.</li> <li>Cada par\u00e0metre enviat tamb\u00e9 va separat per comes.</li> <li>Si una funci\u00f3 no rep par\u00e0metres, simplement no posem res a l'interior de la par\u00e8ntesi, per\u00f2 sempre debem posar la par\u00e8ntesi.</li> <li>Invocar una funci\u00f3 segueix sent una sent\u00e8ncia normal i corrent en Java, aix\u00ed que ha de finalitzar amb ';' com sempre.</li> <li>El valor retornat per un m\u00e8tode o funci\u00f3 pot ser assignat a una variable del mateix tipus.</li> <li>Si es tracta d'un procediment no es pot retornar valor alg\u00fa.</li> <li>Una funci\u00f3 pot cridar a una altra dins de s\u00ed mateixa o fins i tot pot ser enviada com a par\u00e0metre a una altra (mira el seg\u00fcent exemple).</li> </ul> Activitat 408. Copia i raona el seg\u00fcent codi <p>Passa el seg\u00fcent codi a processing, executa'l i raona el que est\u00e0 passant. Quin altre nom alternatiu li podriem posar a la funci\u00f3 per tal que aquest siga m\u00e9s significatiu?</p> <pre><code>void setup () {\nsize(320,240);\nint i = 10;\nint [] array = new int[10];\nfor (int a = 0; a &lt; i; a ++ )\narray[a] = 0;\n\nSystem.out.println(\"Abans de la cirda a la funci\u00f3:\");\nSystem.out.println(\"i=\" + i );\nSystem.out.println(\"array[5]=\" + array[5] );\nfuncio(i,array);\nSystem.out.println(\"Despr\u00e9s de la cirda a la funci\u00f3:\");\nSystem.out.println(\"i=\" + i );\nSystem.out.println(\"array[5]=\" + array[5] );\n}\n\nvoid draw () {\ndelay(10000);\n}\n\nvoid funcio(int i, int [] array) {\ni = 5;\narray[i] = 15;\n}\n</code></pre> Activitat 409. Executa el codi en Processing IDE <p>Escriu el seg\u00fcent codi en Processing i executa'l. </p> <p><pre><code>// Variables globals\nint x, y;\nvoid setup () {\nsize(320,240);\nx = 150;\ny = 120;\n}\n\nvoid draw () {\nbackground(255);\nstroke(0);\n\n// Dibuixem la cara cercle\nstrokeWeight(2);\nfill(255,255,0);\ncircle(x,y,100);\n\n// Dibuixem ulls\nstrokeWeight(2);\nfill(255);\ncircle(130,110,20);\ncircle(165,110,20);\nstrokeWeight(5);\npoint(133,110);\npoint(168,110);\n\n// Dibuixem la boca\nnoFill();\nstrokeWeight(2);\narc(150, 135, 40, 30, 0, PI);\n</code></pre> Aquest codi mostra el seg\u00fcent dibuix</p> <p></p> Activitat 410. Divideix-lo en funcions <p>Separa el codi en funcions, has d'afegir les funcions dibuixaCara, dibuixaUlls i dibuixaBoca seguint els prototips que et mostre a continuaci\u00f3.</p> <pre><code>// Prototips de funcions\nvoid dibuixaCara();\nvoid dibuixaUlls();\nvoid dibuixaBoca();\n</code></pre> Activitat 411. Par\u00e0metres coordenades <p>Modifica el codi anterior per tal que tant el codi que dibuixa els ulls com el codi que dibuixa la boca, estiguen en dues funcions: dibuixaUlls i dibuixaBoca. A aquestes funcions se'ls passar\u00e0 com a par\u00e0metres les coordenads x i y i a partir d'aquestes ha de dibuixar els ulls i la boca on corresponga.</p> <pre><code>// Prototips de les funcions\nvoid dibuixaCara(int x, int y);\nvoid dibuixaUlls(int x, int y);\nvoid dibuixaBoca(int x, int y);\n</code></pre> Activitat 412. Dibuixar cares - Ampliaci\u00f3 <p>Amplia el codi anterior per tal que mostre el seg\u00fcent dibuix. Observa com ha de quedar el codi de la funci\u00f3 draw</p> <p></p> <pre><code>// Variables Globals\nint cercleX, cercleY, triangleX, triangleY, quadratX, quadratY;\n\nvoid setup () {\nsize(640,300);\n// Coordenades del cercle\ncercleX = 150;\ncercleY = 150;\n\n// Coordenades del primer punt del triangle\ntriangleX = 250;\ntriangleY = 200;\n\n// Coordenades del quadrat\nquadratX = 445;\nquadratY = 100;\n}\n\nvoid draw () {\nbackground(255);\n\n// Codi per dibuixar el cercle\n// Escriu el codi necessari per dibuixar el cercle a cercleX i cercleY\ndibuixaUlls(cercleX,cercleY);\ndibuixaBoca(cercleX,cercleY);\n\n// Codi per dibuixar el triangle\n// Escriu el codi necessari per dibuixar el cercle a triangleX i triangleY\ndibuixaUlls(triangleX,triangleY);\ndibuixaBoca(triangleX,triangleY);\n\n// Codi per dibuixar el quadrat\n// Escriu el codi necessari per dibuixar el cercle a quadratX i quadratY\ndibuixaUlls(quadratX,quadratY);\ndibuixaBoca(quadratX,quadratY);\n}\n</code></pre> Activitat 413. Dibuixar pe\u00e7a domino <p>Emplena el codi de la funci\u00f3 dibuixaDomino(int,int) per tal que mostre la imatge seg\u00fcent.</p> <pre><code>void setup() {\nsize(640,480);\n}\nvoid draw  () {\ndibuixaDomino(5,4);\n}\n\nvoid dibuixaDomino(int a, int b) {   // Codi per dibuixar la pe\u00e7a de domin\u00f3 amb la puntuaci\u00f3 que es passa per par\u00e0metre.\n}\n</code></pre> <p></p> Activitat 414. Dibuixar pe\u00e7a domin\u00f3 parametritzada <p>Qu\u00e8 passa si en lloc de 5 i 4 pasarem 6 i 6 per par\u00e0metre? Dibuixa el que esperes que dibuixe? </p> <p>Fes les modficacions necess\u00e0ries al codi per tal que funcione com s'espera. </p> <p>Ampliaci\u00f3: fes que el teu algorisme mostre totes les peces del domin\u00f3 ordenades en files i columnes.</p>"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#pas-dobjectes-a-funcions","title":"Pas d'objectes a funcions","text":"<p>Quan passem un tipus primitiu a una funci\u00f3, es passa per valor. Per\u00f2 quan vam passar un objecte a una funci\u00f3, la situaci\u00f3 canvia dr\u00e0sticament, perqu\u00e8 els objectes es passen per refer\u00e8ncia. Java fa aquesta cosa interessant que \u00e9s una classe d'h\u00edbrid entre passar per valor i passar per refer\u00e8ncia.</p> <p>A l'crear una variable d'un tipus de classe (un objecte), nom\u00e9s varem crear una refer\u00e8ncia a un objecte. Per tant, quan passem aquesta refer\u00e8ncia a un m\u00e8tode, el par\u00e0metre que el rep es referir\u00e0 a el mateix objecte que el referit per l'argument.</p> <p>Aix\u00f2 vol dir efectivament que els objectes actuen com si es passessin als m\u00e8todes mitjan\u00e7ant l'\u00fas del pas per refer\u00e8ncia.</p> <p>IMPORTANT: Els canvis en l'objecte dins el m\u00e8tode es reflecteixen en l'objecte utilitzat com a argument.</p> <p>Per\u00f2 vejam un exemple per tal que quede m\u00e9s clar:</p> <pre><code>// Programa Java per demostrar el pas d'objectes a funcions\n\n// Classe Demo\npublic class Demo {\npublic int a;\npublic int b;\n\n// Constructor de la classe\nDemo (int i, int j) {\na = i;\nb = j;\n}\n\n// Torna true si els valors s\u00f3n els mateixos\nboolean equalTo(Demo obj) {\nreturn (obj.a == this.a &amp;&amp; obj.b == this.b);\n}\n}\n\n// Classe Test: que usarem per provar la classe Demo\npublic class Test {\n\npublic static void main(String args[]) {\nDemo ob1 = new Demo(100, 22);       // Creem un nou objecte ob1 de la classe Demo amb valors 100 i 22\nDemo ob2 = new Demo(100, 22);       // Creem un nou objecte ob2 de la classe Demo amb valors 100 i 22\nDemo ob3 = new Demo(-1, -1);        // Creem un nou objecte ob3 de la classe Demo amb valors -1 i -1\n\n// Comparem els objectes entre ells\nSystem.out.println(\"ob1 == ob2: \" + ob1.equalTo(ob2));\nSystem.out.println(\"ob1 == ob3: \" + ob1.equalTo(ob3));\n}\n}\n</code></pre> <p>Eixida</p> <pre><code>obj1 == obj2: true\nobj1 == obj3: false\n</code></pre> <p>Explicaci\u00f3 en imatges:</p> <p>1.Primer: S'instancien els tres objectes ob1, ob2 i ob3.</p> <pre><code>Demo ob1 = new Demo(100, 22);\nDemo ob2 = new Demo(100, 22);\nDemo ob3 = new Demo(-1, -1);\n</code></pre> <p></p> <p>2. Segon: En la funci\u00f3 equalTo, es declara una refer\u00e8ncia de classe Demo amb un objecte obj i s'assigna inicialment null. </p> <p></p> <p>3. Tercer: En la primera crida al m\u00e8tode equalTo (ob1.equalTo(ob2)), al par\u00e0metre obj del prototip del m\u00e8tode, se li passa l'argument 'ob2', \u00e9s a dir, 'obj' passa a ser una refer\u00e8ncia a 'ob2' quan la seg\u00fcent sent\u00e8ncia s'execute.</p> <pre><code>System.out.println(\"ob1 == ob2: \" + ob1.equalTo(ob2));\n</code></pre> <p></p> <p>4. Quart: Ara com podem observar, es crida al m\u00e8tode equalTo sobre 'ob1' i 'obj' fa refer\u00e8ncia a 'ob2'. Donat que els valors 'a' i 'b' s\u00f3n els mateixos per ambdues refer\u00e8ncies, aleshores si la condici\u00f3 \u00e9s veritat, tornar\u00e0 true.</p> <pre><code>if(obj.a == a &amp;&amp; obj.b == b)\n</code></pre> <p>5. Cinqu\u00e9: De nou 'obj' es reassignar\u00e0 a 'ob3' quan s'executa la seg\u00fcent sent\u00e8ncia com s'ha fet al pas tercer.</p> <pre><code>System.out.println(\"ob1 == ob3: \" + ob1.equalTo(ob3));\n</code></pre> <p></p> <p>6. Sis\u00e9: Ara, com podem observar, el m\u00e8tode equalTo es crida en 'ob1', i 'obj' fa refer\u00e8ncia a 'ob3'. Com que els valors 'a' i 'b' no s\u00f3n els mateixos per a les dues refer\u00e8ncies, aleshores torna false.</p> Activitat 415. Copia el codi <p>Copia i executa el codi anterior en Eclipse IDE</p>"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#recursivitat","title":"Recursivitat","text":"<p>Definici\u00f3</p> <p>En general, la recursivitat \u00e9s el proc\u00e9s de definir alguna cosa en termes de si mateix i \u00e9s una cosa semblant a una definici\u00f3 circular. El component clau d'un m\u00e8tode recursiu \u00e9s una declaraci\u00f3 que executa una crida a si mateix. La recursivitat \u00e9s un poder\u00f3s mecanisme de control.</p> <p>L'exemple cl\u00e0ssic de recursivitat \u00e9s el c\u00e0lcul del factorial d'un nombre. El factorial d'un nombre N \u00e9s el producte de tots els nombres enters que es troben entre 1 i N. Per exemple, el factorial de 3 \u00e9s 1 \u00d7 2 \u00d7 3, \u00e9s a dir, \u00e9s de 6.</p> <p>El seg\u00fcent programa mostra una forma recursiva de calcular el factorial d'un nombre. Per a prop\u00f2sits de comparaci\u00f3, tamb\u00e9 s'inclou un equivalent no recursiu (iteratiu).</p> <pre><code>// Un simple programa de recursivitat\nclass Factorial\n{\n// Aquest m\u00e8tode \u00e9s recursiu\nint facR (int n){\nint resultat;\nif (n==1) return 1;\nresultat=facR(n-1)*n;\nreturn resultat;\n}\n// El seu equivalent iteratiu\nint facI (int n){\nint t, resultat;\nresultat=1;\nfor (t=1; t&lt;=n; t++) resultat *=t;\nreturn resultat;\n}\n}\nclass Recursivitat{\npublic static void main(String[] args) {\nFactorial f= new Factorial();\nSystem.out.println(\"Factorial utlitzant un m\u00e8tode recursiu:\");\nSystem.out.println(\"El factorial de 3 \u00e9s: \"+f.facR(3));\nSystem.out.println(\"El factorial de 6 \u00e9s: \"+f.facR(6));\nSystem.out.println();\nSystem.out.println(\"Factorial utilitzant un m\u00e8tode iteratiu:\");\nSystem.out.println(\"El factorial de 3 \u00e9s: \"+f.facI(3));\nSystem.out.println(\"El factorial de 6 \u00e9s: \"+f.facI(6));\nSystem.out.println();\n}\n}\n</code></pre> <p>Eixida</p> <pre><code>Factorial utilitzant un m\u00e8tode recursiu:\nEl factorial de 3 \u00e9s: 6\nEl factorial de 6 \u00e9s: 720\n\nFactorial utilitzant un m\u00e8tode iteratiu:\nEl factorial de 3 \u00e9s: 6\nEl factorial de 6 \u00e9s: 720\n</code></pre> <p>Stack Overflow</p> <p>Les versions recursives de moltes rutines poden executar-se una mica m\u00e9s lentament que els seus equivalents iteratius causa de la sobrec\u00e0rrega addicional de les trucades a m\u00e8todes addicionals. Massa crides recursives a un m\u00e8tode podrien causar un desbordament de la pila.</p> <p>Com l'emmagatzematge per als par\u00e0metres i les variables locals est\u00e0 a la pila i cada trucada nova crea una nova c\u00f2pia d'aquestes variables, \u00e9s possible que la pila s'acabe esgotant. Si aix\u00f2 passa, el sistema de temps d'execuci\u00f3 (run-time) de Java causar\u00e0 una excepci\u00f3. No obstant aix\u00f2, probablement no haur\u00e0s de preocupar-te per aix\u00f2 a menys que una rutina recursiva es torne loca.</p> <p>El principal avantatge de la recursivitat \u00e9s que alguns tipus d'algoritmes es poden implementar de forma m\u00e9s clara i m\u00e9s recursiva del que poden ser iterativament. Per exemple, l'algorisme de classificaci\u00f3 Quicksort \u00e9s bastant dif\u00edcil d'implementar de manera iterativa. A m\u00e9s, alguns problemes, especialment els relacionats amb la IA, semblen prestar-se a solucions recursives.</p> <pre><code>int fact(int n)\n{\n// Condici\u00f3 de base equivocada (provoca Stack Overflow)\nif (n == 100) return 1;\nelse\nreturn n*fact(n-1);\n}\n</code></pre> <p>En l'exemple anterior: Si es diu a fact (10), cridar\u00e0 a fact(9), fact(8), fact(7), etc., per\u00f2 el nombre mai arribar\u00e0 a 100. Per tant, no s'assoleix la condici\u00f3 base. Si la mem\u00f2ria s'esgota amb aquests m\u00e8todes en la pila, provocar\u00e0 un error de desbordament de pila.</p>"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#la-api-de-java","title":"La API de Java","text":"<p>L'API Java \u00e9s una interf\u00edcie de programaci\u00f3 d'aplicacions (API, per les seves sigles de l'angl\u00e8s: Application Programming Interface) prove\u00efda pels creadors de el llenguatge de programaci\u00f3 Java, que d\u00f3na als programadors els mitjans per desenvolupar aplicacions Java.</p> <p>Com el llenguatge Java \u00e9s un llenguatge orientat a objectes, l'API de Java proveeix d'un conjunt de classes utilit\u00e0ries per a efectuar tota mena de tasques necess\u00e0ries dins d'un programa.</p> <p>L'API Java est\u00e0 organitzada en paquets l\u00f2gics, on cada paquet cont\u00e9 un conjunt de classes relacionades sem\u00e0nticament.</p> <p></p>"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/","title":"Tema 5. Tipus Compostos de Dades","text":""},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#introduccio","title":"Introducci\u00f3","text":"<p>Fins ara hav\u00edem treballat amb tipus de dades simples: int, char, double, float, bool...  per\u00f2 que passa si necessitarem guardar un conjunt de dades o informaci\u00f3 relativa a una persona? Nom, cognoms, DNI, adre\u00e7a postal, data de naixement etc? Amb els tipus de dades simples ens seria impossible representar aquesta informaci\u00f3. Es per aix\u00f2 que s\u2019utilitzen els tipus de dades compostos que ens permetran agrupar de diverses maneres aquesta informaci\u00f3.</p> <p>Ens podem trobar diversos tipus de dades compostos i en aquest tema veurem: </p> <ul> <li>Cadenes de caracters: conjunt d'elements de tipus b\u00e0sic caracter.</li> <li>Arrays: tamb\u00e9 coneguts com vectors o arreglos, contenen elements d'un mateix tipus base o objectes de la mateixa classe.</li> <li>Estructures: conjunt d'elements heterogenis, no tenen per qu\u00e8 ser del mateix tipus base.</li> </ul>"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#arrays","title":"Arrays","text":"<p>Comencem per veure l'estructura m\u00e9s simple de totes, l'array. Un array \u00e9s un tipus de dades compost que permet emmagatzemar un nombre x d\u2019elements del mateix tipus. Amb una \u00fanica declaraci\u00f3 podem tenir acc\u00e9s a un conjunt de valors agrupats. Aquestes agrupacions o arrays poden b\u00e9 ser de tipus simples o tamb\u00e9 de tipus compostos.</p> <p>Per tal d\u2019accedir a cadascun dels elements del array s\u2019utilitza un \u00edndex o posici\u00f3. La primera posici\u00f3 de tot array \u00e9s la 0 mentre que la segona seria la que t\u00e9 \u00edndex 1. A\u00e7\u00f2 pot marejar un poc al principi.</p> <ul> <li>Array d\u2019enters: {8,2,14,55,3,7}</li> <li>Array de car\u00e0cters: {\u2018n\u2019,\u2019a\u2019,\u2019t\u2019,\u2019o\u2019}</li> <li>Array de cadenes: {\"hola\", \"ciao\", \"hi\", \"allo\"}</li> </ul> <p>\u00c9s molt important distingir entre valor i posici\u00f3. Mentre que el valor \u00e9s el contingut de l\u2019array en una posici\u00f3 determinada la posici\u00f3 \u00e9s l\u2019\u00edndex que ens permet recorres l\u2019array i tot el seu contingut.</p> <p> </p> <p>A l\u2019exemple anterior tenim un array de 8 enters, la part superior de color blau ens indica les posicions que van de la 0 a la 7, 8 posicions ens total. Mentre que a la fila inferior trobarem el valor que cont\u00e9 cadascuna de les posicions. Per exemple en la posici\u00f3 5 (la sisena) de l\u2019array tindr\u00edem emmagatzemat un valor de 8.</p> <p>Un altre concepte a tenir en compte \u00e9s la dimensi\u00f3 o grand\u00e0ria de l\u2019array que ens determina el total d\u2019elements que es poden guardar en aquest. En el nostre cas la mida seria de 8.</p>"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#declaracio-i-creacio-dun-array-en-java","title":"Declaraci\u00f3 i creaci\u00f3 d'un array en Java","text":"<p>Un array en Java \u00e9s una estructura de dades que ens permet emmagatzemar un conjunt de dades del mateix tipus. El grand\u00e0ria de l\u2019array es determina en la seua declaraci\u00f3 i no es permet la seua modificaci\u00f3 posterior</p> <pre><code>tipusBase nomArray [];\nnomArray = new tipusBase[grand\u00e0ria];\n</code></pre> <p>Alguns exemples:</p> <pre><code>int mes [];             // Declarem un array mes d'enters (sense espai)\nmes = new int [30];    // Creem espai per a 30 elements a l'array mes\nchar grups [];          // Declarem un array de caracters (sense espai assignat)\ngrups = new char [5];  // Creem espai per a 5 elements\n</code></pre> <p>Aquesta forma de declarar i inicialitzar arrays es pot fer en una sola l\u00ednia de la seg\u00fcent forma:</p> <pre><code>int agendaMensual = new int [30];  // Declarem un array d'enters i reservem 30 posicions de mem\u00f2ria\n</code></pre>"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#inicialitzacio-dun-array","title":"Inicialitzaci\u00f3 d'un array","text":"<p>Per tal d\u2019accedir a les dades que cont\u00e9 un array necessitem l\u2019identificador d\u2019aquest aix\u00ed com tamb\u00e9 la posici\u00f3 concreta a la qual volem accedir. Per exemple, imaginem un array d\u2019enters que es diu n\u00fameros.</p> <pre><code>int n\u00fameros = new int [5]; // Declarem un array d'enters de cinc posicions\nn\u00fameros. [] = {2,4,6,8,10}; // Inicialitzaci\u00f3 dels cinc valors\n</code></pre> <p>D\u2019aquesta forma haur\u00edem creat un array de 5 enters que contindria els nombres parells fins al 10.</p> <p>Difer\u00e8ncia entre declaraci\u00f3 creaci\u00f3 i inicialitzaci\u00f3</p> <p>\u00c9s molt important que conegau b\u00e9 aquestos conceptes:</p> <ul> <li>Declaraci\u00f3: assignaci\u00f3 de nom i tipus.</li> <li>Creaci\u00f3: reserva d'espai necessari.</li> <li>Inicialitzaci\u00f3: assignaci\u00f3 de valors.</li> </ul> <p>Fins ara tots aquestos conceptes anaven lligats quan nom\u00e9s utilitzavem tipus de dades b\u00e0sics, per exemple, quan creavem en un programa nostre una variable de tipus enter, en la mateixa l\u00ednia anava la declaraci\u00f3 (donem nom a la variable), la creaci\u00f3 (automaticament es reserva l'espai necessari per al tipus de dades que hem creat) i la inicialitzaci\u00f3 (ja que per defecte i segons el tipus b\u00e0sic s'assignava un valor inicial). Per\u00f2 ara amb els arrays la cosa \u00e9s un poc m\u00e9s complexa. Vegem algun exemple.</p> <pre><code>int a; int [] array; array = new int [10]; </code></pre> <p>Repassem el codi anterior. A la l\u00ednia 1 de codi i nom\u00e9s amb aquesta l\u00ednia hem aconseguit:</p> <ol> <li>Declaraci\u00f3: es declara una variablem amb identificador 'a' i de tipus enter</li> <li>Creaci\u00f3: automaticament el compilador li reserva l'espai necessari per a representar un enter: 4 bytes.</li> <li>Inicialitzaci\u00f3: per defecte se li dona valor 0.</li> </ol> <p>Ara si mirem les l\u00ednies seg\u00fcents podrem observar que:</p> <ol> <li>A la l\u00ednia 2 del codi es produeix la declaraci\u00f3 de l'array. Hem creat l'array i li hem assignat idendtificador per\u00f2, quans elements pot emmagatzemar?</li> <li>A la l\u00ednia 3 del codi \u00e9s on es crea l'array, \u00e9s a dir, es reserva espai en m\u00e8moria. Al nostre cas 10 enters, \u00e9s a dir, 40 bytes.</li> <li>En aquest cas com que el tipus base de l'array \u00e9s enter, la inicialitzaci\u00f3 d'aquest vindria implicita en la reserva de mem\u00f2ria assignant-se valor 0 a tots els elements.</li> </ol> <p>Per\u00f2 com poden inicialitzar cadascun dels elements del nostre array de forma manual?</p>"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#acces-als-elements-dun-array","title":"Acc\u00e9s als elements d'un array","text":"<p>Una vegada ja tenim la declaraci\u00f3 de l\u2019array i la seua inicialitzaci\u00f3, si volem b\u00e9 accedir al seu contingut o modificar-ho, necessitar\u00edem l\u2019identificador de l\u2019array i l\u2019\u00edndex al qual volem accedir. \u00c9s molt important tenir en compte que el primer element d\u2019un array en Java est\u00e0 a la posici\u00f3 (\u00edndex) 0 i no a la posici\u00f3 1 com ens indicaria la l\u00f2gica.</p> <pre><code>int primerNumero = n\u00fameros. [0]; // primerNumero valdria 2\nn\u00fameros. [0] = 12;  // Canviem el  primer numero de l\u2019array\n</code></pre> Activitat 501. Declara, crea i inicialitza <p>Escriu un programa en Java utilitzant Processing IDE que permeta emmagatzemar en un array 30 enters. Aquest array s'inicialitzar\u00e0 element a element cridant a una funci\u00f3 que es dir\u00e0 'generaNumAleatori' i que tornara un enter random entre 0 i 100. La funci\u00f3 tindr\u00e0 el seg\u00fcent prototip:</p> <ul> <li>int generaNumAleatori();</li> </ul>"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#arrays-de-caracters","title":"Arrays de caracters","text":"<p>Un array que cont\u00e9 car\u00e0cters en lloc de n\u00fameros funciona d\u2019una forma molt semblant al que s\u2019ha explicat en els apartats anteriors. Es pot veure de forma senzilla a l\u2019exemple que vos mostrem a continuaci\u00f3.</p> <pre><code>// Declaraci\u00f3 de l\u2019array vocals que contindr\u00e0 un total de 5 posicions en mem\u00f2ria\nchar vocals = new char [5];\n\n// Inicialitzaci\u00f3 de l'array amb les vocals de l'alfabet.\nvocals [] = {\u2018a\u2019,\u2019e\u2019,\u2019i\u2019,\u2019o\u2019,\u2019u\u2019} // Acc\u00e9s a l'element primer (0) de l'array per modificar el seu valor\nvocals [0] = \u2018z\u2019;\n</code></pre> Activitat 502. Array de caracters <p>Millora el codi anterior. Afegeix un array que puga emmagatzemar 10 caracters i inicialitza-lo amb un altre m\u00e8tode que es dir\u00e0: 'generaCharAleatori()'. El prototip del m\u00e8tode hauria de ser:</p> <ul> <li>char generaCharAleatori();</li> </ul>"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#arrays-com-a-parametres","title":"Arrays com a par\u00e0metres","text":"<p>Com qualsevol altre tipus de dades, un array tamb\u00e9 es pot passar com a par\u00e0metre a un m\u00e8tode. Els arrays sempre es passen per refer\u00e8ncia, \u00e9s a dir, quan passem un array per par\u00e0metre a un m\u00e8tode, el que en realitat estem passant \u00e9s un adre\u00e7a de mem\u00f2ria que \u00e9s la que ens indicaria on est\u00e0 l\u2019inici del contingut d\u2019aquest. Passar per refer\u00e8ncia qualsevol par\u00e0metre significa que qualsevol modificaci\u00f3 que es faja dins del m\u00e8tode afectar\u00e0 tamb\u00e9 a l\u2019array fora d\u2019aquest.</p> <p>No passa el mateix si passem un element concret de l\u2019array, en aquest cas a l\u2019igual que amb els altres par\u00e0metres, aquestos es passen per valor, per tant les  modificacions o canvis que es produeixquen dins del m\u00e8tode no afectaran fora d\u2019aquest.</p> Activitat 503. Mostra array amigablement <p>Seguint amb el codi anterior, fes dos m\u00e8todes per la nostra aplicaci\u00f3 que mostre, de forma amigable, l\u2019array de n\u00fameros i l\u2019array de car\u00e0cters. Els m\u00e8todes es podrien dir mostraEnters i mostraCaracters. Utilitza totes les funcions que conegues de Processing IDE per tal que mostre els arrays de la forma m\u00e9s est\u00e8tica possible.</p> <pre><code>void mostraEnters (int [] array) {\n// Codi per mostrar el vector d'enters\n}\n\nvoid mostraCaracters (char [] array) {\n// Codi per mostrar el vector de caracters\n}\n</code></pre>"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#bucle-for-en-java","title":"Bucle for en Java","text":"<p>A les activitats anteriors t'haur\u00e0s trobat amb el dilema de com rec\u00f2rrer tant l'array d'enters com el de caracters per tal d'inicialitzar-lo. Si vares entendre b\u00e9 el terorema d'estructura i les estructures iteratives, segurament haur\u00e0s utilitzat un bucle while, un do while o un for. Per\u00f2 aquestos bucles a l'hora de rec\u00f2rrer arrays tenen un inconvenient: el tamany de l'array. El programador ha de controlar quan s'arriba al final de l'array per tal que l'aplicaci\u00f3 no done una errada inesperada i aix\u00f3 de vegades no \u00e9s senzill. Mira el seg\u00fcent exemple:</p> <pre><code>final int TAM = 30;\nint [] arrayEnters;\narrayEnters = new int [TAM];\n\n// Recorrem l'array amb un for\n\nfor (int i=0; i &lt; TAM; i++) arrayEnters[i] = i*10;\n\n// Recorrem l'array amb un while\nint i = 0;\nwhile (i &lt; TAM)\narrayEnters[i] = i*10;\n\n// Recorrem l'array amb un do while\nint i = 0;\ndo {\narrayEnters[i] = i*10;\ni++;\n}\nwhile(i &lt; TAM);\n</code></pre> Activitat 504. Fes una tra\u00e7a <p>Fes una tra\u00e7a al codi anterior i digues-me que passa. Falla o podria fallar algun bucle? Per qu\u00e8? Es podria arreglar?</p> <p>La millor forma de rec\u00f3rrer un array sense haver de controlar quan s\u2019arriba al final \u00e9s la sent\u00e8ncia for usada d\u2019una manera alternativa. Si per exemple tenim un array d\u2019enters que s\u2019anomena \u00abvector\u00bb i volem llistar tots els seus elements, podr\u00edem fer el seg\u00fcent:</p> <pre><code>for (int i: vector){\n// Accions a realitzar\n}   </code></pre> Activitat 505. Recorre i mostra l'array <p>Seguint amb les activitats 502 i 503, modifica els m\u00e8todes mostraEnters i mostraCaracters per tal que utilitzen aquest \u00faltim bucle que hem vist per recorrer arrays en Java. Podriem fer el mateix als m\u00e8todes d'inicialitzaci\u00f3 dels arrays? Per qu\u00e8?</p>"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#algorismes-de-recerca","title":"Algorismes de recerca","text":"<p>Implicitament amb l'aparici\u00f3 de les estructures de dades complexes en programaci\u00f3 que, en certa manera, es podrien entendre com a conjunts, apareix la necessitat de poder fer receques elements dintre d'aquestos conjunts. Existeixen dos algorismes de recerca que veurem en aquest apartat: la recerca seq\u00fcencial i la recerca binaria. A l\u2019element que estem buscant li direm clau.</p> <p>Per\u00f2 abans d'anar per feina, canviarem temporalment l'entorn de programaci\u00f3 de Processing IDE a Eclipse IDE i veurem un poc m\u00e9s que s\u00f3n les classes i els objectes i com funcionen en Java abans de veure-ho amb m\u00e9s detall al tema seg\u00fcent. Realitza les activitats seg\u00fcents abans de continuar.</p> Activitat 506. Crea la classe TAD <p>Aquesta primera activitat en Eclipse IDE \u00e9s senzilla, nom\u00e9s haur\u00e0s de crear un nou projecte en Java i copiar el codi seg\u00fcent per\u00f2 primer, veiem amb m\u00e9s detall qu\u00e9 \u00e9s el que es preten aconseguir.  </p> <p>Volem crear una classe amb nom TAD que tinga les seg\u00fcents caracter\u00edstiques:</p> <ul> <li>Ha de ser una classe p\u00fablica</li> <li>Ha de tindre m\u00ednim una constant que ens indicar\u00e0 el total d\u2019elements que tindran els arrays, tant el d\u2019enters com el de car\u00e0cters.</li> <li>Com membres de la classe ha de tindre almenys un array de car\u00e0cters i un d\u2019enters.</li> <li>Tamb\u00e9 ha de tenir un m\u00e8tode main static on s\u2019iniciar\u00e0 el programa.</li> </ul> <pre><code>/**\n* Classe TAD\n* Classe Java que utilitzarem per veure la part dels tipus compostos de dades, recerca i ordenaci\u00f3.\n* @author: Vicent Sanchis\n*/\npublic class TAD {\n// Membres de la classe\nprivate final int TAM = 10;\nprivate int  [] arrayEnters;\nprivate char [] arrayCaracters;\n\n// Constructor de la classe\n\n\npublic static void main (String [] args) {\n\n}\n\npublic void mostraEnters() {\n\n}\n\npublic void mostraCaracters() {\n\n}\n\nprivate int generaNumAleatori() {\nreturn 0;\n}\n\nprivate char generaCharAleatori() {\nreturn 0;\n}\n}\n</code></pre> <p>En aquesta primera activitat haureu de copiar aquest codi en un nou projecte java d'Eclipse IDE i si et fixes, aquesta classe TAD, disposa dels m\u00e8todes: mostraEnters, mostraCaracters, generaNumAleatori i generaCharAleatori que ja havieu implementat a les activitats anteriors. Translada el codi de Processing IDE als m\u00e8todes de la classe TAD en Eclipse IDE per tal que tot compile correctament.</p> Activitat 507. Inicialitzaci\u00f3 d'arrays <p>En aquest punt aprofitarem per crear un constructor a la nostra classe TAD. Un constructor de classe \u00e9s la funci\u00f3 que s\u2019executa en el moment que s\u2019instancia un objecte i \u00e9s en aquest punt on s\u2019haurien d'inicialitzar aquells elements de la classe que ho necessiten. En el nostre cas els arrays. </p> <p>C\u00f2pia el codi seg\u00fcent i posa'l just baix el comentari que diu: \"Constructor de la classe\"</p> <pre><code>public TAD () {\narrayEnters    = new int  [TAM];\narrayCaracters = new char [TAM];\n}\n</code></pre> <p>Afegeix i implementa els m\u00e8todes emplenaArrayNumeros() i emplenaArrayCaracters() per tal que es criden des del constructor de la classe i utilitzen els m\u00e8todes generaNumAleatori() i generaCharAleatori().</p> <p>Finalment i per tal de comprovar que anem b\u00e9 de moment, afegeix la seg\u00fcent l\u00ednia al m\u00e8tode est\u00e0tic main de la nostra classe TAD.</p> <pre><code>TAD test = new TAD();\n</code></pre> <p>Depura el codi anterior i comprova que tot est\u00e0 funcionant com s'espera que funcione.</p> Activitat 508. Ampliaci\u00f3 de funcions <p>En la seg\u00fcent activitat afegirem una funci\u00f3 a la nostra classe en la que ens mostre un men\u00fa de les accions que podem realitzar. Per tal de realitzar aquest men\u00fa afegirem un array d\u2019strings com a nou membre de la classe que inicialitzarem amb les seg\u00fcents opcions: </p> <ol> <li>Eixir</li> <li>Mostrar array enters</li> <li>Mostrar array caracters</li> <li>Reinicialitzar vectors</li> <li>Recerca seq\u00fcencial</li> <li>Recerca bin\u00e0ria</li> <li>Ordenar amb bombolla</li> <li>Ordenar amb Quicksort</li> <li>Ordenar amb Shell</li> </ol> Activitat 509. Mostrar men\u00fa <p>Fes una funci\u00f3 que mostre per pantalla el men\u00fa de forma amigable.</p>"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#sequencial","title":"Seq\u00fcencial","text":"<p>Tamb\u00e9 anomenada recerca lineal, es recorren tots els elements de l\u2019array des del principi fins que es troba la clau (element que estem buscant) o fins que s\u2019arriba a l\u2019\u00faltim element de l\u2019array.</p> <pre><code>int sequencial (int [] array, int clau) {\nfor (int i = 0; i &lt; array.length; i ++ ) if (array[i] == clau ) return i;\nreturn -1;\n}\n</code></pre>"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#binaria","title":"Bin\u00e0ria","text":"<p>En aquest algoritme existeix la precondici\u00f3 que l\u2019array o vector sobre el qual vaja a fer-se la recerca, ha d\u2019estar ordenat. Aquest m\u00e8tode \u00e9s m\u00e9s \u00f2ptim. El funcionament d\u2019aquest algorisme \u00e9s el seg\u00fcent: en una primera iteraci\u00f3 es compara la clau (element que estem buscant) amb el valor al centre, que s\u2019anomena pivot, de l\u2019array. Poden passar tres coses:  - Que hajam trobat el que busquem, per tant s\u2019acaba la recerca - Que el pivot siga major que la clau. En aquest cas continuar\u00edem buscant a la meitat esquerra del vector desestimant la meitat dreta (pivot incl\u00f2s) - Que el pivot siga menor que la clau. Amb la qual cosa haur\u00edem de buscar a la part esquerra del vector.</p> <pre><code>int recercaBinaria (int array[], int clau) {\nint posCentre, posInici, posFinal, valorCentral;\nposInici = 0;\nposFinal = array.length \u2013 1;\nwhile (posInici &lt;= posFinal ) {\nposCentre = (posInici+posFinal)/2;\nvalorCentral=array[posCentre];\nif (clau == valorCentral) {\nreturn posCentre;\n}\nelse if (clau &lt; valorCentral) {\nposFinal = posCentro \u2013 1;\n}\nelse {\nposInici = posCentro + 1;\n}\n}\n}\n</code></pre> Activitat 510. Afegeix m\u00e8todes seq\u00fcencial i binari <p>Afegeix el m\u00e8tode de recerca seq\u00fcencial i el de recerca binaria a la classe TAD. Tamb\u00e9 has d\u2019implementar el codi necessari per tal que quan l\u2019usuari seleccione una de les dues opcions de la nostra aplicaci\u00f3, demane el n\u00famero a buscar i mostre el resultat per pantalla. En cas que es seleccione la recerca bin\u00e0ria, haur\u00edem de comprovar si el vector est\u00e0 ordenat</p> Activitat 511. Compara efici\u00e8ncies <p>Comparem l\u2019efici\u00e8ncia dels dos algorismes de recerca vistos. Fes una funci\u00f3 a la nostra classe TAD en la que es compten el total de vegades que s\u2019accedeix  l\u2019array de n\u00fameros per arribar a trobar la clau. Haur\u00e0s de posar una opci\u00f3 m\u00e9s al men\u00fa, per exemple: \u00abComparar efici\u00e8ncia dels algoritmes\u00bb. Aquesta nova opci\u00f3 haur\u00e0 d\u2019executar varies vegades els dos algorismes de recerca amb vectors de n\u00fameros diferents.</p>"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#algorismes-dordenacio","title":"Algorismes d'ordenaci\u00f3","text":"<p>Els algorismes d\u2019ordenaci\u00f3 permeten ordenar un array en funci\u00f3 d\u2019un criteri establert al propi algorisme. Hi han diferents tipus d\u2019algorismes d\u2019ordenaci\u00f3: selecci\u00f3, inserci\u00f3, bombolla, Shell i Quicksort.</p>"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#seleccio","title":"Selecci\u00f3","text":"<p>El procediment d\u2019ordenaci\u00f3 per selecci\u00f3 \u00e9s el seg\u00fcent: 1. Busquem l\u2019element m\u00e9s menut de l\u2019array i el col\u00b7loquem a la posici\u00f3 0 intercanviant els dos elements  2. A partir de la posici\u00f3 1 busquem l\u2019element m\u00e9s menut seg\u00fcent i fem el mateix que al pas anterior per\u00f2 aquesta vegada a la posici\u00f3 1 de l\u2019array 3. Repetim el pas 2 fins arribar a l\u2019\u00faltima posici\u00f3 de l\u2019array.</p> <p> </p> <pre><code>for(int i = 0; i &lt; TAM-1 ; i++){\nint posMinim = i;\nfor(int j = i + 1 ; j &lt; TAM ; j++){\nif(array[j] &lt; array[posMinim]){\nposMinim = j;\n}\n}\nint aux = array[i];\narray[i] = array[posMinim];\narray[posMinim] = aux;\n}\n</code></pre> Activitat 512. Algorisme d'ordenaci\u00f3 per selecci\u00f3 <p>Implementa l\u2019algorisme d\u2019ordenaci\u00f3 per selecci\u00f3 a la classe TAD i vicula-la a l\u2019opci\u00f3 del men\u00fa corresponent. </p>"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#insercio","title":"Inserci\u00f3","text":"<p>Aquest algorisme consisteix en generar un nou array a partir del que ja es t\u00e9, tal que cada nou element inserit es posa a la seua posici\u00f3 correcta. Imaginem que tenim el seg\u00fcent array d\u2019enters per ordenar: </p> <p>{12, 5, 3, 13, 2, 9, 7}</p> <p>Generem un nou array amb el primer element de l\u2019array a ordenar</p> <p>{12}</p> <p>El seg\u00fcent valor de l\u2019array original \u00e9s 5. \u00c9s major o menor que el que ja est\u00e0 inserit? Com que la resposta \u00e9s menor, aquest s\u2019haur\u00e0 d\u2019inserir abans quedant de la seg\u00fcent forma:</p> <p>{5, 12}</p> <p>El nou array es genera ja ordenat. El seg\u00fcent valor de l\u2019array desordenat \u00e9s 3. On l\u2019haurem de col\u00b7locar? Just abans del 5 quedant aix\u00ed:</p> <p>{3, 5, 12}</p> <p>Repetim la mateixa operaci\u00f3 per cada element de l\u2019array original:</p> <p>{3, 5, 12, 13} {2, 3, 5, 12, 13} {2, 3, 5, 9, 12, 13} {2, 3, 5, 7, 9, 12, 13}</p> <pre><code>void insercio ( int [] array ) {\nint i, j, aux;\nfor (i=1; i &lt; array.legnth; i++ ) {\nj = i;\naux = array [i];\nwhile ( j &gt; 0 &amp;&amp; aux &lt; array[j-1]) {\narray [j] = array [j-1];\nj--;\n}\narray[j] = aux;\n}\n}\n</code></pre> <p> </p> Activitat 513. Algorisme ordenaci\u00f3 per inserci\u00f3 <p>Implementa l\u2019algorisme d\u2019ordenaci\u00f3 per inserci\u00f3 a la classe TAD i vincula-la a l\u2019opci\u00f3 del men\u00fa corresponent. </p>"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#bombolla","title":"Bombolla","text":"<p>L\u2019algorisme d\u2019ordenaci\u00f3 per bombolla \u00e9s el m\u00e9s conegut i tamb\u00e9 el menys eficient, ja que a cada passada per ordenar un element compara cadascun d\u2019ells amb el seu adjacent de forma que si les seues posicions s\u00f3n incorrectes, s\u2019intercanvien. Al finalitzar cada passada l\u2019element m\u00e9s gran es va posant al final de la llista</p> <p>Donat el seg\u00fcent array: </p> <p>{12, 5, 3, 13, 2, 9, 7}</p> <p>Pas 1. Comparem les posicions 0 i 1, \u00e9s a dir, 12 i 5 i com que estan desordenats (el primer \u00e9s major que el segon), s\u2019intercanvien.</p> <p>{5, 12, 3, 13, 2, 9, 7}</p> <p>Pas 2. A continuaci\u00f3 comparem les posicions 1 i 2 de l\u2019array, que s\u00f3n 12 i 3. Com que tamb\u00e9 estan desordenades, les intercanviem</p> <p>{5, 3, 12, 13, 2, 9, 7}</p> <p>Pas 3. Ara anem a comparar les posicions 2 i 3 que contenen els valors 12 i 13 respectivament. Com que estan ben ordenades no es realitza cap acci\u00f3:</p> <p>Pas 4. Posicions 3 i 4 que s\u00f3n 13 i 2. Les intercanviem.</p> <p>{5, 3, 12, 2, 13, 9, 7}</p> <p>Pas 5. Posicions 4 i 5 que tamb\u00e9 estan desordenades per tant executem l\u2019intercanviem</p> <p>{5, 3, 12, 2, 9, 13, 7}</p> <p>Pas 6. Comparem posicions 5 i 6 que tenen els valors 13 i 7 i s\u2019han d\u2019intercanviar</p> <p>{5, 3, 13, 2, 9, 7, 13}</p> <p>Una vegada finalitzada la primera passada hem aconseguit que l\u2019element major de l\u2019array estiga posicionat a l\u2019\u00faltima posici\u00f3. A la seg\u00fcent passada recorrerem l\u2019array fins la posici\u00f3 anterior a on es troba ara el n\u00famero 13, \u00e9s a dir la posici\u00f3 5 i aquest procediment es repeteix fins arribar a la posici\u00f3 0</p> <p>Finalment el codi quedaria aix\u00ed:</p> <pre><code>void bombolla ( int [] arrayNumeros) {\nfor (int i = 0; i &lt; arrayNumeros.length-1; i++) {\nfor(int j = i + 1; j &lt; arrayNumeros.length; j++) {\nif (arrayNumeros[i] &gt; arrayNumeros[j]) {\nint canvi = arrayNumeros[i];\narrayNumeros[i] = arrayNumeros[j];\narrayNumeros[j] = canvi;\n}\n}\n}\n}\n</code></pre> <p> </p> Activitat 515. Ordenaci\u00f3 per bombolla <p>Implementa l\u2019algorisme d\u2019ordenaci\u00f3 per bombolla a la classe TAD i vincula-la a l\u2019opci\u00f3 del men\u00fa corresponent. </p>"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#shell","title":"Shell","text":"<p>L\u2019algorisme Shell \u00e9s una millora de l\u2019algorisme d\u2019inserci\u00f3 directa. Compara elements separats per un espai de v\u00e0ries posicions el que permet que un element faja passos m\u00e9s grans fins trobar la seua posici\u00f3 esperada. </p> <p>Els passos m\u00faltiples sobre els elements de l\u2019array es fan amb espais de posicions cada vegada m\u00e9s menuts. L\u2019\u00faltim pas de l\u2019algorisme Shell \u00e9s una simple ordenaci\u00f3 per inserci\u00f3 per\u00f2 arribats a aquest punt es pot garantir que l\u2019array esta ja quasi ordenat, el que fa que l\u2019ordenaci\u00f3 per inserci\u00f3 siga molt eficient.</p> <p>Vegem com actuaria aquest algorisme aplicat sobre l\u2019array que estem utilitzant com exemple: </p> <p>{12, 5, 3, 13, 2, 9, 7}. </p> <p>Aquest array t\u00e9 un total de 7 elements (n=7). Creem n/2 grups, separats n/2 n\u00fameros entre ells. n/2=7/2=3, \u00e9s a dir, el nostre interval per crear grups val 3 Marquem en negreta els valors de la primera subllista.</p> <p>{12, 5, 3, 13, 2, 9, 7}</p> <p>Donats els elements 12, 13 i 7 els hem d\u2019ordenar correctament</p> <p>{7, 5, 3, 12, 2, 9, 13}</p> <p>Continuem formant grups de 3 a partir del segon valor de l\u2019array</p> <p>{7, 5, 3, 12, 2, 9, 13}</p> <p>Ordenem els n\u00fameros en cas de no estar-ho, quedant l\u2019array aix\u00ed:</p> <p>{7, 2, 3, 12, 5, 9, 13}</p> <p>Passem a l\u2019element 3 de l\u2019array i apliquem el mateix procediment.</p> <p>{7, 2, 3, 12, 5, 9, 13}</p> <p>Els valors ja estan ordenats en aquest cas, per tant no hem de fer res. </p> <p>{7, 2, 3, 12, 5, 9, 13}</p> <p>No podem m\u00e9s grups ja que hem arribat al final del vector. Ara el que hem de fer \u00e9s tornar a dividir el nostre interval entre 2. El nou interval \u00e9s 3/2 = 1. </p> <pre><code>void shellSort ( int [] array) { int interval, i, j, k, temp;\ninterval = array.length / 2;\nwhile ( interval &gt; 0 ) {\nfor (i=interval; i&lt;n; i++) {\nj=i-interval;\nwhile(j&gt;=0) {\nk=j+interval;\nif(array[j] &lt;= array[k] j = -1;\nelse {\ntemp = array[j];\narray[j] = array[k];\narray[k] = temp;\nj -= interval;\n}\n}\n} interval = interval / 2;\n}   }\n</code></pre> Activitat 516. Ordenaci\u00f3 per Shell <p>Implementa l\u2019algorisme d\u2019ordenaci\u00f3 shell a la classe TAD i vincula-la a l\u2019opci\u00f3 del men\u00fa corresponent. </p>"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#quicksort","title":"Quicksort","text":"<p>Aquest \u00e9s un dels algorismes d\u2019ordenaci\u00f3 m\u00e9s r\u00e0pids i eficients. Utilitza la t\u00e8cnica \u00abdivideix i vencer\u00e0s\u00bb de tal forma que divideix l\u2019array a ordenar en parts que ordenar\u00e0 al mateix temps. B\u00e0sicament es tria l\u2019element de l\u2019array com a pivot tal que es forme dos subArrays, en un d\u2019ells s\u2019emmagatzemen els elements menors que l\u2019element que hem triat com a pivot i a l\u2019altre array es guarden els element majors que el pivot. Una vegada fet, s\u2019aplica el mateix procediment als subarrays obtinguts.</p> <p>Seguint amb el mateix array dels exemples anteriors, aplicarem l\u2019algorisme d\u2019ordenaci\u00f3 quicksort.</p> <p>{12, 5, 3, 13, 2, 9, 7}</p> <p>Triem un valor que fara el paper de pivot, per exmple el primer element de l\u2019array, el 12 i a partir d\u2019aquest creem dos arrays, un amb els n\u00fameros menors que el pivot i l\u2019altre amb els n\u00fameros majors que el pivot:</p> <p>pivot: {12}; menors: {5, 3, 2, 9, 7}; majors {13}</p> <p>El subarray de majors ja est\u00e0 ordenada ja que nom\u00e9s t\u00e9 un n\u00famero. Ara ordenem el subarray de menors: {5, 3, 2, 9, 7} per la qual cosa escollim com a pivot el primer element de l\u2019array, \u00e9s a dir, el 5.</p> <p>pivot: {5}; menors {3, 2}; majors: {9, 7}.</p> <p>Seguim dividint en subarrays, Una vegada els subarrays estan ordenats sempre sempre s\u2019ensamblaran col\u00b7locant subarrays de menors, seguides de pivot i subarrays de majors</p> <p>{2, 3, 5, 7, 9, 12, 13}</p> Activitat 517. Algorisme Quicksort <p>Implementa l\u2019algorisme d\u2019ordenaci\u00f3 quicksort a la classe TAD i vincula-la a l\u2019opci\u00f3 del men\u00fa corresponent. </p> <pre><code>void Quicksort ( int [] array, int primer, int ultim) {\nint i, j, central, pivot, tmp;\ncentral = (primer + ultim)/2;\npivot = array[central];\ni = primer;\nj = ultim;\ndo {\nwhile (array[i] &lt; pivot) i ++;\nwhile (array[j] &gt; pivot) j --;\nif (i &lt;= j) { tmp = array[i];\narray[i] = array[j];\narray[j] = tmp;\ni ++;\nj \u2013-;\n}\n}\nwhile (i&lt;=j);\nif (primer &lt; j) Quicksort (array, primer, j);\nif ( i &lt; ultim ) Quicksort (array, i, ultim);\n}\n</code></pre> Activitat 518. Mostrar tra\u00e7a algorismes ordenaci\u00f3 <p>Fes que en cada algorisme d\u2019ordenaci\u00f3 es mostre una tra\u00e7a on a cada passada de l\u2019algoritme, \u00e9s a dir, cada vegada que mou un element a l\u2019array, mostre aquest per pantalla.</p> Activitat 519. Entrega TAD <p>Entrega mitjan\u00e7ant la plataforma aules la classe TAD que inclou de les activitats 1 a la 13 amb totes les funcions tant de recerca com d\u2019ordenaci\u00f3 sobre arrays unidimensionals.</p>"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#arrays-multidimensionals","title":"Arrays multidimensionals","text":"<p>Fins ara hem estan utilitzant arrays d\u2019una sola dimensi\u00f3, coneguts tamb\u00e9 com vectors, taules o llistes. Aquests arrays es recorren amb ajuda d\u2019un sol \u00edndex (tenen una sola dimensi\u00f3). En aquest apartat estudiarem arrays de m\u00e9s d\u2019una dimensi\u00f3 per als que necessitarem m\u00e9s d\u2019un \u00edndex a l\u2019hora de ser recorreguts.  Els arrays multidimensionals m\u00e9s comuns s\u00f3n els de dues dimensions o bidimensionals, tamb\u00e9 coneguts com matrius. \u00c9s com\u00fa representar aquest tipus de dades com una taula composta per una s\u00e8rie de files i columnes:</p> 0,0 0,1 0,2 0,3 ... 0,N 1,0 1,1 1,2 1,3 ... 1,N 2,0 2,1 2,2 2,3 ... 2,N ... ... ... ... ... ... N,0 N,1 N,2 N,3 ... N,N <p>Al contrari del que passava amb els arrays d\u2019una sola dimensi\u00f3 on nom\u00e9s necessitavem un \u00edndex per accedir al valor, en els arrays de dues dimensions com el de l\u2019exemple anterior, necessitarem dos \u00edndex per accedir al valor de l\u2019array. Les matrius, com es coneixen els arrays bidimensionals es forme per files i columnes.</p>"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#declaracio-i-creacio","title":"Declaraci\u00f3 i creaci\u00f3","text":"<p>Per tal de declarar una matriu en java, \u00e9s a dir, un array de dues dimensions, ho farem de la seg\u00fcent forma:\u00c7</p> <pre><code>tipusBase matriu [][];\n</code></pre> <p>Si es fixeu, mentre quan declaravem un array d\u2019una sola dimensi\u00f3 utilitzavem nom\u00e9s un parell de claud\u00e0tors: </p> <p><pre><code>tipusBase array[];\n</code></pre> Ara que volem crear una matriu (array de dues dimensions) utilitzarem dos parells de claud\u00e0tors.</p> <p>\u00c9s f\u00e0cil deduir que si vulguerem declarar un array de tres dimensions, hauriem d\u2019utilitzar tres parells de claud\u00e0tors.</p> <p>Amb aquesta instrucci\u00f3 el que estem fent es declarar la matriu per\u00f2 no li hem dit quina grand\u00e0ria tindr\u00e0. Eixa \u00e9s la difer\u00e8ncia entre declaraci\u00f3 i creaci\u00f3. Per tal de crear, \u00e9s a dir, reservar espai per a la nostra matriu, hem de fer el seg\u00fcent:</p> <pre><code>matriu = new tipusBase[n][m];\n</code></pre> <p>On n i m s\u00f3n valors enters que ens indiquen la grand\u00e0ria de cada dimensi\u00f3.  Per exemple, per declarar i crear una matriu d\u2019enters de 5 files i 10 columnes fariem el seg\u00fcent:</p> <pre><code>int matriuEnters [][];\nmatriuEnters = new int [5][10];\n// Tamb\u00e9 ho podriem fer en una sola instrucci\u00f3\nint matriuEnters[][] = new int [5][10];\n</code></pre>"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#inicialitzacio-i-acces","title":"Inicialitzaci\u00f3 i acc\u00e9s","text":"<p>El proc\u00e9s d\u2019inicialitzaci\u00f3 d\u2019un vector, dona igual les dimensions que tinga, consisteix en donar-li valor a les cel\u00b7les que inicialment estan buides. Aquesta inicialitzaci\u00f3 es pot fer de tres formes diferents:</p> <ul> <li>De forma individual.</li> <li>En el moment de la declaraci\u00f3.</li> <li>Mitjan\u00e7ant l\u2019\u00fas d\u2019una sent\u00e8ncia de control repetitiva.</li> </ul> <p>Inicialitzaci\u00f3 i acc\u00e9s a cada element de l'array Per accedir a una dada en un array multimensional hem de coneixer els \u00edndex de posici\u00f3 d\u2019aquest. En un array de dues dimensions, per accedir a una dada s\u2019ha d\u2019indicar la fila i la columna d\u2019on es troba aquesta informaci\u00f3.</p> <p>Per exemple, imaginem que tenim la seg\u00fcent taula (array de dos dimensions)</p> 12 13 5 9 22 14 21 11 8 56 23 7 6 10 32 36 24 99 78 55 57 79 18 14 <p>Per tal d\u2019inicialitzar-la element a element hauriem d\u2019executar les seg\u00fcents sent\u00e8ncies:</p> <pre><code>for (int i = 0; i &lt; FILES; i ) {\nfor (int j=0; j&lt; COLUMNES; j++ ) {\narray [i][j] = 0;\n}\n}\n</code></pre> <p>Per tal d\u2019entendre el concepte de matriu o array bidimensional, realitzarem un exercici on treballarem amb les t\u00edpiques matrius matem\u00e0tiques, realitzant les operacions pr\u00f2pies d\u2019aquestes.</p> Activitat 520. Matrius <p>Es tracta de desenvolupar una aplicaci\u00f3 que realitze operacions utilitzant matrius de 3x3. El men\u00fa ha de mostrar el seg\u00fcent:</p> <ol> <li>Emplena la primera matriu</li> <li>Emplena la segona matriu</li> <li>Visualitza les matrius4</li> <li>Suma les matrius</li> <li>Multiplica per un escalar</li> <li>Producte de matrius</li> <li>Transposta</li> <li>Eixir</li> </ol> <p>Per a cadascuna de les operacions anteriors s\u2019ha d\u2019implementar un m\u00e8tode Mireu el seg\u00fcent exemple:</p> <p></p> Activitat 521. Alumnes i assignatures <p>Imagina que has de mantindre les notes dels alumnes de tres assignatures. A cada assignatura tens 15 alumnes, tal que s\u2019ha de mantenir la informaci\u00f3 mitjan\u00e7ant una variable que gr\u00e0ficament presenta la seg\u00fcent estructura</p> Assignatura 1 5 6 7,3 2,3 4,5 Assignatura 2 7,8 8,7 7,7 3,3 4,8 Assignatura 3 7 9 10 8,2 2,8 <p>Crea una aplicaci\u00f3 en la que pugues:</p> <ol> <li>Inserir notes de l\u2019assignatura sel\u00b7leccionada.</li> <li>Inserir totes les notes</li> <li>Calcular la nota mitjana de l\u2019assignatura sel\u00b7leccionada.</li> <li>Ordenar les assignatures de forma ascendent.</li> <li>Estad\u00edstica</li> <li>Eixir de l\u2019aplicaci\u00f3.</li> </ol> <p>L\u2019opci\u00f3 estad\u00edstica mostra la quantitat de notes entre 0 i 3, entre 3,1 i 5, entre 5,1 i 7, entre 7.1 i 9 i entre 9,1 i 10.</p>"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#arrays-irregulars","title":"Arrays irregulars","text":"<p>Una matriu irregular o escalonada no \u00e9s m\u00e9s que un array de taules, on cadascuna de les taules que formen l\u2019array no necess\u00e0riament han de tenir la mateixa grand\u00e0ria.</p> <p></p> <p>La declaraci\u00f3 d\u2019un array irregular en java seria de la seg\u00fcent manera:</p> <pre><code>// Declaraci\u00f3 d\u2019una matriu (files)\nint [][] mat;\n\n// Primer creem la quantitat de files deixant les columnes buit\nmat=new int[3][];\n\n// Despr\u00e9s creem cada fila indicant la quantitat d\u2019elements\nmat[0]=new int[5];\nmat[1]=new int[3];\nmat[2]=new int[2];\n</code></pre>"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#cadenes-de-caracters","title":"Cadenes de caracters","text":"<p>En Java hem vist que quan volem emmagatzemar un valor enter, definim una variable de tipus int, si pel contrari, el que volem \u00e9s emmagatzemar un valor amb decimals, definim una variable de tipus double o float. Ara b\u00e9, si el que volem \u00e9s emmagatzemar una cadena de caracters, per exemple el nom d\u2019una pesona, hem de definir un objecte de tipus String</p> <pre><code>// Crear un objecte string\nString strNom = \u00abManolo el del bombo\u00bb;\n</code></pre> <p>Aquest codi el que fa \u00e9s crear un objectes string strNom que cont\u00e9 el nom: \u00abManolo el del bombo\u00bb. Tamb\u00e9 podriem crear un string de la seg\u00fcent manera:</p> <pre><code>String strNome = new String(\u00abManolo el del bombo\u00bb);\n</code></pre> <p>Al tractar-se d\u2019una classe, la forma natural de treballar amb ella ser\u00e0 mitjan\u00e7ant l\u2019\u00fas dels m\u00e8todes que disposa la classe. Aquests m\u00e8todes s\u00f3n:</p> <ul> <li>int length(): retorna la llarg\u00e0ria de la cadena en un enter.</li> <li>char charAt (int i): ens diu quin caracter est\u00e0 a la posici\u00f3 \u2018i\u2019</li> <li>String substring(int i): ens retorna la subcadena que hi ha a partir de la posici\u00f3 \u2018i\u2019 fins el final de la cadena</li> <li>String substring(int i, int j): ens retorna la subcadena que es troba des de l\u2019\u00edndex i fins el j</li> <li>String concat(String str): concadena la cadena \u2018str\u2019 que es passa com a par\u00e0metre al final de la cadena. Per exemple:</li> </ul> <pre><code>      tring s1 = \u00abJava\u00bb;\nString s2 = \u00abPego\u00bb;\nString s3 = s1.concat(s2); // El resultat seria \u00abJavaPego\u00bb\n</code></pre> <ul> <li>int indexOf(String s): Ens retorna l\u2019index dins de la cadena de la primera aparici\u00f3 de la subcadena s. Per exemple:</li> </ul> <pre><code>      String s1 = \u00abJava a Pego\u00bb;\nint pos = s1.indexOf(\u00abPego\u00bb); // Retorna 7\n</code></pre> <ul> <li>int indexOf(String s, int i): retorna l\u2019\u00edndex dins de la cadena de la primera aparici\u00f3 de la subcadena s a partir de l\u2019\u00edndex i</li> <li>int lastIndexOf(int ch): torna l\u2019\u00edndex de l\u2019\u00faltima vegada que apareix el caracter \u2018ch\u2019 dins de la cadena.</li> <li>boolean equals(Sring str): Compara l\u2019string amb l\u2019objecte que es passa per par\u00e0metre.</li> <li>boolean equalsIgnoreCase (String otroString): Compara dues cadenes sense tenir en compte maj\u00fascules i min\u00fascules.</li> <li>int compareTo (String otroString): compara dues cadenes lexicogr\u00e0ficament. En altres paraules, diu quina \u00e9s major que l\u2019altra.</li> <li>int compareToIgnoreCase (String otroString): com el m\u00e8tode anterior per\u00f2 sense tenir en compte maj\u00fascules ni min\u00fascules.</li> <li>String toLowerCase(): converteix la cadena a min\u00fascules.</li> <li>String toUpperCase(): converteix la cadena a maj\u00fascules.</li> <li>String trim(): suprimeix els espais en blanc que puguen haver als extremps de la cadena</li> <li>String replace (char oldChar, char newChar): substitueix totes les ocurr\u00e8ncies de oldChar que hi ha a la cadena per newChar</li> </ul>"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#enumeracions","title":"Enumeracions","text":"<p>Una enumeraci\u00f3 \u00e9s un tipus especial de \u2018classe\u2019 que representa un grup de constants. Cada element d\u2019aquesta estructura est\u00e0 associada a un valor de un tipus de dades concret (normalment enter) on el primer element de l\u2019enumeraci\u00f3 sol agafar el valor 0</p> <pre><code>// Exemple 1. Dies de la setmana\nenum Dies {\nDilluns,\nDimarts,\nDimecres,\nDijous,\nDivendres,\nDissabte,\nDiumenge\n}\n\n// Exemple 2. Talles de roba\nenum Talles {\nXXL,\nXL,\nL,\nM,\nS,\nXS\n}\n</code></pre> <p>)</p>"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/","title":"Tema 6. Programaci\u00f3 Orientada a Objectes.","text":""},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#introduccio","title":"Introducci\u00f3","text":"<p>La programaci\u00f3 orientada a objectes tamb\u00e9 coneguda com POO \u00e9s el paradigma de programaci\u00f3 que m\u00e9s s\u2019utilitza hui en dia i que permet modelar de manera m\u00e9s eficient la realitat des del punt de vista del programari.</p> <p>La programaci\u00f3 orientada a objectes intenta proporcionar un model de programaci\u00f3 basat en objectes que contenen dades i procediments associats coneguts com a m\u00e8todes. Aquests objectes, que s\u00f3n inst\u00e0ncies de les classes, s\u00f3n tipus abstractes de dades que encapsulen (amaguen) tant les dades com les funcions per accedir-hi.</p> <p>Un dels objectius de la programaci\u00f3 orientada a objectes \u00e9s reflectir la realitat, de forma que els elements d\u2019un programa s\u2019ajusten a elements de la vida quotidiana. Per exemple, suposem que volem realitzar una aplicaci\u00f3 per un taller de vehicles. En un programa estructurat definir\u00edem funcions independentment de les dades, tal que per un costat crear\u00edem el codi de la funci\u00f3 i posteriorment al programa principal s\u2019establiria una variable o variables sobre les que aplicar\u00edem canvis, podria ser un array d\u2019una estructura a la que guardar\u00edem tipus de vehicle, matr\u00edcula, color, etc. En programaci\u00f3 orientada a objectes creem un objecte que simula un cotxe amb les seues caracter\u00edstiques generals i les funcions incloses, tal que en la funci\u00f3 principal de la nostra aplicaci\u00f3, crearem variables d\u2019aquest objecte i usarem els m\u00e8todes aplicats a unes dades concretes a cada moment.</p> <p>La programaci\u00f3 orientada a objectes permet la creaci\u00f3 de programari cada vegada m\u00e9s complexe a partir d\u2019unitats o blocs de codi reutilitzables.</p>"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#caracteristiques-principals","title":"Caracter\u00edstiques principals","text":"<p>Les propietats principals o caracter\u00edstiques fonamentals del paradigma de programaci\u00f3 orientada a objectes s\u00f3n:</p>"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#abstraccio","title":"Abstracci\u00f3","text":"<p>Abstraure's \u00e9s a\u00efllar mentalment, considerar separadament (un o diversos atributs o qualitats) d'una cosa. Per exemple abstraure els conceptes m\u00e9s importants d'un discurs, \u00e9s a dir, quedar-se amb el important.</p> <p>En programaci\u00f3 orientada a objectes abstraure\u2019s, l\u2019abstracci\u00f3, seria mostrar \u00fanicament les caracter\u00edstiques essencials, que fa l\u2019objecte i per a que es crea, deixant de banda elements com la implementaci\u00f3.</p> <p>L\u2019abstracci\u00f3 permet representar les caracter\u00edstiques essencials d\u2019un objecte, deixant enrere aquelles que no tenen tanta import\u00e0ncia. A m\u00e9s a m\u00e9s, es centra en l\u2019objecte tal i com el coneixem en la vida real, de forma que ens centrem en all\u00f2 que es capa\u00e7 de fer per\u00f2 no en com ho fa. B\u00e0sicament, definir\u00edem l\u2019abstracci\u00f3 com la forma de descriure una entitat del m\u00f3n real sense importar la complexitat que est\u00e0 present i el poder utilitzar aquesta en qualsevol aplicaci\u00f3.</p> <p> </p> <p>Un altre exemple d'abstracci\u00f3:</p> <p> </p>"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#encapsulament","title":"Encapsulament","text":"<p>L\u2019encapsulament \u00e9s, en altres paraules, l\u2019ocultaci\u00f3 d\u2019informaci\u00f3, de forma que les dades internes d\u2019un objecte estan ocultes al m\u00f3n exterior, nom\u00e9s es coneix d\u2019ell la seua ess\u00e8ncia, \u00e9s a dir, qu\u00e8 podem fer amb ell.</p> <p>Per exemple, amb freq\u00fc\u00e8ncia es desenvolupa codi font o projectes en els que utilitzem la classe out, m\u00e9s concretament el m\u00e8tode println. Out es troba dins de l\u2019espai de noms (namespace) System i no \u00e9s m\u00e9s que una classe d\u2019aquest paquet. Dit en altres paraules. Out \u00e9s una classe i println() \u00e9s un m\u00e8tode de la classe Out.</p> <p> </p>"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#modularitat","title":"Modularitat","text":"<p>Aquesta propietat fa refer\u00e8ncia a la forma en la que els elements en programaci\u00f3 orientada a objectes es troben organitzats en m\u00f2duls, facilitant aix\u00ed l\u2019encapsulament i abstracci\u00f3 de la informaci\u00f3.</p> <p>La modularitat permet dividir una aplicaci\u00f3 en parts. Aquestes parts han de ser   tan independents com puguen de la resta de m\u00f2duls aix\u00ed com tamb\u00e9 de l\u2019aplicaci\u00f3 principal. El motiu pel qual els m\u00f2duls han de ser el m\u00e9s independents possibles de l\u2019aplicaci\u00f3 \u00e9s perqu\u00e8 aix\u00ed es podran reutilitzar en altres aplicacions m\u00e9s endavant.</p>"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#jerarquia-i-herencia","title":"Jerarquia i her\u00e8ncia","text":"<p>La jerarquia \u00e9s la propietat de la programaci\u00f3 orientada a objectes respecte de la relaci\u00f3 o ordre existent entre les distintes classes i objectes. El mecanisme principal per tal d\u2019ordenar les classes als nostres projectes \u00e9s l\u2019her\u00e8ncia. Podem parlar d\u2019her\u00e8ncia entre classes quan elements d\u2019una classe (superclasse) son heretats per una altra o incl\u00f2s els seus m\u00e8todes poden ser sobrecarregats.</p> <p> </p> <p>Suposem una aplicaci\u00f3 d\u2019un taller de vehicles en el qual treballen moltes persones per\u00f2 cadascuna fa una funci\u00f3 diferent al taller. Malgrat que cadascuna es dedique a un tasca concreta i no s\u00e0piga res de la resta de feines que es fan al taller, tots els empleats s\u00f3n persones, \u00e9s a dir, tots tenen un s\u00e8rie de caracter\u00edstiques comuns: Nom, cognoms, DNI, data de naixement etc.. Mentre que al mateix temps hi ha algunes caracter\u00edstiques especifiques per a cada tipus d\u2019empleat </p> <p>Imaginem que tenim dos classes d\u2019empleats: els mec\u00e0nics i els comercials. Dels primers hem de guardar informaci\u00f3 del nombre d\u2019hores extra que fa al mes mentre que dels segons hem de gestionar informaci\u00f3 sobre les cites que t\u00e9 amb clients durant la setmana.</p> <p> classDiagram Empleat &lt;|-- Mecanic Empleat &lt;|-- Comercial  Empleat : Nom Empleat : Cognoms Empleat : SouBase  Mecanic : HoresExtra Comercial: Cites Comercial: Plus  </p>"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#polimorfisme","title":"Polimorfisme","text":"<p>Polimorfisme \u00e9s una paraula grega que significa \u00abmoltes formes\u00bb. Aquesta paraula \u00e9s ideal per definir aquesta caracter\u00edstica de la programaci\u00f3 orientada a objectes ja que en POO podem tindre objectes amb el mateix nom que realitzen funcions distintes o implementen codi diferent.</p> <p>El polimorfisme \u00e9s un mecanisme que s\u2019utilitza molt en POO juntament amb l\u2019her\u00e8ncia tal que quan una classe deriva d\u2019una altra hereta les seues caracter\u00edstiques i operacions. A la classe que hereta es pot redefinir qualsevol m\u00e8tode heretat, de forma que en funci\u00f3 de la refer\u00e8ncia a objectes que usem a cada moment s\u2019estar\u00e0 executant un m\u00e8tode o un altre.</p> <p>Un mateix missatge enviat a objectes diferents donar\u00e0 com a resposta eixides diferents, \u00e9s a dir, si tenim diversos objectes amb m\u00e8todes similars, segons es referencie l\u2019un o l\u2019altre objecte el resultat final ser\u00e0 diferent. </p> <p>Per exemple seguint amb l\u2019esquema dels empleats de la nostra empresa suposem que la classe (\u00absuperclasse\u00bb) t\u00e9 un m\u00e8tode que es diu \u00abcalcularSou\u00bb, aquest m\u00e8tode l\u2019hereten tant el mec\u00e0nic com el comercial per\u00f2 el seu c\u00e0lcul seria diferent en un i l\u2019altre. El sou del mec\u00e0nic ser\u00e0 el sou base m\u00e9s el n\u00famero d\u2019hores extra multiplicades pel preu al que es paguen les hores extra, mentre que el sou del comercial seria el sou base m\u00e9s el plus.</p> <p> classDiagram Empleat &lt;|-- Mecanic Empleat &lt;|-- Comercial  Empleat : Nom Empleat : Cognoms Empleat : SouBase Empleat : calculaSou()  Mecanic : HoresExtra Mecanic : calculaSou()  Comercial: Cites Comercial: Plus Comercial: calculaSou()  </p>"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#realitzacio-de-programes-orientats-a-objectes","title":"Realitzaci\u00f3 de programes orientats a objectes","text":"<p>A partir d\u2019ara, quan hajam de resoldre un problema hem de comen\u00e7ar a pensar d\u2019una forma diferent a la que est\u00e0vem fent fins ara. En programaci\u00f3 orientada a objectes seguirem usant els mecanismes de programaci\u00f3 estructurada com ara sent\u00e8ncies repetitives, alternatives, etc.. tanmateix hem de plantejar un sistema  on les dades presenten una major import\u00e0ncia.</p> <p>L\u2019objectiu de l\u2019orientaci\u00f3 a objectes \u00e9s plasmar la realitat de manera que programem els elements el m\u00e9s pr\u00f2xim possible a com els veiem al seu entorn natural. Aix\u00ed, quan hajam d\u2019encarar un problema d\u2019aquest tipus:</p> <ul> <li>Ens preguntarem sobre aquells elements dels que realment es interessant emmagatzemar informaci\u00f3, \u00e9s a dir, localitzarem els possibles objectes del nostre programa.</li> <li>De cada element hem de con\u00e8ixer quines s\u00f3n les seues caracter\u00edstiques o quines s\u00f3n les caracter\u00edstiques que el representen.</li> <li>De cada element hem de con\u00e8ixer les operacions a realitzar ja que cada conjunt de dades permetr\u00e0 la realitzaci\u00f3 d\u2019un conjunt d\u2019operacions.</li> <li>Finalment, desenvoluparem un entorn on utilitzarem els elements configurats.</li> </ul> <p>Per exemple, a l\u2019hora de desenvolupar l\u2019aplicaci\u00f3 per al un taller de reparacions de vehicles, podem resoldre les seg\u00fcents q\u00fcestions per determinar els elements que inclourem:</p> <ol> <li> <ol> <li>Quins elements del taller han de ser desats o s\u2019han de tenir en compte a la nostra aplicaci\u00f3? Els vehicles i els empleats</li> </ol> </li> <li>De cada element, quines dades ens interessen? Dels vehicles: l\u2019hora d\u2019entrada al taller, danys que presenta, matr\u00edcula, marca i model, etc.. de cada empleat: nom i cognoms, adre\u00e7a, sou, c\u00e0rrec, reparacions associades, etc..</li> <li>A cada element, quines operacions associarem? A un vehicle podem canviar-li l\u2019oli, reparar la xapa, canviar el color, posar a punt, etc.. als empleats podem modificar-los el sou base, establir hores de treball etc..</li> <li>Pel que fa a l\u2019aplicaci\u00f3 principal que utilitze aquests objectes, podem plantejar un programa que emmagatzeme de forma din\u00e0mica els vehicles que van entrant al taller, aix\u00ed com tamb\u00e9 els empleats que treballen en ell estructurar la funcionalitat mitjan\u00e7ant un men\u00fa d\u2019opcions que permeta utilitzar les operacions anteriorment plantejades per a cada objecte.</li> </ol> Activitat 601. Gestor de pr\u00e9stecs <p>Fes un an\u00e0lisi semblant al de l\u2019aplicaci\u00f3 del taller per\u00f2 per a una aplicaci\u00f3 de gesti\u00f3 de pr\u00e9stecs. Quants objectes diferents hi ha? Quines s\u00f3n les seues caracter\u00edstiques principals? Quines accions poden realitzar?</p>"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#classes-i-objectes","title":"Classes i Objectes","text":"<p>Una classe \u00e9s la definici\u00f3 d\u2019un objecte, \u00e9s l\u2019element que descriu els components d\u2019un objecte de forma general. Diem que hem creat un objecte quan donem valors i utilitzem els components definits a la classe.</p> <p>Per exemple, si continuem utilitzant el nostre taller de vehicles, una classe podria ser la classe cotxe, en la que es descriu de forma general aquest element de la vida quotidiana. S\u2019establiria que un cotxe es caracteritza per:</p> <ul> <li>Tindre rodes</li> <li>Tindre matricula</li> <li>Tindre portes</li> <li>Se d\u2019una marca i un model concrets.</li> <li>Etc..</li> </ul> <p>Ara b\u00e9, si al nostre taller entra un Seat Arosa de tres portes, les caracter\u00edstiques abans esmentades adopten certs valors:</p> <ul> <li>Quatre m\u00e9s la de recanvi. </li> <li>Matricula. 1234ACB</li> <li>3 portes</li> <li>Seat. Model Arosa</li> </ul> <p>Aix\u00ed tenim per un costat la classe cotxe i per l\u2019altra l\u2019objecte Seat Arosa.</p> <p>Alhora de crear una classe definim el que denominem propietats o atributs i m\u00e8todes de classe.</p> <ul> <li> <p>Atributs: una caracter\u00edstica concreta d\u2019un objecte de la vida quotidiana. Quan s\u2019estableix un atribut a una classe, es defineix com quan cre\u00e0vem variables als nostres programes estructurats, indicant tipus de dades i nom amb el que el reconeixem.</p> </li> <li> <p>M\u00e8todes de la classe: donen funcionalitat a la classe, \u00e9s a dir, reflecteixen les operacions que aquesta pot fer sobre els atributs. Els m\u00e8todes s\u00f3n similars a les funcions o procediments que cre\u00e0vem en programaci\u00f3 estructurada per\u00f2 orientats a modificar i actuar sobre les propietats d\u2019una classe.</p> </li> </ul> <p>Un objecte dona valors concrets als atributs que defineix la classe i utilitza els seus m\u00e8todes. Quan un objecte utilitza un m\u00e8tode concret es diu que aquesta enviant un missatge. D\u2019alguna manera a\u00e7\u00f2 t\u00e9 l\u00f2gica ja que estem donant una ordre a un component que reflecteix la realitat. Si a un taller hem de canviar el color d\u2019un vehicle, direm canvia el color a l\u2019operari que estiga treballant, li estem enviant un missatge de que ha de realitzar aquesta acci\u00f3 concreta.</p> <p>A l\u2019hora de enviar un missatge a un element concret d\u2019un objecte utilitzarem l\u2019operador punt, per exemple, arosa.canviaColor().</p> <p>A sovint donem el nom d\u2019estat als valors que en un objecte t\u00e9 en un moment concret de la vida del programa on s\u2019est\u00e0 utilitzant. A m\u00e9s a m\u00e9s, quan creem un objecte, donem valors a les propietats de la classe, diem que estem instanciant aquesta classe.</p>"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#definicio-de-classes-en-java","title":"Definici\u00f3 de classes en Java","text":"<p>Una vegada ja sabem que s\u00f3n les classes i els objectes veurem com es defineixen classes i instancien objectes en el llenguatge Java. Definir una classe implica donar-li nom a ella i als elements que emmagatzemen la seua informaci\u00f3, aix\u00ed com tamb\u00e9 descriure els m\u00e8todes que realitzaran les accions considerades als objectes.</p> <p>Les definicions o especificacions no constitueixen un codi de programa executable si no que s\u2019utilitzen per assignar mem\u00f2ria on emmagatzemar els valors dels atributs que utilitza el programa i recon\u00e8ixer els m\u00e8todes que aquesta utilitzar\u00e0; normalment es situen en arxius formant packages, utilitzant un arxiu per v\u00e0ries classes relacionades.</p> <p><pre><code>class nomClasse {\nllista_de_membres\n}\n</code></pre> - nomClasse: definit per l\u2019usuari i identifica la classe; pot incloure lletres, n\u00fameros i subratllats com qualsevol identificador. - llista_de_membres: s\u00f3n els m\u00e8todes i atributs de la classe, etc..</p> <p>M\u00e9s concretament, una classe es podria definir de la seg\u00fcent manera:</p> <pre><code>class nomClasse {\nllista_de_constants;\nllista_de_atributs;\nconstructor_de_classe;\nconstructor_de_c\u00f2pia;\nm\u00e8todes;\n}\n</code></pre> <p>En realitat si la definici\u00f3 de les parts de la classe es fera en un altre ordre, no afectaria a la compilaci\u00f3 i execuci\u00f3 d\u2019aquesta per\u00f2 s\u00ed a la lectura del codi i el faria m\u00e9s complicat d\u2019interpretar.</p> <p>Exemple de classe: per tal d\u2019il\u00b7lustrar com es defineix una classe amb un exemple, definirem la classe \u2018punt\u2019. Aquesta classe determina les coordenades a les quals es troba un punt concret: x i y;</p> <pre><code>class Punt {\nprivate int x;\nprivate int y;\npublic Punt () {\nx = 0;\ny = 0;\n}\n\npublic Punt (int a, int b) {\nx = a;\ny = b;\n}\n\npublic int LlegirX () {\nreturn x;\n}\n\npublic int LlegirY () {\nreturn y;\n}\n\npublic void FixarX(int valor) {\nx = valor;\n}\n\npublic void FixarY(int valor) {\ny = valor;\n}\n}\n</code></pre> <p>Una vegada tenim la definici\u00f3 de la classe punt, instanciarem un punt concret que es troba a les coordenades 10 i 5</p> <pre><code>Punt a = new Punt(10,5);\n</code></pre>"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#visibilitat-dels-membres-de-la-classe","title":"Visibilitat dels membres de la classe","text":"<p>Un principi fonamental en la programaci\u00f3 orientada a objectes  \u00e9s l\u2019ocultaci\u00f3 de la informaci\u00f3, a\u00e7\u00f2 significa que no es pot accedir per m\u00e8todes externs de la classe a determinada informaci\u00f3 interna. El mecanisme principal per aconseguir-ho \u00e9s posar-los dins d\u2019una classe i fer-los privats i aix\u00ed nom\u00e9s es podr\u00e0 accedir a aquests des de dins de la classe</p> <p>Existeixen tres diferents especificacions d\u2019acc\u00e9s o modificadors de visibilitat:</p> <ul> <li>public (+): un m\u00e8tode o atribut t\u00e9 una visibilitat p\u00fablica quan totes les dem\u00e8s classes poden accedir a ells, b\u00e9 siga una altra classe o una subclasse.</li> <li>Private (-): sols es pot accedir a ells des del propi codi de la classe.</li> <li>Protected (#): nom\u00e9s des del propi codi de la classe o de les seues subclasses es pot accedir.</li> <li>Package (~): nom\u00e9s accessible per membres del paquet.</li> </ul>"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#atributs","title":"Atributs","text":"<p>Els atributs s\u00f3n les caracter\u00edstiques individuals que diferencien un objecte d\u2019un altre i determinen la seua aparen\u00e7a, estat o altres qualitats. Els atributs es desen en variables anomenades variables d\u2019inst\u00e0ncia i cada objecte particular pot tindre valors distints per a aquestes variables.  Per exemple, si hem de definir una persona en base a les seues caracter\u00edstiques individuals que diferencien a una persona d\u2019una altra en el m\u00f3n real, qu\u00e8 escollir\u00edem? Segurament: estatura, color de la pell, color dels ulls, color del pel, etc.. per\u00f2 segurament tamb\u00e9 altres caracter\u00edstiques no tan visualment evidents com podrien ser: nom, cognoms, data de naixement, etc.. i altres m\u00e9s \u00abadministratives\u00bb com podria ser el DNI. Aix\u00ed ens quedaria la classe persona:</p> <pre><code>public class Persona {\nprivate String DNI;\nprivate String nom;\nprivate String cognoms;\nprivate String dataNaixement;\nprivate double estatura;\nprivate double pes;\nprivate String colorUlls;\nprivate String colorCabells;\n}\n</code></pre> <p>Les variables d\u2019inst\u00e0ncia tamb\u00e9 anomenades membres s\u00f3n declarades a la classe per\u00f2 els seus valors son canviats i fixats a l\u2019objectes ja que una classe no \u00e9s m\u00e9s que un esquema que defineix com seran les persones al nostre programa.</p> <p>A m\u00e9s de les variables d\u2019inst\u00e0ncia hi ha variables de classe, les quals  s\u2019apliquen a la classe i a totes les inst\u00e0ncies. Per exemple, el n\u00famero de rodes d\u2019un cotxe \u00e9s el mateix per a tots els objectes cotxe.</p>"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#metodes","title":"M\u00e8todes","text":"<p>Els m\u00e8tode s\u00f3n aquelles accions que pot realitzar la classe que estem definint. B\u00e0sicament el que fa un m\u00e8tode \u00e9s modificar l\u2019estat de l\u2019objecte mitjan\u00e7ant el canvi del valor dels seus atributs. Continuant amb la classe persona que hem definit al punt anterior, caldria que ens f\u00e9rem les seg\u00fcents q\u00fcestions: quines accions s\u00f3n les que pot realitzar la nostra persona? En que afecta eixes accions als atributs que hem escollit per definir-la?</p> <p>A la q\u00fcesti\u00f3 primera dir\u00edem que una persona pot: caminar, botar, c\u00f3rrer, menjar, cr\u00e9ixer, tintar-se els cabells, etc.. Pel que fa a la segon q\u00fcesti\u00f3, podr\u00edem dir que nom\u00e9s modifiquen atributs: menjar, augmentant de pes; cr\u00e9ixer, modificant l\u2019estatura i tintar-se els cabells, canviant el color del pel. Aix\u00ed la classe  persona podria quedar de la seg\u00fcent forma:</p> <pre><code>public class Persona {\n// Atributs\nprivate String DNI;\nprivate String nom;\nprivate String cognoms;\nprivate String dataNaixement;\nprivate double estatura;\nprivate double pes;\nprivate String colorUlls;\nprivate String colorCabells;\n\n// M\u00e8todes\npublic void creixer ( ) { estatura ++; }\npublic void menjar ( ) { pes ++; }\npublic void tintarse (String colorNou) {colorCabells = colorNou; }\n}\n</code></pre> <p>Fixeu-se que mentre els atributs de la classe tenen un modificador de visibilitat private, els m\u00e8todes el solen tindre public. Encara que no necess\u00e0riament ha de ser aix\u00ed sempre per\u00f2 \u00e9s molt habitual. Els m\u00e8todes a Java sempre s\u00f3n membres d\u2019una classe, no hi ha m\u00e8todes o funcions fora d\u2019aquestes. La seua implementaci\u00f3 s\u2019inclou dins del cos de la classe.</p> <p>Exemple: A continuaci\u00f3 modelarem una s\u00e8rie de classes geom\u00e8triques sobre les quals farem una s\u00e8rie de c\u00e0lculs. Utilitzant un llenguatge de programaci\u00f3 orientada a objectes com \u00e9s Java, modelarem un triangle i un quadrat.</p> <p>Primer la classe triangle.</p> <pre><code>public class Triangle {\nint iTotalCostats;\nprivate double dArea;\nprivate double dCostat;\nprivate double dAltura;\n\npublic Triangle () {\niTotalCostats = 3;\ndCostat = 1;\ndAltura = Math.sqrt(3*dCostat)/2;\n}\n\npublic Triangle (double dLong) {\niTotalCostats = 3;\ndCostat = dLong;\n}\n\npublic double getArea () {\nreturn (dCostat*dAltura)/2;\n}\n}\n</code></pre> <p>A continuaci\u00f3 la classe quadrat</p> <pre><code>public class Quadrat {\nint iTotalCostats;\nprivate double dArea;\nprivate double dCostat;\nprivate double dAltura;\n\npublic Quadrat () {\niTotalCostats = 4;\ndCostat = 1;\ndAltura = Math.sqrt(3*dCostat)/2;\n}\n\npublic Triangle (double dLong) {\niTotalCostats = 4;\ndCostat = dLong;\n}\n\npublic double getArea () {\nreturn dCostat*dAltura;\n}\n}\n</code></pre>"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#instancies","title":"Inst\u00e0ncies","text":"<p>La declaraci\u00f3 d\u2019una classe no \u00e9s m\u00e9s que la definici\u00f3 d\u2019una realitat utilitzant un llenguatge de programaci\u00f3 orientada a objectes. El seg\u00fcent pas seria fer \u00fas d\u2019aquesta definici\u00f3 o classe, \u00e9s a dir, instanciar o crear un objecte a partir d\u2019aquesta classe.</p> <p>Per tal d\u2019instanciar una classe s\u2019utilitza la seg\u00fcent sent\u00e8ncia:</p> <pre><code>nom_classe nom_instancia= new nom_classe(par\u00e0metres);\n</code></pre> <p>La paraula \u00abnew\u00bb s\u2019encarrega de reservar espai en mem\u00f2ria i torna una refer\u00e8ncia a l\u2019adre\u00e7a de mem\u00f2ria on s\u2019ha emmagatzemat l\u2019objecte. </p> <ul> <li>nom_classe: en el primer cas \u00e9s el nom de la classe que es vol instanciar. A la segon part es refereix al constructor de la classe que ha de ser igual que el nom d\u2019aquesta. El constructor \u00e9s un m\u00e8tode especial de la classe i com a m\u00e8tode que \u00e9s pot rebre par\u00e0metres.</li> <li>nom_instancia: identificador amb el que s\u2019identificar\u00e0 l\u2019objecte instanciat.</li> </ul> <p>L\u2019espai reservat a mem\u00f2ria per un objecte dependr\u00e0 de la quantitat d\u2019elements  o membres que continga. Quan un objecte no est\u00e0 siguen referenciat es treu de mem\u00f2ria per tal d\u2019alliberar espai pel \u00abgarbage collector\u00bb</p> <p>Quan creem un objecte d\u2019una classe, cada atribut ser\u00e0 inicialitzat amb els valors per defecte del tipus de dades utilitzat o b\u00e9 pel valor establert al constructor.</p>"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#constructors","title":"Constructors","text":"<p>Un constructor \u00e9s un m\u00e8tode membre d\u2019una classe que s\u2019executa de forma autom\u00e0tica quan es crea un instancia d\u2019aquesta. El constructor d\u2019una classe es diferencia de la resta perqu\u00e8 s\u2019ha d\u2019anomenar igual que la classe (respectant maj\u00fascules i min\u00fascules) i mai s\u2019especifica a la seua definici\u00f3 un tipus de dades a retornar encara que siga void.</p> <p>El constructor admet par\u00e0metres, sent un m\u00e8tode que es pot sobrecarregar, \u00e9s a dir, podem tindre diversos constructors amb un nombre diferent de par\u00e0metres o diferents tipus de dades. Els constructors tenen com a finalitat principal la inicialitzaci\u00f3 de les variables o atributs de la classe.</p> <p>No \u00e9s obligatori definir un constructor a cada classe, encara que es sol fer.  Aix\u00ed establim els valors que desitgem per quan un atribut de forma autom\u00e0tica a la creaci\u00f3 de l\u2019objecte, en lloc de fer-ho en un altre moment mitjan\u00e7ant altres m\u00e8todes. </p> <pre><code>public class Empleat {\nprivate String strNom;\nprivate String strCognom;\nprivate String strDNI;\nprivate double dSouBase;\n\npublic Empleat () {\nstrDNI = \"00000000Z\";\n}\n\npublic Empleat (String NIF) {\nstrDNI = NIF;\n}\n\npublic Empleat (String NIF, String nom, String C1) {\nstrDNI = NIF;\nstrNom = nom;\nstrCognom = C1;\n}\n}\n</code></pre>"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#acces-als-membres-de-la-classe","title":"Acc\u00e9s als membres de la classe","text":"<p>Podrem accedir als membres d\u2019una classe en funci\u00f3 de la seua visibilitat i el lloc on es desitge accedir. Els modificadors de visibilitat s\u00f3n: public, private, protected i internal.</p> <p>Per accedir a un membre de la classe utilitzem el \u00ab.\u00bb (punt): NomClasse.membre</p> <p>Basant-nos en la classe Persona dels punts anteriors farem un programa que inst\u00e0ncie un objecte Persona i veurem com s\u2019accedeix als membres de la classes</p> <p>Suposem que persona t\u00e9 un constructor de la classe al qual li passem els seg\u00fcents par\u00e0metres: DNI, nom, cognom, estatura, pes i color del p\u00e8l.</p> <pre><code>public class Programa {\npublic static void main (String []args) {\nPersona manolo;\nmanolo = new Persona (\"11111111A\", \"Manolo\", \"Garibolo\");\nmanolo.tintar(\"blau\");\nmanolo.menjar();\nmanolo.creixer();\n}\n}\n</code></pre> <p>Tanmateix no podr\u00edem accedir als membres privats de la classe des de fora, per exemple, no podr\u00edem fer vicent.nom= \u00abAntonio\u00bb ja que nom \u00e9s un membre privat.</p>"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#la-paraula-reservada-this","title":"La paraula reservada 'this'","text":"<p>La paraula reservada \u00abthis\u00bb s\u2019utilitza per fer refer\u00e8ncia a l\u2019objecte actual. Si est\u00e0s dissenyant una classe, \u00abthis\u00bb fa refer\u00e8ncia a la pr\u00f2pia classe.</p> <p>Quan es crida a un m\u00e8tode, es passa autom\u00e0ticament un argument impl\u00edcit que \u00e9s una refer\u00e8ncia a l\u2019objecte invocat, \u00e9s a dir, l\u2019objecte sobre el que es crida al m\u00e8tode. Aquesta refer\u00e8ncia \u00e9s \u00abthis\u00bb. Amb els atributs de la classe tamb\u00e9 passa el mateix.</p> <p>Per comprendre-ho millor, mirem el seg\u00fcent exemple: </p> <pre><code>public class Persona {\npublic String nom;\npublic String cognom;\npublic String DNI;\n\npublic Persona (String nom, String cognom, String DNI) {\nthis.nom = nom;\nthis.cognom = cognom;\nthis.DNI = DNI;\n}\n}\n</code></pre> <p>Aquesta paraula clau sol utilitzar-se quan hi han b\u00e9 m\u00e8todes o atributs (membres) a dues classes diferents amb el mateix nom per exemple.</p>"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#desenvolupament-dun-projecte-en-java","title":"Desenvolupament d'un projecte en Java","text":"<p>Vista ja un poc la teoria de com \u00e9s el paradigma de programaci\u00f3 orientada a objectes i continuant amb l\u2019activitat d'an\u00e0lisi del joc de \u00abBatalla Naval\u00bb, ha arribat el moment de desenvolupar un projecte utilitzant la metodologia POO amb el llenguatge de programaci\u00f3 Java.</p> <p>Donarem per suposat que les fases d\u2019an\u00e0lisi i disseny ja han sigut realitzades i disposem de l\u2019esquema UML amb el diagrama de classes del nostre joc.</p> <p></p>"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#per-on-comencem","title":"Per on comencem","text":"<p>Si disposem d\u2019una eina de modelat UML, podr\u00edem a partir del diagrama de classes que ens han passat generar el codi en Java que ens serviria per poder comen\u00e7ar a programar ja el seu comportament.</p> <p>Existeixen m\u00faltiples eines lliures que s\u2019encarreguen de fer aquesta tasca autom\u00e0ticament com s\u00f3n: StarUML, ArgoUML, Umbrello i altres extensions que podem afegir a alguns IDEs com s\u00f3n Eclipse. Aquestes eines el que fan \u00e9s generar els esquelets de les classes amb tots els membres especificats al diagrama, \u00e9s a dir: constructors, atributs i m\u00e8todes. La qual cosa ens estalviar\u00e0 un munt de feina. </p> <p>Una vegada ja tenim cadascun dels esquelets de les nostres classes en fitxers, haur\u00edem de crear un nou projecte i afegir-li aquestes classes. Aquesta part es podria fer amb un IDE tipus Eclipse, NetBeans o Visual Studio Code per exemple.</p> <p></p> <p>Arribats a aquest punt ja tenim preparat el nostre projecte i ja podem comen\u00e7ar a \u00abpicar codi\u00bb</p>"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#la-funcio-main-a-java","title":"La funci\u00f3 main a Java","text":"<p>El m\u00e8tode main a Java \u00e9s un est\u00e0ndard utilitzat per la maquina virtual de Java o JVM per iniciar la execuci\u00f3 de qualsevol programa escrit en Java. Aquest m\u00e8tode es coneix com el punt d\u2019entrada de l\u2019aplicaci\u00f3 Java. </p> <p>En altres paraules, per poder executar la nostra aplicaci\u00f3 \u00abBatalla Naval\u00bb haurem de tindre un m\u00e8tode main que instancie i utilitze les classes que hem creat a partir del diagrama de classes que ens han passat. Aquest m\u00e8tode main ha d\u2019estar dins d\u2019una classe, per tant, ens creem una classe nova que es diga \u00abJoc\u00bb i en ella podrem implementar el m\u00e8tode main.</p> <p><pre><code>public class Joc {\npublic static void main (String [] args) {\n\n}\n}\n</code></pre> Main ha de ser \u00abpublic\u00bb perqu\u00e8 \u00e9s el punt d\u2019entrada a la nostra aplicaci\u00f3 i per tant ha de ser accessible de fora de la classe i ha de ser \u00abstatic\u00bb perqu\u00e8 \u00e9s un m\u00e8tode que s\u2019ha de poder cridar sense necessitat d\u2019instanciar un objecte de la classe Joc.</p> Activitat 602. Tenda d'electrodom\u00e8stics <p>Manolo \u00e9s el propietari d\u2019una tenda d\u2019electrodom\u00e8stics en la t\u00e9: televisors, neveres, microones, forns, llavadores, estufes i altres. A Manolo li agradaria tindre una aplicaci\u00f3 en la que puga emmagatzemar la informaci\u00f3 relativa a tots els electrodom\u00e8stics que t\u00e9 a la tenda en estoc aix\u00ed com tamb\u00e9 li agradaria tindre la informaci\u00f3 guardada de tots els clients en una agenda i quines s\u00f3n les compres que li han realitzat. </p> <p>De cada electrodom\u00e8stic vol saber coses com la marca, el model, el n\u00famero de refer\u00e8ncia, efici\u00e8ncia energ\u00e8tica i ja m\u00e9s espec\u00edficament la pot\u00e8ncia dels microones, el volum i l\u2019altura de les neveres aix\u00ed com si tenen o no congelador, les polzades i tipus de definici\u00f3 dels televisors, pot\u00e8ncia i volum del forn, programes de les llavadores i capacitat, potencia de les estufes etc...</p> <p>De cada client vol saber el seu nom, cognoms, adre\u00e7a, DNI i tots els electrodom\u00e8stics que ha comprat a la tenda. Tamb\u00e9 seria interessant poder guardar un inventari de la disponibilitat d\u2019electrodom\u00e8stics que hi han actualment. </p> <p>Les accions que podr\u00e0 realitzar la nostra aplicaci\u00f3 seran: donar de alta i baixa electrodom\u00e8stics i clients, comprar electrodom\u00e8stics per part dels clients, consultar l'estoc etc..</p> <p>El diagrama de classes resultant de l\u2019an\u00e0lisi anterior podria ser el seg\u00fcent:</p> <p></p> Activitat 603. S\u00e8ries i p\u00e8l\u00b7licules <p>Imagina que volem fer una aplicaci\u00f3 sobre s\u00e8ries i pel\u00b7l\u00edcules de les distintes plataformes d\u2019streaming que existeixen en l\u2019actualitat. Aquesta aplicaci\u00f3 tindr\u00e0 usuaris que es connectaran mitjan\u00e7ant unes credencials (nick i contrasenya) i cada usuari podr\u00e0 afegir s\u00e8ries o pel\u00b7l\u00edcules, a banda de posar qualificacions amb comentaris als continguts. El nick de cada usuari d\u2019aquesta aplicaci\u00f3 ser\u00e0 el seu correu electr\u00f2nic, d\u2019aquesta forma ens assegurem un nom \u00fanic per cada usuari. Tamb\u00e9 s\u2019enregistrar\u00e0 per cada usuari el seu nom i cognoms. </p> <p>De cada pel\u00b7l\u00edcula ens agradaria saber: t\u00edtol, any, pa\u00eds de producci\u00f3, genere i resum de la mateixa. Els generes disponibles seran: acci\u00f3, aventures, animaci\u00f3, com\u00e8dia, documental, drama, terror, musical, rom\u00e0ntica, ci\u00e8ncia ficci\u00f3.</p> <p>A banda tamb\u00e9 s\u2019haur\u00e0 de guardar informaci\u00f3 relativa a les actrius i actors que intervenen aix\u00ed com tamb\u00e9 el director. De les quals haurem de saber el seu nom i cognoms aix\u00ed com tamb\u00e9 la seua nacionalitat i l\u2019any de naixement.</p> <p>Pel que fa  les s\u00e8ries, a banda de la informaci\u00f3 que tamb\u00e9 tenen les pel\u00b7l\u00edcules, tamb\u00e9 ens agradaria saber el n\u00famero de temporades que t\u00e9, de quin any \u00e9s la temporada i quants cap\u00edtols t\u00e9 amb el seu t\u00edtol i breu sinopsis.</p> <p>Finalment cada usuari del nostre sistema podr\u00e0 afegir tant s\u00e8ries com pel\u00b7l\u00edcules i podr\u00e0 qualificar-les (de 0 a 10) a banda d\u2019acompanyar la qualificaci\u00f3 d\u2019un comentari al respecte.</p>"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#metodes-variables-i-blocs-statics","title":"M\u00e8todes, variables i blocs statics","text":"<p>La paraula reservada \u00abstatic\u00bb en Java \u00e9s un modificador que en Java es pot aplicar a variables, m\u00e8todes, classes i blocs de codi</p>"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#variables-estatiques","title":"Variables est\u00e0tiques","text":"<p>Una variable est\u00e0tica (static) \u00e9s una variable que pertany a la classe en la que va ser declarada i s\u2019inicialitza nom\u00e9s una vegada a l\u2019inici de l\u2019execuci\u00f3 del programa, la caracter\u00edstica principal d\u2019aquest tipus de variables \u00e9s que es pot accedir directamen amb el nom de la classe sense necessitat d\u2019instanciar un objecte. A banda tamb\u00e9: - \u00c9s una variable que pertany a la classe (variable de classe) i no a l\u2019objecte. - Les variables static s\u2019inicialitzen nom\u00e9s una vegada, a l\u2019inici de l\u2019execuci\u00f3. Aquestes variables s\u2019inicialitzaran primer abans de la inicialitzaci\u00f3 de qualsevol variable d\u2019inst\u00e0ncia.</p>"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#metodes-estatics","title":"M\u00e8todes est\u00e0tics","text":"<p>Un m\u00e8tode est\u00e0tic nom\u00e9s pot accedir a les variables o tipus de dades est\u00e0tiques i no pot accedir a les dades no est\u00e0tiques.</p> <ul> <li>Un m\u00e8tode est\u00e0tic nom\u00e9s pot accedir a dades est\u00e0tiques. No pot accedir a dades no est\u00e0tiques (variables d\u2019inst\u00e0ncia)</li> <li>Un m\u00e8tode est\u00e0tic pot cridar nom\u00e9s a m\u00e8todes est\u00e0tics i no pot invocar un m\u00e8tode no est\u00e0tic a partir d\u2019ell.</li> <li>Un m\u00e8tode est\u00e0tic es pot accedir directament pel nom de la classe i no es necessita crear un objecte per accedir al m\u00e8tode.</li> <li>Un m\u00e8tode est\u00e0tic no pot fer refer\u00e8ncia a \u00abthis\u00bb o \u00absuper\u00bb</li> </ul>"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#blocs-estatics","title":"Blocs est\u00e0tics","text":"<p>El bloc est\u00e0tic \u00e9s un bloc d\u2019instruccions dins de la classe (static { ... }) que s\u2019executa quan una classe es carrega per primera vegada en la m\u00e0quina virtual de Java (JVM). B\u00e0sicament un bloc est\u00e0tic inicialitza variables de tipus est\u00e0tic dins d\u2019una classe, de la mateixa forma que un constructor de classe ajuden a inicialitzar les variables d\u2019inst\u00e0ncia, un bloc est\u00e0tic inicialitza les variables tipus static de la classe.</p>"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#sobrecarrega-doperadors","title":"Sobrec\u00e0rrega d'operadors","text":"<p>En Java \u00e9s possible sobrecarregar m\u00e8todes, \u00e9s dir, definir dos o m\u00e9s dins de la mateixa classe, que comparteix nombre i que les declaracions dels seus par\u00e0metres s\u00f3n diferents; la sobrec\u00e0rrega \u00e9s una forma de polimorfisme.</p> <p>En les cridades als m\u00e8todes sobrecarregats, el compilador determina quin \u00e9s el m\u00e8tode invocat basant-se en el nombre i tipus d\u2019arguments passats; per tant, els m\u00e8todes sobrecarregats han de diferir en nombre i tipus de par\u00e0metres. Quan Java troba una trucada a un m\u00e8tode sobrecarregat, s\u2019executa la versi\u00f3 del que t\u00e9 par\u00e0metres (n\u00famero i tipus) que coincideixen amb els arguments utilitzats en la trucada.</p>"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#sobrecarrega-de-constructors","title":"Sobrecarrega de constructors","text":"<p>En Java es possible sobrecarregar m\u00e8todes, \u00e9s dir, definir dos o m\u00e9s dins de la mateixa classe, que comparteixen nombre i que les declaracions dels seus par\u00e0metres s\u00f3n diferents; la sobrec\u00e0rrega \u00e9s una forma de polimorfisme.</p> <p>La classe descriu un conjunt d'objectes amb les mateixes propietats i comportament; quan l\u2019objecte es crea, es inicialitza amb valors predeterminats o amb els que es transmeten en el moment de la inst\u00e0ncia; el m\u00e8tode que realitza la inicialitzaci\u00f3 de l\u2019objecte \u00e9s el constructor, aquest t\u00e9 el mateix nombre que la classe i no t\u00e9 tipus de retorn.</p> <p>A m\u00e9s de la sobrec\u00e0rrega de m\u00e8todes normals, es poden sobrecarregar els constructors; estos \u00faltims normalment es sobrecarregaran a la majoria de les classes creades, encara que no es regla; fins i tot una classe pot definir-se sense constructor i, per ende, sense arguments.</p>"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/","title":"Tema 7. Her\u00e8ncia, polimorfisme i interf\u00edcies","text":""},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#introduccio","title":"Introducci\u00f3","text":"<p>Un dels mecanismes m\u00e9s potents que incorpora el paradigma de programaci\u00f3 orientada a objectes s\u00f3n l\u2019her\u00e8ncia i el polimorfisme.  El primer ens permet crear una jerarquia de classes relacionades entre s\u00ed de tal forma que la quantitat de codi, especialment el codi redundant, es redueix significativament. </p> <p>El segon permet redefinir m\u00e8todes de tal forma que realitzen funcions diferents depenent del context en el qual es troben. En altres paraules, el polimorfisme \u00e9s el mecanisme de la programaci\u00f3 orientada a objectes que permet que una funci\u00f3 amb el mateix nom realitze tasques diferents depenent de l\u2019objecte des del qual es fa refer\u00e8ncia. </p> <p>Finalment tamb\u00e9 veurem com a les interf\u00edcies podrem especificar les operacions que haurien de definir-se a les classes que la implementen. Una interf\u00edcie \u00e9s un mitj\u00e0 per a que els objectes no relacionats es comuniquen entres s\u00ed. Aquestes s\u00f3n les definicions de m\u00e8todes i valors sobre els quals els objectes estan d\u2019acord per cooperar.</p>"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#herencia","title":"Her\u00e8ncia","text":"<p>En programaci\u00f3 orientada a objectes l\u2019her\u00e8ncia \u00e9s un mecanisme que permet potenciar la reutilitzaci\u00f3 i l\u2019extensibilitat en el desenvolupament de programari a banda de reduir la quantitat de codi redundant. Aquest mecanisme permet crear noves classes a partir d\u2019una classe o jerarquia de classes preexistent (ja comprovades i verificades) evitant d\u2019aquesta forma el redisseny, la modificaci\u00f3 i verificaci\u00f3 de la part ja implementada. L\u2019her\u00e8ncia facilita la creaci\u00f3 d\u2019objectes a partir d\u2019altres ja existents i implica que una subclasse obt\u00e9 tot el comportament (m\u00e8todes) i finalment els atributs (variables) de la seua superclasse.</p> <p>En aquest tema veurem com Java implementa el mecanisme de l\u2019her\u00e8ncia i quines s\u00f3n les opcions que ens dona.</p> <p>Suposem el cas en el que disposem de dues classes (amb menys classes resultaria impossible l\u2019her\u00e8ncia), una s\u2019anomenar\u00e0: classe base, superclasse o classe pare; mentre que l\u2019altra ser\u00e0 la classe derivada, subclasse o classe filla.</p> <p>En el nostre cas la classe pare, superclasse o classe base ser\u00e0 \u00abInstrument\u00bb i la classe derivada, filla o subclasse ser\u00e0 \u00abGuitarra\u00bb que en llenguatge natural es podria traduir com que una guitarra \u00e9s un tipus d\u2019instrument.</p> <p></p> <p>La classe base en una jerarquia d\u2019her\u00e8ncia \u00e9s la classe que cont\u00e9 els atributs i m\u00e8todes comuns a totes les classes derivades i \u00e9s per aix\u00f2 que s\u2019evita la redund\u00e0ncia del codi que es produiria si hagu\u00e9rem de repetir codi com\u00fa a cadascuna de les subclasses, per tant, es podria deduir que una classe derivada \u00e9s de facto una ampliaci\u00f3 de les funcionalitats de la classe base ja que contindr\u00e0 tant els membres de la classe base com els que s'afegeixen de m\u00e9s a la classe derivada.</p>"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#declaracio-duna-classe-derivada","title":"Declaraci\u00f3 d'una classe derivada","text":"<p>Per tal de declarar que una classe hereta d\u2019una altra, Java utilitza la paraula reservada \u2018extends\u2019. Mira l\u2019exemple seg\u00fcent:</p> <p><pre><code>public class Guitarra extends Instrument {\n\n}\n</code></pre> Afegim al nostre exemple dos instruments m\u00e9s; un baix i un teclat. El diagrama de classes quedaria aix\u00ed:</p> <p></p> <p>El codi en Java resultant seria el seg\u00fcent:</p> <pre><code>public class Instrument {\n\n}\n\npublic class Guitarra extends Instrument {\n\n}\n\npublic class Baix extends Instrument {\n\n}\n</code></pre> <p>Respecte de la visibilitat dels membre de la superclasse, les subclasses tindran acc\u00e9s als membres, siguen atributs o m\u00e8todes, public o protected mentre que no heretaran els membres privats de la classe pare. </p>"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#disseny-de-subclasses","title":"Disseny de subclasses","text":"<p>Dissenyar \u00e9s adaptar la realitat que es vol representar a un model concret, en el nostre cas els diagrames de classes d\u2019UML. \u00c9s en aquest pas en el que s\u2019han de prendre les decisions que poden condicionar el resultat final de la nostra aplicaci\u00f3 i no sempre \u00e9s f\u00e0cil determinar quines s\u00f3n les relacions que s\u2019han d\u2019establir.  \u00c9s per aix\u00f2 que cal tenir en ment sempre la seg\u00fcent m\u00e0xima: \u00abLa jerarquia de classes m\u00e9s eficient i efectiva \u00e9s aquella que minimitza el codi al redundant al m\u00e0xim i simplifica el codi\u00bb</p> <p>Al utilitzar el mecanisme de l\u2019her\u00e8ncia en programaci\u00f3 orientada a objectes hem d\u2019intentar sempre tindre un m\u00e0xim de membres a la superclasse i despr\u00e9s a les diferents subclasses nom\u00e9s aquells membres o atributs que fan de discriminador, \u00e9s a dir, que diferencien la classe especialitzada (o subclasse) de la classe superior. Ampliem el nostre exemple de banda de rock anterior i afegim atributs i membres a totes les classes. Per exemple cada instrument tindr\u00e0 amo, any, tipus, marca, model i clau d\u2019afinaci\u00f3. A m\u00e9s a m\u00e9s, podr\u00e0 afinar i tocar. </p> <p>Ja m\u00e9s espec\u00edficament d\u2019una bateria hem de saber el total de Toms que t\u00e9, el total de pedals (hi ha bateries amb doble pedal) i el total de plats a banda de poder tocar un redoble. D\u2019una guitarra hem d\u2019especificar quin ampli utilitza i quantes cordes t\u00e9 (pot tenir-ne fins 12). Finalment pel que fa al teclat, sabrem el nombre de tecles que t\u00e9 i podr\u00e0 tocar melodies.</p> <p></p> <p>El codi resultant d\u2019aquest disseny seria el seg\u00fcent:</p> <p><pre><code>public class Instrument {\n\npublic Instrument () {\n\n}\n\nprivate String amo;\nprotected int any;\nprotected String marca;\nprotected String model;\nprotected String clauAfinacio;\n\npublic void afinar ( ) {\n\n}\n\npublic void tocar ( ) {\n\n}\n}\n\npublic class Guitarra extends Instrument {\n\npublic Guitarra ( ) {\n\n}\n\nprivate int numCordes;\nprivate String ampli;\n\npublic void ferSolo () {\n\n}\n}\n\npublic class Teclat extends Instrument {\n\npublic Teclat () {\n\n}\n\nprivate int totalTecles;\n\npublic void tocarMelodia () {\n\n}\n}\n\npublic class Bateria extends Instrument {\n\npublic Bateria () {\n\n}\n\nprivate int totalToms;\nprivate int pedals;\nprivate int totalPlats;\n\npublic void ferRedoble () {\n\n}\n}\n</code></pre> Del codi anterior es pot extreure la seg\u00fcent informaci\u00f3:</p> <ul> <li>Amo \u00e9s un atribut que no hereta cap subclasse al ser privat.</li> <li>Totes les subclasses tindran acc\u00e9s, encara que al codi no estiga, a any, marca, model i clauAfinaci\u00f3.</li> <li>Totes les subclasses quan criden als m\u00e8todes afinar i tocar, executaran el codi que hi ha a la superclasse sempre que no es s\u2019indique el contrari (sobrec\u00e0rrega)</li> <li>Guitarra i Bateria no tenen acc\u00e9s a l\u2019atribut totalTecles.</li> <li>Teclat i Bateria no tenen poden fer solos.</li> </ul>"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#sobrecarrega-de-metodes-a-la-classe-derivada","title":"Sobrec\u00e0rrega de m\u00e8todes a la classe derivada","text":"<p>La sobrec\u00e0rrega de m\u00e8todes \u00e9s la creaci\u00f3 de diversos m\u00e8todes amb el mateix nom per\u00f2 amb diferent llista de tipus de par\u00e0metres. Java diferencia entre els m\u00e8todes sobrecarregats en base al n\u00famero i tipus de par\u00e0metres o arguments que t\u00e9 el m\u00e8tode i no pel tipus que retorna.</p> <p>classe derivada pot redefinir un m\u00e8tode de la classe base amb el   mateix nom per\u00f2 una llista diferent d\u2019arguments </p> <p>Si pel contrari tenim un mateix m\u00e8tode amb el mateix nom i la mateixa signatura (els mateixos par\u00e0metres) el que estem fent es sobreescriure (overridint) i no sobrecarregar (overloading)</p> <p>Seguint amb l\u2019exemple de la nostra banda de rock mireu el seg\u00fcent codi:</p> <p></p> <p>Com es pot observar a la imatge anterior hi ha una sobrecarrega del m\u00e8tode afinar a cada classe derivada perqu\u00e8 seria el mateix que el de la classe pare per\u00f2 amb diferents par\u00e0metres mentre que el m\u00e8tode tocar est\u00e0 sobreescrit ja que la interf\u00edcie \u00e9s id\u00e8ntica. En codi podria quedar de la seg\u00fcent forma:</p> <pre><code>public class Instrument {\n\npublic Instrument () {\n\n}\n\nprivate String amo;\nprotected int any;\nprotected String marca;\nprotected String model;\nprotected String clauAfinacio;\n\npublic void afinar ( ) {\nSystem.out.println(\"Afinar la superclasse\");\n}\n\npublic void tocar ( ) {\nSystem.out.println(\"Tocar instrument\");\n}\n}\n\npublic class Guitarra extends Instrument {\n\npublic Guitarra ( ) {\n\n}\n\nprivate int numCordes;\nprivate String ampli;\n\npublic void ferSolo () {\n\n}\n\npublic void tocar ( ) {\nSystem.out.println(\"Tocar Guitarra\");\n}\n\npublic void afinar (char clau) {\nSystem.out.println(\"Afinar guitarra en clau \" + clau);\n}\n}\n\npublic class Teclat extends Instrument {\n\npublic Teclat () {\n\n}\n\nprivate int totalTecles;\n\npublic void tocarMelodia () {\n\n}\n\npublic void tocar ( ) {\nSystem.out.println(\"Tocar Teclat\");\n}\n\npublic void afinar (char clau) {\nSystem.out.println(\"Afinar teclat en clau \" + clau);\n}\n}\n\npublic class Bateria extends Instrument {\n\npublic Bateria () {\n\n}\n\nprivate int totalToms;\nprivate int pedals;\nprivate int totalPlats;\n\npublic void ferRedoble () {\n\n}\n\npublic void tocar ( ) {\nSystem.out.println(\"Tocar Bateria\");\n}\n\npublic void afinar (char clau) {\nSystem.out.println(\"Afinar bateria en clau \" + clau);\n}\n}\n</code></pre>"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#herencia-publica","title":"Her\u00e8ncia p\u00fablica","text":"<p>En Java tenim la possibilitat de fer protected (#) private (-) public (+) i package (~) ens determina la visibilitat dels membres d\u2019una classe. Java considera que l\u2019her\u00e8ncia \u00e9s sempre p\u00fablica i que la classe derivada tindr\u00e0 per tant acc\u00e9s als membres protected i public de la classe pare per\u00f2 no als membres privats. El fet de poder tindre elements privats a la nostra classe base seria per poder ocultar informaci\u00f3 a les classes derivades.</p>"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#constructors-en-herencia","title":"Constructors en her\u00e8ncia","text":"<p>De la mateixa manera que s\u2019hereten m\u00e8todes i atributs tamb\u00e9 s\u2019hereten els constructors de la classe. D\u2019aquesta forma si declarem un objecte d\u2019una classe derivada, primer s\u2019executa el constructor de la classe base i a continuaci\u00f3 s\u2019executa la part de codi de la classe derivada.</p> <p>Continuant amb la nostra banda de rock farem algunes modificacions. Afegim un constructor parametritzat a la classe instrument que s\u2019encarregar\u00e0 d\u2019inicialitzar els atributs amo, any, marca i model.</p> <pre><code>public class Instrument {\n\nprivate String amo;\nprotected int any;\nprotected String marca;\nprotected String model;\nprotected String clauAfinacio;\n\npublic Instrument () {\n\n}\n\npublic Instrument ( String strAmo, int iAny, String strMarca, String strModel ) {\nthis.amo = strAmo;\nthis.any = iAny;\nthis.marca = strMarca;\nthis.model = strModel;\n}\n\n\npublic void afinar ( ) {\nSystem.out.println(\"Afinar la superclasse\");\n}\n\npublic void tocar ( ) {\nSystem.out.println(\"Tocar instrument\");\n}\n}\n</code></pre> <p>Per l\u2019altre costat a la classe Guitarra hi afegim tamb\u00e9 un nou constructor (sobrecarregat) amb els par\u00e0metres: amo, any, marca, model, n\u00famero de cordes i l\u2019amplificador que utilitza.</p> <pre><code>public class Guitarra extends Instrument {\n\nprivate int numCordes;\nprivate String ampli;\n\npublic Guitarra ( ) {\n\n}\n\npublic Guitarra ( String strAmo, int iAny, String strMarca, String strModel, int iCordes, String strAmpli) {\nsuper(strAmo, iAny, strMarca, strModel);\nthis.numCordes = iCordes;\nthis.ampli = strAmpli;\n}\n\npublic void ferSolo () {\n\n}\n\npublic void tocar ( ) {\nSystem.out.println(\"Tocar Guitarra\");\n}\n\npublic void afinar (char clau) {\nSystem.out.println(\"Afinar guitarra en clau \" + clau);\n}\n}\n</code></pre> <p>Amb aquest disseny de classes podr\u00edem per exemple executar el seg\u00fcent codi</p> <pre><code>public class Test {\npublic static void main (String [] args ) {\nGuitarra lesPaul = new Guitarra (\"Vicent\", 2007, \"Gibson\", \"LesPaul\", 6, \"Marshall\");\nlesPaul.afinar('R');\nlesPaul.tocar();\n}\n}\n</code></pre> <p>Qu\u00e8 \u00e9s el que estaria passant si ferem un tra\u00e7a?</p> <p>Al crear un objecte \u2018gibsonLesPaul\u2019 de la classe guitarra passant-li par\u00e0metres, es cridaria al constructor de la classe guitarra. Aquest el primer que faria seria cridar al constructor de la classe pare utlitzant \u2018super\u2019 per indicar-li que ha d\u2019executar el constructor de la superclasse assignant-li d\u2019aquesta forma: l\u2019amo, any, marca i model per immediatament despr\u00e9s assignar el nombre de cordes i l\u2019amplificador de la classe derivada.</p> <p>El m\u00e8tode super(), es crida nom\u00e9s quan s\u2019utilitzen constructors sobrecarregats per tal que execute tamb\u00e9 el constructor de la superclasse amb par\u00e0metres i no el constructor per defecte que \u00e9s el que faria si no li diguem el contrari.</p>"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#exemple","title":"Exemple","text":"<p>Que executaria el seg\u00fcent codi?</p> <p></p> <p>A m\u00e9s a m\u00e9s, super() tamb\u00e9 ens permet cridar a m\u00e8todes de la classe pare de la seg\u00fcent forma:</p> <pre><code>super.metode(argumnets);\n</code></pre>"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#conversio-entre-subclasse-i-superclasse","title":"Conversi\u00f3 entre subclasse i superclasse","text":"<p>De vegades en programaci\u00f3 hem de poder convertir entre tipus de dades, aquest mecanisme s\u2019anomena tamb\u00e9 \u00abcast\u00bb. Per exemple si tenim un double amb valor 6,8 i volem convertir-lo en un moment determinat de la nostra aplicaci\u00f3 a un int, ho fariem de la seg\u00fcent forma:</p> <pre><code>double d = 6,8;\nint i = (int)d;\n</code></pre> <p>Entre objectes tamb\u00e9 existeix la possibilitat de aplicar aquest mecanisme. Al nostre model de banda de rock, ens podr\u00edem trobar amb la seg\u00fcent situaci\u00f3:</p> <pre><code>Instrument inst = new Instrument ();\nGuitarra git = new Guitarra ();\nTeclat tcl = new Teclat ();\ninst = git;  // Conversi\u00f3 autom\u00e0tica\ninst = tcl;  // Conversi\u00f3 autom\u00e0tica\n</code></pre>"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#classes-no-derivables-atribut-final","title":"Classes no derivables: atribut final","text":"<p>Si volem que alguna classe en concret no siga ja m\u00e9s derivable, \u00e9s a dir, que no volem que es creen m\u00e9s subclasses a partir d\u2019una classe concreta, ho indiquem utilitzant la paraula reservada \u00abfinal\u00bb</p> <p><pre><code>public final class Bateria extends Instrument {\npublic Bateria () {\n\n}\n\nprivate int totalToms;\nprivate int pedals;\nprivate int totalPlats;\n\npublic void Tocar ( ) {\nSystem.out.println(\"Tocar la bateria\");\n}\n\npublic void afinar ( char clau) {\nSystem.out.println(\"Afinar la bateria en \" + clau);\n}\n}\n</code></pre> Amb aquest codi aconseguim que no es puguen crear subclasses de la classe Bateria.</p>"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#polimorfisme","title":"Polimorfisme","text":"<p>El polimorfisme (del Grec \u03c0\u03bf\u03bb\u03cd\u03c2, polys, \"molt, molts\" i \u03bc\u03bf\u03c1\u03c6\u03ae, morph\u0113, \"forma, figura\") \u00e9s una caracter\u00edstica d'alguns llenguatges de programaci\u00f3 que tenen la propietat d'enviar missatges sint\u00e0cticament iguals als objectes de diferents tipus. L'\u00fanic requisit que han de complir els objectes que s'utilitzen de manera polim\u00f2rfica \u00e9s saber respondre al missatge que se'ls hi envia.</p> <p>El polimorfisme permet fer refer\u00e8ncia a altres objectes de classes mitjan\u00e7ant el mateix element de programa i realitzar la mateixa operaci\u00f3 de diferents maneres d\u2019acord amb l\u2019objectes al qual es fa refer\u00e8ncia en cada moment.</p> <p>Si mirem la nostra banda de rock, l\u2019exemple m\u00e9s clar \u00e9s el del m\u00e8tode tocar, tots el nostres instruments poden tocar per\u00f2 cadascun ho fa d\u2019una forma diferent.</p>"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#lligadura","title":"Lligadura","text":"<p>El terme lligadura es correspon a l\u2019enlla\u00e7 que es produeix entre un objecte o inst\u00e0ncia d\u2019una classe i les seues propietats. Si aquestes propietats s\u00f3n atributs, la lligadura \u00e9s refereix a la connexi\u00f3 entre l\u2019atribut i la refer\u00e8ncia a mem\u00f2ria on es trobaria el valor de l\u2019atribut en q\u00fcesti\u00f3 mentre que si estem parlant de m\u00e8todes, la lligadura \u00e9s refereix a la connexi\u00f3 entre el nom del m\u00e8tode que es pret\u00e9n executar i el codi que executaria.</p> <p>Per un altre costat, el temps de lligadura \u00e9s el moment en el que l\u2019atribut s\u2019associa amb el seu valor o que un m\u00e8tode s\u2019agrupa amb el seu codi corresponent. Aquest temps de lligadura pot ser \u2018est\u00e0tic\u2019 o \u2018din\u00e0mic\u2019. El primer es produeix durant la compilaci\u00f3 del programa mentre que la segona es produeix en temps d\u2019execuci\u00f3.</p> <p>La majoria de llenguatges de programaci\u00f3 com C utilitzen la lligadura est\u00e0tica en temps de compilaci\u00f3 mitjan\u00e7ant l\u2019enlla\u00e7ador, pel contrari els llenguatges de programaci\u00f3 que utilitzen lligadura din\u00e0mica, no determinen quin \u00e9s el codi que s\u2019executar\u00e0 en la crida al m\u00e8tode fins que arriba el moment en temps d\u2019execuci\u00f3 i \u00e9s nom\u00e9s en eixe cas en el que es determinar\u00e0 de totes les possibilitats de codi a executar (polimorfisme) quin \u00e9s el que s\u2019enlla\u00e7ar\u00e0 o lligar\u00e0 (lligadura efectiva).</p> <p>Java \u00e9s un llenguatge orientat a objectes que utilitza la lligadura din\u00e0mica en temps d\u2019execuci\u00f3 amb l\u2019excepci\u00f3 dels m\u00e8todes static o final que utilitzen lligadura est\u00e0tica.</p>"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#classes-i-metodes-abstractes","title":"Classes i m\u00e8todes abstractes","text":"<p>Les classes i m\u00e8todes abstractes s\u00f3n un \u00abfenomen\u00bb que es dona en algunes de les generalitzacions que ens apareixen quan analitzem una realitat des del punt de vista de la programaci\u00f3 orientada a objectes. \u00c9s a dir, l\u2019abstracci\u00f3 com a t\u00e8cnica en POO nom\u00e9s es pot donar en l\u2019her\u00e8ncia entre classes, concretament a les classes m\u00e9s altes de la jerarquia.</p> <p>Una classe abstracta \u00e9s aquella de la qual mai s\u2019instanciar\u00e0 cap objecte. Per exemple Instrument a la nostra banda de rock on o s\u2019instancia una guitarra, un baix o una bateria per\u00f2 mai un instrument com a tal.</p> <p>A nivell de codi l\u2019\u00fanic canvi que es produeix \u00e9s que a la classe general \u00abInstrument\u00bb se li afegeix la paraula reservada abstract com a modificador de comportament de la classe.</p> <pre><code>public abstract class Instrument {\n\n}\n</code></pre> <p>Normalment els m\u00e8todes d\u2019una classe abstracta tamb\u00e9 seran abstractes.</p> <p>Al convertir la classe Instrument a abstracta ja no la podr\u00edem instanciar \u00e9s a dir, no podrem crear cap objecte de la classe Instrument, \u00e9s a dir, no podrem en cap moment fer Instrument ins = new Instrument(); ja que ens donaria error de compilaci\u00f3 per\u00f2 en canvi, si podr\u00edem fer Instrument ins = new Guitarra(); ja que la classe Guitarra no \u00e9s abstracta i una Guitarra \u00e9s, segons el nostre model, un instrument.</p> <p>M\u00e8todes Abstractes Un m\u00e8tode abstracte \u00e9s un m\u00e8tode que defineix un comportament o funcionalitat concreta per\u00f2 no especifica la seua implementaci\u00f3 i ha de ser la classe filla la que implemente el m\u00e8tode.</p> <p>En altres paraules, a la classe para o superclasse podem tindre m\u00e8tode tocar, public void abstract tocar(), que no tindra cap codi a la seua implementaci\u00f3 si no que ser\u00e0 la classe filla o subclasse, guitarra per exemple, la que incorpore el codi dins del seu m\u00e8tode public void tocar(). Fixeu-se que aquest \u00faltim ja no porta la paraula reservada \u00ababstract\u00bb</p> <p>La implementaci\u00f3 de m\u00e8todes abstractes per part de les classes filles en una jerarquia utilitzen la lligadura din\u00e0mica ja que no es possible determinar el codi que s\u2019ha d\u2019executar en temps de compilaci\u00f3.</p>"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#us-del-polimorfisme","title":"\u00das del polimorfisme","text":"<p>Arribats a aquest punt podem treure les  seg\u00fcents conclusions: que el polimorfisme ens permet que diferents objectes responguen de manera diferent al mateix missatge (m\u00e8tode amb el mateix nom) i que aquesta diferenciaci\u00f3 de quin codi executar ho fa el compilador amb lligadura din\u00e0mica (en temps d\u2019execuci\u00f3 i no de compilaci\u00f3) </p> <p>Per usar el polimorfisme a Java hem de seguir les seg\u00fcents regles:</p> <ol> <li>Crear una jerarquia de classes amb les operacions importants definies per els m\u00e8todes membre declarades com abstractes a la base.</li> <li>Les implementacions espec\u00edfiques dels m\u00e8todes abstractes s\u2019han de fer a les classes derivades.</li> <li>Les inst\u00e0ncies d\u2019aquestes classes s\u2019usen mitjan\u00e7ant una refer\u00e8ncia a la base amb lligadura din\u00e0mica la qual \u00e9s l\u2019ess\u00e8ncia del polimorfisme a Java</li> </ol> <p>Finalment,en realitat no \u00e9s necessari declarar abstractes els m\u00e8todes a la classe base si despr\u00e9s es redefineixen amb la mateixa signatura (nom m\u00e9s par\u00e0metres) a la classe derivada.</p>"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#avantatges-del-polimorfisme","title":"Avantatges del polimorfisme","text":"<p>El polimorfisme fa el seu sistema m\u00e9s flexible, sense perdre cap dels avantatges de la compilaci\u00f3 est\u00e0tica de tipus que tenen lloc en temps de compilaci\u00f3; tal \u00e9s el cas de Java.</p> <p>Les aplicacions m\u00e9s freq\u00fcents del polimorfisme s\u00f3n: - Especialitzaci\u00f3 de classes derivades. \u00c9s a dir, especialitzar classes que han estat definits des; per exemple: Quadrat \u00e9s una especialitzaci\u00f3 de la classe Rectangle perqu\u00e8 qualsevol quadrat \u00e9s un tipus de rectangle; aquesta classe de polimorfisme augmenta la efici\u00e8ncia de la subclasse, mentre conserva un alt grau de flexibilitat i permet un mitj\u00e0 uniforme de manejar rectangles i quadrats. - Estructures de dades heterogenis. De vegades \u00e9s \u00fatil poder manipular conjunts similars dors d'objectes; amb el polimorfisme es poden crear i gestionar f\u00e0cilment estructures de dades heterogenis que s\u00f3n f\u00e0cils de dissenyar i dibuixar, sense perdre la comprovaci\u00f3 de tipus dels elements utilitzats. - Gesti\u00f3 d'una jerarquia de classes. S\u00f3n col\u00b7leccions de classes altament estructurades amb relacions d'her\u00e8ncia que es poden estendre f\u00e0cilment.</p>"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#metodes-no-derivables-atribut-final","title":"M\u00e8todes no derivables: atribut final","text":"<p>Al context de l\u2019her\u00e8ncia, la paraula reservada final, s\u2019utilitza per protegir la redefinici\u00f3 dels m\u00e8todes de la classe base; un m\u00e8tode que t\u00e9 l\u2019atribut final, no pot tornar a definir-se a la o les classes derivades</p>"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#interficies","title":"Interf\u00edcies","text":"<p>Una interf\u00edcie en Java, \u00e9s sint\u00e0cticament similar a una classe abstracta, en la qual pot especificar un o m\u00e9s m\u00e8todes que no tenen cos. Aquests m\u00e8todes han de ser implementats per una classe perqu\u00e8 es defineixen les seues accions.</p> <p>Per tant, una interf\u00edcie especifica qu\u00e8 s'ha de fer, per\u00f2 no com fer-ho. Una vegada que es defineix una interf\u00edcie, qualsevol quantitat de classes pot implementar-la. A m\u00e9s, una classe pot implementar qualsevol quantitat d'interf\u00edcies.</p> <p>Per implementar una interf\u00edcie, una classe ha de proporcionar cossos (implementacions) per als m\u00e8todes descrits per la interf\u00edcie. Cada classe \u00e9s lliure de determinar els detalls de la seva pr\u00f2pia implementaci\u00f3. Dues classes poden implementar la mateixa interf\u00edcie de diferents maneres, per\u00f2 cada classe encara admet el mateix conjunt de m\u00e8todes. Per tant, el codi que t\u00e9. Her\u00e8ncia, polimorfisme i Interf\u00edcies coneixement de la interf\u00edcie pot usar objectes de qualsevol classe, ja que la interf\u00edcie amb aquests objectes \u00e9s la mateixa.</p>"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#implementacio-duna-interficie","title":"Implementaci\u00f3 d'una interf\u00edcie","text":"<p>La interf\u00edcie especifica el comportament com\u00fa que tenen un conjunt de dades el qual es realitza en cadascuna d\u2019elles i es coneix tamb\u00e9 com a implementaci\u00f3 d\u2019una interf\u00edcie. La sintaxis \u00e9s similar a la derivaci\u00f3 o extensi\u00f3 d\u2019una classe amb la paraula reservada implements en llo d\u2019extends.</p> <p><pre><code>Class nomClasse implements nomInterficie {\n// definici\u00f3 d\u2019atributs\n// implementaci\u00f3 dels m\u00e8todes de la classe\n// implementaci\u00f3 dels m\u00e8todes de la interf\u00edcies\n}\n</code></pre> La classe que implementa la interf\u00edcie ha d\u2019especificar el codi (la implementaci\u00f3) de cadascun dels m\u00e8todes, en cas de no fer-ho, la classe es. Her\u00e8ncia, polimorfisme i Interf\u00edcies converteix en abstracta i com a tal s\u2019ha de declarar. \u00c9s a dir, si una classe implementa una interf\u00edcie, est\u00e0 obligada a implementar tots els seus m\u00e8todes.</p> <p>Per tal d\u2019il\u00b7lustrar amb un exemple sobre una interf\u00edcie, utilitzarem un comandament a dist\u00e0ncia de qualsevol dispositiu electr\u00f2nic. Es suposa que des d\u2019un comandament a dist\u00e0ncia podrem: encendre i apagar el dispositiu, pujar i baixar el volum, silenciar etc..</p> <p>La nostra interf\u00edcie creada amb Java podria ser com la seg\u00fcent:</p> <pre><code>public class Comandament {\nvoid engegar ();\nvoid apagar ();\nvoid pujarVolum(int increment);\nvoid baixarVolum(int decrement);\nvoid silenciar();\n}\n</code></pre> <p>Els m\u00e8todes declarats ac\u00ed a la interf\u00edcie Comandament deurien ser autoexplicatoris. Hem incl\u00f2s nom\u00e9s unes poques de les m\u00faltiples accions que es poden realitzar amb un comandament a dist\u00e0ncia d\u2019un dispositiu electr\u00f2nic i encara se li podrien afegir algunes m\u00e9s ben segur. </p> <p>No hi ha definici\u00f3 de cap dels m\u00e8todes ac\u00ed, Els m\u00e8todes declarats en una interf\u00edcie s\u00f3n sempre abstractes i sempre p\u00fablics per defecte. Ara qualsevol classe que necessite de l\u2019\u00fas de la funcionalitat prove\u00efda per Comandament nom\u00e9s ha de delcarar que implementa la interficie a m\u00e9s a m\u00e9s de definir cadascun dels m\u00e8todes que la formen. </p> <p>Posem per exemple una televisi\u00f3, el codi Java seria el seg\u00fcent:</p> <pre><code>public class TV implements comandament {\npublic void engegar () {\n// Codi necessari per engegar la televisi\u00f3\n}\npublic void apagar () {\n// Codi necessari per apagar la televisi\u00f3\n}\n\npublic void pujaVolum (int increment) {\n// Codi necessari per incrementar el volum en increment\n}\n\npublic void baixaVolum (int increment) {\n// Codi necessari per disminuir el volum en increment\n}\n\npublic void silenciar () {\n// Codi necessari per silenciar la televisi\u00f3\n}\n}\n</code></pre>"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#jerarquia-dinteficies","title":"Jerarquia d'intef\u00edcies","text":"<p>Les interf\u00edcies tamb\u00e9 es poden organitzar de forma jerarquica de manera que els m\u00e8todes siguen heredats</p> <pre><code>interficie extends interficie2 extends interficie3...\n</code></pre>"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#herencia-de-classes-i-implementacio-dinterficies","title":"Her\u00e8ncia de classes i implementaci\u00f3 d'interf\u00edcies","text":"<p>es interf\u00edcies no s\u00f3n classes ja que especifiquen un comportament mitjan\u00e7ant m\u00e8todes per la classe que els implemente; per aix\u00f2, una classe pot heretar de la seua classe base i al mateix temps implementar una interf\u00edcie. Per exemple si tenim una classe base anomenada Electrodom\u00e8stic de la qual hereten una s\u00e8rie de classes com podrien ser: Televisi\u00f3, DVD, Microones, Forn, Nevera etc..i a m\u00e9s a m\u00e9s tamb\u00e9 disposem d\u2019una interf\u00edcie Comandament,  podr\u00edem crear una aplicaci\u00f3 en la que la televisi\u00f3 herete de la classe general electrodom\u00e8stic i a banda implemente la interf\u00edcie comandament com hem vist abans.</p> <pre><code>public class Televisio extends Electrodomestic implements comandament { ... }\n</code></pre>"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#classes-internes","title":"Classes internes","text":"<p>Una classe interna \u00e9s una classe que es declara dintre d\u2019una altra classe.</p>"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/","title":"Tema 8. Entrada, eixida i excepcions","text":""},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#introduccio","title":"Introducci\u00f3","text":"<p>Una part important de tot llenguatge de programaci\u00f3 \u00e9s com s\u2019establir\u00e0 el contacte amb l\u2019exterior, b\u00e9 siga mitjan\u00e7ant la consola o a trav\u00e9s del sistema de fitxers, per finalment poder actuar amb l\u2019usuari d\u2019una aplicaci\u00f3 en execuci\u00f3. Ambd\u00f3s, consola i sistema de fitxers, poden funcionar tant d\u2019entrada als nostres programes com d\u2019eixida.</p> <p>Java defineix una abstracci\u00f3, els streams o fluxos per tractar la comunicaci\u00f3 d\u2019informaci\u00f3 amb l\u2019exterior. Per entendre-ho millor, un stream o flux \u00e9s com un canal de comunicaci\u00f3 entre un origen i un dest\u00ed. Per exemple suposem el cas d\u2019un programa que quan arranque haja de llegir una llista de clients d\u2019un fitxer de text per crear una agenda. En aquest cas l\u2019origen seria el fitxer de text i el dest\u00ed el programa o aplicaci\u00f3 que s\u2019encarrega d\u2019emplenar l\u2019agenda amb el llistat de clients, doncs b\u00e9, l\u2019stream en aquest escenari seria el canal de comunicaci\u00f3 que s\u2019establiria entre el fitxer de text i el programa per tal que aquest puga llegir la informaci\u00f3.</p> <p></p> <p>A la imatge anterior es poden observar dos tipus de fluxos de dades: El primer \u00e9s un flux d'entrada de dades, s'enten d'entrada perqu\u00e8 va del sistema de fitxers al programa, mentre que el segon representa un flux de dades d'eixida, ja que aquest va del programa al sistema de fitxers.</p> <p>En aquest tema explicarem com Java tracta mitjan\u00e7ant objectes l\u2019establiment d'aquests canals de comunicaci\u00f3 i quines s\u00f3n les operacions que hi podem fer i com s\u2019han d\u2019utilitzar aquestes abstraccions de Java. D\u2019altra banda Java tamb\u00e9 ofereix el mecanisme d\u2019excepcions per controlar els errors sobrevinguts. Una excepci\u00f3 \u00e9s un problema que es produeix en temps d\u2019execuci\u00f3. Java permet controlar aquests problemes i programar amb els try...catch la soluci\u00f3 als errors en temps d\u2019execuci\u00f3.</p>"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#entrada-i-eixida-basiques","title":"Entrada i eixida b\u00e0siques","text":"<p>Com hem dit abans, Java organitza la entrada i eixida mitjan\u00e7ant l\u2019\u00fas d\u2019streams, que s\u00f3n abstraccions en realitat, i aquests streams el que fan es transportar la informaci\u00f3 del programa o aplicaci\u00f3 a dispositius externs. Aquests dispositius externs poden ser b\u00e9 fitxers o incl\u00fas la consola, que es tractada com un fitxer per Java.</p>"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#flux-i-jerarquia-de-classes","title":"Flux i jerarquia de classes","text":"<p>Com que les possibilitats que tenim en programaci\u00f3 respecte de l\u2019\u00fas de fitxers \u00e9s ampla, podem: llegir de fitxers, escriure en fitxers, llegir per una entrada com un teclat System.in o escriure en una eixida com un monitor System.out, Java en primera inst\u00e0ncia distingeix entre dos tipus de fluxos: flux de bytes i flux de caracters</p> E/S Bytes Caracters Flux entrada InputStream Reader Flux eixida OutputStream Writer <p>Java declara quatre classes abstractes, \u00e9s a dir, que no podem instanciar cap objectes d'aquestes classes, que deriven directament de la superclasse \u00abObject\u00bb que s\u00f3n: InputStream, OutputStream, Reader i Writer.</p> <p>InputStream \u00e9s la base per a totes les classes definides per al flux d\u2019entrada de dades a nivell de bytes. A la imatge seg\u00fcent es mostren totes les classes que deriven d'InputStream.  De totes les classes derivades de la classe abstracta InputStream, veurem amb m\u00e9s detal les seg\u00fcents: FileInputStream, DataInputStream i ObjectInputStream.</p> <p></p> <p>OutputStream \u00e9s la classe base per a les classes que gestionen el flux d\u2019eixida a nivell de bytes. A la imatge seg\u00fcent es poden observar totes les seues classes derivades. Pel que fa a aquesta classe abstracta, veurem amb m\u00e9s detall: FileOutputStream, DataOutputStream, PrintStream i ObjectOutputStream.</p> <p></p> <p>Reader \u00e9s la classe per llegir streams a nivell de caracter. Observa les classes derivades a la imatge seg\u00fcent. D'aquesta classe abstracta veurem amb m\u00e9s detall: BufferedReader, InputStreamReader, FileReader</p> <p></p> <p>Writer \u00e9s la classe per escriure a streams a nivell de caracter i les classes que deriven d'ell s\u00f3n les que es poden veure a la seg\u00fcent imatge. De totes les derivades ens centrarem en: OutputStreamWriter, FileWriter, BufferedWriter i PrintWriter.</p> <p></p>"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#consola","title":"Consola","text":"<p>Una de les possibilitats de realitzar l'entrada eixida a un programa \u00e9s mitjan\u00e7ant la consola, on d'una banda es pot escriure i mostrar missatges i d'altra banda l'usuari pot introduir informaci\u00f3.</p>"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#utilitzant-bufferedreader","title":"Utilitzant BufferedReader","text":"<p>BufferedReader \u00e9s una classe derivada de la classe abstracta Reader que es troba dins del paquet java.io. A l'exemple seg\u00fcent es mostra com podem utilitzar aquesta classe.</p> <pre><code>import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamRader;\n\nBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\ntry {\nString strName = reader.readLine();\nSystem.out.println(\"Hola: \" + strName + \"!\");\n} catch (IOException e) {\nSystem.out.println(\"S'ha produit un error: \" + e.getMessage());\n} finally() {\nreader.close(); // \u00c9s molt important tancar els streams\n}\n</code></pre> <p>Consideracions de l'exemple anterior:</p> <ul> <li>S'han d'importar les llibreries necess\u00e0ries per poder utilitzar les classes necess\u00e0ries.</li> <li>Per instanciar un objecte de la classe BufferedReader, el constructor necessita que se li passe un objecte de tipus InputStreamReader que apunte al flux d'entrada predefinit System.in (el teclat)</li> <li>Tota instrucci\u00f3 relacionada amb els streams, s'han de posar dins d'un bloc try..catch.</li> </ul>"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#utilitzant-scanner","title":"Utilitzant Scanner","text":"<p>L'altra alternativa, m\u00e9s comoda al meu entendre, \u00e9s l'\u00fas de la classe Scanner. Aquesta classe es troba dins del paquet java.util i \u00e9s una derivada de la classe arrel Object. Observa l'exemple seg\u00fcent d'\u00fas de la classe Scanner:</p> <pre><code>import java.util.Scanner;\n\nSystem.out.println(\"Per favor escriu el teu nom i prem Intro\");\nScanner scanner = new Scanner(System.in);\nString strName = scanner.nextLine();\n\nSystem.out.println(\"Hola: \" + strName + \"!\");\n</code></pre> <p>Algunes consideracions:</p> <ul> <li>S'han d'importar les llibreries necess\u00e0ries per poder utilitzar les classes necess\u00e0ries.</li> <li>Per instanciar un objecte de la classe Scanner, el constructor necessita que se li passe un flux d'entrada com pot ser: System.in (el teclat)</li> <li>A difer\u00e8ncia del BufferedReader no \u00e9s necessari posar el codi dins del bloc try..catch</li> </ul> <pre>\nActivitat 1. Entrada i eixida per consola.\nSeguint els exemples anteriors, crear un nou projecte en Eclipse que et demane el nom per consola i despr\u00e9s mostre el missatge: \"Hola *nom*\". Has de fer el mateix dues vegades: una utilitzant el **BUfferedReader** i l'altre amb la classe **Scanner**.\n</pre>"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#flux-darxius","title":"Flux d'arxius","text":"<p>Un arxiu o fitxer \u00e9s un conjunt de bytes que s\u00f3n emmagatzemats en un dispositiu. Un arxiu o fitxer es identificat per un nom i la descripci\u00f3 de la carpeta o directori (la ruta) que el cont\u00e9. Una de les principals finalitats dels arxius \u00e9s tindre desats en mem\u00f2ria secund\u00e0ria, quan les aplicacions ja han acabat d\u2019executar-se, i que siguen recuperables despr\u00e9s.</p> <p>Un fitxer s\u2019ha de poder llegir, actualitzar, esborrar registres i tornar a guardar-se de nou amb tots els canvis realitzats. Segons el dispositiu f\u00edsic que els emmagatzeme, els arxius poden ser directes o seq\u00fcencials, el primer implica que per poder accedir a qualsevol registre, hem de passar pr\u00e8viament pels anteriors, per exemple una cinta magn\u00e8tica, mentre que el segon tipus d\u2019arxiu permet l\u2019acc\u00e9s directe al registre en q\u00fcesti\u00f3 sense haver de passar pels anteriors. </p> <p>En Java un arxiu \u00e9s una seq\u00fcencia de bytes que contenen la informaci\u00f3 emmagatzemada. Per poder treballar amb aquestes seq\u00fcencies de bytes, Java disposa de classes com s\u00f3n els tipus b\u00e0sics (int, double, string..). D\u2019una altra banda, com ja hem explicat abans, un flux \u00e9s una abstracci\u00f3 que es refereix a una corrent (stream) de dades entre un origen (tamb\u00e9 conegut com a font o productor) i una destinaci\u00f3 o embornal (consumidor) i la connexi\u00f3 que existeix entre els dos tamb\u00e9 es coneix com a pipe o tub per on circules les dades.</p> <p>Quan comen\u00e7a qualsevol execuci\u00f3 d\u2019un programa Java, es creen tres objectes flux, canals pels que pot fluir informaci\u00f3 d\u2019entrada o eixida; aquests objectes estan definits a la classe System i s\u00f3n:</p> <ul> <li>Sytem.in: entrada est\u00e0ndard, permet l\u2019entrada de dades des del teclat.Una excepci\u00f3 \u00e9s un fallo que es produeix en temps d\u2019execuci\u00f3. Classe InputStream</li> <li>System.out: eixida est\u00e0ndard, permet la programa imprimir per pantalla. Classe PrintStream</li> <li>System.err: eixida d\u2019errors, permet al programa imprimir errors per pantalla Per defecte sol ser la mateixa eixida que System.out. Classe PrintStream</li> </ul>"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#class-file","title":"Class File","text":"<p>Per poder identificar d\u2019un fitxer al sistema de fitxers de qualsevol sistema operatiu, necessitem: nom i ruta. Per exemple \u2018/user/data/file.txt\u2019. El fitxer es diu file.txt i la ruta en la qual es troba \u00e9s \u2018/user/data/\u2019. Aquest identificador de fitxer \u00e9s el que es passa al constructor de la classe per tal d\u2019obrir un flux.</p> <pre><code>File fitxer = new File ( strPath + \"prova.txt\");\n// Fes el que vullgues fer amb el fitxer\n</code></pre> <p>En l\u2019exemple anterior hem utilitzat la classe File per tal d\u2019instanciar un stream al fitxer que li hem passat per par\u00e0metre \u00abprova.txt\u00bb. Compte que s\u2019ha de passar la ruta absoluta d\u2019on es troba el fitxer.</p> <p>Hi ha alternatives al constructor de la classe File que hem mostrat a l\u2019exemple anterior, es pot construir tamb\u00e9 amb dos par\u00e0metres: ruta i nom del fitxer o incl\u00fas indicar-li la ruta mitjan\u00e7ant un altre objecte File.</p> <p>Els m\u00e8todes de la classe File s\u00f3n:</p> M\u00e8tode Explicaci\u00f3 public bolean exists() Torna true si el fitxer existeix public boolean canWrite() Torna true si es pot escriure al fitxer public boolean canRead() Torna true si es nom\u00e9s de lectura public boolean isFile() Torna true si \u00e9s un fitxer public boolean isDirectory() Torna true si \u00e9s un directori public boolean isAbsolute() Torna true si el directori t\u00e9 ruta completa public long lenght() Torna la mida en bytes del fitxer public long lastModified() Torna el timestamp de l\u2019\u00faltima modificaci\u00f3 public String getName() Torna una string amb el nom del fitxer public String getPath() Torna una string amb el path del fitxer public String getAbsolutePath() Torna la ruta absoluta del fitxer public boolean setReadOnly() Converteix el fitxer en nom\u00e9s lectura public boolean delete() Elimina el fitxer o directori (si est\u00e0 buit) public boolean renameTo(File nou) Canvia el nom pel del fitxer nou public boolean mkdir() Crea el directori del fitxer public String[] list() Torna un array d\u2019strings dels elements <pre>\nActivitat 2. Class File\nCrea un projecte en Eclipse que obriga un fitxer de prova qualsevol, per exemple: prova.txt. Llegeixca l\u00ednia a l\u00ednia el contingut del fitxer i el mostre per pantalla.\n</pre> <p>Fins ara hem vist com llegir i escriure per consola, la forma m\u00e9s senzilla \u00e9s utilitzant la classe Scanner i tamb\u00e9 com obrir i treballar amb fitxers utilitzant la classe File. A continuaci\u00f3 estudiarem amb m\u00e9s detall les diferents classes que disposa Java pel tractament de l'entrada i eixida d'informaci\u00f3. Per tal entendre-ho millor, dividirem aquesta secci\u00f3 en dos blocs: Tractament a nivell de byte amb les classes abstractes InputStream i OutputStream i les seues classes derivades i tractament a nivell de caracter amb les classes abstraces Writer i Reader i les seues subclasses.</p>"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#flux-de-dades-a-nivell-de-byte","title":"Flux de dades a nivell de byte","text":"<p>Com ja hem explicat abans, el tractament de l'entrada eixida en java a nivell de bytes es fa amb les classes abstractes InputStream i OutputStream de les quals deriven les classes: </p> <ul> <li>FileInputStream i FileOutputStream</li> <li>PipedInputStream i PipedOutputStream </li> <li>FilterInputStream i FilterOutputStream</li> <li>ByteArrayInputStream i ByteArrayOutputStream</li> <li>ObjectInputStream i ObjectOutputStream, etc.. </li> </ul>"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#fileinputstream-i-fileoutputstream","title":"FileInputStream i FileOutputStream","text":"<p>Tot arxiu es pot considerar en s\u00ed mateix una seq\u00fc\u00e8ncia de bytes de baix nivell i despr\u00e9s sobre aquesta informaci\u00f3 es pot construir informaci\u00f3 de mes alt nivell per tal de processar dades m\u00e9s complexes des de tipus b\u00e0sic fins objectes. </p> <p>En altres paraules, si volem obrir un flux de dades a un fitxer o arxiu i volem llegir byte a byte per despr\u00e9s decidir nosaltres a nivell de programaci\u00f3 que volem fer amb aquests bytes, haur\u00edem d\u2019utilitzar aquestes classes.</p> <p><pre><code>FileInputStream fen = new FileInputStream(strPath + \"provat.txt\");\n// Fem el que hem de fer amb le fitxer i despr\u00e9s s'ha de tancar\nfen.close();\n</code></pre> La classe FileInputStream s\u2019utilitza per llegir bytes o grups de bytes del fitxer associat. Tots els m\u00e8todes tenen visibilitat p\u00fablica i s\u2019ha de tenir en compte quina \u00e9s l\u2019excepci\u00f3 que llencen per controlar els possibles errors en temps d\u2019execuci\u00f3.</p> M\u00e8tode Explicaci\u00f3 FileOutputStream(String nombre) throws IOException; Crea un objecte inicialitzat amb el nom d\u2019arxiu que es passa com argument FileOutputStream(String nombre, boolean sw) throws IOException; Crea un objecte inicialitzat amb el nom d\u2019arxiu que es passa per par\u00e0metre. Si sw \u00e9s true els nous bytes s\u2019afegeixen al final FileOutputStream(File nombre) throws IOException; Crea un objecte inicialitzat amb l\u2019objecte file que es passa per par\u00e0metre void write(byte a) throws IOException; Escriu el byte \u2018a\u2019 al flux associat void write(byte[] s) throws IOException; Escriu l\u2019array de bytes \u2018s\u2019 al flux void write(byte[] s, int org, int len) throws IOException; Llig una seq\u00fc\u00e8ncia de bytes del flux i la desa a \u2018s\u2019 comen\u00e7ant per \u2018org\u2019 i una mida de \u2018len\u2019. Torna -1 si arriba al final del fitxer void close()throws IOException; Tanca el flux i el fitxer queda lliure per al seu \u00fas posterior"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#exemple","title":"Exemple","text":"<p>A continuaci\u00f3 obrirem el fitxer \u00abprova.txt\u00bb amb un FileInputStream per llegir-lo i desarem el seu contingut a un fitxer d\u2019eixida \u00abresultat.txt\u00bb que obirem amb un FileOutputStream. Al fitxer d\u2019eixida, bolcarem el contingut de \u00abprova.txt\u00bb</p> <pre><code>try {\nFileInputStream fen = new FileInputStream(strPath + \"prova.txt\");\nFileOutputStream fout = new FileOutputStream(strPath + \"resultat.txt\");\n\nint byteLlegit = fen.read();\nwhile ( byteLlegit != -1 ) {\nfout.write(byteLlegit);\nbyteLlegit = fen.read();\n}\nfen.close();\nfout.close();\n}\ncatch (FileNotFoundException f ) {\nSystem.out.println(\"Fitxer no trobat\");\n}\ncatch (IOException e) {\nSystem.out.println(\"Error d'entrada eixida\");\n}\n</code></pre> <pre>\nActivitat 3. Copiar invertit\nBasat en el codi anterior i fes que al fitxer resultat, el d\u2019eixida, es copie el que apareix a \u00abprova.txt\u00bb, el d\u2019entrada per\u00f2 a l\u2019inrev\u00e9s. Per exemple:\n</pre> <p>Un possible resultat de l'activitat anterior podria ser el que es pot observar a la imatge seg\u00fcent:</p> <p></p>"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#datainputstream-i-dataoutputstream","title":"DataInputStream i DataOutputStream","text":"<p>La veritat \u00e9s que treballar amb bytes quan estem parlant de fitxers o arxius que contenen informaci\u00f3 o dades de m\u00e9s nivell pot resultar incomode, ja que entre altres haur\u00edem de saber quants bytes t\u00e9 un car\u00e0cter, un enter o un doble. </p> <p>En Java tenim les classes DataInputStream i DataOutputStream que s\u00f3n subclasses de les classes FilterInputStream i FilterOutputStream. </p> <p>Abans d'entrar en el detall d'aquetes classes, veurem amb m\u00e9s profunditat que s\u00f3n les classes FilterInputStream i FilterOutputStream. Aquestes dues classes deriven de les classes abstractes InputStream i OutputStream. B\u00e0sicament el que fan es sobreescriure tots els m\u00e8todes de les seues super classes i permeten agrupar bytes (Input) i desagrupar-lo(Output) de tal forma que classes derivades seues podran treballar amb informaci\u00f3 de m\u00e9s alt nivell.</p> <p>Per tal d'instanciar un objecte de la classe DataInputStream d'on es podria llegir, ho fariem de la seg\u00fcent manera:</p> <pre><code>FileInputStream gs = new FileInputStream(strPath + \"prova.txt\");\nDataInputStream ent = new DataInputStream(gs);\n// Treballem amb ells i com passava amb els streams anteriors tamb\u00e9 els hem de tancar\ngs.close();\nent.close();\n</code></pre> <p>Observa el codi anterior: Primer s'instancia un objecte de la classe FileInputStream (derivada de InputStream) en la que se li indica la ruta del fitxer amb el que volem treballar. Despr\u00e9s aquest objecte FileInputStream s'utilitza per poder instanciar un objecte de la classe DataInputStream que utilitzarem per llegir tipus de dades primitius del fitxer.</p> <p>B\u00e0sicament aquestes classes el que fan \u00e9s organitzar els bytes en tipus primitius de tal forma que ja podem treballar llegint i escrivint als fluxos: enters, car\u00e0cters, reals, cadenes etc..</p> M\u00e8tode Explicaci\u00f3 public DataInputStream(InputStream entrada) throws IOException Crea un objecte associat a l\u2019stream que es passa per par\u00e0metre public final boolean readBoolean() throws IOException Torna el valor de tipus boole\u00e0 llegit public final byte readByte() throws IOException Torna el valor de tipus byte llegit public final short readShort() throws IOException Torna el valor de tipus short llegit public final char readChar() throws IOException Torna el valor de tipus char llegit public final int readInt() throws IOException Torna el valor de tipus int llegit public final long readLong() throws IOException Torna el valor de tipus long llegit public final float readFloat() throws IOException Torna el valor de tipus float llegit public final double readDouble() throws IOException Torna el valor de tipus double llegit public final String readUTF() throws IOException Torna una cadena que es va escriure en UTF <p>D\u2019aquesta forma ja no ens hem de preocupar de saber quants bytes de mem\u00f2ria s\u2019han de reservar per un car\u00e0cter o un enter. Per exemple si associem  un DataOutputStream a un fitxer i despr\u00e9s cridem al m\u00e8tode writeInt, realment el que s\u2019est\u00e0 fent \u00e9s escriure 4 bytes d\u2019informaci\u00f3 al fitxer de la qual cosa s\u2019estaria encarregant de manera transparent a l\u2019usuari.</p> <p>Per tal d'instanciar un objecte de la classe DataOutputStream, on es podria escriure, ho fariem de la seg\u00fcent forma:</p> <pre><code>FileOutputStream fn = new FileOutputStream(strPath + \"result.txt\");\nDataOutputStream snb = new DataOutputStream(fn);\n// Treballem amb ells i tanquem.\nfn.close();\nsnb.close();\n</code></pre> <p>Al contrari que passava amb el DataInputStream, al codi anterior estem instanciant un objecte de la classe DataOutputStream que utlitzarem per escriure la informaci\u00f3 desitjada.</p> M\u00e8tode Explicaci\u00f3 public DataOutputStream(OutputStream destino) throws IOException Crea un objecte associat a l\u2019out11putstream que es passa per par\u00e0metre public final void writeBoolean(boolean v) throws IOException Escriu un boolean public final void writeByte(int v) throws IOException Escriu un byte public final void writeShort(int v) throws IOException Escriu un short public final void writeChar(int v) throws IOException Escriu un char public final void writeChars(String v) throws IOException Escriu tots els chars que cont\u00e9 la String v public final void writeInt(int v) throws IOException Escriu un int public final void writeLong(long v) throws IOException Escriu un long public final void writeFloat(float v) throws IOException Escriu un float public final void writeDouble(double v) throws IOException Escriu un double public final void writeUTF(String cad) throws IOException Escriu la cadena cad en format UTF public final int close()throws IOException Tanca el flux <p>Un altre exemple d'\u00fas del DataInputStream:</p> <pre><code>InputStream input = new FileInputStream(\"datastreamdemo.txt\");\nDataInputStream inst = new DataInputStream(input);\nint count = input.available();\nbyte[] arr = new byte[count];\ninst.read(arr);\nfor (byte byt : arr) {\nchar ki = (char) byt;\nSystem.out.print(ki+\"-\");\n}\n</code></pre> <p>A continuaci\u00f3 podem veure un exemple en el que fem \u00fas del DataOutputStream i DataInputStream. El que fa aquest exemple \u00e9s escriure a un fitxer d\u2019eixida \u00abpluges.dat\u00bb dos valors double aleatoris per despr\u00e9s llegir-los amb un DataInputStream i mostrar-los per pantalla. </p> <p>El codi podria ser el seg\u00fcent:</p> <pre><code>try {\nFileOutputStream fos = new FileOutputStream(strPath + \"pluges.dat\");\nDataOutputStream dos = new DataOutputStream(fos);\n\ndouble info  Math.random()*100;\ndos.writeDouble(info);\n\nFileInputStream fis = new FileInputStream(strPath + \"pluges.dat\");\nDataInputStream dis = new DataInputStream(fis);\n\ndouble info2 = dis.readDouble();\nSystem.out.println(\"Primer valor: \" + info2);\ninfo2 = dis.readDouble();\nSystem.out.println(\"Segon valor: \" + info2);\n\nfos.close();\ndos.close();\nfis.close();\ndis.close();\n}\ncatch (FileNotFoundException e) {\nSystem.out.println(\"El fitxer no existeix\");\n}\ncatch (IOException e) {\nSystem.out.println(\"Error IO inesperat\");\n}\n</code></pre> <pre>\nActivitat 4. Data Iput i Data Output\nCrea un projecte en Eclipsei copia el codi anterior i una vegada acabada l'execuci\u00f3 del programa, obre el fitxer \"pluges.dat\" i compara el que s'ha mostrat a consola amb el que s'ha gravat al fitxer. Posa el mateix? Per qu\u00e8?\n</pre>"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#printstream","title":"PrintStream","text":"<p>La classe PrintStream deriva de FilterOutputStream i el valor afegit d\u2019aquesta classe derivada \u00e9s que permet afegir el car\u00e0cter final de l\u00ednia als fitxers. Aquests tipus de fluxos s\u00f3n sempre d\u2019eixida i s\u2019associen a un altre flux de bytes de m\u00e9s baix nivell. System.out \u00e9s un objecte de tipus PrintStream.</p> <p>System.out \u00e9s un clar exemple de PrintStream</p> <pre><code>PrintStream ps = new PrintStream(new FileOutputStream(\"Complex.dat\"));\n// Treballem i tanquem\nps.close();\n</code></pre> M\u00e8tode Explicaci\u00f3 public PrintStream(OutputStream destino) Crea un objecte associat a qualsevol objecte d\u2019eixida per par\u00e0metre public PrintStream(OutputStream destino, boolean flag) Crea un objecte associat a qualsevol objecte d\u2019eixida per par\u00e0metre. Si flag \u00e9s true, es produeix un bolcat autom\u00e0tic al escriure final de l\u00ednia. public void flush() Bolca el flux actual ublic void print(Object obj) Escriu la representaci\u00f3 de l\u2019objecte obj al flux public void print(String cad) Escriu la cadena al flux public void print(char c) Escriu un car\u00e0cter al flux public void println(Object obj) Escriu la representaci\u00f3 de l\u2019objecte al flux i final de l\u00ednia public void println(String cad) Escriu la cadena al flux i final de l\u00ednia <p>Observa el codi seg\u00fcent. Utilitzant la classe PrintStream s'obre un fitxer 'output.txt' dintre del qual s'escriur\u00e0 una sola cadena de caracters 'data' i despr\u00e9s es tancar\u00e0 l'stream una vegada finalitzat l'execuci\u00f3 del codi.</p> <pre><code>import java.io.PrintStream;\n\nclass Main {\npublic static void main(String[] args) {\n\nString data = \"Text que volem escriure dintre del fitxer\";\n\ntry {\nPrintStream output = new PrintStream(\"output.txt\");\n\noutput.print(data);\noutput.close();\n}\ncatch(Exception e) {\ne.getStackTrace();\n}\n}\n}\n</code></pre> <pre>\nActivitat 5\nUtilitzant la classe Scanner que hem vist abans, has de fer una aplicaci\u00f3 en Eclipse IDE que tot all\u00f2 que llegeixca per teclat o guarde en un fitxer de text juntament amb l'hora a la qual s'ha escrit. Per exemple, si l'usuari escriu per pantalla el seu nom, \"Manolo\" i prem Intro, al fitxer d'eixida s'hauria de gravar: \n\n  [09:05:25] - Manolo\n\nHas d'utilitzar la classe PrintStream per fer aquesta activitat.\n</pre>"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#flux-de-dades-a-nivell-de-caracter","title":"Flux de dades a nivell de caracter","text":"<p>Una altra forma de poder treballar amb fitxers en lloc de a nivell de byte com estavem fent als apartats anteriors, \u00e9s fer-ho a nivell de caracter. Al cap i a la fi els arxius, en una gran majoria, solen ser seq\u00fc\u00e8ncies de caracters i des del punt de vista l\u00f2gic ens resulta m\u00e9s natural treballar amb ells a aquest nivell.</p>"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#reader-i-writer","title":"Reader i writer","text":"<p>Els arxius de text s\u00f3n arxius de car\u00e0cters, es poden crear fluxos de bytes o de car\u00e0cters derivats de les classes abstractes Reader i Writer.</p> <p>Els fluxos Reader i Writer s\u00f3n fluxos de Java orientats a car\u00e0cters. Amb aquests fluxos podem llegir i escriure car\u00e0cters o cadenes de car\u00e0cters al dispositius connectats mitjan\u00e7ant aquests fluxos.</p> <p>Per llegir arxius de car\u00e0cters s\u2019utilitzen fluxos derivats de la classe Reader on es declaren o sobreescriuen m\u00e8todes per la lectura de car\u00e0cters. Els m\u00e8todes m\u00e9s importants s\u00f3n:</p> M\u00e9tode Explicaci\u00f3 public int read() Llig un car\u00e0cter en forma d\u2019enter. Si arriba al final del fitxer torna -1 public int read(char [] b) Llig una seq\u00fcencia de car\u00e0cters fins completar l\u2019array b o llegir el final del fitxer. Torna el nombre de car\u00e0cters llegits o -1 si arriba al final de l\u2019arxiu"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#inputstreamreader-i-outputstreamwriter","title":"InputStreamReader i OutputStreamWriter","text":"<p>Els fluxos de la classe IntpuStreamReader envolten (wrap) a un flux de bytes; converteixen la seq\u00fc\u00e8ncia de bytes en seq\u00fc\u00e8ncia de car\u00e0cters i aix\u00ed ja no ho hem de fer nosaltres; la classe deriva directament de Reader, pel que t\u00e9 disponibles els m\u00e8todes read() de la seua classe pare per la lectura de car\u00e0cters</p> <p><pre><code>InputStreamReader ent = new InputStreamReader(Sytem.in);\n// En acabar tanquem l'stream\nent.close();\n</code></pre> La classe OutputStreamWriter que deriva de writer, permet escriure car\u00e0cters en un flux de bytes al qual s\u2019associa la creaci\u00f3 de l\u2019objecte o flux.</p> <p><pre><code>OutputStreamWriter ot = new OutputStreamWriter(new FileOutputStream(arxiu));\n// Despr\u00e9s hem de recordar de tancar l'stream\not.close();\n</code></pre> Els m\u00e8todes de la classe InputStreamReader s\u00f3n:</p> M\u00e9tode Explicaci\u00f3 void close() Tanca el flux i allibera tots els recursos del sistema associats String getEconding() Retorna el nom de la codificaci\u00f3 de car\u00e0cters que utilitza aquest flux int read() Llegeix un sol car\u00e0cter int read(char[] buf, int offset, int length) Llegeix car\u00e0cters en una part d'una matriu boolean ready() Indica si aquest flux est\u00e0 llest per ser llegit <p>Els m\u00e8todes de la classe OutputStreamWriter s\u00f3n:</p> M\u00e9tode Explicaci\u00f3 void close() Tanca el corrent, rentant-lo primer void flush() Redueix el corrent String getEconding() Retorna el nom de la codificaci\u00f3 de car\u00e0cters que utilitza aquest flux void write(char [] buf, int off, int len) Escriu una part d'una matriu de car\u00e0cters void write(int c) Escriu un sol car\u00e0cter void write(String str, int off, int len) Escriu una part d'una cadena <pre>\nActivitat 6\nRepeteix l'activitat anterior, la 5, per\u00f2 utilitzant InputStreamReader i OutputStreamReader\n</pre> <p>Per\u00f2 all\u00f2 normal \u00e9s que no s'utilitzen directament aquestes classes sino que es faja \u00fas de FileReader i FileWriter.</p>"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#filereader-i-filewriter","title":"FileReader i FileWriter","text":"<p>Per llegir arxius de text o de car\u00e0cters es pot crear un flux del tipus FileReader, aquesta classe deriva d\u2019InputStreamReader, hereta els m\u00e8todes read() per a llegir car\u00e0cters, el constructor t\u00e9 com entrada una cadena amb el nom de l\u2019arxiu</p> <p>Per exemple</p> <p><pre><code>FileReader fr = new FileReader(\"cartes.dat\");\nfr.close();\n</code></pre> Els constructors de la classe FileReader s\u00f3n:</p> Constructor Explicaci\u00f3 FileReader(File file) Crea un nou FileReader , amb el nom del fitxer des del qual cal llegir FileReader(FileDescriptor fd) Crea un nou FileReader , donat el FileDescriptor per llegir FileReader(String fileName) Crea un nou FileReader , amb el nom del fitxer des del qual cal llegir <p>Els m\u00e8todes dels que disposa FileReader s\u00f3n:</p> <ul> <li>Heretats de java.io.InputStreamReader: close, getEncoding, read, ready</li> <li>Heretats de java.io.Reader: mark, markSupported, read, reset, skip</li> <li>Heretats de java.lang.Object: clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait</li> </ul> <p>No es freq\u00fcent utilitzar directament fluxos OutputStreamWriter, encara que resulta interessant perqu\u00e8 la classe FileWriter \u00e9s una extensi\u00f3 d\u2019ella. Dissenyada per escriure en un arxiu de car\u00e0cters, els fluxos d\u2019aquest tipus escriuen car\u00e0cters amb el m\u00e8tode write() a l\u2019arxiu al que s\u2019associa el flux quan es crea l\u2019objecte.</p> <p><pre><code>FileWriter nr = new FileWriter(\"cartes.dat\");\nnr.write(\"Frase qualsevol a escriure\");\nnr.close();\n</code></pre> Els constructors de la classe FileWriter s\u00f3n:</p> Constructor Explicaci\u00f3 FileWriter(File file) Construeix un objecte FileWriter donat un objecte File FileWriter(File file, boolean append) Construeix un objecte FileWriter donat un objecte File FileWriter(FileDescriptor fd) Construeix un objecte FileWriter associat a un descriptor de fitxer FileWriter(String fileName) Construeix un objecte FileWriter amb un nom de fitxer FileWriter(String fileName, boolean append) Construeix un objecte FileWriter amb un nom de fitxer amb un boole\u00e0 que indica si s'han d'afegir o no les dades escrites <p>En general no resulta eficient llegir directament d\u2019un flux d\u2019aquest tipus, s\u2019utilitzar\u00e0 un flux BufferedReader</p> <pre>\nActivitat 7\nUtilitzant les classes anteriors, obre un fitxer que continga text, llig tot el seu coningut i enregistra'l a un fitxer d'eixida amb la condici\u00f3 que has de canviar maj\u00fascules per min\u00fascules i a l'inrev\u00e9s des del fitxer d'origen.\n</pre>"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#bufferedreader-i-bufferedwriter","title":"BufferedReader i BufferedWriter","text":"<p>La lectura d\u2019arxius de text es realitza amb un flux que emmagatzema els car\u00e0cters en un buffer intermedi, aquests no es lligen directament de l\u2019arxiu si no del buffer. D\u2019aquesta manera augmentem l\u2019efici\u00e8ncia a les operacions d\u2019entrada, la classe BufferedReader permet crear fluxos de car\u00e0cters amb buffer que no \u00e9s m\u00e9s que una forma d\u2019organitzar el flux b\u00e0sic de car\u00e0cters del que ve  el text perqu\u00e8 al crear un flux BufferReader, aquest s\u2019inicialitza com un flux de car\u00e0cters InputStreamReader o qualsevol altre.</p> <p>El constructor de la classe t\u00e9 un argument de tipus Reader, FileReader o InputStreamReader, el flux creat disposa d\u2019un buffer de grand\u00e0ria suficient, el qual es pot especificar en el constructor amb un segon argument encara que no fa falta. Exemples de fluxos amb buffer.</p> <p>Els m\u00e8todes de la classe BufferedReader s\u00f3n:</p> M\u00e8tode Explicaci\u00f3 void close() Tanca el flux i allibera tots els recursos del sistema associats void mark(int readAheadLimit) Marca la posici\u00f3 actual al flux boolean markSupported() Indica si aquest flux admet l'operaci\u00f3 mark(), que fa read() Llegeix un sol car\u00e0cter int read(char[] cbuf, int off, int len) Llegeix car\u00e0cters en una part d'una matriu String readLine() Llegeix una l\u00ednia de text boolean ready() ndica si aquest flux est\u00e0 llest per ser llegit void reset() Restableix el flux a la marca m\u00e9s recent long skip(long n) Omet personatges <p>Exemple <pre><code>File someFile = new File(...);\nint aCount = 0;\nFileReader fr = new FileReader(someFile);\nBufferedReader br = new BufferedReader(fr);\n\n// Count the number of 'a' characters.\nint ch;\nwhile ((ch = br.read()) != -1) {\nif (ch == 'a') {\naCount++;\n}\n}\nSystem.out.println(\"There are \" + aCount + \" 'a' characters in \" + someFile);\n</code></pre></p> <p>BufferedWriter, per un altre costat, escriu text en un flux de sortida de car\u00e0cters, guarda els car\u00e0cters en mem\u00f2ria interm\u00e8dia (buffer) per tal de proporcionar una escriptura eficient de car\u00e0cters, matrius i cadenes individuals.</p> <p>Es pot especificar la mida de la mem\u00f2ria interm\u00e8dia o es pot acceptar la mida predeterminada. El valor predeterminat \u00e9s prou gran per a la majoria de prop\u00f2sits.</p> <p>Es proporciona un m\u00e8tode newLine(), que utilitza la pr\u00f2pia noci\u00f3 de separador de l\u00ednies de la plataforma tal com es defineix per la propietat del sistema line.separator . No totes les plataformes utilitzen el car\u00e0cter de nova l\u00ednia ('\\n') per acabar les l\u00ednies. Per tant, es prefereix cridar aquest m\u00e8tode per acabar cada l\u00ednia de sortida que escriure directament un car\u00e0cter de nova l\u00ednia.</p> <p>Els m\u00e8todes de la classe s\u00f3n:</p> M\u00e8tode Explicaci\u00f3 void close() Tanca el corrent, rentant-lo primer void flush() Redueix el corrent void newLine() Escriu un separador de l\u00ednies void   write(char[] cbuf, int off, int len) Escriu una part d'una matriu de car\u00e0cters void write(int c) Escriu un sol car\u00e0cter void write(String s, int off, int len) Escriu una part d'una cadena <p>Exemple</p> <pre><code>import java.io.FileWriter;\nimport java.io.BufferedWriter;\n\npublic class Main {\n\npublic static void main(String args[]) {\n\nString data = \"This is the data in the output file\";\n\ntry {\n// Creates a FileWriter\nFileWriter file = new FileWriter(\"output.txt\");\n\n// Creates a BufferedWriter\nBufferedWriter output = new BufferedWriter(file);\n\n// Writes the string to the file\noutput.write(data);\n\n// Closes the writer\noutput.close();\n}\n\ncatch (Exception e) {\ne.getStackTrace();\n}\n}\n}\n</code></pre>"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#printwriter","title":"PrintWriter","text":"<p>Els fluxos m\u00e9s utilitzats en l\u2019eixida de car\u00e0cters s\u00f3n de tipus PrintWriter, aquesta classe declara constructors per associar un flux PrintWriter amb qualsevol altre de tipus Writer o b\u00e9 OutputStream.</p> M\u00e8tode Explicaci\u00f3 public PrintWriter(OutputStream dest\u00ed) Crea un flux associat amb un altre d\u2019eixida a nivell de byte. public PrintWriter(Writer destino) Crea un flux associat amb un altre d\u2019eixida de car\u00e0cters de tipus Writer. <p>La import\u00e0ncia d\u2019aquesta classe radica en que defineix m\u00e8todes print() i println() per cadascun dels tipus de dades simples, per String i per Object; la difer\u00e8ncia entre els m\u00e8todes print() i println() est\u00e0 en que el segon afegeix els car\u00e0cters de final de l\u00ednia a continuaci\u00f3 dels escrits per l\u2019argument. </p> M\u00e8tode Explicaci\u00f3 public void print(Object obj) Escriu la representaci\u00f3 de l\u2019objecte obj al flux public void print(String cad) Escriu la cadena al flux public void print(char c) Escriu el car\u00e0cter c al flux. public void println(Object obj) Escriu la representaci\u00f3 de l\u2019objecte obj al flux i final de l\u00ednia public void println(String cad) Escriu la cadena al flux i el final de l\u00ednia public void println(char c) Escriu el car\u00e0cter c al flux i final de l\u00ednia. <p>Exemple</p> <pre><code>import java.io.PrintWriter;\n\nclass Main {\npublic static void main(String[] args) {\n\nString data = \"This is a text inside the file.\";\n\ntry {\nPrintWriter output = new PrintWriter(\"output.txt\");\n\noutput.print(data);\noutput.close();\n}\ncatch(Exception e) {\ne.getStackTrace();\n}\n}\n}\n</code></pre> <p>Fixa't en l'exemple anterior i fes la seg\u00fcent activitat.</p> <pre>\nActivitat 8\nRepeteix l'activitat 7 per\u00f2 utilitzant les classes PrintWriter i BufferedReader.\n</pre>"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#arxius-dobjectes","title":"Arxius d'objectes","text":"<p>Fins ara hem tractat el tema d'entrada - eixida d'informaci\u00f3 utilitzant els tipus primitius o b\u00e0sics que ens proporciona el llenguatge de programaci\u00f3: int, char, float, String... per\u00f2 que passa si el que volem desar o llegir des d'un dispositiu extern \u00e9s un o diversos objectes? Com es guarden i com es recuperen aquestos objectes?</p> <p>Java proporciona una mecanisme que s'anomena serialitzaci\u00f3 que consisteix en convertir un objecte en una seq\u00fc\u00e8ncia de bytes de tal forma que, ara s\u00ed, es podr\u00e0 desar a un fitxer o un dispositiu extern. El proc\u00e9s de lectura d'un objecte serialitzat a un fitxer, per contra, s'anomena desserialitzaci\u00f3.</p> <p>Per tal que un objecte continue existint, \u00e9s a dir, que siga persistent, una vegada ja hem finalitzat l\u2019execuci\u00f3 d\u2019un programa o aplicaci\u00f3 l\u2019hem de desar a un arxiu d\u2019objectes. Per poder aconseguir a\u00e7\u00f2, utilitzarem les classes ObjectInputStream i ObjectOutputStream</p>"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#classe-dobjecte-persistent","title":"Classe d'objecte persistent","text":"<p>Serialitzaci\u00f3: \u00e9s el proc\u00e9s de convertir un objecte (incloses les refer\u00e8ncies a altres objectes) a una seq\u00fc\u00e8ncia de bytes, aix\u00ed com tamb\u00e9 l'acci\u00f3 de reconstruir eixos bytes en un objecte viu en un futur. La serialitzaci\u00f3 s'utilitza quan vols persistir un objecte, \u00e9s a dir, que dure m\u00e9s que el que dura l'execuci\u00f3 d'un programa o apliaci\u00f3.</p> <p>La declaraci\u00f3 de la classe els objectes de la qual van a ser persistents, han de implementar la interf\u00edcie \u00abserializable\u00bb del paquet java.io, la qual \u00e9s buida, no declara m\u00e8todes, simplement indica a la m\u00e0quina virtual de Java que les inst\u00e0ncies d\u2019aquestes classes podran gravar-se en un fitxer.</p> <p>Exemples</p> <pre><code>class racional implements serializable { ... }\n</code></pre> <pre><code>import java.io.Serializable;\n\npublic class SerialClass implements Serializable {\nprivate static final long serialVersionUID = 1L;\nprivate Date currentTime;\n\npublic SerialClass() {\ncurrentTime = Calendar.getInstance().getTime();\n}\n\npublic Date getCurrentTime() {\nreturn currentTime;\n}\n}\n</code></pre>"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#objectoutputstream","title":"ObjectOutputStream","text":"<p>Els fluxos de la classe ObjectOutputStream s\u2019utilitzen per gravar objectes persistents. El m\u00e8tode writeObject() escriu qualsevol objecte d\u2019una classe serializable en el flux de bytes associat. Pot llen\u00e7ar excepcions del tipus IOException que \u00e9s necessari processar.</p> <pre><code>public void writeObject(Object obj) throws IOException;\n</code></pre> <p>El constructor de la classe espera un argument de tipus OutputStream, que \u00e9s la base dels fluxos d\u2019eixida a nivell de bytes, per tant, per crear aquest tipus de fluxos primer es crea un d\u2019eixida a nivell de bytes associat a un arxiu extern i a continuaci\u00f3, es passa com argument al constructor de ObjectOutputStream, per exemple:</p> <pre><code>FileOutputStream bn = new FileOutputStream(\"dadesRac.dat\");\nObjectOutputStream fobj = new ObjectOuputStream(bn);\nbn.close();\nfobj.close();\n</code></pre> <p>A continuaci\u00f3 es pot escriure qualsevol objecte al flux:</p> <pre><code>Persona juan = new Persona(\"Juan\",\"Martin\", \"123432123X\");\nfobj.writeObject(juan);\nString str = new String (\"Cadena de favors\");\nfobj.write(str);\nfobj.close();\n</code></pre>"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#objectinputstream","title":"ObjectInputStream","text":"<p>El objectes guardats en arxius amb fluxos de la classe ObjectOutputStream es recuperen i lligen amb fluxos d\u2019entrada del tipus ObjectInputStream, aquesta classe \u00e9s una extensi\u00f3 d\u2019InputStream, a m\u00e9s a m\u00e9s, implementa la interf\u00edcie DataInput, per aix\u00f2 disposa de diversos m\u00e8todes d\u2019entrada (read) per cadascun dels tipus de dades com readInt() o altres. El m\u00e8tode m\u00e9s important definit per la classe ObjectInputStream \u00e9s readObject(), el qual llig un objecte del flux d\u2019entrada, \u00e9s a dir, de l\u2019arxiu associat al flux de baix nivell; l\u2019objecte llegit es va escriure en el seu moment amb el m\u00e8tode writeObject()</p> <pre><code>public Object readObject() throws IOException;\n</code></pre> <p>El constructor de fluxos ObjectInputStreeam t\u00e9 com entrada un altre flux de baix nivell de qualsevol tipus derivat d\u2019InputStream, per exemple: FileInputStream associat amb l\u2019arxiu d\u2019objectes. A continuaci\u00f3 es crea un flux d\u2019entrada per llegir els objectes de l\u2019arxiu \u00abarchivoObjects.dat\u00bb</p> <pre><code>ObjectInputStream obj = new ObjectInputStream(new FileInputStream(\"arxiuObjects.dat\"));\nobj.close();\n</code></pre> <p>El constructor llen\u00e7a una excepci\u00f3 si, per exemple, l\u2019arxiu no existeix, aquella \u00e9s del tipus \u00abClassNotFoundException\u00bb o \u00abIOException\u00bb, \u00e9s necessari poder capturar aquestes excepcions</p> <p>Exemple</p> <pre><code>import java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\nclass Dog implements Serializable {\n\nString name;\nString breed;\n\npublic Dog(String name, String breed) {\nthis.name = name;\nthis.breed = breed;\n}\n}\n\nclass Main {\npublic static void main(String[] args) {\n\n// Creates an object of Dog class\nDog dog = new Dog(\"Tyson\", \"Labrador\");\n\ntry {\nFileOutputStream file = new FileOutputStream(\"file.txt\");\n\n// Creates an ObjectOutputStream\nObjectOutputStream output = new ObjectOutputStream(file);\n\n// Writes objects to the output stream\noutput.writeObject(dog);\n\nFileInputStream fileStream = new FileInputStream(\"file.txt\");\n\n// Creates an ObjectInputStream\nObjectInputStream input = new ObjectInputStream(fileStream);\n\n// Reads the objects\nDog newDog = (Dog) input.readObject();\n\nSystem.out.println(\"Dog Name: \" + newDog.name);\nSystem.out.println(\"Dog Breed: \" + newDog.breed);\n\noutput.close();\ninput.close();\n}\n\ncatch (Exception e) {\ne.getStackTrace();\n}\n}\n}\n</code></pre> <pre>\nActitivat 9\nDissenya una aplicaci\u00f3 amb Eclipse IDE on es podr\u00e0 per un costat introduir informaci\u00f3 d'alumnes que es guardaran en un fitxer que s'anomene: 'alumnes.dat'. Al principi l'apliaci\u00f3 llegir\u00e0 de l'arxiu 'alumnes.dat' tots els alumnes inscrits al curs i els mostrar per pantalla, ordenats alfab\u00e8ticament pel congnom. Una vegada haja mostrat tots els alumnes, l'apliaci\u00f3 esperar\u00e0 que s'introduiexca algun alumne nou per consola, una vegada introduits totes les dades de l'alumne, aquesta es guardar\u00e0 en un objecte primer i despr\u00e9s al fitxer 'alumnes.dat' a continuaci\u00f3 dels que ja haiven estat enregistrats. Despr\u00e9s tornar\u00e0 a mostrar els alumnes ordenats alfab\u00e8ticament i torna a comen\u00e7ar.\n</pre>"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#excepcions","title":"Excepcions","text":"<p>Un problema important en el desenvolupament del programari \u00e9s la gesti\u00f3 de les errades o errors. No importa quan b\u00e9 estiga planificat aquest desenvolupament i quan eficient siga l\u2019equip desenvolupador. \u00c9s una m\u00e0xima en inform\u00e0tica el fet que sempre apareixeran problemes. Aquests problemes inesperats s\u00f3n problemes o errors que apareixen en temps d\u2019execuci\u00f3, per exemple: esgotament de mem\u00f2ria o recursos, errors en els intervals dels bucles, divisions per zero, arxius no existents, etc..</p> <p>Les excepcions s\u00f3n el mecanisme previst per Java per tractar aquests problemes sobrevinguts. Amb les excepcions, Java dona la possibilitat al programador salvar aquest tipus de situacions de manera controlada sense que el programa o aplicaci\u00f3 es tanque, bloquege o deixe de respondre.</p>"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#condicions-derrors-en-programes","title":"Condicions d'errors en programes","text":"<p>Programar, escriure codi, m\u00e8todes, classes, etc.. que siga eficient, efica\u00e7 i lliure d\u2019errades \u00e9s altament complicat. El control d\u2019errades \u00e9s una part tant important en el disseny d\u2019aplicacions que a totes les diferents metodologia de cicle de vida software, hi ha una fase que es dedica \u00fanica i exclusivament a detectar aquestes errades i solucionar-les i aix\u00ed i tot \u00e9s impossible produir programari totalment lliure d\u2019errades.</p>"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#tractament-dels-codis-derror","title":"Tractament dels codis d'error","text":"<p>Java inclou un mecanisme de gesti\u00f3 d\u2019excepcions per poder intentat cobrir possibles errades en els programes en temps d\u2019execuci\u00f3. Aquest mecanisme consisteix en capturar (catch) els errors quan es produeixen en temps d\u2019execuci\u00f3.</p> <p>Quan es produeix un fallo en temps d\u2019execuci\u00f3 es podrien fer tres coses: parar l\u2019execuci\u00f3 de sobte, continuar executant esperant que no passe res o establir una senyal d\u2019error que el mateix codi amb altres sent\u00e8ncies s\u2019encarregue de gestionar.</p> <p>Aquestes senyals que envia (throw) el programa quan es produeix alguna errada en Java s\u2019anomenen excepcions i el bloc del codi on es posen les sent\u00e8ncies per tal d\u2019intentar solucionar-lo en temps d\u2019execuci\u00f3 \u00e9s el bloc catch.</p>"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#excepcions-en-java","title":"Excepcions en Java","text":"<p>Una excepci\u00f3 \u00e9s un fallo que es produeix en temps d\u2019execuci\u00f3. Si hem escrit b\u00e9 el codi per tal de gestionar aquest fallo, el flux d\u2019execuci\u00f3 passa al codi destinat a gestionar les excepcions, en cas contrari el programa acaba la seua execuci\u00f3.</p> <p>Aquestes excepcions es poden produir per exemple si intenten accedir a un element d\u2019un array fora dels seus l\u00edmits, si intentem obrir un fitxer que no existeix o est\u00e0 bloquejat, si dividim per zero, etc..</p> <p>El model de gesti\u00f3 d\u2019excepcions a Java afegeix cinc noves paraules reservades: try, throw, throws, catch i finally.</p> <ul> <li>try: bloc on es detectaran les excepcions</li> <li>catch: captura les excepcions que es produiexen al bloc try </li> <li>throw: expressi\u00f3 per llen\u00e7ar excepcions</li> <li>throws: indica les excepcions que pot llen\u00e7ar un m\u00e8tode.</li> <li>finally: bloc opcional situat despr\u00e9s del try catch</li> </ul> <p>Els pasos del model de control d\u2019excepcions en Java s\u00f3n:</p> <ol> <li>El bloc try cont\u00e9 les instruccions o part del codi susceptible de provocar algun error.</li> <li>Si en temps d\u2019execuci\u00f3 es produeix algun error dins de les sent\u00e8ncies que es troben dins del bloc try, es llen\u00e7a una excepci\u00f3.</li> <li>S\u2019executa el codi que es troba dins del bloc catch associat a la excepci\u00f3 que s\u2019ha llen\u00e7at al punt anterior.</li> <li>S\u2019executa el bloc finally (opcional)</li> </ol> <p>Exemple. Suposem una classe persona que incorporarem a la nostra aplicaci\u00f3. Aquesta classe t\u00e9 un constructor al qual se li passa el DNI, imaginem ara que de la nostra aplicaci\u00f3 instanciem un objecte de la classe persona a la qual l direm Joan per\u00f2 quan cridem al constructor de la classe no li passem un DNI, aquest \u00abmal \u00fas\u00bb de la classe Persona, llen\u00e7aria una excepci\u00f3 que hauria de capturar la nostra aplicaci\u00f3 al bloc catch i \u00e9s ac\u00ed, en aquest bloc d\u2019instruccions, en el que s\u2019hauria de corregir la situaci\u00f3 o avisar a l\u2019usuari de l\u2019aplicaci\u00f3 del que ha passat.</p> <pre><code>public void escolta () throws Exception {\n// Codi del metode escolta\n// ...\nthrow new Exception ();\n}\n\npublic static void main (String [] args) {\ntry {\nescolta();\n}\ncatch(Exception e) {\n// Codi a executar quan es produeix una excepci\u00f3.\n}\n}\n</code></pre> <p>Al codi anterior hem crear un m\u00e8tode escolta que l\u2019\u00fanic que fa \u00e9s lle\u00e7ar una excepci\u00f3. Quan al m\u00e8tode main cridem a la funci\u00f3 escolta, si volem fer \u00fas del sistema d\u2019excepcions de Java, l\u2019haurem de posar dins del bloc try. Just despr\u00e8s d\u2019acabar el conjunt d\u2019instruccions del bloc try posem un catch indicant-li quina \u00e9s la classe d\u2019excepci\u00f3 que hauriem de capturar, al nostre cas Exception, i dins del bloc catch posariem el codi que s\u2019hauria d\u2019executar en cas de produir-se eixe error. Normalment es solen posar missatges d\u2019error que alerten l\u2019usuari de l\u2019aplicaci\u00f3.</p> <p>A continuaci\u00f3 explicarem amb m\u00e9s detall qu\u00e8 \u00e9s el que fan cadascun dels blocs del mecanisme d\u2019excepcions que ha dissenyat Java.</p>"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#bloc-try","title":"Bloc try","text":"<p>Dins del bloc try s\u2019han de posar aquelles sent\u00e8ncies que poden llen\u00e7ar alguna excepci\u00f3 entre claud\u00e0tors, despr\u00e9s del claud\u00e0tor de tancament s\u2019ha de posar el bloc catch o controlador d\u2019excepcions almenys un bloc catch. Si l\u2019excepci\u00f3 que es produeix coincideix amb algun dels par\u00e0metres dels blocs catch que hi han, s\u2019executen les sent\u00e8ncies que es troben a dintre.</p> <p>Els blocs try, de la mateixa forma que amb totes les sent\u00e8ncies de programaci\u00f3 estructurada, es poden niar.</p> <pre><code>public static void main (String [] args) {\ntry {\nescolta();\n\ntry {\ntornaAEscoltar();\n}\ncatch (Exception e) {\n// Codi excepci\u00f3 interna\n}\n}\ncatch (Exception e) {\n// Codi excepci\u00f3 externa\n}\n}\n</code></pre> <p>A l\u2019exemple anterior \u00e9s pot observar un codi amb dos blocs try niats on el primer bloc try t\u00e9 dos blocs catch per controlar varies excepcions</p>"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#bloc-throw","title":"Bloc throw","text":"<p>La sent\u00e8ncia throw llen\u00e7a (raise) una excepci\u00f3. Les excepcions en Java s\u00f3n objectes, per tant, una excepci\u00f3 \u00e9s una inst\u00e0ncia d\u2019una classe que deriva de la classe Exception A l\u2019exemple anterior com es pot observar es capturen dos tipus d\u2019excepcions diferents, una generica Exception i una altra FileNotFoundException. Aquesta \u00faltima es produiex normalment quan volem obrir un fitxer, amb la classe File per exemple, i aquest no existeix.    </p>"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#bloc-catch","title":"Bloc catch","text":"<p>El bloc catch o de captura d\u2019excepcions. Quan una excepci\u00f3 es llen\u00e7a des d\u2019un bloc try, si el tipus d\u2019excepci\u00f3 que s\u2019ha llen\u00e7at coincideix amb el tipus d\u2019excepci\u00f3 que s\u2019ha passat per par\u00e0metre al catch, s\u2019executarien les sent\u00e8ncies que hi han dins del bloc catch. Normalment es sol posar el codi necessari per poder eixir de la situaci\u00f3 en la que ens trobem quan s\u2019al\u00e7a una excepci\u00f3.</p>"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#clausula-finally","title":"Cl\u00e0usula finally","text":"<p>El bloc finally en un try..catch, \u00e9s el bloc d\u2019instruccions que s\u2019executar\u00e0 sempre, hi haja excepcions o no, al final de tot el nostre codi.  Normalment es solen posar sent\u00e8ncies per tal d\u2019alliberar tot all\u00f2 que pugam haver creat dins del bloc try, \u00e9s a dir, tancar fluxos, fitxers, connexions a bases de dades etc..amb la finalitat d\u2019alliberar mem\u00f2ria.</p>"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#classes-dexcepcions-en-java","title":"Classes d'excepcions en Java","text":""},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#nove-excepcions","title":"Nove excepcions","text":"<p>Java permet la creaci\u00f3 d\u2019excepcions noves que deriven de la classe base Exception</p>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/","title":"Tema 9. Gr\u00e0fics. Java Swing","text":""},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#introduccio","title":"Introducci\u00f3","text":"<p>Fins ara hem estat utilitzant la consola i el teclat a les nostres aplicacions per tal de comunicar-nos amb l'usuari. En aquest tema utilitzarem l'API de Java per al desenvolupament de components gr\u00e0fics Swing.</p> <p>Swing \u00e9s un conjunt d'eines per a Java. \u00c9s una API que proporciona interf\u00edcie gr\u00e0fica d'usuari (GUI) per a programes de Java. Entre d'altres Swing cont\u00e9: frames, botons, textbox, men\u00fas a banda dels events associats als elements.</p> <p>Swing va ser desenvolupat per a proporcionar un conjunt m\u00e9s complex de components GUI que l'anterior Abstract Window Toolkit (AWT). Swing proporciona un aspecte i aparen\u00e7a natiu que emula diverses plataformes, tamb\u00e9 d\u00f3na suport a extensions d'aspecte i aparen\u00e7a que permeten a les aplicacions tindre un aspecte i apare\u00e7a que no guarda relaci\u00f3 amb la plataforma subjacent.</p> <p>Hu\u00ed en dia la majoria de desenvolupadors Java utilitzen Swing o JavaFX per construir interf\u00edcies d'usuari</p>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#la-llibreria-swing","title":"La llibreria Swing","text":"<p>Com tot en Java, swing no anava a ser menys, est\u00e0 dissenyat com una llibreria de classes, interf\u00edcies, recursos, etc.. per la construcci\u00f3 d'insterf\u00edcies gr\u00e0fiques. Swing cont\u00e9 tres APIs una per a components 2D, una altra per al Drag &amp; Drop i l'\u00faltima per facilitar l'acc\u00e9s. Swing est\u00e0 basada en AWT per\u00f2 \u00e9s independent de la plataforma, \u00e9s a dir, sempre mostra la mateixa aparen\u00e7a independentment del sistema en el que s'execute l'aplicaci\u00f3 a difer\u00e8ncia d'AWT.</p> <p>Amb Swing podem fer: - Marcs: Finestres amb de t\u00edtol, men\u00fa, botons maximitzar, minimitzar i tancar. - Contenidors: poden agrupar diversos controls. - Botons - Etiqutes: text - Camps i arees de text. - Desplegables</p> <p>Per tal de poder utilitzar les llibreries Swing de Java hauriem d'afegir al nostre codi el seg\u00fcent:</p> <pre><code>import javax.swing.*;\n</code></pre>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#components-i-contenidors","title":"Components i contenidors","text":"<p>En general, els components Swing es deriven de la classe JComponent. Les \u00faniques excepcions s\u00f3n els quatre contenidors de nivell superior. JComponent proporciona la funcionalitat que \u00e9s com\u00fa a tots els components. Per exemple, JComponent admet la look &amp; feel conectables. JComponent hereta les classes AWT Container i Component. Per tant, un component Swing est\u00e0 integrat i es compatible amb un component AWT.</p> <p>Tots els components de Swing estan representats per classes definides dins del paquet javax.swing com hem explicat abans. La seg\u00fcent taula mostra els noms de classe per als components Swing inclosos els contenidors.</p>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#components-java-swing","title":"Components Java Swing","text":"JApplet JButton JCheckBox JCheckBoxMenuItem JColorChooser JComboBox JComponent JDesktopPane JDialog JEditorPane JFileChooser JFormattedTextField JFrame JInternalFrame JLabel JLayer JLayeredPane JList JMenu JMenuBar JMenuItem JOptionPane JPanel JPasswordField JPopUpMenu JProgressBar JRadioButton JRadioButtonMenuItem JRootPane JScrollBar JScrollPane JSeparator JSlider JSpineer JSplitPane JTabbedPane JTable JTextArea JTextField JTextPane JTogglebutton JToolBar JToolTip JTree JViewport JWindows <p>La majora de noms solen ser prou significatius i resulta intuitiu a primer cop d'ull saber quina \u00e9s la finalitat de cadascun dels components.</p>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#contenidors-java-swing","title":"Contenidors Java Swing","text":"<p>Swing defineix dos tipus de contenidors. Els primers s\u00f3n contenidors de nivell superior: JFrame, JApplet, JWindow i JDialog. (JApplet, que admet applets basats en Swing, ha estat descartat per JDK 9.) Aquests contenidors no hereten JComponent. No obstant aix\u00f2, hereten les classes AWT Component i Container. A difer\u00e8ncia d'altres components de Swing, que s\u00f3n lightweight, els contenidors de nivell superior s\u00f3n heavyweight. Aix\u00f2 fa que els contenidors de nivell superior siguin un cas especial a la biblioteca de components Swing.</p> <p>Com el seu nom indica, un contenidor de nivell superior ha d'estar a la part superior d'una jerarquia de contenci\u00f3. Un contenidor de nivell superior no est\u00e0 contingut en cap altre contenidor. A m\u00e9s, cada jerarquia de contenci\u00f3 ha de comen\u00e7ar amb un contenidor de nivell superior. El m\u00e9s comunament utilitzat per les aplicacions \u00e9s JFrame.</p> <p>El segon tipus de contenidor compatible amb Swing \u00e9s el contenidor lightweight. Els contenidors lightweight hereten JComponent. Exemples de contenidors lightweight s\u00f3n JPanel, JScrollPane i JRootPane. Els contenidors lightweight sovint es fan servir per a organitzar i administrar col\u00b7lectivament grups de components relacionats perqu\u00e8 un contenidor lightweight es pot contenir dins d'un altre contenidor. Per tant, pot utilitzar contenidors lightweight per crear subgrups de controls relacionats que estan continguts dins d'un contenidor extern.</p>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#swing-vs-awt","title":"Swing vs AWT","text":"<p>\u00c9s possible utilitzar Swing i AWT a la mateixa interf\u00edcie, per\u00f2 podria donar problemes. \u00c9s recomanable utilitzar nom\u00e9s components Swing, ja que tot component AWT t\u00e9 el seu equivalent Swing.</p> <p>La majoria de classes Swing comencen per J, per exemple: JButton, JFrame... encara que tamb\u00e9 existeixen Frame i Button que pertanyen a la llibreria AWT. Cal tindre molta cura en no oblidar de posar la 'J' davant dels components ja que si no podria portar a inconsist\u00e8ncies a causa de mesclar components.</p> <p>A l'actualitat quasi tota la programaci\u00f3 gr\u00e0fica en Java es fa amb Swing que implemente una interf\u00edcie gr\u00e0fica normalment va a tenir quatre tipus d'elements: 1. Un contenidor de nivell superior: un marc (JFrame), un applet (JApplet) o b\u00e9 objectes JDialog. Aquests contenidors no estan dins d'una altra finestra, s\u00f3n les finestres principals. 2. Components de la interf\u00edcie gr\u00e0fica: botons, camps de text, etc\u00e8tera, que se situen a la finestra principal o en contenidors. 3. Contenidors dissenyats per altres elements de la interf\u00edcie; JPanel i JScrollPane s\u00f3n dos contenidors i, a el mateix temps, s\u00f3n components. 4. Elements per a la gesti\u00f3 d'esdeveniments. Els components sempre s'afegeixen a una l\u00e0mina o panell; pot ser la de el marc, o b\u00e9 un panell tipus JPanel. En general, sempre es creen classes derivades de les classes contenidors de nivell superior; tot marc ser\u00e0 una subclasse de JFrame, a l'igual que un applet \u00e9s una subclasse de JApplet.</p>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#creacio-dun-jframe","title":"Creaci\u00f3 d'un JFrame","text":"<p>La difer\u00e8ncia entre crear programes que es comuniquen amb l'usuari mitjan\u00e7ant el terminal i el teclat i fer programes amb Swing \u00e9s considerable. Al crear una aplicaci\u00f3 Swing s'han de tenir en compte conceptes nous com el threading. Per\u00f2 per entendre-ho tot millor, farem un programa Swing d'exemple.</p> <p>Per al programa d'exemple crearem un JFrame al qual li posarem una JLabel</p>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#exemple-1-programa-simple-swing","title":"Exemple 1. Programa simple Swing","text":"<pre><code>// Un simple programa Swing\n\nimport javax.swing.*;\npublic class SwingDemo {\nSwingDemo(){\nJFrame jfrm=new JFrame(\"Aplicaci\u00f3 Simple Swing\");        // Crea un nou contenidor JFrame.\njfrm.setSize(475,200);                                   // Establim el tamany inicial\njfrm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);     // Acabe el programa quan l'usuari tanque l'aplicaci\u00f3.\nJLabel jLabel= new JLabel(\"Programaci\u00f3 GUI amb Swing.\"); // Creem una etiqueta\njLabel.setHorizontalAlignment(SwingConstants.CENTER);    // Situem l'etiqueta al centre del frame\njfrm.add(jLabel);                                        // Afegim l'etiqueta al frame\njfrm.setVisible(true);                                   // Visualitzem el marc.\n}\npublic static void main(String[] args) {\nSwingUtilities.invokeLater(new Runnable() {\npublic void run(){\nnew SwingDemo();\n}\n});\n}\n}\n</code></pre> <p>El resultat del codi anterior seria el seg\u00fcent:</p> <p></p> <p>JFrame \u00e9s un contenidor de nivell superior que s'utilitza de forma com\u00fa a les aplicacions Swing, mentre que JLabel \u00e9s una etiqueta que ens servir\u00e0 per posar text.</p> <p>Expliquem amb m\u00e9s detall el que fa la funci\u00f3 main: - SwingUtilities.invokeLater()    -  static void invokeLater(Runnable doRun): Executa un doRun.run() per tal que s'execute de forma asincrona al AWT event dispatching thread. A aquets m\u00e8tode se li ha de passar un objecte Runnable - new Runnable() { }:   - Objecte Runnable que s'ha de passar al m\u00e8tode invokeLater - public void run() { }: M\u00e8tode run que s'executa de l'objecte runnable que se li passa a InvokeLater - new SwingDemo()   - Codi del m\u00e8tode run de l'objecte runnable.</p> <p>Una aplicaci\u00f3 que implemente una interf\u00edcie gr\u00e0fica normalment va a tindre quatre tipus d'elements. 1.  Un contenidor de nivell superior: un marc (JFrame), un applet (JApplet) o b\u00e9 di\u00e0legs (JDialog) que faran el paper de finestra principal. 2.  Components de la interf\u00edcie gr\u00e0fica: botons, camps de text, etc, que s'afegiran al contenidor de nivell superior anterior. 3.  Contenidors dissenyats per altres elements de la interf\u00edcie: JPanel i JScrollPane s\u00f3n dos contenidors i al mateix temps s\u00f3n components. 4.  Elements per la gesti\u00f3 d'events. </p> <p>Els components sempre s'afegeixen a una l\u00e0mina o paper; pot ser la del marc o b\u00e9 un panel tipus JPanel. En general, sempre es creen classes derivades de les classes contenidores de nivell superior. Tot marc ser\u00e0 una subclasse de JFrame, de la mateixa forma que un applet \u00e9s una subclasse de JApplet</p>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#jframe","title":"JFrame","text":"<p>La classe JFrame \u00e9s un tipus de contenidor que hereta de la classe java.awt.Frame. JFrame funciona com la finestra principal on components com etiquetes, botons, camps de text etc, s'afegeixen per crear una interf\u00edcie gr\u00e0fica.</p>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#metodes","title":"M\u00e8todes","text":"M\u00e8tode Descripci\u00f3 JFrame() Constructor de la classe. Crea un marca sense t\u00edtol JFrame (String titol) Crea un marc amb t\u00edtol. void setTitle (String titlo) Estableix el t\u00edtol del marc void setIconImage ( Image img ) Estableix la icona del marc void setDefaultCloseOperation (int op ) programa el comportament del marca quan es tanca. Possibles valors: EXIT_ON_CLOSE, DO_NOTHING_ON_CLOSE, DISPOSE_ON_CLOSE, HIDE_ON_CLOSE Container getContentPane () proporciona el layout de continguts del marc, \u00e9s a dir, les vores void setResizable ( boolean r ) si r val true, es pot redimensionar el marc void add (Component c) Afegeix el component c al marc void removeComponent (Component c) elimina el component c del marc Component add (Component c, int p) Coloca el component c a la posici\u00f3 p del marc void setLayout (LayoutManager mngr) estableix la forma de distribuir el components al marc, els quals normalment es distribueixen en posicions relatives, segons el layout que tinga associat el marc void setVisible (boolean b) fa visible el component si b \u00e9s true void setBounds (int x, int y, int ample, int alt) situa el component i canvia el seu tamany void setLocation (int x, int y) situa el component a les coordenades x i y void setLocation (Point p) situa el component al punt p void setSize (int ample, int alt) estableix les dimensions del component void setSize (Dimension dim) estableix la dimensi\u00f3 del component a dim"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#layout-manager-gestor-de-posicionament","title":"Layout Manager - Gestor de posicionament","text":"<p>A difer\u00e8ncia d'altres aplicacions que es dediquen al disseny d'interf\u00edcies gr\u00e0fiques, les posicions dels elements dintre del nostre contenidor no es fan en pixels ni valors absoluts, s'utilitzen els Layout Manager que ho podriem traduir com \"gestors de disposici\u00f3\" o \"gestor de plantilla\" o \"gestor de posicionament\". Aquestos gestors de posicionament s\u00f3n elements que implementen la interf\u00edcie \"LayoutManager\".</p> <p>Cada cotenidor t\u00e9 associat un Layout Manager que pot ser: BorderLayout, FlowLayout, GridLayout, BoxLayout, GridBagLayout, CardLayout, SpringLayout...</p> <p>Veiem un exemple:</p>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#exemple-2-marc-de-prova","title":"Exemple 2. Marc de prova","text":"<p><pre><code>JFrame marc = new JFrame(\"MarcProva\");\nmarco.setLayout(new GridLayout(3,4));\n</code></pre> El que hem fet al codi anterior \u00e9s crear i instanciar un nou marc de tipus JFrame amb el t\u00edtol \"MarcProva\" i despr\u00e9s hem establert el seu gestor de posicionament de tipus GridLayout. </p> <p>A continuaci\u00f3 detallarem els m\u00e9s utilitzats</p>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#borderlayout","title":"BorderLayout","text":"<p>Gestor de posicionament per defecte dels marcs (JFrame) i di\u00e0legs (JDialog). Divideix al contenidor en cinc zones: nord, sud, est, oest i centre, que es corresponen a: BorderLayout.NORTH, BorderLayout.SOUTH, BorderLayout.EAST, BorderLayout.WEST i BorderLayout.CENTER</p> <p>Veiem un exemple:</p>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#exemple-3-marc-amb-vora","title":"Exemple 3. Marc amb vora","text":"<pre><code>import javax.swing.*;\nimport java.awt.*;\n\npublic class MarcBorder extends JFrame\n{\nstatic int AMPLE =350;\nstatic int ALT = 200;\npublic MarcBorder()\n{\nsuper(\"T\u00edtol Marc\");\nadd(new JLabel(\"Nord\", SwingConstants.CENTER), BorderLayout.NORTH);\nadd(new JLabel(\"Sud\", SwingConstants.CENTER), BorderLayout.SOUTH);\nadd(new JLabel(\"Centre\", SwingConstants.CENTER), BorderLayout.CENTER);\nadd(new JLabel(\"Oest\", SwingConstants.CENTER), BorderLayout.WEST);\nadd(new JLabel(\"Est\", SwingConstants.CENTER), BorderLayout.EAST);\nsetSize(AMPLE,ALT);\nsetVisible(true);\n}\npublic static void main(String args[])\n{      MarcBorder marc = new MarcBorder();\nmarc.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n}\n}\n</code></pre> <p>El resultat del codi anterior \u00e9s:</p> <p></p>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#flowlayout","title":"FlowLayout","text":"<p>Amb aquest gestor podem colocar els elements d'esquerra cap a dreta i de dalt cap avall. La classe FlowLayout disposa de diversos constructors, un d'ells ens permet establir l'alineaci\u00f3 dels components FlowLayout(int align) on align pot ser: FlowLayout.RIGHT, FlowLayout.CENTER, FlowLayout.LEFT. </p>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#exemple-4-flowlayout","title":"Exemple 4. Flowlayout","text":"<pre><code>import java.awt.*;\nimport javax.swing.*;\n\npublic class MarcFlow extends JFrame\n{   static int AMPLE =175;\nstatic int ALT = 100;\npublic MarcFlow()\n{\nsuper(\"El meu marc\");\nsetLayout(new FlowLayout());\nadd(   new JLabel(\"Primera\"));\nadd(new JLabel(\"Segona\"));\nadd(new JLabel(\"Tercera\"));\nadd(new JLabel(\"Quarta\"));\nadd(new JLabel(\"Cinquena\"));\nadd(new JLabel(\"Sisena\"));\nsetSize(AMPLE,ALT);\nsetVisible(true);\n}\npublic static void main(String args[])\n{\nMarcFlow marc = new MarcFlow();\nmarc.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n}\n}\n</code></pre> <p>I aquest \u00e9s el resultat: </p>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#gridlayout","title":"GridLayout","text":"<p>Aquest gestor de posicionament distribueix els components del container associat en forma de graella de cel\u00b7les iguals en forma de quadricula de dalt cap avall i de esquerra a dreta, \u00e9s a dir, en files i columnes.</p>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#exemple-5-gridlayout","title":"Exemple 5. GridLayout","text":"<pre><code>import java.awt.*;\nimport javax.swing.*;\npublic class MarcGrid extends JFrame\n{\nstatic int AMPLE =175;\nstatic int ALT = 100;\npublic MarcGrid()\n{\nsuper(\"El meu marc\");\nsetLayout(new GridLayout(3,2,15,15));\nadd(new JLabel(\"Primera\"));\nadd(new JLabel(\"Segona\"));\nadd(new JLabel(\"Tercera\"));\nadd(new JLabel(\"Quarta\"));\nadd(new JLabel(\"Cinquena\"));\nadd(new JLabel(\"Sisena\"));\nsetSize(AMPLE,ALT);\nsetVisible(true);\n}\n\npublic static void main(String args[])\n{\nMarcGrid marc = new MarcGrid();\nmarc.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n}\n}\n</code></pre> <p>Resultat del codi anterior:</p> <p></p>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#boxlayout","title":"BoxLayout","text":"<p>Aquest gestor coloca els components en una \u00fanica fila o una \u00fanica columna, s'assembla a una caixa amb orientaci\u00f3 horitzontal o vertical; el constructor necessita un argument amb el contenidor que es va a utilitzar i l'orientaci\u00f3 que pot ser: BoxLayout.X_AXIS o BoxLayout.Y_AXIS. </p> <p>El format del constructor \u00e9s: BoxLayout (Container desti, int orientacio)</p>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#exemple-6-boxlayout","title":"Exemple 6. BoxLayout","text":"<pre><code>import javax.swing.*;\nimport java.awt.*;\n\npublic class MarcBox extends JFrame\n{\nstatic int AMPLE =175;\nstatic int ALT = 150;\n\npublic MarcBox()\n{\nsuper(\"El meu marcBox\");\nJPanel panel = new JPanel() ;\npanel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));\npanel.add(new JLabel(\"Primera\"));\npanel.add(new JLabel(\"Segona\"));\npanel.add(new JLabel(\"Tercera\"));\npanel.add(new JLabel(\"Quarta\"));\npanel.add(new JLabel(\"Cinquena\"));\npanel.add(new JLabel(\"Sisena\"));\nadd(panel);\nsetSize(AMPLE,ALT);\nsetVisible(true);\n}\n\npublic static void main(String args[])\n{\nMarcBox miMarcBox = new MarcBox();\nmiMarcBox.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n}\n}\n</code></pre>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#boxlayout-box","title":"BoxLayout - Box","text":"<p>Box o caixa, \u00e9s un contenidor que t\u00e9 com gestor de posicionament (LayoutManager) predeterminat un BoxLayout; utilitzant aquest contenidor no cal crear un panel perqu\u00e8 directament es crea un objecte Box i a continuaci\u00f3 s'afegeixen els components.</p> <p>La classe Box disposa de dos m\u00e8todes static (m\u00e8todes factoria) que creen l'objecte, i s\u00f3n: </p> <pre><code>Box.createHorizontalBox();\nBox.createVerticalBox();\n</code></pre> <p>Aleshores, per crear un Box no s'utilitza el constructor sino que es crida a un d'aquestos dos m\u00e8todes; per un objecte Box amb orientaci\u00f3 horitzontal, per exemple:</p> <pre><code>Box caixaHoriz = Box.createHorizontalBox();\n</code></pre> <p>Al contenidor se li afegeix el component caixaHoriz.add(element) i despr\u00e9s el contenidor al marc.</p>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#exemple-7-boxlayout-box","title":"Exemple 7. BoxLayout - Box","text":"<pre><code>import javax.swing.*;\nimport java.awt.*;\n\npublic class Marc2Box extends JFrame\n{\nstatic int AMPLE =275;\nstatic int ALT = 175;\n\npublic Marc2Box()\n{\nsuper(\"El meu marc\");\nJButton b1 = new JButton(\"Boto1\");\nJButton b2 = new JButton(\"Boto2\");\nJButton b3 = new JButton(\"Boto3\");\nJButton b4 = new JButton(\"Boto4\");\nJButton b5 = new JButton(\"Boto5\");\nJButton b6 = new JButton(\"Boto6\");\nBox caixaH = Box.createHorizontalBox(); // m\u00e9todo factor\u00eda\ncaixaH.add(b1);\n// separaci\u00f3n horizontal de 10 pixeles\ncaixaH.add(Box.createHorizontalStrut(10));\ncaixaH.add(b2);\n// zona r\u00edgida, separaci\u00f3n horizontal\ncaixaH.add(Box.createRigidArea(new Dimension(5,5)));\ncaixaH.add(b3);\nadd(caixaH,BorderLayout.NORTH);\n\nBox caixaV = Box.createVerticalBox();\ncaixaV.add(Box.createHorizontalStrut(70));\ncaixaV.add(b4);\n// separaci\u00f3n horizontal 10 pixeles\ncaixaV.add(Box.createVerticalStrut(10));\ncaixaV.add(b5);\ncaixaV.add(Box.createRigidArea(new Dimension(5,5)));\ncaixaV.add(b6);\nadd(caixaV,BorderLayout.CENTER);\nsetSize(AMPLE,ALT);\nsetVisible(true);\n}\npublic static void main(String args[])\n{\nMarc2Box marcBox2 = new Marc2Box();\nmarcBox2.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n}\n}\n</code></pre>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#combinar-layouts","title":"Combinar Layouts","text":"<p>JFrame, JDialog i JPanel nom\u00e9s poden tindre un gestor de posicionament per\u00f2 si agafem un contenidor de primer nivell com un marc, podr\u00edem combinar diversos layouts niats (nested). Al seg\u00fcent exemple podem veure una combinaci\u00f3 de tres gestors de posicionament en un mateix contenidor.</p>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#exemple-8-combinacio-de-disposicions-layouts","title":"Exemple 8. Combinaci\u00f3 de disposicions (layouts)","text":"<pre><code>import javax.swing.*;\nimport java.awt.*;\n\npublic class MarcGestors extends JFrame\n{\npublic MarcGestors()\n{\nJPanel pa1 = new JPanel(new FlowLayout());\nJPanel pa2 = new JPanel(new BorderLayout());\nJPanel pa3 = new JPanel();\npa3.setLayout(new BoxLayout(pa3, BoxLayout.Y_AXIS));\n\n// componentes del panel 1\nString [] opc = {\"Alta mar\", \"Baixa mar\", \" Muntanya\"};\npa1.add(new JLabel (\"Tria..\", JLabel.CENTER));\npa1.add(new JList(opc));\npa1.add(new JButton(\"Pr\u00e8mer\"));\n\n// componentes del panel 2\nJTextField j = new JTextField(\"Raons \");\nj.setEditable(false);\npa2.add(j,BorderLayout.WEST);\npa2.add(new JButton(\"Bot\u00f3\"),BorderLayout.EAST);\n\n// componentes del panel 3\npa3.add(new JCheckBox(\"Box \",false));\npa3.add(new JLabel (\"Calendari\", JLabel.CENTER));\npa3.add(new JRadioButton(\"Bot Radio\", true));\n\n// asigna layout al marco y se ponen los paneles\nsetLayout( new BorderLayout(10, 15));\nadd(pa1,BorderLayout.NORTH);\nadd(pa2,BorderLayout.CENTER);\nadd(pa3,BorderLayout.SOUTH);\n}\n\npublic static void main(String[] args) {\nMarcGestors m;\nm = new MarcGestors();\nm.setSize(200,300);\nm.setLocation(20,200);\nm.setResizable(false);\nm.setVisible(true);\nm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n}\n}\n</code></pre> <p>El resultat seria:</p> <p></p>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#desactivar-gestor-de-posicionament","title":"Desactivar gestor de posicionament","text":"<p>Per defecte un contenidor sempre t\u00e9 associat un gestor de posicionament (layout) per\u00f2 de vegades ens pot resultar interessant desactivar aquest gestor de posicionament. Utilitzarem el m\u00e8tode setLayout i li passarem per parametre null.</p>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#etiqutes","title":"Etiqutes","text":"<p>Una etiqueta \u00e9s un component nom\u00e9s lectura al qual li podem modificar el text que cont\u00e9 i que normalment s'utilitza per posar algun missatge significatiu de la nostra interf\u00edcie a l'usuari final. En altres paraules, s\u00f3n components de text fixe que nom\u00e9s mostren text per\u00f2 que no reben cap event. Per gestionar les etiquetes a Java utilitzem la classe JLabel</p>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#metodes_1","title":"M\u00e8todes","text":"<ul> <li>JLabel (): Crea una etiqueta sense text associat.</li> <li>JLabel (String msg): Crea una etiqueta amb el text msg.</li> <li>JLabel (String msg, Icon icona): Crea una etiqueta amb el text msg i la icona icon.</li> <li>JLabel (String msg, int align): crea una etiqueta amb el text msg alineat segons el segon argument que pot ser SwingConstants.CENTER, SwingConstants.LEFT o SwingConstants.RIGHT.</li> <li>public String getText (): torna el text de l'etiqueta</li> <li>public void setText (String msg): estableix el text de l'etiqueta.</li> </ul>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#botons","title":"Botons","text":"<p>A Swing es defineixe diversos tipus de botons, la classe base dels quals \u00e9s Abstract Button, \u00e9s una classe abstracta que encapsula propietats i m\u00e8todes comuns als diversos tipus de botons</p>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#metodes_2","title":"M\u00e8todes","text":"<ul> <li>void setText (String text): Estableix el text del bot\u00f3.</li> <li>String getText (): Obt\u00e9 el text del bot\u00f3.</li> <li>boolean isSelected(): true si s'ha seleccionat el bot\u00f3.</li> <li>void setSelectes (boolean b): selecciona el bot\u00f3.</li> <li>void doClick (int temps): tria el bot\u00f3 durant temps milisegons</li> <li>void setIcon (Icon icona): estableix la icona del bot\u00f3.</li> <li>void setMnemonic (int mnemonic): relaciona una tecla amb el bot\u00f3.</li> <li>void addActionListener(ActionListener al): assigna un listener per controlar events.</li> </ul>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#jbutton","title":"JButton","text":"<p>La classe JButton representa el bot\u00f3 com\u00fa; es crea especificament una cadena, una icona, ambdos, o un element encara sense especificar; els constructors de la classe s\u00f3n: - JButton(): Constructor de la classe - JButton(String text): Constructor amb text del bot\u00f3. - JButton(String text, Icon icona): Constructor amb text i icona.</p> <p>La classe deriva d'AbstractButton per tant tots els seus m\u00e8todes estaran disponibles tamb\u00e9.</p> <pre><code>JButton b1, b2, b3;\nb1 = new JButton(); b2 = new JButton(\"GROC\");\nb3 = new JButton(new LibroIcon()); </code></pre>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#botons-amb-dos-estats","title":"Botons amb dos estats","text":"<p>JToogleButton \u00e9s la classe base dels botons amb dos estats; JRadioButton que s'utilitza per definir un grup de botons d'opci\u00f3 \u00fanica; per agrupar botons d'opci\u00f3 \u00fanica s'utilitza la classe ButtonGroup, primer es crea un objecte ButtonGroup (constructor sense arguments); a continuaci\u00f3 s'afegeix JRadioButton amb el m\u00e8tode de ButtonGroup, add(AbstracButton b).</p>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#constructors-de-jradiobutton","title":"Constructors de JRadioButton","text":"<ul> <li>JRadioButton(): Constructor per defecte.</li> <li>JRadioButton(String msg): Constructor amb text del bot\u00f3.</li> <li>JRadioButton(String msg, boolean sel): Constructor amb el text i si sel \u00e9s true, el bot\u00f3 ja estaria seleccionat.</li> </ul>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#exemple-9-diversons-botons","title":"Exemple 9. Diversons botons","text":"<pre><code>import javax.swing.*;\nclass PanelJRadio extends JPanel\n{\nButtonGroup grb;\nJRadioButton jr1, jr2, jr3;\n\npublic PanelJRadio() {\ngrb = new ButtonGroup();\nsetLayout(new GridLayout(4,1));\nadd (new JLabel(\"Selecci\u00f3 excloent\"));\n\n// se crea bot\u00f3n de radio, se a\u00f1ade al panel y a la agrupaci\u00f3n\njr1 = new JRadioButton(\"Avi\u00f3\", false);\nadd(jr1);\ngrb.add(jr1);\n\n// se crea bot\u00f3n de radio, se a\u00f1ade al panel y a la agrupaci\u00f3n\njr2 = new JRadioButton(\"Tren\", false);\nadd(jr2);\ngrb.add(jr2);\n\n// se crea bot\u00f3n de radio, se a\u00f1ade al panel y a la agrupaci\u00f3n\njr3 = new JRadioButton(\"Cotxe\", false);\nadd(jr3);\ngrb.add(jr3);\n}\n}\n</code></pre> <p>JCheckBox o tamb\u00e9 anomenat: casella de verificaci\u00f3, check o checkbox.</p>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#constructors-de-jcheckbox","title":"Constructors de JCheckBox","text":"<ul> <li>JCheckBox(): Constructor per defecte.</li> <li>JCheckBox(String text):: Constructor amb el text associat.</li> <li>JCheckBox(String text, boolean sel): Constructor amb text i si sel \u00e9s true, la casella vindria ja marcada.</li> </ul> <p>La classe JComboBox no est\u00e0 a la jerarquia de botons, no deriva d'AbstractButton; combina en un sol component un bot\u00f3 amb una llista d'elements. Una JComboBox s'utilitza per crear una llista desplegable a la que es poden afegir opcions, editarles o fer seleccions.</p>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#constructors-de-jcombobox","title":"Constructors de JComboBox","text":"<ul> <li>JComboBox(): Constructor per defecte.</li> <li>JComboBox(Object llista[]): Constructor amb una llista d'objectes per par\u00e0metre.</li> </ul> <p>Alguns dels seus m\u00e8todes s\u00f3n: - public void addItem(Object q): afegeix un element a la llista (pel final). - public insertItemAt(Object q, int indice): insereix en \u00edndex l'element. - public void setEditable(boolean flag): si flag \u00e9s true l'element de llista seleccionat \u00e9s editable. - public void setMaximumRowCount(int n): posa el m\u00e0xim d'elements a mostrar en el combo, si hi ha m\u00e9s elements apareix la barra d'scroll. - public Object getSelectedItem(): torna l'element seleccionat.</p> <p>Els m\u00e8todes seg\u00fcents s\u00f3n per la gesti\u00f3 d'events al combobox: - public void actionPerformed(ActionEvent ev); - public void addActionListener(ActionListener ae); - public void addItemListener(ItemListener it); - public void addStateChanged(ItemEvent ev);</p>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#exemple-10-combobox","title":"Exemple 10. ComboBox","text":"<pre><code>import javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.*;\n\nclass PanelJCombo extends JPanel\n{\nprivate JComboBox jcb;\npublic PanelJCombo() {\njcb = new JComboBox();\nsetLayout(new BorderLayout());\njcb.addItem(\"MAD - BCN\");\njcb.addItem(\"MAD - AGP\");\njcb.addItem(\"MAD - XRY\");\njcb.addItem(\"BRU - TFN\");\njcb.addItem(\"LEN - BCN\");\njcb.addItem(\"ROM - BCN\");\njcb.setMaximumRowCount(4);\nadd(jcb,BorderLayout.NORTH);\n}\n}\n</code></pre>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#components-de-text","title":"Components de text","text":"<p>Els components Swing que s'utilitzen per editar o mostrar text formen una jerarquia de classes la base de la qual \u00e9s JTextComponent; aquesta \u00faltima \u00e9s una classe abstracta que es troba al paquet java.swing.text</p>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#jtextcomponent","title":"JTextComponent","text":"<p>Els components de text suporten una ampla varietat de caracters de c\u00f2dis alfab\u00e8tics; en ells es pot inserir, esborrar o seleccionar caracters; \u00e9s text modificable per l'usuari; la classe disposa del constructor JTextComponent() que crea una component de text editable. </p> <p>Els seus m\u00e8todes s\u00f3n: - String getText(): torna el text que t\u00e9 el component. - String getText(int dspl,int lon): torna el text del component a partir del despla\u00e7ament dspl i de la longitud lon. - void setText(String txt):: substituieix el text del component per txt; si txt \u00e9s null o \u00e9s una cadena buida, esborra el text del component. - void setEditable(boolean b): un component de text \u00e9s editable per omisi\u00f3; amb aquest m\u00e8tode s'especifica si \u00e9s o no.</p>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#jtextfield-jpasswordtext","title":"JTextField, JPasswordText","text":"<p>La classe JTextField representa un camp de text modificable per l'usuar; amb aquest component s'edita una l\u00ednia de text amb l'ample, alineaci\u00f3 i tipus de lletra que es desitge.</p> <p>JPasswordField es deriva de JTextField; representa un camp de text amb la particularitat de que emmascara els caracters quan es visualitza; s'utilitza per editar una clau secreta, contrasenya o password; per omisi\u00f3, cada caracter de un JPasswordField es substitueix per un '*'.</p> <p>Els constructors de JTextField s\u00f3n: - JTextField(): camp de text buit de 0 columnes. - JTextField(int cols): camp de text buit de cols columnes. - JTextField(String msg): camp de text ajustat a la cadena msg. - JTextField(String msg,int col): camp de text amb la cadena msg i de cols columnes.</p> <p>Els constructors de JPasswordField tenen els mateixos arguments que JTextField; els seus m\u00e8todes s\u00f3n: - void setFont(Font tipo) - void setHorizontalAlignment(int alig): alineaci\u00f3 del text; els valors possibles d'alig son les constants de SwingConstants: RIGHT, LEFT, CENTER, TRAILING, LEADING (aquest \u00e9s el predeterminat) - void setColumns(int cols): posa el n\u00famero de columnes preferit per al camp.</p> <p>JPasswordField hereta els m\u00e8todes anteriors i a m\u00e9s a m\u00e9s disposa d'aquestos: - void setEchoChar(char c): coloca c per emmascarar els caracters del camp. - char getEchoChar(): torna el caracter que emmascara; per defecte ''. - char[] getPassword():* torna la cadena del camp en un array de caracters.</p>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#exemple-11-passwords-i-labels","title":"Exemple 11. Passwords i Labels","text":"<pre><code>import javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.*;\n\npublic class MarcPassWord extends JFrame {\nprivate static final int AMPLE=300, ALT=150;\nprivate JPasswordField clau = null;\nprivate JLabel et1 = null;\nprivate JLabel res = null;\n\npublic MarcPassWord(String c) {\nsuper(c);\nsetSize(ANCHO,ALTO);\ncreaComponentes();\npack();\n}\n\nprivate void creaComponents() {\nclau = new JPasswordField(20);\net1= new JLabel();\n\n// oyente para proceso de la acci\u00f3n del usuario\nclave.addActionListener(new ActionListener() {\npublic void actionPerformed(ActionEvent evt) {\nprocesoAccionUser(evt);\n}\n});\n\n// pone el campo de texto con la clave\nadd(clau, BorderLayout.CENTER);\n\n// crea y pone la etiqueta en el marco\net1.setFont(new java.awt.Font(\"Times New Roman\", 3, 12));\net1.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);\net1.setText(\"PASSWORD \");\net1.setToolTipText(\"Exemple\");\nadd(et1,BorderLayout.NORTH);\n\n// m\u00e9todo que se ejecuta al actuar el usuario sobre el campo\nprivate void procesoAccionUser(ActionEvent evt) {\nchar pas[];\npas = clau.getPassword();\nres= new JLabel(\" \");\nres.setFont(new Font(\"Book Antiqua\", 3, 14));\nif (pas.length == 0) {\nSystem.out.println(\"Teclejar Password \");\net1.setText(\"PASSWORD(teclejar) \");\n}\nelse {\nclau.setEditable(false);\nres.setText(\"Es valida la clau\");\n}\nadd(res, BorderLayout.SOUTH);\nvalidate();\npack();\n}\n\npublic static void main(String args[]) {\nMarcPassWord marc;\nmarc = new MarcPassWord(\"Marc amb password\");\nmarc.setVisible(true);\nmarc.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n}\n}\n}\n</code></pre> <p>Resultat</p> <p></p>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#jtextarea","title":"JTextArea","text":"<p>El component JTextArea s'utilitza amb la finalitat de mostrar moltes l\u00ednies de text; disposa de m\u00e8todes per fixar l'ample de cada l\u00ednia i l'acci\u00f3 a realitzar si la l\u00ednia que s'insereix \u00e9s major que l'ample prefixat; tamb\u00e9 permet decidir si es trenquen o no les paraules al canvi de l\u00ednia.</p> <p>Aquest component no disposa de barra d'scroll JScrollPane, cal crear l'scroll i associar-lo al component; per exemple: es crea el component areaText: <pre><code>JTextArea areaText = new JTextArea();\n// A continuaci\u00f3 es crea l'scroll i s'associa a **areaText**:\nJScrollPane barra = new JScrollPane(areaText);\n// Per \u00faltim, l'scroll es posa al marc\nareaText.add(barra);\n</code></pre> Els constructors s\u00f3n: - JTextArea(): crea el component amb cadena nula, zero files i columnes. - JTextArea(int filas,int cols): crea amb cadena nula i el n\u00famero de files i columnes especificat. - JTextArea(String t): crea el component amb cadena t i zero files i columnes. - JTextArea(String t,int filas, int col):  crea el component amb cadena t i el n\u00famero de files i columnes especificat.</p> <p>Els seus m\u00e8todes s\u00f3n: - public void append(String t): afegeix la cadena t al final del document. - public void insert(String t,int p): insereix la cadena t a partir de la posici\u00f3 p. - void replaceRange(String t, int inici, int fi): substitueix el text del document al rang inici-fi per la cadena t. - public void setColumns(int cols): fixa l'ample de cada l\u00ednia. - public void setLineWrap(boolean f): si f \u00e9s true activa el canvi autom\u00e0tica de l\u00ednia. - public void setWrapStyleWord(boolean f): si f \u00e9s true no 'trenca' les paraules en el canvi de l\u00ednia.</p>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#esdeveniments","title":"Esdeveniments","text":"<p>En aquest punt tractarem l'\u00fas dels esdeveniments per tal que la nostra aplicaci\u00f3 interactue amb l'usuari. </p> <p>Esdeveniment: All\u00f2 que s'esdev\u00e9. Fet considerat extraordinari o molt important en la vida d'una persona o col\u00b7lectivitat. </p> <p>Esdeveniment (Inform\u00e0tica):  Fet que s'esdev\u00e9 o canvi d'un conjunt particular de circumst\u00e0ncies. </p> <p>En altres paraules un esdeveniment en una aplicaci\u00f3 inform\u00e0tica \u00e9s all\u00f3 que passa sense que necessariament estiga controlat al codi. </p> <p>Exemples d'esdeveniments: - Fer clic a un bot\u00f3. - Fer clic dins d'un textbox. - Minimitzar una finestra. - Escriure al teclat - etc</p> <p>Arribats a aquest punt podriem tindre una interf\u00edcie totalment dissenyada per\u00f2 no completament funcional, \u00e9s a dir, imagineu que hem dissenyat la interf\u00edcie per a una calculadora amb tots els seus controls necessaris. Qu\u00e8 passa si fem clic en algun bot\u00f3 de la calculadora? No res ,veritat. Encara hem de programar el comportament d'aquesta calculadora i per tal d'aconseguir-ho hem de fer \u00fas de la programaci\u00f3 d'esdeveniments. Aquest procediment es diu Event Handling i es pot aplicar a aquells elements gr\u00e0fics que produeixen algun esdeveniment.</p> <p>Els esdeveniments s\u00f3n essencials per als usuaris interactuen amb els components de una aplicaci\u00f3 gr\u00e0fica; el model d'esdeveniments segueix el AWT de Java. Aquest cap\u00edtol estudia la forma general de captura d'esdeveniments, la jerarquia de classes del model i les interfaces desenvolupades per a la seva captura; inclou exemples senzills de captura d\u2019esdeveniments de los botons.</p> <p>Veiem un exemple</p> <pre><code>import java.awt.*;\nimport java.awt.event.*;\nimport javax.swing.*;\n\npublic class EventDemo {\nJLabel lab;\npublic EventDemo () {\nJFrame jfrm = new JFrame (\"Esdeveniments\");\njfrm.setLayout(new FlowLayout());\njfrm.setSize(220,90);\njfrm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\nJButton btnAlpha = new JButton(\"Alpha\");\nJButton btnBeta  = new JButton(\"Beta\" );\nbtnAlpha.addActionListener(new ActionListener() {\npublic void actionPerformed(ActionEvent ae) {\nlab.setText(\"Alpha Pressed\");\n}\n\n});\n\nbtnBeta.addActionListener(new ActionListener() {\npublic void actionPerformed(ActionEvent ae) {\nlab.setText(\"Beta Pressed\");\n}\n\n});\n\njfrm.add(btnAlpha);\njfrm.add(btnBeta);\n\nlab = new JLabel(\"Apreta un bot\u00f3\");\njfrm.add(lab);\n\njfrm.setVisible(true);\n}\n\npublic static void main (String [] args) {\nSwingUtilities.invokeLater(new Runnable() {\npublic void run() {\nnew EventDemo();\n}\n});\n}\n}\n</code></pre> <p>El resultat seria</p> <p></p>"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#jlist-selection-listener","title":"Jlist Selection Listener","text":"<p>A continuaci\u00f3 escriurem un 'listener' per a un control JList. Suposem una llista que nom\u00e9s pot sel\u00b7leccionar un element de la llista</p>"},{"location":"Tema%2010.%20Acc%C3%A9s%20a%20dades/","title":"Tema 10. Acc\u00e9s a dades","text":""},{"location":"Tema%2010.%20Acc%C3%A9s%20a%20dades/#introduccio","title":"Introducci\u00f3","text":"<p>Fins ara hem estat treballant amb aplicacions que si necessitaven desar informaci\u00f3 o carregar-la, ho feiem utilitzant arxius o la consola d'entrada. En aquest tema veurem com podem connectar una aplicaci\u00f3 Java a una base de dades MySql.</p>"},{"location":"Tema%2010.%20Acc%C3%A9s%20a%20dades/#jdbc","title":"JDBC","text":"<p>Java proporciona l\u2019API Java Database Connectivity (connectivitat Java a bases dedades) com a mecanisme per poder generar i invocar sent\u00e8ncies SQL sobre una base de dades relacional mitjan\u00e7ant codi en programes Java. La seva particularitat \u00e9s que, en contrast amb altres sistemes existents, ofereix una interf\u00edcie comuna per a l\u2019acc\u00e9s a qualsevol tipus de BD, independentment del fabricant. Per al desenvolupador, la BD real que hi ha al darrere \u00e9s totalment transparent i obvia la necessitat d\u2019efectuar cap classe de configuraci\u00f3 en la m\u00e0quina on s\u2019executa l\u2019aplicaci\u00f3 que accedeix ales dades. Aquesta biblioteca es troba principalment en els paquets java.sql i javax.sql. </p> <p>Partint de la suposici\u00f3 que ja hi ha una BD correctament configurada i a la qualvolem accedir des del codi d\u2019un programa Java, el resum de passos que cal fer dins l\u2019aplicaci\u00f3 \u00e9s:</p> <ol> <li>Importar correctament els packages corresponents</li> <li>Carregar el controlador (driver) per a l\u2019acc\u00e9s a la BD. Aquest dep\u00e8n de la BD a accedir.</li> <li>Establir la connexi\u00f3 a la BD.</li> <li>A partir d\u2019aqu\u00ed, ja es poden executar sent\u00e8ncies SQL en la BD i processarles respostes.</li> <li>Quan ja no es vol treballar m\u00e9s amb la BD, cal tancar la connexi\u00f3.</li> </ol> <p>JDBC, igual que moltes altres API en Java, est\u00e0 dissenyat amb la simplicitat enel pensament i intenta que l\u2019ordre de les operacions que ha de fer l\u2019operador siga gen\u00e8ric i, fins a cert punt, l\u00f2gic. Igual que per llegir dades d\u2019un fitxer el que cal fer\u00e9s dir quina \u00e9s la seva ubicaci\u00f3, obrir-lo, llegir o escriure les dades i tancar-lo, enaquest cas la idea \u00e9s similar. Simplement, \u201cllegir-lo o escriure\u2019l\u201d vol dir invocaruna sent\u00e8ncia SQL, enlloc de posicionar un apuntador. Tot i aix\u00ed, cal tenir un cert domini d\u2019SQL per poder fer correctament aquesta feina.</p>"},{"location":"Tema%2010.%20Acc%C3%A9s%20a%20dades/#installacio-de-drivers","title":"Instal\u00b7laci\u00f3 de drivers","text":"<p>Per poder connectar-nos a una base de dades utilitzant JDBC primer hem d'instal\u00b7lar els drivers i afegir-los al classpath per tal que siguen accessibles. Cada fabricant de sistemes gestors de bases de dades ofereix el connector JDBC per a la seua base de dades, aix\u00f2 vol dir que si la nostra aplicaci\u00f3 s'ha de connectar a una base de dades mysql, ser\u00e0 des del lloc web de MySql d'on ens haruem de descarregar el driver, mentre que si el que volem \u00e9s accedir a una base de dades Oracle, haurem d'obtenir el driver JDBC des d'Oracle.</p>"},{"location":"Tema%2010.%20Acc%C3%A9s%20a%20dades/#descarregar-driver","title":"Descarregar driver","text":"<p>A continuaci\u00f3 podeu entrar i descarregar el driver JDBC per a MySql de de la seg\u00fcent p\u00e0gina:</p> <p>https://dev.mysql.com/downloads/connector/j/</p> <pre><code>$&gt; apt install ./mysql-connector-java_8.0.24-1ubuntu20.04_all.deb\n\n$&gt; dpkg -i mysql-connector-java_8.0.24-1ubuntu20.04_all.deb\n</code></pre> <p>Una vegada executades aquestos commandaments, tindrem didponible el paquest mysql-connector.jar a la ruta /usr/share/java i ara hauriem de podre afegir el paquet al classpath del nostre projecte.</p>"},{"location":"Tema%2010.%20Acc%C3%A9s%20a%20dades/#afegir-al-classpath","title":"Afegir al Classpath","text":"<p>All\u00f2 important \u00e9s que el fitxer que cont\u00e9 el driver mysql-connector.jar es trobe dins del classpath del projecte. Ja que anirem a eixe path per carregar-lo i utilitzar-lo al notre programa.</p> <p>La manera m\u00e9s facil d'afegir el paquet al classpath del nostre projecte \u00e9s amb eclipse. Fem clic dret sobre el nostre projecte i seleccionem propietats</p> <p></p> <p>Al di\u00e0leg que s'ens obre, hem d'anar a Java Build Path i dins de la pestanya Libraries punxar sobre l'opci\u00f3 Classpath per finalment fer clic al bot\u00f3 Add External JARs.</p> <p></p> <p>Ja nom\u00e9s ens quedaria anar a la carpeta en la qual es troba el fitxer .jar del driver i seleccionar-lo.</p> <p></p> <p>Finalment premem el bot\u00f3 Aplicar i tancar i ja ho tindriem al path del nostre projecte.</p>"},{"location":"Tema%2010.%20Acc%C3%A9s%20a%20dades/#connexio-a-la-base-de-dades","title":"Connexi\u00f3 a la base de dades","text":"<p>Per tal de podre connectar amb una base de dades utilitzarem els paquets java.sql i javax.sql. Dins d'aquestos paquets disposem d'una s\u00e8rie de classes,interf\u00edcies etc.. que ens serviran per poder interactuar amb el nostre sistema gestor de bases de dades. Els m\u00e9s importants s\u00f3n: la classe DriveManager i les interf\u00edcies: ResultSet, Connection, Statement i DataSource. Per tant primer, importem tant java.sql com javax.sql al nostre projecte.</p> <p><pre><code>import java.sql.*;\nimport javax.sql.*;\n</code></pre> Una vegada ja tenim importats els paquets del driver JDBC, hem d'establir la connexi\u00f3 a la base de dades mitjan\u00e7ant un objecte connexi\u00f3 i aquest objecte connexi\u00f3 estar\u00e0 relacionat amb un String on s'emmagatzemar\u00e0 la cadena de connexi\u00f3 a la base de dades. Veiem alguns exemples de cadenes de connexi\u00f3:</p> <ul> <li>jdbc:mysql://localhost:port/BD</li> <li>jdbc:odbc:DSN_BD</li> <li>jdbc:oracle:usuari@servidor:port:BD</li> </ul> <p>Cal tindre tamb\u00e9 l'usuari i la contrassenya d'acc\u00e9s a la base de dades. Tamb\u00e9 esl pot donar el cas que es llence una excepci\u00f3, per tant, necessitarem posar el codi dins d'un bloc try..catch.</p> <p>En definitiva per tal d'establir una connexi\u00f3 amb la nostra base de dades en Java ho fariem de la seg\u00fcent forma:</p> <p><pre><code>import java.sql.*;\nimport javax.sql.*;\n\npublic class ConnectaBD {\n\nprivate Connection con;\n\npublic MySqlConnection () {\ntry {\n// 1. Establim la connexi\u00f3 amb la base de dades.\ncon = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/CicleFormatiu\", \"root\", \"******\");\n\n} catch (Exception e) {\nSystem.out.println(\"Error Acc\u00e9s BD\");\n}\n}\n}\n</code></pre> I des del main o la classe Test que cont\u00e9 el m\u00e8tode main est\u00e0tic:</p> <pre><code>import java.sql.*;\nimport javax.sql.*;\n\npublic class TestBD {\n\npublic static void main(String[] args) {\nConnectaBD m = new ConnectaBD();\n}\n\n}\n</code></pre> <p>Arribats a aquest punt ja tindriem establerta la connexio entre la nostra aplicaci\u00f3 i la base de dades</p>"},{"location":"Tema%2010.%20Acc%C3%A9s%20a%20dades/#creacio-i-execucio-de-sentencies-sql","title":"Creaci\u00f3 i execuci\u00f3 de sent\u00e8ncies SQL","text":"<p>El seg\u00fcent pas, una vegada ja tenim establerta la connexi\u00f3 amb la nostra base de dades hem de crear un objecte Statement des del objecte connexi\u00f3 amb el m\u00e8tode createStatement() que ens retornar\u00e0 un objecte de tipus Statement.</p> <pre><code>import java.sql.*;\nimport javax.sql.*;\n\npublic class ConnectaBD {\n\nprivate Connection con;\nprivate Statement stat;\n\npublic ConnectaBD () {\ntry {\n// 1. Establim la connexi\u00f3 amb la base de dades.\ncon = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/CicleFormatiu\", \"root\", \"******\");\n\n// 2. Creem l'objecte Statement.\nstat = con.createStatement();\n\n} catch (Exception e) {\nSystem.out.println(\"Error Acc\u00e9s BD\");\n}\n}\n}\n</code></pre> <p>Ara hauriem de poder executar les sent\u00e8ncies SQL que necessitem. Per poder executar sent\u00e8ncies Sql utilitzarem el m\u00e8tode executeQuery() que \u00e9s un m\u00e8tode que pertany a l'objecte Statement anteriorment creat. Aquest m\u00e8tode ens resornar\u00e0 un ResultSet qu\u00e8 \u00e9s on tindrem la informaci\u00f3 obtesa de la base de dades.</p> <p>En el nostre exemple, crearem un m\u00e8otde nou a la classe MySqlConnection de tipus public al qual se li passar\u00e0 un objecte strQuery de tipus String i ens retornar\u00e0 un ResultSet. Veiem el codi c continuaci\u00f3:</p> <pre><code>public ResultSet ExecutarSQL (String strQuery) {\nResultSet rs = null;\n\nif ( strQuery == null )\nreturn null;\ntry {\nrs = stat.executeQuery(strQuery);\n} catch (Exception e) {\nSystem.out.println(\"Error executant SQL\");\n}\nreturn rs;\n}\n</code></pre> <p>Amb aquest codi, des de la nostra classe on es troba el m\u00e8tode main estatic podriem fer el seg\u00fcent:</p> <pre><code>import java.sql.*;\nimport javax.sql.*;\n\npublic class TestBD {\n\npublic static void main(String[] args) {\nConnectaBD m = new ConnectaBD();\nResultSet rs = m.ExecutarSQL(\"SELECT * FROM Alumnes;\");\n}\n\n}\n</code></pre> <p>Una vegada executat i comprovat aquest codi, deuriem tindre tots els alumnes de la nostra base de dades al ResultSet rs.</p>"},{"location":"Tema%2010.%20Acc%C3%A9s%20a%20dades/#obtencio-de-dades","title":"Obtenci\u00f3 de dades","text":"<p>I ara com llegim els registres de la BD?</p> <p>En el ResultSet que hem obt\u00e9s al pas anterior, el que tindrem ser\u00e0 una esp\u00e8cie de taula on podrem recorrer tota la informaci\u00f3.  Per poder accedir a aquest resultSet podem utilitzar els m\u00e8todes getString() i next() de l'objecte resultSet.</p>"}]}