{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u00cdndex CURS DE PROGRAMACI\u00d3 Tema 1. Introducci\u00f3 a la programaci\u00f3 Tema 2. Programaci\u00f3 Estructurada Tema 3. Programaci\u00f3 Modular Tema 5. Tipus Compostos de Dades Tema 9. Gr\u00e0fics. Java Swing","title":"\u00cdndex"},{"location":"#index","text":"","title":"\u00cdndex"},{"location":"#curs-de-programacio","text":"Tema 1. Introducci\u00f3 a la programaci\u00f3 Tema 2. Programaci\u00f3 Estructurada Tema 3. Programaci\u00f3 Modular Tema 5. Tipus Compostos de Dades Tema 9. Gr\u00e0fics. Java Swing","title":"CURS DE PROGRAMACI\u00d3"},{"location":"Tema%201.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/","text":"Tema 1. Introducci\u00f3 a la programaci\u00f3 Introducci\u00f3 Un programa \u00e9s: Segons el diccionari normatiu valenci\u00e0 (DNV) Conjunt d'instruccions detallades i codificades que es donen a un sistema inform\u00e0tic perqu\u00e8 execute unes determinades operacions. Segons el Termcat: Conjunt de dades i d'instruccions codificades que s\u00f3n l'expressi\u00f3 completa d'un procediment que pot executar un sistema inform\u00e0tic. Per tant programar podrien dir que \u00e9s l\u2019acci\u00f3 d\u2019elaborar un programa. En altres paraules un programa \u00e9s un conjunt d\u2019instruccions escrites en un llenguatge de programaci\u00f3 que s\u2019utilitzen per donar ordres o indicacions a un ordinador. En aquest primer tema, veure una s\u00e8rie de conceptes b\u00e0sics que seran necessaris per entendre que \u00e9s la programaci\u00f3. Conceptes b\u00e0sics Algorisme vs Programa Un algorisme \u00e9s un conjunt ordenat i finti d\u2019operacions o instruccions a seguir que permeten trobar la soluci\u00f3 a un problema. Per exemple: algorisme de la suma, la resta, la multiplicaci\u00f3 o la divisi\u00f3. Per tal de fer una suma de xifres de m\u00e9s d\u2019un digit cadascuna, el que es diu comunament sumar portant, hem de seguir unes \u2018instruccions\u2019 que si les realitzem de forma correcta, obtenim el resultat. Doncs b\u00e9, eixes \u2018instruccions\u2019 serien l\u2019algorisme. Un programa no \u00e9s m\u00e9s que un algorisme les \u2018instruccions\u2019 del qual les executa un ordinadorEn realitat aquesta fase Caracter\u00edstiques d'un programa Un algorisme posteriorment convertit a programa ha de complir una s\u00e8rie de caracter\u00edstiques: Finit: ha de comen\u00e7ar i acabar. Llegible: un programa s'escriu una vegada per\u00f2 es llig moltes. Modificable: ha de poder evolucionar. Eficient: No utilitza m\u00e9s recursos dels necessaris Modular: s'ha de dividir en parts el qual millora la legibilitat. Estructurat Llenguatges de programaci\u00f3 De la mateixa manera que dues persones es comuniquen entre s\u00ed utilitzant un llenguatge natural, una persona es comunica amb una m\u00e0quina utilitzant un llenguatge de programaci\u00f3. Evidentment, un llenguatge de programaci\u00f3 ha de ser m\u00e9s simple i gens ambigu al contrari de com passa amb els llenguatges naturals. Els llenguatges de programaci\u00f3 solen complir les seg\u00fcents caracter\u00edstiques: Existeix un nombre finit de paraules reservades que podem usar: for, var, int, while... \u00c9s a dir, un llenguatge de programaci\u00f3 t\u00e9 un conjunt l\u00e8xic de paraules amb un significat associat com passa amb els llenguatges naturals. Les frases com a combinaci\u00f3 de diferents paraules amb les que ens comuniquem en llenguatge natural es diuen instruccions Cada instrucci\u00f3 finalitza d\u2019una manera concreta, per exemple, utilitzant un \u2018;\u2019 per tal que la m\u00e0quina sapiga quan acaba una instrucci\u00f3 i comen\u00e7a una altra. Classificaci\u00f3 Els llenguatges de programaci\u00f3 es poden classificar segons diversos criteris Proximitat a la m\u00e0quina Les m\u00e0quines en realitat nom\u00e9s entenen 0 i 1, hi han llenguatges de programaci\u00f3 molts pr\u00f2xims a aquest tipus de codificaci\u00f3 bin\u00e0ria per\u00f2 que s\u00f3n complicats d\u2019entendre per un \u00e9sser hum\u00e0. D\u2019una altra banda existeixen llenguatges que utilitzen un conjunt de paraules reservades que fan que siga m\u00e9s f\u00e0cil d\u2019entendre per una persona. Al final de tot aquest llenguatge m\u00e9s pr\u00f2xim al llenguatge hum\u00e0 acaba convertint-se en una seq\u00fc\u00e8ncia de 0 i 1 la m\u00e0quina pot entendre en el proc\u00e9s de compilaci\u00f3 que veurem m\u00e9s endavant. Llenguatges de baix nivell: s\u00f3n els llenguatges m\u00e9s pr\u00f2xims al llenguatge m\u00e0quina com per exemple el llenguatge assemblador. Llenguatges de nivell mitj\u00e0: llenguatges que s\u2019aproximen un poc m\u00e9s al llenguatge natural utilitzant una s\u00e8rie de paraules reservades que s\u2019utilitzen en llenguatge natural com per exemple el llenguatge C Llenguatges d\u2019alt nivell: Els m\u00e9s pr\u00f2xims al llenguatge natural per\u00f2 sense ambig\u00fcitats. Proposit del llenguatge \u00c9s a dir segons quins tipus de programes poden generar Llenguatges de prop\u00f2sit general que s\u00f3n capa\u00e7os de crear qualsevol tipus de programa. Llenguatge C Llenguatges de prop\u00f2sit espec\u00edfic que es dissenyen per trEn realitat aquesta faselenguatges de programaci\u00f3, aquests han anat evolucionant i adaptant-se a les noves caracter\u00edstiques tant f\u00edsiques com d\u2019\u00fas del maquinari i els dispositius. Primera Generaci\u00f3: llenguatges m\u00e0quina i llenguatges assemblador. Anys 40 \u2013 50. En aquesta \u00e8poca s\u2019usaven targetes perforades i es programava utilitzant seq\u00fcencies d\u2019uns i zeros indicant quin c\u00e0lcul havien de realitzar els programes. Els llenguatges assemblador afegeixen la primera capa d\u2019abstracci\u00f3 sobre el binari de forma que una s\u00e8rie d\u2019instruccions simples s\u00f3n despr\u00e9s tradu\u00efdes a binari per la mateixa m\u00e0quina. Aquestes instruccions estaven directament relacionades amb el processador, \u00e9s a dir, cada processador tenia el seu conjunt d'instruccions propi. Segona Generaci\u00f3: Apareixen els llenguatges de nivell mitj\u00e0 i els primers compiladors, que per que ho entenem de moment, s\u00f3n els encarregats de traduir d\u2019un llenguatge de programaci\u00f3 a llenguatge m\u00e0quina o binari. Exemple de llenguatge de nivell mitj\u00e0: FORTRAN (FORmula TRANSlating system) de l\u2019any 1956 Tercera Generaci\u00f3: Apareix la programaci\u00f3 estructurada, ja no nom\u00e9s s\u2019utilitzen els llenguatges de programaci\u00f3 per realitzar c\u00e0lculs matem\u00e0tics com fins ara. Apareix tamb\u00e9 l\u2019\u00fas de variables, subprogrames, estructures etc.. En aquesta generaci\u00f3 podem trobar llenguatges de programaci\u00f3 com C, Pascal o Modula. Quarta Generaci\u00f3: En aquesta generaci\u00f3 trobarem llenguatges desenvolupats per crear un determinat tipus de programari, es configuren per tasques molt concretes. Cinquena Generaci\u00f3: on estarien els llenguatges dissenyats per afrontar la intel\u00b7lig\u00e8ncia artificial com per exemple Prolog. Comen\u00e7a tamb\u00e9 a posar-se en pr\u00e0ctica la programaci\u00f3 orientada a objectes com a nou paradigma de programaci\u00f3. Generaci\u00f3 Visual: nascuda a principis dels anys 90 i com a conseq\u00fc\u00e8ncia de la necessitat de usar interf\u00edcies cada vegada m\u00e9s amigables i f\u00e0cils. Forma d'execuci\u00f3 Com havien dit abans, abans d\u2019executar un programa escrit en un llenguatge de programaci\u00f3 qualsevol, s\u2019ha de traduir al llenguatge que pot entendre la m\u00e0quina, binari. Aquest proc\u00e9s es pot fer de dues formes: Llenguatges compilats: per tal de compilar un programa es realitzen les seg\u00fcents tasques: an\u00e0lisi l\u00e8xic, sint\u00e0ctic i sem\u00e0ntic del programa, traducci\u00f3 a codi objecte, enlla\u00e7 amb altres llibreries i creaci\u00f3 de l\u2019executable. Llenguatges interpretats: Aquest tipus de codis es lligen,Un diagrama de flux \u00e9s una representaci\u00f3 gr\u00e0fica d'un algorisme. S'utilitza en disciplines com la programaci\u00f3 inform\u00e0tica, l'economia, els processos industrials o la psicologia cognitiva. Aquests diagrames utilitzen s\u00edmbols amb significats ben definits que representen els passos de l'algorisme, i representen el flux d'execuci\u00f3 mitjan\u00e7ant fletxes que connecten els punts d'inici i de finalitzaci\u00f3. Un diagrama de flux sempre t\u00e9 un \u00fanic punt d'inici i un \u00fanic punt de finalitzaci\u00f3. A m\u00e9s, tot cam\u00ed d'execuci\u00f3 ha de permetre arribar des de l'inici fins al final. Les seg\u00fcents s\u00f3n accions pr\u00e8vies a la realitzaci\u00f3 del diagrama de flux: Identificar les idees principals que s'han d'incloure en el diagrama de flux. Han d'estar presents el propietari o responsable del proc\u00e9s, els propietaris o responsables del proc\u00e9s anterior i posterior i d'altres processos interrelacionats, aix\u00ed com les terceres parts interessades. Definir qu\u00e8 s'espera obtenir del diagrama de flux. Identificar qui ho far\u00e0 servir i com. Establir el nivell de detall requerit. Determinar els l\u00edmits del proc\u00e9s a descriure. Els passos a seguir per construir el diagrama de flux s\u00f3n: Establir l'abast del proc\u00e9s a descriure. D'aquesta manera quedar\u00e0 fixat el comen\u00e7ament i el final del diagrama. Sovint el comen\u00e7ament \u00e9s la sortida del proc\u00e9s previ i el final l'entrada al proc\u00e9s seg\u00fcent. Identificar i llistar les principals activitats/subprocessos que estan incloses en el proc\u00e9s a descriure i el seu ordre cronol\u00f2gic. Si el nivell de detall definit inclou activitats menors, llistar-les tamb\u00e9. Identificar i llistar els punts de decisi\u00f3. Construir el diagrama respectant la seq\u00fc\u00e8ncia cronol\u00f2gica i assignant els corresponents s\u00edmbols. Assignar un t\u00edtol al diagrama i verificar que estigui complet i descrigui amb exactitud el proc\u00e9s escollit.s a la m\u00e0quina i els declaratius que plantegen una s\u00e8rie de regles sobre les quals es construeix la soluci\u00f3. Aquests \u00faltims s\u2019utilitzen en Intel\u00b7lig\u00e8ncia artificial. Paradigma de programaci\u00f3 Programaci\u00f3 estructurada: Utilitzen les estructures b\u00e0siques de programaci\u00f3: seq\u00fcencial, alternativa i iterativa combinats amb la programaci\u00f3 modular per dissenyar programes. Programaci\u00f3 orientada a objectes: Entenen els programes com un conjunt d\u2019objectes que tenen unes caracter\u00edstiques pr\u00f2pies, uns m\u00e8todes i que interactuen amb els altres objectes que formen part del sistema. Segons el nombre de processos \u00c9s a dir, si permeten la execuci\u00f3 concurrent, m\u00e9s d\u2019un proc\u00e9s al mateix temps o no. Per tant ens podem trobar: Llenguatges de programaci\u00f3 concurrent que permeten la concurr\u00e8ncia Llenguatges de programaci\u00f3 no concurrent. Segons interactivitat Si permeten la interacci\u00f3 amb l\u2019usuari o no. Visuals o no ten la programaci\u00f3 per reutilitzaci\u00f3 de components mitjan\u00e7ant drag and drop en un entorn gr\u00e0fic o no. Paraules reservades Els llenguatges de programaci\u00f3 utilitzen una s\u00e8rie de paraules o s\u00edmbols que fan una funci\u00f3 espec\u00edfica dins d\u2019un programa. A aquest conjunt de signes o combinaci\u00f3 d\u2019ells se les anomena paraules reservades. Aquestes paraules nom\u00e9s poden usar-se en un concepte determinat, mai lliurement per l\u2019usuari. Per exemple, el llenguatge C t\u00e9 com a paraules reservades if o while. Ambdues nom\u00e9s podran ser utilitzades en cas que es vullga iniciar una sent\u00e8ncia de control condicional o bucle. Fases de desenvolupament d'un programa A l\u2019hora d\u2019afrontar la realitzaci\u00f3 d\u2019un programa hem de tindre clar que hem de fer. \u00c9s un error comen\u00e7ar a crear programari a lo loco ja que nom\u00e9s conseguirem deicar a aquest menester m\u00e9s temps que el que es necessita. A m\u00e9s a m\u00e9s el proc\u00e9s de creaci\u00f3 d\u2019un programa no nom\u00e9s \u00e9s picar codi. D\u2019aquesta manera a l\u2019hora de construir un programa es deurien seguir una s\u00e8rie de fases o pautes: An\u00e0lisi del problema Estudi del problema, quina \u00e9s la seua finalitat, a qui va dirigit, quins elements ha d\u2019incloure, quines tasques ha de realitzar. En aquesta fase es realitzen entrevistes amb els usuaris o clients entre d\u2019altres t\u00e8cniques. La finalitat d\u2019aquesta fase \u00e9s fer un recull dels diferents requeriments que ha de tenir el nostre producte. Exemple: Imaginem que ens disposem a fer una aplicaci\u00f3 que gestione la fruteria del barri. En aquesta fase \u00e9s on hauriem d'esbrinar, entre altres coses: quins productes es venen, quin preu tenen, l'agenda de clients, quina informaci\u00f3 volem saber dels clients, quina informaci\u00f3 volem saber de prove\u00efdors etc. Suposem que ens farem c\u00e0rrec d'una part xicoteta d'aquesta aplicaci\u00f3: la introducci\u00f3 de tickets de compra nous . En aquesta fase podriem extreure que a un ticket de compra necessitaria que es reflexara la seg\u00fcent informaci\u00f3: Data i hora de la compra. Llista de productes comprats: producte, preu uniitari, quantitat i total. Subtotal de la compra. IVA i descomptes aplicats. Total de la compra. Producte: Requeriments del sistema o aplicaci\u00f3. En base a la informaci\u00f3 que hem aconseguit per mitja d'entrevistes, enquestes etc.. En altres paraules: el que ha de fer la nostra aplicaci\u00f3, finalitat, objectius. Disseny de l'algorisme Es refereix a com anem a sol\u00b7lucionar els requeriments obtiguts a la fase anterior. En aquesta fase s'estudien possibles opcions d'implementaci\u00f3 per a l'aplicaci\u00f3 que hem de construir, aix\u00ed com decidir l'estructura general de la mateixa. El disseny \u00e9s una estapa complexa i el seu proc\u00e9s s'ha de realitzar d'una forma iterativa. Es possible que la soluci\u00f3 inicial no siga la m\u00e9s adequada, per tant en tal cas s'hauria de redefinir. Tammateix, hi ha cat\u00e0legs de patrons de disseny molt \u00fatils que recullen errades que altres han com\u00e9s per no caure a la mateixa trampa. Exemple: Continuant en la nostra aplicaci\u00f3 de la fruteria, en aquesta fase i una vegada acabada la fase d'an\u00e0lisi d'on s'obtenen els requeriments, hauriem de, per un costat triar el paradigma de programaci\u00f3 que escollirem: programaci\u00f3 estructurada o programaci\u00f3 orientada a objectes (Normalment aquest \u00faltim). El llenguatge de programaci\u00f3 a utilitzar. Una vegada ja ho hem triat, hem de decidir com el nostre programa va a complir amb els requeriments obtesos a la fase d'analisi, \u00e9s a dir, com crearem el nou ticket de compra, com afegirem els productes i com calcularem el preu final i imprimirem el document. Producte: Si hem triat el paradigma de programaci\u00f3 estructurada hauriem de dissenyar els diagramres flux de les diferents funcionalitats de l'aplicaci\u00f3, el pseudocodi, etc.. Per exemple en aquesta fase es dissenyaria l'alogorisme en pseudocodi o diagrama de flux on s'indique pas a pas com es faria la introducci\u00f3 d'un ticket nou. En canvi, si pel contrari escollim el paradigma de programaci\u00f3 orientada a objectes obtindriem casos d'\u00fas, diagrames de classes, diagrames de comportament en UML. Codificaci\u00f3 Ha arribat el moment de picar codi. A la fase de codificaci\u00f3, ens arriben els documents (pseudocodi, flux, diagrames de classes, UML) necessaris per poder comen\u00e7ar a programar. En aquesta fase hem d'escollir les eines (IDEs) adequades per poder desenvolupar el nostre projecte i tamb\u00e9 escollirem (va lligat en realitat) el llenguatge de programaci\u00f3 Exemple: seguint amb la fruteria i suposant que ens han passat un pseudocodi de la nostra apliaci\u00f3 de generaci\u00f3 de tickets, podriem per exemple triar l'IDE Visual Studio Code i C# com a llenguatge de programaci\u00f3 o l'IDE Eclipse i Java o Visual Studio i Java... Producte: El projecte amb tots els fitxers que tenen el codi desenvolupat aix\u00ed com tamb\u00e9 els executables o binaris ja compilats i funcionant. Prova i depuraci\u00f3 Com que errar es d'humans, la fase de proves del cicle de vida de programari busca detectar els errors comesos en les etapes anteriors per tal de poder corregir-los. Per supost, all\u00f2 ideal \u00e9s fer-ho abans que l'usuari final se'ls trobe. Es diu que una prova amb exit \u00e9s una prova que detecta algun error. Documentaci\u00f3 Aquesta \u00e9s la fase que a cap programador li agrada fer, per\u00f2 en realitat \u00e9s una fase que no est\u00e0 necess\u00e0riament al final del cicle de vida del programa, sino que es fa de forma transversal en totes les etapes del desenvolupament. Es considera documentaci\u00f3 des dels requeriments inicials al manual d'usuari passant per el pseudocodi, diagrames de classes i \u00fas, i tamb\u00e9 els comentaris que es posen al codi. Diagrames de flux Un diagrama de flux \u00e9s una representaci\u00f3 gr\u00e0fica d'un algorisme. S'utilitza en disciplines com la programaci\u00f3 inform\u00e0tica, l'economia, els processos industrials o la psicologia cognitiva. Aquests diagrames utilitzen s\u00edmbols amb significats ben definits que representen els passos de l'algorisme, i representen el flux d'execuci\u00f3 mitjan\u00e7ant fletxes que connecten els punts d'inici i de finalitzaci\u00f3. Un diagrama de flux sempre t\u00e9 un \u00fanic punt d'inici i un \u00fanic punt de finalitzaci\u00f3. A m\u00e9s, tot cam\u00ed d'execuci\u00f3 ha de permetre arribar des de l'inici fins al final. Les seg\u00fcents s\u00f3n accions pr\u00e8vies a la realitzaci\u00f3 del diagrama de flux: Identificar les idees principals que s'han d'incloure en el diagrama de flux. Han d'estar presents el propietari o responsable del proc\u00e9s, els propietaris o responsables del proc\u00e9s anterior i posterior i d'altres processos interrelacionats, aix\u00ed com les terceres parts interessades. Definir qu\u00e8 s'espera obtenir del diagrama de flux. Identificar qui ho far\u00e0 servir i com. Establir el nivell de detall requerit. Determinar els l\u00edmits del proc\u00e9s a descriure. Els passos a seguir per construir el diagrama de flux s\u00f3n: Establir l'abast del proc\u00e9s a descriure. D'aquesta manera quedar\u00e0 fixat el comen\u00e7ament i el final del diagrama. Sovint el comen\u00e7ament \u00e9s la sortida del proc\u00e9s previ i el final l'entrada al proc\u00e9s seg\u00fcent. Identificar i llistar les principals activitats/subprocessos que estan incloses en el proc\u00e9s a descriure i el seu ordre cronol\u00f2gic. Si el nivell de detall definit inclou activitats menors, llistar-les tamb\u00e9. Identificar i llistar els punts de decisi\u00f3. Construir el diagrama respectant la seq\u00fc\u00e8ncia cronol\u00f2gica i assignant els corresponents s\u00edmbols. Assignar un t\u00edtol al diagrama i verificar que estigui complet i descrigui amb exactitud el proc\u00e9s escollit. Simbologia i significat Oval o el\u00b7lipse: inici i final (obre i/o tanca el diagrama). Rectangle: activitat (representa l'execuci\u00f3 d'una o m\u00e9s activitats o procediments). Rombe: decisi\u00f3 (formula una pregunta o q\u00fcesti\u00f3). Cercle: connector (representa l'enlla\u00e7 d'activitats amb una altra dins d'un procediment). Triangle cap per avall: fitxer definitiu (guarda un document de forma permanent). Triangle cap per amunt: fitxer temporal (proporciona un temps per a l'emmagatzematge del document). Exemple. La nostra fruiteria A la imatge seg\u00fcent podem observar un exemple d'algorisme de creaci\u00f3 d'un nou ticket (nova compra). Expliquem breument el que fa aquest diagrama: primer crea un nou ticket i afegeix un nou element (fruta o verdura), aquesta acci\u00f3 \u00faltima es repeteix fins que acabe de comprar. Quan s'acaba d'afegir items al nou ticket, es calcula el preu final i s'imprimeix. Pseudocodi El pseudocodi (o fals llenguatge) \u00e9s una descripci\u00f3 a molt alt nivell de l'estructura d'un programa. Encara que utilitze estructures t\u00edpiques de la programaci\u00f3 es diu que \u00e9s a alt nivell perqu\u00e8 una persona amb pocs o sense coneixements inform\u00e0tics pugui entendre i interpretar la porci\u00f3 de codi que estigui llegint. Seguint amb l'exemple anterior, farem el mateix disseny fet amb diagrames de flux per\u00f2 aquesta vegada utilitzant pseudocodi. createTicket(); fer { afegirElement(); } mentre continue comprant calcularPreuFinal(); ImprimirTicket(); Proc\u00e9s de compilaci\u00f3 \u00c9s el proc\u00e9s pel qual es tradueixen les instruccions escrites en un determinat llenguatge de programaci\u00f3 a llenguatge m\u00e0quina. A m\u00e9s d'un traductor, es poden necessitar altres programes per crear un programa objecte executable. Un programa font es pot dividir en m\u00f2duls emmagatzemats en arxius diferents. La tasca de reunir el programa font sovint es confia a un programa diferent, anomenat preprocessador. El preprocessador tamb\u00e9 pot expandir abreviatures, crides a macros, a proposicions del llenguatge font. Normalment la creaci\u00f3 d'un programa executable (un t\u00edpic.exe per a Microsoft Windows o DOS) comporta dos passos. El primer pas es diu compilaci\u00f3 ( pr\u00f2piament dit) i tradueix el codi font escrit en un llenguatge de programaci\u00f3 emmagatzemat en un arxiu a codi de baix nivell (normalment en codi objecte, no directament a llenguatge m\u00e0quina). El segon pas es diu enlla\u00e7at en el qual s'enlla\u00e7a el codi de baix nivell generat de tots els fitxers i subprogrames que s'han enviat compilar i s'afegeix el codi de les funcions que hi ha a les biblioteques del compilador perqu\u00e8 l'executable pugui comunicar-se directament amb el sistema operatiu, traduint aix\u00ed finalment el codi objecte a codi m\u00e0quina, i generant un m\u00f2dul executable. Aquests dos passos es poden fer per separat, emmagatzemant el resultat de la fase de compilaci\u00f3 en arxius objectes (un t\u00edpic .obj per a Microsoft Windows, DOS o per a Unix ), per a enlla\u00e7ar-los en fases posteriors, o crear directament l'executable, amb la qual cosa la fase de compilaci\u00f3 s'emmagatzema nom\u00e9s temporalment. Un programa podria tenir parts escrites en diversos llenguatges (per exemple C, C + + i Asm), que es podrien compilar de forma independent i despr\u00e9s enlla\u00e7ar juntes per formar un \u00fanic m\u00f2dul executable.","title":"Tema 1. Introducci\u00f3 a la programaci\u00f3"},{"location":"Tema%201.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#tema-1-introduccio-a-la-programacio","text":"","title":"Tema 1. Introducci\u00f3 a la programaci\u00f3"},{"location":"Tema%201.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#introduccio","text":"Un programa \u00e9s: Segons el diccionari normatiu valenci\u00e0 (DNV) Conjunt d'instruccions detallades i codificades que es donen a un sistema inform\u00e0tic perqu\u00e8 execute unes determinades operacions. Segons el Termcat: Conjunt de dades i d'instruccions codificades que s\u00f3n l'expressi\u00f3 completa d'un procediment que pot executar un sistema inform\u00e0tic. Per tant programar podrien dir que \u00e9s l\u2019acci\u00f3 d\u2019elaborar un programa. En altres paraules un programa \u00e9s un conjunt d\u2019instruccions escrites en un llenguatge de programaci\u00f3 que s\u2019utilitzen per donar ordres o indicacions a un ordinador. En aquest primer tema, veure una s\u00e8rie de conceptes b\u00e0sics que seran necessaris per entendre que \u00e9s la programaci\u00f3.","title":"Introducci\u00f3"},{"location":"Tema%201.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#conceptes-basics","text":"","title":"Conceptes b\u00e0sics"},{"location":"Tema%201.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#algorisme-vs-programa","text":"Un algorisme \u00e9s un conjunt ordenat i finti d\u2019operacions o instruccions a seguir que permeten trobar la soluci\u00f3 a un problema. Per exemple: algorisme de la suma, la resta, la multiplicaci\u00f3 o la divisi\u00f3. Per tal de fer una suma de xifres de m\u00e9s d\u2019un digit cadascuna, el que es diu comunament sumar portant, hem de seguir unes \u2018instruccions\u2019 que si les realitzem de forma correcta, obtenim el resultat. Doncs b\u00e9, eixes \u2018instruccions\u2019 serien l\u2019algorisme. Un programa no \u00e9s m\u00e9s que un algorisme les \u2018instruccions\u2019 del qual les executa un ordinadorEn realitat aquesta fase","title":"Algorisme vs Programa"},{"location":"Tema%201.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#caracteristiques-dun-programa","text":"Un algorisme posteriorment convertit a programa ha de complir una s\u00e8rie de caracter\u00edstiques: Finit: ha de comen\u00e7ar i acabar. Llegible: un programa s'escriu una vegada per\u00f2 es llig moltes. Modificable: ha de poder evolucionar. Eficient: No utilitza m\u00e9s recursos dels necessaris Modular: s'ha de dividir en parts el qual millora la legibilitat. Estructurat","title":"Caracter\u00edstiques d'un programa"},{"location":"Tema%201.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#llenguatges-de-programacio","text":"De la mateixa manera que dues persones es comuniquen entre s\u00ed utilitzant un llenguatge natural, una persona es comunica amb una m\u00e0quina utilitzant un llenguatge de programaci\u00f3. Evidentment, un llenguatge de programaci\u00f3 ha de ser m\u00e9s simple i gens ambigu al contrari de com passa amb els llenguatges naturals. Els llenguatges de programaci\u00f3 solen complir les seg\u00fcents caracter\u00edstiques: Existeix un nombre finit de paraules reservades que podem usar: for, var, int, while... \u00c9s a dir, un llenguatge de programaci\u00f3 t\u00e9 un conjunt l\u00e8xic de paraules amb un significat associat com passa amb els llenguatges naturals. Les frases com a combinaci\u00f3 de diferents paraules amb les que ens comuniquem en llenguatge natural es diuen instruccions Cada instrucci\u00f3 finalitza d\u2019una manera concreta, per exemple, utilitzant un \u2018;\u2019 per tal que la m\u00e0quina sapiga quan acaba una instrucci\u00f3 i comen\u00e7a una altra.","title":"Llenguatges de programaci\u00f3"},{"location":"Tema%201.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#classificacio","text":"Els llenguatges de programaci\u00f3 es poden classificar segons diversos criteris","title":"Classificaci\u00f3"},{"location":"Tema%201.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#proximitat-a-la-maquina","text":"Les m\u00e0quines en realitat nom\u00e9s entenen 0 i 1, hi han llenguatges de programaci\u00f3 molts pr\u00f2xims a aquest tipus de codificaci\u00f3 bin\u00e0ria per\u00f2 que s\u00f3n complicats d\u2019entendre per un \u00e9sser hum\u00e0. D\u2019una altra banda existeixen llenguatges que utilitzen un conjunt de paraules reservades que fan que siga m\u00e9s f\u00e0cil d\u2019entendre per una persona. Al final de tot aquest llenguatge m\u00e9s pr\u00f2xim al llenguatge hum\u00e0 acaba convertint-se en una seq\u00fc\u00e8ncia de 0 i 1 la m\u00e0quina pot entendre en el proc\u00e9s de compilaci\u00f3 que veurem m\u00e9s endavant. Llenguatges de baix nivell: s\u00f3n els llenguatges m\u00e9s pr\u00f2xims al llenguatge m\u00e0quina com per exemple el llenguatge assemblador. Llenguatges de nivell mitj\u00e0: llenguatges que s\u2019aproximen un poc m\u00e9s al llenguatge natural utilitzant una s\u00e8rie de paraules reservades que s\u2019utilitzen en llenguatge natural com per exemple el llenguatge C Llenguatges d\u2019alt nivell: Els m\u00e9s pr\u00f2xims al llenguatge natural per\u00f2 sense ambig\u00fcitats.","title":"Proximitat a la m\u00e0quina"},{"location":"Tema%201.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#proposit-del-llenguatge","text":"\u00c9s a dir segons quins tipus de programes poden generar Llenguatges de prop\u00f2sit general que s\u00f3n capa\u00e7os de crear qualsevol tipus de programa. Llenguatge C Llenguatges de prop\u00f2sit espec\u00edfic que es dissenyen per trEn realitat aquesta faselenguatges de programaci\u00f3, aquests han anat evolucionant i adaptant-se a les noves caracter\u00edstiques tant f\u00edsiques com d\u2019\u00fas del maquinari i els dispositius. Primera Generaci\u00f3: llenguatges m\u00e0quina i llenguatges assemblador. Anys 40 \u2013 50. En aquesta \u00e8poca s\u2019usaven targetes perforades i es programava utilitzant seq\u00fcencies d\u2019uns i zeros indicant quin c\u00e0lcul havien de realitzar els programes. Els llenguatges assemblador afegeixen la primera capa d\u2019abstracci\u00f3 sobre el binari de forma que una s\u00e8rie d\u2019instruccions simples s\u00f3n despr\u00e9s tradu\u00efdes a binari per la mateixa m\u00e0quina. Aquestes instruccions estaven directament relacionades amb el processador, \u00e9s a dir, cada processador tenia el seu conjunt d'instruccions propi. Segona Generaci\u00f3: Apareixen els llenguatges de nivell mitj\u00e0 i els primers compiladors, que per que ho entenem de moment, s\u00f3n els encarregats de traduir d\u2019un llenguatge de programaci\u00f3 a llenguatge m\u00e0quina o binari. Exemple de llenguatge de nivell mitj\u00e0: FORTRAN (FORmula TRANSlating system) de l\u2019any 1956 Tercera Generaci\u00f3: Apareix la programaci\u00f3 estructurada, ja no nom\u00e9s s\u2019utilitzen els llenguatges de programaci\u00f3 per realitzar c\u00e0lculs matem\u00e0tics com fins ara. Apareix tamb\u00e9 l\u2019\u00fas de variables, subprogrames, estructures etc.. En aquesta generaci\u00f3 podem trobar llenguatges de programaci\u00f3 com C, Pascal o Modula. Quarta Generaci\u00f3: En aquesta generaci\u00f3 trobarem llenguatges desenvolupats per crear un determinat tipus de programari, es configuren per tasques molt concretes. Cinquena Generaci\u00f3: on estarien els llenguatges dissenyats per afrontar la intel\u00b7lig\u00e8ncia artificial com per exemple Prolog. Comen\u00e7a tamb\u00e9 a posar-se en pr\u00e0ctica la programaci\u00f3 orientada a objectes com a nou paradigma de programaci\u00f3. Generaci\u00f3 Visual: nascuda a principis dels anys 90 i com a conseq\u00fc\u00e8ncia de la necessitat de usar interf\u00edcies cada vegada m\u00e9s amigables i f\u00e0cils.","title":"Proposit del llenguatge"},{"location":"Tema%201.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#forma-dexecucio","text":"Com havien dit abans, abans d\u2019executar un programa escrit en un llenguatge de programaci\u00f3 qualsevol, s\u2019ha de traduir al llenguatge que pot entendre la m\u00e0quina, binari. Aquest proc\u00e9s es pot fer de dues formes: Llenguatges compilats: per tal de compilar un programa es realitzen les seg\u00fcents tasques: an\u00e0lisi l\u00e8xic, sint\u00e0ctic i sem\u00e0ntic del programa, traducci\u00f3 a codi objecte, enlla\u00e7 amb altres llibreries i creaci\u00f3 de l\u2019executable. Llenguatges interpretats: Aquest tipus de codis es lligen,Un diagrama de flux \u00e9s una representaci\u00f3 gr\u00e0fica d'un algorisme. S'utilitza en disciplines com la programaci\u00f3 inform\u00e0tica, l'economia, els processos industrials o la psicologia cognitiva. Aquests diagrames utilitzen s\u00edmbols amb significats ben definits que representen els passos de l'algorisme, i representen el flux d'execuci\u00f3 mitjan\u00e7ant fletxes que connecten els punts d'inici i de finalitzaci\u00f3. Un diagrama de flux sempre t\u00e9 un \u00fanic punt d'inici i un \u00fanic punt de finalitzaci\u00f3. A m\u00e9s, tot cam\u00ed d'execuci\u00f3 ha de permetre arribar des de l'inici fins al final. Les seg\u00fcents s\u00f3n accions pr\u00e8vies a la realitzaci\u00f3 del diagrama de flux: Identificar les idees principals que s'han d'incloure en el diagrama de flux. Han d'estar presents el propietari o responsable del proc\u00e9s, els propietaris o responsables del proc\u00e9s anterior i posterior i d'altres processos interrelacionats, aix\u00ed com les terceres parts interessades. Definir qu\u00e8 s'espera obtenir del diagrama de flux. Identificar qui ho far\u00e0 servir i com. Establir el nivell de detall requerit. Determinar els l\u00edmits del proc\u00e9s a descriure. Els passos a seguir per construir el diagrama de flux s\u00f3n: Establir l'abast del proc\u00e9s a descriure. D'aquesta manera quedar\u00e0 fixat el comen\u00e7ament i el final del diagrama. Sovint el comen\u00e7ament \u00e9s la sortida del proc\u00e9s previ i el final l'entrada al proc\u00e9s seg\u00fcent. Identificar i llistar les principals activitats/subprocessos que estan incloses en el proc\u00e9s a descriure i el seu ordre cronol\u00f2gic. Si el nivell de detall definit inclou activitats menors, llistar-les tamb\u00e9. Identificar i llistar els punts de decisi\u00f3. Construir el diagrama respectant la seq\u00fc\u00e8ncia cronol\u00f2gica i assignant els corresponents s\u00edmbols. Assignar un t\u00edtol al diagrama i verificar que estigui complet i descrigui amb exactitud el proc\u00e9s escollit.s a la m\u00e0quina i els declaratius que plantegen una s\u00e8rie de regles sobre les quals es construeix la soluci\u00f3. Aquests \u00faltims s\u2019utilitzen en Intel\u00b7lig\u00e8ncia artificial.","title":"Forma d'execuci\u00f3"},{"location":"Tema%201.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#paradigma-de-programacio","text":"Programaci\u00f3 estructurada: Utilitzen les estructures b\u00e0siques de programaci\u00f3: seq\u00fcencial, alternativa i iterativa combinats amb la programaci\u00f3 modular per dissenyar programes. Programaci\u00f3 orientada a objectes: Entenen els programes com un conjunt d\u2019objectes que tenen unes caracter\u00edstiques pr\u00f2pies, uns m\u00e8todes i que interactuen amb els altres objectes que formen part del sistema.","title":"Paradigma de programaci\u00f3"},{"location":"Tema%201.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#segons-el-nombre-de-processos","text":"\u00c9s a dir, si permeten la execuci\u00f3 concurrent, m\u00e9s d\u2019un proc\u00e9s al mateix temps o no. Per tant ens podem trobar: Llenguatges de programaci\u00f3 concurrent que permeten la concurr\u00e8ncia Llenguatges de programaci\u00f3 no concurrent.","title":"Segons el nombre de processos"},{"location":"Tema%201.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#segons-interactivitat","text":"Si permeten la interacci\u00f3 amb l\u2019usuari o no.","title":"Segons interactivitat"},{"location":"Tema%201.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#visuals-o-no","text":"ten la programaci\u00f3 per reutilitzaci\u00f3 de components mitjan\u00e7ant drag and drop en un entorn gr\u00e0fic o no.","title":"Visuals o no"},{"location":"Tema%201.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#paraules-reservades","text":"Els llenguatges de programaci\u00f3 utilitzen una s\u00e8rie de paraules o s\u00edmbols que fan una funci\u00f3 espec\u00edfica dins d\u2019un programa. A aquest conjunt de signes o combinaci\u00f3 d\u2019ells se les anomena paraules reservades. Aquestes paraules nom\u00e9s poden usar-se en un concepte determinat, mai lliurement per l\u2019usuari. Per exemple, el llenguatge C t\u00e9 com a paraules reservades if o while. Ambdues nom\u00e9s podran ser utilitzades en cas que es vullga iniciar una sent\u00e8ncia de control condicional o bucle.","title":"Paraules reservades"},{"location":"Tema%201.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#fases-de-desenvolupament-dun-programa","text":"A l\u2019hora d\u2019afrontar la realitzaci\u00f3 d\u2019un programa hem de tindre clar que hem de fer. \u00c9s un error comen\u00e7ar a crear programari a lo loco ja que nom\u00e9s conseguirem deicar a aquest menester m\u00e9s temps que el que es necessita. A m\u00e9s a m\u00e9s el proc\u00e9s de creaci\u00f3 d\u2019un programa no nom\u00e9s \u00e9s picar codi. D\u2019aquesta manera a l\u2019hora de construir un programa es deurien seguir una s\u00e8rie de fases o pautes:","title":"Fases de desenvolupament d'un programa"},{"location":"Tema%201.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#analisi-del-problema","text":"Estudi del problema, quina \u00e9s la seua finalitat, a qui va dirigit, quins elements ha d\u2019incloure, quines tasques ha de realitzar. En aquesta fase es realitzen entrevistes amb els usuaris o clients entre d\u2019altres t\u00e8cniques. La finalitat d\u2019aquesta fase \u00e9s fer un recull dels diferents requeriments que ha de tenir el nostre producte. Exemple: Imaginem que ens disposem a fer una aplicaci\u00f3 que gestione la fruteria del barri. En aquesta fase \u00e9s on hauriem d'esbrinar, entre altres coses: quins productes es venen, quin preu tenen, l'agenda de clients, quina informaci\u00f3 volem saber dels clients, quina informaci\u00f3 volem saber de prove\u00efdors etc. Suposem que ens farem c\u00e0rrec d'una part xicoteta d'aquesta aplicaci\u00f3: la introducci\u00f3 de tickets de compra nous . En aquesta fase podriem extreure que a un ticket de compra necessitaria que es reflexara la seg\u00fcent informaci\u00f3: Data i hora de la compra. Llista de productes comprats: producte, preu uniitari, quantitat i total. Subtotal de la compra. IVA i descomptes aplicats. Total de la compra. Producte: Requeriments del sistema o aplicaci\u00f3. En base a la informaci\u00f3 que hem aconseguit per mitja d'entrevistes, enquestes etc.. En altres paraules: el que ha de fer la nostra aplicaci\u00f3, finalitat, objectius.","title":"An\u00e0lisi del problema"},{"location":"Tema%201.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#disseny-de-lalgorisme","text":"Es refereix a com anem a sol\u00b7lucionar els requeriments obtiguts a la fase anterior. En aquesta fase s'estudien possibles opcions d'implementaci\u00f3 per a l'aplicaci\u00f3 que hem de construir, aix\u00ed com decidir l'estructura general de la mateixa. El disseny \u00e9s una estapa complexa i el seu proc\u00e9s s'ha de realitzar d'una forma iterativa. Es possible que la soluci\u00f3 inicial no siga la m\u00e9s adequada, per tant en tal cas s'hauria de redefinir. Tammateix, hi ha cat\u00e0legs de patrons de disseny molt \u00fatils que recullen errades que altres han com\u00e9s per no caure a la mateixa trampa. Exemple: Continuant en la nostra aplicaci\u00f3 de la fruteria, en aquesta fase i una vegada acabada la fase d'an\u00e0lisi d'on s'obtenen els requeriments, hauriem de, per un costat triar el paradigma de programaci\u00f3 que escollirem: programaci\u00f3 estructurada o programaci\u00f3 orientada a objectes (Normalment aquest \u00faltim). El llenguatge de programaci\u00f3 a utilitzar. Una vegada ja ho hem triat, hem de decidir com el nostre programa va a complir amb els requeriments obtesos a la fase d'analisi, \u00e9s a dir, com crearem el nou ticket de compra, com afegirem els productes i com calcularem el preu final i imprimirem el document. Producte: Si hem triat el paradigma de programaci\u00f3 estructurada hauriem de dissenyar els diagramres flux de les diferents funcionalitats de l'aplicaci\u00f3, el pseudocodi, etc.. Per exemple en aquesta fase es dissenyaria l'alogorisme en pseudocodi o diagrama de flux on s'indique pas a pas com es faria la introducci\u00f3 d'un ticket nou. En canvi, si pel contrari escollim el paradigma de programaci\u00f3 orientada a objectes obtindriem casos d'\u00fas, diagrames de classes, diagrames de comportament en UML.","title":"Disseny de l'algorisme"},{"location":"Tema%201.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#codificacio","text":"Ha arribat el moment de picar codi. A la fase de codificaci\u00f3, ens arriben els documents (pseudocodi, flux, diagrames de classes, UML) necessaris per poder comen\u00e7ar a programar. En aquesta fase hem d'escollir les eines (IDEs) adequades per poder desenvolupar el nostre projecte i tamb\u00e9 escollirem (va lligat en realitat) el llenguatge de programaci\u00f3 Exemple: seguint amb la fruteria i suposant que ens han passat un pseudocodi de la nostra apliaci\u00f3 de generaci\u00f3 de tickets, podriem per exemple triar l'IDE Visual Studio Code i C# com a llenguatge de programaci\u00f3 o l'IDE Eclipse i Java o Visual Studio i Java... Producte: El projecte amb tots els fitxers que tenen el codi desenvolupat aix\u00ed com tamb\u00e9 els executables o binaris ja compilats i funcionant.","title":"Codificaci\u00f3"},{"location":"Tema%201.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#prova-i-depuracio","text":"Com que errar es d'humans, la fase de proves del cicle de vida de programari busca detectar els errors comesos en les etapes anteriors per tal de poder corregir-los. Per supost, all\u00f2 ideal \u00e9s fer-ho abans que l'usuari final se'ls trobe. Es diu que una prova amb exit \u00e9s una prova que detecta algun error.","title":"Prova i depuraci\u00f3"},{"location":"Tema%201.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#documentacio","text":"Aquesta \u00e9s la fase que a cap programador li agrada fer, per\u00f2 en realitat \u00e9s una fase que no est\u00e0 necess\u00e0riament al final del cicle de vida del programa, sino que es fa de forma transversal en totes les etapes del desenvolupament. Es considera documentaci\u00f3 des dels requeriments inicials al manual d'usuari passant per el pseudocodi, diagrames de classes i \u00fas, i tamb\u00e9 els comentaris que es posen al codi.","title":"Documentaci\u00f3"},{"location":"Tema%201.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#diagrames-de-flux","text":"Un diagrama de flux \u00e9s una representaci\u00f3 gr\u00e0fica d'un algorisme. S'utilitza en disciplines com la programaci\u00f3 inform\u00e0tica, l'economia, els processos industrials o la psicologia cognitiva. Aquests diagrames utilitzen s\u00edmbols amb significats ben definits que representen els passos de l'algorisme, i representen el flux d'execuci\u00f3 mitjan\u00e7ant fletxes que connecten els punts d'inici i de finalitzaci\u00f3. Un diagrama de flux sempre t\u00e9 un \u00fanic punt d'inici i un \u00fanic punt de finalitzaci\u00f3. A m\u00e9s, tot cam\u00ed d'execuci\u00f3 ha de permetre arribar des de l'inici fins al final. Les seg\u00fcents s\u00f3n accions pr\u00e8vies a la realitzaci\u00f3 del diagrama de flux: Identificar les idees principals que s'han d'incloure en el diagrama de flux. Han d'estar presents el propietari o responsable del proc\u00e9s, els propietaris o responsables del proc\u00e9s anterior i posterior i d'altres processos interrelacionats, aix\u00ed com les terceres parts interessades. Definir qu\u00e8 s'espera obtenir del diagrama de flux. Identificar qui ho far\u00e0 servir i com. Establir el nivell de detall requerit. Determinar els l\u00edmits del proc\u00e9s a descriure. Els passos a seguir per construir el diagrama de flux s\u00f3n: Establir l'abast del proc\u00e9s a descriure. D'aquesta manera quedar\u00e0 fixat el comen\u00e7ament i el final del diagrama. Sovint el comen\u00e7ament \u00e9s la sortida del proc\u00e9s previ i el final l'entrada al proc\u00e9s seg\u00fcent. Identificar i llistar les principals activitats/subprocessos que estan incloses en el proc\u00e9s a descriure i el seu ordre cronol\u00f2gic. Si el nivell de detall definit inclou activitats menors, llistar-les tamb\u00e9. Identificar i llistar els punts de decisi\u00f3. Construir el diagrama respectant la seq\u00fc\u00e8ncia cronol\u00f2gica i assignant els corresponents s\u00edmbols. Assignar un t\u00edtol al diagrama i verificar que estigui complet i descrigui amb exactitud el proc\u00e9s escollit.","title":"Diagrames de flux"},{"location":"Tema%201.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#simbologia-i-significat","text":"Oval o el\u00b7lipse: inici i final (obre i/o tanca el diagrama). Rectangle: activitat (representa l'execuci\u00f3 d'una o m\u00e9s activitats o procediments). Rombe: decisi\u00f3 (formula una pregunta o q\u00fcesti\u00f3). Cercle: connector (representa l'enlla\u00e7 d'activitats amb una altra dins d'un procediment). Triangle cap per avall: fitxer definitiu (guarda un document de forma permanent). Triangle cap per amunt: fitxer temporal (proporciona un temps per a l'emmagatzematge del document).","title":"Simbologia i significat"},{"location":"Tema%201.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#exemple-la-nostra-fruiteria","text":"A la imatge seg\u00fcent podem observar un exemple d'algorisme de creaci\u00f3 d'un nou ticket (nova compra). Expliquem breument el que fa aquest diagrama: primer crea un nou ticket i afegeix un nou element (fruta o verdura), aquesta acci\u00f3 \u00faltima es repeteix fins que acabe de comprar. Quan s'acaba d'afegir items al nou ticket, es calcula el preu final i s'imprimeix.","title":"Exemple. La nostra fruiteria"},{"location":"Tema%201.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#pseudocodi","text":"El pseudocodi (o fals llenguatge) \u00e9s una descripci\u00f3 a molt alt nivell de l'estructura d'un programa. Encara que utilitze estructures t\u00edpiques de la programaci\u00f3 es diu que \u00e9s a alt nivell perqu\u00e8 una persona amb pocs o sense coneixements inform\u00e0tics pugui entendre i interpretar la porci\u00f3 de codi que estigui llegint. Seguint amb l'exemple anterior, farem el mateix disseny fet amb diagrames de flux per\u00f2 aquesta vegada utilitzant pseudocodi. createTicket(); fer { afegirElement(); } mentre continue comprant calcularPreuFinal(); ImprimirTicket();","title":"Pseudocodi"},{"location":"Tema%201.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#proces-de-compilacio","text":"\u00c9s el proc\u00e9s pel qual es tradueixen les instruccions escrites en un determinat llenguatge de programaci\u00f3 a llenguatge m\u00e0quina. A m\u00e9s d'un traductor, es poden necessitar altres programes per crear un programa objecte executable. Un programa font es pot dividir en m\u00f2duls emmagatzemats en arxius diferents. La tasca de reunir el programa font sovint es confia a un programa diferent, anomenat preprocessador. El preprocessador tamb\u00e9 pot expandir abreviatures, crides a macros, a proposicions del llenguatge font. Normalment la creaci\u00f3 d'un programa executable (un t\u00edpic.exe per a Microsoft Windows o DOS) comporta dos passos. El primer pas es diu compilaci\u00f3 ( pr\u00f2piament dit) i tradueix el codi font escrit en un llenguatge de programaci\u00f3 emmagatzemat en un arxiu a codi de baix nivell (normalment en codi objecte, no directament a llenguatge m\u00e0quina). El segon pas es diu enlla\u00e7at en el qual s'enlla\u00e7a el codi de baix nivell generat de tots els fitxers i subprogrames que s'han enviat compilar i s'afegeix el codi de les funcions que hi ha a les biblioteques del compilador perqu\u00e8 l'executable pugui comunicar-se directament amb el sistema operatiu, traduint aix\u00ed finalment el codi objecte a codi m\u00e0quina, i generant un m\u00f2dul executable. Aquests dos passos es poden fer per separat, emmagatzemant el resultat de la fase de compilaci\u00f3 en arxius objectes (un t\u00edpic .obj per a Microsoft Windows, DOS o per a Unix ), per a enlla\u00e7ar-los en fases posteriors, o crear directament l'executable, amb la qual cosa la fase de compilaci\u00f3 s'emmagatzema nom\u00e9s temporalment. Un programa podria tenir parts escrites en diversos llenguatges (per exemple C, C + + i Asm), que es podrien compilar de forma independent i despr\u00e9s enlla\u00e7ar juntes per formar un \u00fanic m\u00f2dul executable.","title":"Proc\u00e9s de compilaci\u00f3"},{"location":"Tema%202.%20Programaci%C3%B3%20Estructurada/","text":"Tema 2. Programaci\u00f3 Estructurada Introducci\u00f3 Al inici dels temps del la inform\u00e0tica moderna segona meitat dels segle XX) i considerant ordinador programable aquell que seguia l'arquitectura de von Neumann, els primers programes s'escrivien en binari (llenguatge m\u00e0quina) en tarjetes perforades. Aquestes targetes perforades s'utilitzaven per escriure programes sencers amb una finalitat molt concreta. Les targetes s'utilitzaven com a entrada de dades a la m\u00e0quina que s'encarregava de llegir les instruccions escrites en binari, i una a una, carregar-les a mem\u00f2ria i executar-les. Un problema d'aquest incipient paradigma de programaci\u00f3 \u00e9s que cada conjunt d'instruccions \u00e9s espec\u00edfic a cada m\u00e0quina. Amb el temps i conforme augmenta la capacitat de computaci\u00f3 dels ordinadors i tamb\u00e9 la complexitat dels programes, les targetes deixen de ser funcionals i apareixen els primers llenguatges de programaci\u00f3 generalistes com FORTRAN, COBOL o LISP per\u00f2 aquestos encara no utilitzen el paradigma de programaci\u00f3 estructurada. A la decada dels anys 60, B\u00f6hm i Jacopini escriuen el teorema de la programaci\u00f3 estructurada, basant-se per supost en part en aquells llenguatges de programaci\u00f3 que ja exisitien, i arriben a la conclusi\u00f3 qu\u00e8: la sent\u00e8ncia GOTO era una sent\u00e8ncia considerada perjudicial per a la programaci\u00f3 i per entendre els programes escrits en qualsevol llenguatge i tamb\u00e9 que amb nom\u00e9s les estructures seq\u00fcencial, iterativa i condicional era suficient per escriure qualsevol programa. En aquest tema veurem quine s\u00f3n les estructures de control de la programaci\u00f3 estructurada i com s'utilitzen, aix\u00ed com tamb\u00e9 les seues corresponents representacions gr\u00e0fiques en programes escrits en diagrames de flux, pseudocodi o algun llenguatge de programaci\u00f3 d'alt nivell. Conceptes b\u00e0sics El teorema de el programa estructurat \u00e9s un resultat en la teoria de llenguatges de programaci\u00f3. Estableix que tota funci\u00f3 computable pot ser implementada en un llenguatge de programaci\u00f3 que combine nom\u00e9s tres estructures l\u00f2giques. Aquestes tres formes tamb\u00e9 anomenades estructures de control espec\u00edficament s\u00f3n: Seq\u00fc\u00e8ncia: execuci\u00f3 d'una instrucci\u00f3 despr\u00e9s d'una altra. Selecci\u00f3: execuci\u00f3 d'una de dues instruccions (o conjunts), segons el valor d'una variable booleana. Iteraci\u00f3: execuci\u00f3 d'una instrucci\u00f3 (o conjunt) mentre una variable booleana siga 'veritable'. Aquesta estructura l\u00f2gica tamb\u00e9 es coneix com a cicle o bucle. Aquest teorema demostra que la instrucci\u00f3 GOTO no \u00e9s estrictament necess\u00e0ria i que per a tot programa que l'utilitze existeix un altre equivalent que no fa \u00fas d'aquesta instrucci\u00f3. Els cient\u00edfics de la computaci\u00f3 usualment acrediten el teorema a un article de 1966 escrit per Corrado B\u00f6hm i Giuseppe Jacopini . No obstant aix\u00f2, David Harel va rastrejar els seus or\u00edgens fins a la descripci\u00f3 de 1946 de l'arquitectura de von Neumann i el teorema de la forma normal de Kleene. Abans d'entrar en el detall i funcionament d'aquestes estructures de control de la programaci\u00f3 estructurada, hem de veure tamb\u00e9 (basnt-nos en un llenguatge de programaci\u00f3 concret) com es representa la informaci\u00f3, les dades, les variables, operadors, operacions, etc. En el nostre cas usarem l'IDE Processing i el llenguatge sera Java. Dades, Variables i identificadors. En qualsevol llenguatge de programaci\u00f3 existeixen una s\u00e8rie d'elements com variables, constants, funcions, llibreries. Aquestos elements requereixen d'un nom per tal de distingir-lo de la resta. Aquestos noms es diuen identificadors Un identificador \u00e9s una cadena alfan\u00famerica que representa o dona un nom a un element dins del nostre programa. Els identificadors de les variables s\u00f3n noms que s'inventa el programador i s'hauria de tindre en consideraci\u00f3 al seg\u00fcent m\u00e0xima: Quan triem el nom per identificar a una variable, ha de ser significatiu, \u00e9s a dir, que el mateix identificador ja done alguna pista de que \u00e9s el que representa. Paraules reservades Uns dels principals identificadors que ens trobarem a tot llenguatge de programaci\u00f3 s\u00f3n les paraules reservades . Per entendre-ho, el conjunt de paraules reservades d'un llenguatge de programaci\u00f3 s\u00f3n el diccionari de totes les paraules que t\u00e9 aquest llenguatge. Aquetes paraules reservades no poden utilitzar-se per cap altra cosa m\u00e9s, per exemple, si Java t\u00e9 la paraula reservada public , el programador no podr\u00e0 crear cap variable utilitzant l'identificador public. Tipus de dades Tot llenguatge de programaci\u00f3 porta una s\u00e8rie de tipus de dades predefinits que es poden usar. Aquestos tipus de dades tamb\u00e9 es coneixen com a tipus primitius o tipus simples. . Java defineix 8 tipus diferents de dades: byte, short, int, long, char, float, double i boolean. Aquestos tipus es poden agrupar en quatre blocs: - Enters: on podem trobar el byte, short, long i int. - Punt flotant: aquest grup inclou el float i el double on es representen els n\u00fameros decimals. - Caracters: char representa a tot el conjunt de caracters del nostre sistema. - Boole\u00e0: boolean \u00e9s un tipus especial que nom\u00e9s pot tindre dos possibles valors: true o false. Variables Al final tot programa s'encarrega de processar informaci\u00f3 i aquesta informaci\u00f3 ha d'estar disponible en algun lloc del nostre codi. Per exemple si volem fer un programa que sume dos n\u00fameros enters, haurem de tindre la informaci\u00f3 o el valor d'aquestos dos n\u00fameros en algun lloc. Una variable \u00e9s com un contenidor que t\u00e9 associat un tipus (enter, real, caracter) i cont\u00e9 un valor, si es tracta d'una variable de tipus enter contindr\u00e0 un valor enter, si per contra es tracta d'una variable de tipus caracter contindr\u00e0 una lletra. La variable \u00e9s l'unitat b\u00e0sica d'emmagatzemament en Java. Una variable en java es defineix amb la combinaci\u00f3 d'un identificador i el seu tipus de dades // Declaraci\u00f3 d'una variable en Java // type identifier; // Per exemple: int a; float b; long j; char c; int i = 0; // En aquesta declaraci\u00f3 s'inclou tamb\u00e9 la inicialitzaci\u00f3 del seu valor. Les varialbes com a contenidors d'informaci\u00f3, poden variar el seu valor durant l'execuci\u00f3 del programa. Constants Les constants en java s\u00f3n semblants a les variables, \u00e9s a dir, s\u00f3n contenidors d'informaci\u00f3, tenen un identificador i un tipus b\u00e0sic associat per\u00f2 el seu valor no canvia durant l'execuci\u00f3 del programa. Les variables en java es defineixen de la seg\u00fcent forma: // Constant en java static final int prova = 10; // Prova valdr\u00e0 10 durant tot el programa. Comentaris Els comentaris a qualsevol llenguatge de programaci\u00f3, s'utilitzen per fer que el codi siga m\u00e9s f\u00e0cil de llegir millorant aix\u00ed el manteniment. Els comentaris s\u00f3n totalment ignorats pel compilador. En java tenim tres tipus de comentaris: - Comentaris en l\u00ednia: - S'utilitzen per comentar parts concretes del codi. // Comentari d'una sola l\u00ednia en Java Comentaris de v\u00e0ries l\u00ednies: Si un programador vol descriure m\u00e9s detalladament un codi m\u00e9s complex i no es pot utilitzar el comentari d'una l\u00ednia perqu\u00e8 requereix m\u00e9s text /* Comentari de m\u00e9s d'una l\u00ednia linia 1 linia 2 linia 3 linia final */ Comentaris de documentaci\u00f3: Aquest tipus de comentaris ajuda a l'hora de generar documentaci\u00f3 de forma automatitzada per alguns dels IDEs que s'utilitzen a l'actualitat o les enies que porten amb ells. Un exemple d'eina de generar documentaci\u00f3 de refer\u00e8ncia \u00e9s javadoc /** * Troba la mitjana de tres n\u00fameros! * El programa FindAvg implementa una aplicacio que * simplement calcula la mitjana de tres enteros i els mostra * a la eixida per pantalla. * * @author Aleix Caminou * @version 1.0 * @since 2020-2-2 */ Operadors i expressions Les expressions s\u00f3n equacions matem\u00e0tiques que solen representar c\u00e0lculs, per exemple: 3 x + 7 z. L'expressi\u00f3 anterior la formen els seg\u00fcents elements: dos literals enters: 3 i 7; dos identificadors de variables (no sabem el tipus) x i z; i els simbols * i +. Aquestos simbols s\u00f3n els operadors, concretament * \u00e9s l'operador aritm\u00e8tic de multiplicaci\u00f3 i el s\u00edmbol + representa l'operador de suma. Aquesta expressi\u00f3 tindr\u00e0 finalment un valor, per exemple, s\u00ed x val 3 i z val 2, el resultat de l'expressi\u00f3 seria 23. Operador assignaci\u00f3 L'operador assignaci\u00f3 en Java \u00e9s el s\u00edmbol '=' i s'utilitza de la seg\u00fcent forma // variable = expressi\u00f3 // Seguint l'exemple anterior int x=3, y, z=2; y = 3*x + 7*z; On l'operador '=' assignaria el valor de l'expressi\u00f3 '3x+2z' a la variable y, \u00e9s a dir, executada aquesta acci\u00f3 dins de la variable y haur\u00edem depositat el valor 23. Altres exemples d'\u00fas de l'operador assignaci\u00f3: int a, b, c; a = b = c = 10; // Tant a com b com c tindr\u00eden valor 10 int i = 3; i = i * 3; // i valdria 9 int j = 2; j *= 2; // Aquesta manera peculiar d'usar l'operador assignaci\u00f3 \u00e9s el mateix que j = j * 2; Operadors aritm\u00e8tics Els operador aritm\u00e8tics en Java serveixen per realitzar operacions b\u00e0siques algebraiques com: la suma, resta, multiplicaci\u00f3 o divisi\u00f3. - Suma: s\u00edmbol (+). Exemple: 4+5 - Resta: s\u00edmbol (-). Exemple: 5-2 - Multiplicaci\u00f3: s\u00edmbol ( ). Exemple: 3 7 - Divisi\u00f3 (Quocient): s\u00edmbol (/). Exemple: 8/5. - Divisi\u00f3 (Residu): s\u00edmbol (%). Exemple 10%2. Operadors increment i decrement En programaci\u00f3 i com her\u00e8ncia de C i C++ existeixen els operadors increment (++) i decrement (--) que el que fan \u00e9s incrementar o decrementar en una unitat la variable a la qual s'apliquen. int x = 10; x ++; // Aquest codi seria equivalent a x = x + 1; x --; // Aquest codi seria equivalent a x = x -1 ; Aquestos operadors tamb\u00e9 es poden posar abans de la variable produint el mateix efecte int x = 10; ++ x; // Aquest codi seria equivalent a x = x + 1; -- x; // Aquest codi seria equivalent a x = x -1 ; Operadors relacionals Com hem explicat en l'apartat sobre Tipus de dades , existeix en Java el tipus boolean que nom\u00e9s pot tenir valors true o false. Aquest tipus de dades est\u00e0 relacionat amb els operadors relacionals, ja que tota expressi\u00f3 relacional ha de donar com a resultat b\u00e9 true o false. Els operadors relacionals a Java s\u00f3n: - == o igual a. Exemple d'\u00fas: a == b, compara si a i b s\u00f3n iguals o no. - != o distint de. Exemple d'\u00fas: a != b, comprova si a i b s\u00f3n distints. - > o major que. Exemple d'\u00fas: 'a>b' comprova si a \u00e9s major que b. - < o menor que. Exemple d'\u00fas: 'a = o major igual que. Exemple d'\u00fas: 'a>=b' comprova si a \u00e9s major o igual que b. - <=** o menor igual que. Exemple d'\u00fas: 'a<=b' comprova si a \u00e9s menor o igual que b. Operadors l\u00f2gics not (!) : negaci\u00f3 l\u00f2gica. and (&&) : and l\u00f2gic. or (||) : or l\u00f2gic. or exclusivo (^) : or exclusiu. Vegem alguns exemples. Operador condicional Java inclou un operador especial de tipus ternari que de vegades s'utilitza per substituir algunes estructures if then else. Aquest \u00e9s l'operador ? i la seua forma general \u00e9s: expressio1 ? expressio2 : expressio 3; Expressi\u00f3 1: \u00e9s l'expressi\u00f3 que avalua un valor boole\u00e0, d'aquesta forma, si l'expressi\u00f3 1 s'avalua com a true, s'executaria l'expressi\u00f3 2 mentre que si l'expressi\u00f3 1 s'avalua a false, s'executaria l'expressi\u00f3 2. Exemple double temperatura; // Variable que ens indica la temperatur ambient boolean AC_ON = false; // Variable booleana que ens indica si l'aire condicionat est\u00e0 en marxa temperatura > 25 ? AC_ON = true : AC_ON = false; // B\u00e0sicament el que faria aquesta espressi\u00f3 seria engegar l'aire condicionat si la temperatura // \u00e9s superior a 25 graus. Estructures Com ja hem anomenat als primers putns d'aquest tema, el teorema de la programaci\u00f3 estructurada preveu una s\u00e8rie d'estrucutures b\u00e0siques amb les quals es podr\u00eden codificar tots els algorismes sense necessitat d'usar cap sent\u00e8ncia GOTO o similar. Aquestes estructures s\u00f3n: - Seq\u00fcencial - Condicional - Repetitiva Al final tot algorisme escrit en un llenguatge de programaci\u00f3 estrucuturada s'executa de forma seq\u00fcencial, \u00e9s a dir, es llig la primera sent\u00e8ncia s'executa i despr\u00e8s passem a la seg\u00fcent fins arribar al final. Les estructures condicional i repetitiva es poden interpretar com estructures seq\u00fcencials amb algunes particularitats. L'estructura condicional potser s'execute o no i l'estructura repetitiva s'executara un nombre de vegades. Estructura d'un programa en Java El primer que s'ha de tenir en compte \u00e9s que tot programa escrit en Java ha de tindre almenys un main() a la classe principal per tal que s'execute. En resum, programa escrit en Java ha de tindre: - Declaracions d'importaci\u00f3 de paquets o inclusi\u00f3 d'altres llibreries. - Declaracions de les classes que el formen. - El m\u00e8tode main - M\u00e8todes definits pels usuaris dins de les classes. - Comentaris. // Programa principal import java.io.*; // Llibreries amb funcions d'entrada i eixida. public class nomPrograma { // Nom de la classe principal Calculadora calc; // Membres de la classe (una calculadora) public static void main (String [] args) { // M\u00e8tode principal main calc = new Calculadora(); // Instruccions del m\u00e8tode principal. int result = calc.suma(10,20) System.out.println(\"Resultat: \" + result ); } } // Una altra classe import java.io.*; public class Calculadora { // Nom de la classe public int suma(int a, int b) { // M\u00e8tode de la classe return a + b; } } Al programa anterior podem trobar una classe 'nomPrograma' que cont\u00e9 el m\u00e8tode principal main i que al mateix temps cont\u00e9 el conjunt d'instruccions que es van a executar seq\u00fcencialment al nostre programa. Aquesta classe nomPrograma t\u00e9 un memebre calc que \u00e9s un objecte (ja veurem classes i objectes m\u00e9s endavant) de tipus calculadora i que est\u00e0 definit m\u00e9s endavant amb la classe p\u00fablica calculadora. Les sent\u00e8ncies que executa el nostre programa d'exmemple s\u00f3n les seg\u00fcents: - Instancia l'objecte calc (calc = new Calculadora()). - Declara una variable de tipus enter result - Crida al m\u00e8tode suma de l'objecte calc passant-li els par\u00e0metres 10 i 20 - Deposita el resultat que retorna el m\u00e8tode suma de la classe calc a la variable result - Mostra per pantalla el resultat de la suma. Estructura Seq\u00fcencial Les ordres d'un programa s'executen per defecte en ordre seq\u00fcencial. El que significa que les instruccions s'executen, com hem comentat abans, una darrere de l'altra en el mateix ordre que apareixen escrites al programa. L'estructura seq\u00fcencial \u00e9s l'ordre natura d'execuci\u00f3. Les instruccions que formen part d'aquesta estructura s'executen en ordre una a continuaci\u00f3 de l'altra. Al final de cada instrucci\u00f3 hi ha un punt i coma per indicar-li al compilador el final de la sent\u00e8ncia individual. Les instruccions dintre d'una estructura seq\u00fcencial es solen agrupar en blocs ( {...} ) // Exemple de bloc - estructura seq\u00fcencial { Instrucci\u00f31; Instrucci\u00f32; ... Instrucci\u00f3N; } En resum podr\u00edem dir que l'estructura seq\u00fcencial no \u00e9s m\u00e9s que un conjunt de sent\u00e8ncies o instruccions individuals agrupades. Estructures de selecci\u00f3 \u00c9s una de les estructures que permeten modificar l'ordre d'execuci\u00f3 de les instruccions del programa. Una estructura condicional determina si s'executen unes accions o altres segons es compleixca o no una determinada condici\u00f3. La condici\u00f3 que es comprova per decidir si unes instruccions s'executen o no deu ser una expressi\u00f3 booleana, \u00e9s a dir, ha de donar com a resultat un valor boole\u00e0 true o false. En Java l'estructura de selecci\u00f3 pot ser: - Selecci\u00f3 simple - Selecci\u00f3 doble - Selecci\u00f3 multiple - Operador condicional ? Selecci\u00f3 Simple \u00c9s l'estructura condicional m\u00e9s simple de Java. S'utilitza per determinar si una instrucci\u00f3 o bloc d'instruccions s'executa basat en una condici\u00f3. S'avalua la condici\u00f3 i si es true, s'executa la instrucci\u00f3 o bloc d'instruccions associat a la condici\u00f3. Si mirem b\u00e9 la imatge anterior, el codi que s'executaria seria: S'executa la instrucci\u00f3 1 S'executa la instrucci\u00f3 2 S'avalua a condici\u00f3 Si s'acompleix: S'executa la instrucci\u00f3 3 S'executa la instruccio 4 S'executa la instrucci\u00f3 5 S'executa la instrucci\u00f3 6 En definitiva, al codi anterior podr\u00eden passar dues coses: que s'acompleixca la condici\u00f3 (true) o que no s'acompleixca (false). Si s'avalua true la condici\u00f3 el codi seria: Instrucci\u00f31, Instrucci\u00f32, Instrucci\u00f33, Instrucci\u00f34, Instrucci\u00f35 i Instrucci\u00f36. Pel contrari si s'avalua la condici\u00f3 a false, les instruccions a executar serien: Instrucci\u00f31, Instrucci\u00f32, Instrucci\u00f35 i Instrucci\u00f36. \u00c9s a dir, no s'executarien la 3 i la 4. El seu codi en Java seria: if (condicio) instruccio; // O tamb\u00e9 if (condicio) { instruccio1; instruccio2; ... instruccioN; } En el primer cas si quan s'avalua la condici\u00f3 aquesta \u00e9s veritat, s'executaria la instrucci\u00f3 si pel contrari la condici\u00f3 \u00e9s falsa, no es fa res. Al segon cas \u00e9s igual que el primer per\u00f2 en cas d'avaluar-se possitivament la condici\u00f3 no s'executaria una sola instrucci\u00f3 si no que s'executaria (seq\u00fcencialment) el bloc d'instruccions seg\u00fcent: instrucci\u00f31, instrucci\u00f32 fins instrucci\u00f3N. Exemple: import java.util.*; public class condicioSimple { public static void main (String [] args) { Scanner sc = new Scanner (System.in); System.out.println(\"Quina hora \u00e9s?:\"); int hora = sc.nextInt(); if ( hora >= 9) System.out.println(\"A sopar\"); System.out.println(\"Adeu\"); } } if .. else Amb aquesta estructura condicional de la programaci\u00f3 estructurada es poden seguir camins distints depenent de si l'avaluaci\u00f3 de la condici\u00f3 \u00e9s true o false. En altres paraules, si la condici\u00f3 \u00e9s true, executaria una instrucci\u00f3 o bloc d'instruccions mentre que si s'avalua a false executaria una altra instrucci\u00f3 o bloc d'instruccions. El codi en Java seria instruccio1; instruccio2; if (condicio) { instruccio3; instruccio4; } else { instruccio5; instruccio6; } instruccio7; instruccio8; Si ens fixem en el codi anterior, podem trobar dues seq\u00fc\u00e8ncies d'execucio d'instruccions depenenet si la condici\u00f3 del 'if' s'avalua 'true' o 'false'. En el primer cas, amb la condici\u00f3 a true, s'executarien: instrucci\u00f31, instrucci\u00f32, instrucci\u00f33, instrucci\u00f34, instrucci\u00f37 i instrucci\u00f38. Mentre que si la condici\u00f3 del 'if' s'avaluara a 'false', les instruccions a executar serien: instrucci\u00f31, instrucci\u00f32, instrucci\u00f35, instrucci\u00f36, instrucci\u00f37 i instrucci\u00f38. Exemple import java.util.*; public class condicioDoble { public static void main (String [] args) { Scanner sc = new Scanner (System.in); System.out.println(\"Quina hora \u00e9s?:\"); int hora = sc.nextInt(); if ( hora >= 12) System.out.println(\"Encara \u00e9s de mat\u00ed\"); else System.out.println(\"Ja \u00e9s de vesprada\"); } } if else if else Si volem avaluar m\u00e9s d'una condici\u00f3 al nostre codi, estariem parlant d'una estructura condicional m\u00faltiple que b\u00e0sicament consisteix en encadenar varios if..else. A continuaci\u00f3 es pot veure com seria un exemple de condicional m\u00faltiple en diagrama de flux. El mateix exemple en pseudocodi que teniu a la imatge anterior seria: instruccio1; if (condicio1) { instruccio2; instruccio3; } else if (condicio2) { instruccio4; } else if (condicio3) { instruccio5; instruccio6; instruccio7; } else { instruccio8; instruccio9; } instruccio10; Al codi anterior l'\u00fanic que s\u00ed sabem cert \u00e9s que s'executaran les instruccions 1 i 2 i depenent de quina condici\u00f3 s'avalua a true s'executar\u00e0 algun bloc d'instruccions que estan dins de l'estructura condicional. Exemple Seguint amb l'exemple de l'hora que hem utilitzat als apartats anteriors veiem com es podria usar una condici\u00f3 m\u00faltiple amb if else import java.util.*; public class condicioMultiple { public static void main (String [] args) { Scanner sc = new Scanner (System.in); System.out.println(\"Quina hora \u00e9s?:\"); int hora = sc.nextInt(); if (hora >= 7 && hora <= 9) System.out.println(\"Eres matiner\"); else if (hora > 9 && hora <= 12) System.out.println(\"Deuries haver esmorzat ja\"); else if (hora > 12 && hora <= 15) System.out.println(\"Es hora de dinar si no has dinat\"); else if (hora > 15 && hora <= 18) System.out.println(\"Si no has fet una migdiada oblidat\"); else System.out.println(\"Hora de la cervesa\"); } } switch case La sent\u00e8ncia de control 'switch' \u00e9s una altra forma de codificar la condici\u00f3 m\u00f9ltiple que hem vist a l'apartat anterior per\u00f2 m\u00e9s senzilla de visualitzar a primer cop d'ull switch (condicio) { case 1: // Instruccions break; case 2: // INstrucciones 2 break; default: // Instruccions per defecte break; } Un altre exemple m\u00e9s clar //Programa que demana un numero i diu quin mes \u00e9s import java.util.*; public class ExempleSwitch { public static void main(String[] args) { int mes; Scanner sc = new Scanner(System.in); System.out.print(\"Introdueix el numero del mes: \"); mes = sc.nextInt(); switch (mes) { //inicio del switch case 1: System.out.println(\"GENER\"); break; case 2: System.out.println(\"FEBRER\"); break; case 3: System.out.println(\"MAR\u00c7\"); break; case 4: System.out.println(\"ABRIL\"); break; case 5: System.out.println(\"MAIG\"); break; case 6: System.out.println(\"JUNY\"); break; case 7: System.out.println(\"JULIOL\"); break; case 8: System.out.println(\"AGOST\"); break; case 9: System.out.println(\"SETEMBRE\"); break; case 10: System.out.println(\"OCTUBRE\"); break; case 11: System.out.println(\"NOVEMBRE\"); break; case 12: System.out.println(\"DESEEMBRE\"); break; default : System.out.println(\"No v\u00e0lid\"); } } } Estructures de repetici\u00f3 Si les estructures condicionals serveixen per determinar quines instruccions o bloc d'instruccions s'executen, la programaci\u00f3 estructurada tamb\u00e9 disposa d'estrutctures repetitives o tamb\u00e9 anomenades bucles, que ens permeten executar una instrucci\u00f3 o bloc d'instruccions diverses vegades. Imaginem que tenim un vector d'enters de 100 elements i volem trobar un nombre concret. Usant les estrcutures condicionals ho podr\u00edem fer. int [] arrayNumeros; // Declarem un array d'enters arrayNumeros = new int [100]; // Reservem espai en mem\u00f2ria per 100 elements inicialitzaNumeros(arrayNumeros); // Emplenem de forma aleat\u00f2ria l'array // Comencem la recerca del n\u00famero 10 per exemple if ( array[0] == 10 ) System.out.println(\"N\u00famero trobat a la posici\u00f3 0\"); else if (array[1] == 10) System.out.println(\"N\u00famero trobat a la posici\u00f3 1\"); else if (array[2] == 10) System.out.println(\"N\u00famero trobat a la posici\u00f3 2\"); else if (array[3] == 10) System.out.println(\"N\u00famero trobat a la posici\u00f3 3\"); else if (array[4] == 10) System.out.println(\"N\u00famero trobat a la posici\u00f3 4\"); else if (array[5] == 10) System.out.println(\"N\u00famero trobat a la posici\u00f3 5\"); // I aix\u00ed fins 100 ... Com podeu observar, nom\u00e9s he necessitat escriure codi per als 5 primers elements del nostre array per adondar-me que aquest codi \u00e9s totalment ineficient i t\u00e9 un manteniment molt complicat. Imagineu un array amb 1000 elements i que ho hagurem de codificar com hem fet abans. Les estructures repetitives permetrien rec\u00f2rrer l'array de principi a final sense necessitat d'escriure tant de codi. Veiem els seg\u00fcents exemples. while Mentre la condici\u00f3 (tamb\u00e9 anomenada condici\u00f3 d'eixida) siga avaluada com a true, s'executar\u00eden les instruccions que hi ha dins del bucle while. En aquest tipus de bucle, el bloc d'instruccions del bucle while, es poden executar zero o m\u00e9s vegades. Els passos que representen el diagrama anterior s\u00f3n: 1. S'executa la instrucci\u00f3 1 2. S'avalua la condici\u00f3 3. Si la condici\u00f3 \u00e9s true, s'executa el bloc d'instruccions del bucle i es torna a avaluar la condici\u00f3. 4. En cas que la condici\u00f3 s'avalue com a false, passar\u00edem a executar la instrucci\u00f3 2. Exemple: Com far\u00edem el codi necessari per rec\u00f2rrer el nostre array de 100 elements fins trobar el n\u00famero que busquem? int i = 0; // Inicialitzem una variable que ens servir\u00e0 de contador. while (i < 100) { if (arrarNumeros[i] == 10) System.out.println(\"N\u00famero trobat a la posici\u00f3 \" + i); i ++; // Important incrementar el contador o entrar\u00edem en un bucle infinit. } do .. while Molt semblant al bucle while per\u00f2 amb la difer\u00e8ncia que el bloc s'instruccions que cont\u00e9 l'estructura s'executaria almenys una vegada ja que la condici\u00f3 d'eixida s'avalua despr\u00e9s d'executar les instruccions. Els passos que representen el diagrama anterior s\u00f3n: 1. S'executa la instrucci\u00f3 1 2. S'executen les instruccions que cont\u00e9 el bloc 3. S'avalua la condici\u00f3 4. Si la condici\u00f3 \u00e9s true, s'executa el bloc d'instruccions del bucle i es torna a avaluar la condici\u00f3. 5. En cas que la condici\u00f3 s'avalue com a false, passar\u00edem a executar la instrucci\u00f3 2. Exemple: Com far\u00edem el codi necessari per rec\u00f2rrer el nostre array de 100 elements fins trobar el n\u00famero que busquem? int i = 0; // Inicialitzem una variable que ens servir\u00e0 de contador. do { if (arrarNumeros[i] == 10) System.out.println(\"N\u00famero trobat a la posici\u00f3 \" + i); i ++; // Important incrementar el contador o entrar\u00edem en un bucle infinit. } while (i < 100); bucle for La m\u00e9s complicada de comprendre per\u00f2 tamb\u00e9 possiblement la m\u00e9s utilitzada. Mirem un exemple. Executem instrucci\u00f3 1 (aliena al bucle for) Inicialitzaci\u00f3 Avaluaci\u00f3 de la condici\u00f3 Si la condici\u00f3 \u00e9s true Executem les instruccions del bucle for Actualitzem \u00edndex Si la condici\u00f3 es false eixim del bucle i executem instrucci\u00f3 2 for (int i = 0; i < 100; i ++ ) { if (arrarNumeros[i] == 10) System.out.println(\"N\u00famero trobat a la posici\u00f3 \" + i); } Al codi anterior: 1. Inicialitzaci\u00f3: int i = 0; 2. Avaluaci\u00f3 de la condici\u00f3: \u00e9s i < 100 ? 3. Actualitzaci\u00f3: i ++","title":"Tema 2. Programaci\u00f3 Estructurada"},{"location":"Tema%202.%20Programaci%C3%B3%20Estructurada/#tema-2-programacio-estructurada","text":"","title":"Tema 2. Programaci\u00f3 Estructurada"},{"location":"Tema%202.%20Programaci%C3%B3%20Estructurada/#introduccio","text":"Al inici dels temps del la inform\u00e0tica moderna segona meitat dels segle XX) i considerant ordinador programable aquell que seguia l'arquitectura de von Neumann, els primers programes s'escrivien en binari (llenguatge m\u00e0quina) en tarjetes perforades. Aquestes targetes perforades s'utilitzaven per escriure programes sencers amb una finalitat molt concreta. Les targetes s'utilitzaven com a entrada de dades a la m\u00e0quina que s'encarregava de llegir les instruccions escrites en binari, i una a una, carregar-les a mem\u00f2ria i executar-les. Un problema d'aquest incipient paradigma de programaci\u00f3 \u00e9s que cada conjunt d'instruccions \u00e9s espec\u00edfic a cada m\u00e0quina. Amb el temps i conforme augmenta la capacitat de computaci\u00f3 dels ordinadors i tamb\u00e9 la complexitat dels programes, les targetes deixen de ser funcionals i apareixen els primers llenguatges de programaci\u00f3 generalistes com FORTRAN, COBOL o LISP per\u00f2 aquestos encara no utilitzen el paradigma de programaci\u00f3 estructurada. A la decada dels anys 60, B\u00f6hm i Jacopini escriuen el teorema de la programaci\u00f3 estructurada, basant-se per supost en part en aquells llenguatges de programaci\u00f3 que ja exisitien, i arriben a la conclusi\u00f3 qu\u00e8: la sent\u00e8ncia GOTO era una sent\u00e8ncia considerada perjudicial per a la programaci\u00f3 i per entendre els programes escrits en qualsevol llenguatge i tamb\u00e9 que amb nom\u00e9s les estructures seq\u00fcencial, iterativa i condicional era suficient per escriure qualsevol programa. En aquest tema veurem quine s\u00f3n les estructures de control de la programaci\u00f3 estructurada i com s'utilitzen, aix\u00ed com tamb\u00e9 les seues corresponents representacions gr\u00e0fiques en programes escrits en diagrames de flux, pseudocodi o algun llenguatge de programaci\u00f3 d'alt nivell.","title":"Introducci\u00f3"},{"location":"Tema%202.%20Programaci%C3%B3%20Estructurada/#conceptes-basics","text":"El teorema de el programa estructurat \u00e9s un resultat en la teoria de llenguatges de programaci\u00f3. Estableix que tota funci\u00f3 computable pot ser implementada en un llenguatge de programaci\u00f3 que combine nom\u00e9s tres estructures l\u00f2giques. Aquestes tres formes tamb\u00e9 anomenades estructures de control espec\u00edficament s\u00f3n: Seq\u00fc\u00e8ncia: execuci\u00f3 d'una instrucci\u00f3 despr\u00e9s d'una altra. Selecci\u00f3: execuci\u00f3 d'una de dues instruccions (o conjunts), segons el valor d'una variable booleana. Iteraci\u00f3: execuci\u00f3 d'una instrucci\u00f3 (o conjunt) mentre una variable booleana siga 'veritable'. Aquesta estructura l\u00f2gica tamb\u00e9 es coneix com a cicle o bucle. Aquest teorema demostra que la instrucci\u00f3 GOTO no \u00e9s estrictament necess\u00e0ria i que per a tot programa que l'utilitze existeix un altre equivalent que no fa \u00fas d'aquesta instrucci\u00f3. Els cient\u00edfics de la computaci\u00f3 usualment acrediten el teorema a un article de 1966 escrit per Corrado B\u00f6hm i Giuseppe Jacopini . No obstant aix\u00f2, David Harel va rastrejar els seus or\u00edgens fins a la descripci\u00f3 de 1946 de l'arquitectura de von Neumann i el teorema de la forma normal de Kleene. Abans d'entrar en el detall i funcionament d'aquestes estructures de control de la programaci\u00f3 estructurada, hem de veure tamb\u00e9 (basnt-nos en un llenguatge de programaci\u00f3 concret) com es representa la informaci\u00f3, les dades, les variables, operadors, operacions, etc. En el nostre cas usarem l'IDE Processing i el llenguatge sera Java.","title":"Conceptes b\u00e0sics"},{"location":"Tema%202.%20Programaci%C3%B3%20Estructurada/#dades-variables-i-identificadors","text":"En qualsevol llenguatge de programaci\u00f3 existeixen una s\u00e8rie d'elements com variables, constants, funcions, llibreries. Aquestos elements requereixen d'un nom per tal de distingir-lo de la resta. Aquestos noms es diuen identificadors Un identificador \u00e9s una cadena alfan\u00famerica que representa o dona un nom a un element dins del nostre programa. Els identificadors de les variables s\u00f3n noms que s'inventa el programador i s'hauria de tindre en consideraci\u00f3 al seg\u00fcent m\u00e0xima: Quan triem el nom per identificar a una variable, ha de ser significatiu, \u00e9s a dir, que el mateix identificador ja done alguna pista de que \u00e9s el que representa.","title":"Dades, Variables i identificadors."},{"location":"Tema%202.%20Programaci%C3%B3%20Estructurada/#paraules-reservades","text":"Uns dels principals identificadors que ens trobarem a tot llenguatge de programaci\u00f3 s\u00f3n les paraules reservades . Per entendre-ho, el conjunt de paraules reservades d'un llenguatge de programaci\u00f3 s\u00f3n el diccionari de totes les paraules que t\u00e9 aquest llenguatge. Aquetes paraules reservades no poden utilitzar-se per cap altra cosa m\u00e9s, per exemple, si Java t\u00e9 la paraula reservada public , el programador no podr\u00e0 crear cap variable utilitzant l'identificador public.","title":"Paraules reservades"},{"location":"Tema%202.%20Programaci%C3%B3%20Estructurada/#tipus-de-dades","text":"Tot llenguatge de programaci\u00f3 porta una s\u00e8rie de tipus de dades predefinits que es poden usar. Aquestos tipus de dades tamb\u00e9 es coneixen com a tipus primitius o tipus simples. . Java defineix 8 tipus diferents de dades: byte, short, int, long, char, float, double i boolean. Aquestos tipus es poden agrupar en quatre blocs: - Enters: on podem trobar el byte, short, long i int. - Punt flotant: aquest grup inclou el float i el double on es representen els n\u00fameros decimals. - Caracters: char representa a tot el conjunt de caracters del nostre sistema. - Boole\u00e0: boolean \u00e9s un tipus especial que nom\u00e9s pot tindre dos possibles valors: true o false.","title":"Tipus de dades"},{"location":"Tema%202.%20Programaci%C3%B3%20Estructurada/#variables","text":"Al final tot programa s'encarrega de processar informaci\u00f3 i aquesta informaci\u00f3 ha d'estar disponible en algun lloc del nostre codi. Per exemple si volem fer un programa que sume dos n\u00fameros enters, haurem de tindre la informaci\u00f3 o el valor d'aquestos dos n\u00fameros en algun lloc. Una variable \u00e9s com un contenidor que t\u00e9 associat un tipus (enter, real, caracter) i cont\u00e9 un valor, si es tracta d'una variable de tipus enter contindr\u00e0 un valor enter, si per contra es tracta d'una variable de tipus caracter contindr\u00e0 una lletra. La variable \u00e9s l'unitat b\u00e0sica d'emmagatzemament en Java. Una variable en java es defineix amb la combinaci\u00f3 d'un identificador i el seu tipus de dades // Declaraci\u00f3 d'una variable en Java // type identifier; // Per exemple: int a; float b; long j; char c; int i = 0; // En aquesta declaraci\u00f3 s'inclou tamb\u00e9 la inicialitzaci\u00f3 del seu valor. Les varialbes com a contenidors d'informaci\u00f3, poden variar el seu valor durant l'execuci\u00f3 del programa.","title":"Variables"},{"location":"Tema%202.%20Programaci%C3%B3%20Estructurada/#constants","text":"Les constants en java s\u00f3n semblants a les variables, \u00e9s a dir, s\u00f3n contenidors d'informaci\u00f3, tenen un identificador i un tipus b\u00e0sic associat per\u00f2 el seu valor no canvia durant l'execuci\u00f3 del programa. Les variables en java es defineixen de la seg\u00fcent forma: // Constant en java static final int prova = 10; // Prova valdr\u00e0 10 durant tot el programa.","title":"Constants"},{"location":"Tema%202.%20Programaci%C3%B3%20Estructurada/#comentaris","text":"Els comentaris a qualsevol llenguatge de programaci\u00f3, s'utilitzen per fer que el codi siga m\u00e9s f\u00e0cil de llegir millorant aix\u00ed el manteniment. Els comentaris s\u00f3n totalment ignorats pel compilador. En java tenim tres tipus de comentaris: - Comentaris en l\u00ednia: - S'utilitzen per comentar parts concretes del codi. // Comentari d'una sola l\u00ednia en Java Comentaris de v\u00e0ries l\u00ednies: Si un programador vol descriure m\u00e9s detalladament un codi m\u00e9s complex i no es pot utilitzar el comentari d'una l\u00ednia perqu\u00e8 requereix m\u00e9s text /* Comentari de m\u00e9s d'una l\u00ednia linia 1 linia 2 linia 3 linia final */ Comentaris de documentaci\u00f3: Aquest tipus de comentaris ajuda a l'hora de generar documentaci\u00f3 de forma automatitzada per alguns dels IDEs que s'utilitzen a l'actualitat o les enies que porten amb ells. Un exemple d'eina de generar documentaci\u00f3 de refer\u00e8ncia \u00e9s javadoc /** * Troba la mitjana de tres n\u00fameros! * El programa FindAvg implementa una aplicacio que * simplement calcula la mitjana de tres enteros i els mostra * a la eixida per pantalla. * * @author Aleix Caminou * @version 1.0 * @since 2020-2-2 */","title":"Comentaris"},{"location":"Tema%202.%20Programaci%C3%B3%20Estructurada/#operadors-i-expressions","text":"Les expressions s\u00f3n equacions matem\u00e0tiques que solen representar c\u00e0lculs, per exemple: 3 x + 7 z. L'expressi\u00f3 anterior la formen els seg\u00fcents elements: dos literals enters: 3 i 7; dos identificadors de variables (no sabem el tipus) x i z; i els simbols * i +. Aquestos simbols s\u00f3n els operadors, concretament * \u00e9s l'operador aritm\u00e8tic de multiplicaci\u00f3 i el s\u00edmbol + representa l'operador de suma. Aquesta expressi\u00f3 tindr\u00e0 finalment un valor, per exemple, s\u00ed x val 3 i z val 2, el resultat de l'expressi\u00f3 seria 23.","title":"Operadors i expressions"},{"location":"Tema%202.%20Programaci%C3%B3%20Estructurada/#operador-assignacio","text":"L'operador assignaci\u00f3 en Java \u00e9s el s\u00edmbol '=' i s'utilitza de la seg\u00fcent forma // variable = expressi\u00f3 // Seguint l'exemple anterior int x=3, y, z=2; y = 3*x + 7*z; On l'operador '=' assignaria el valor de l'expressi\u00f3 '3x+2z' a la variable y, \u00e9s a dir, executada aquesta acci\u00f3 dins de la variable y haur\u00edem depositat el valor 23. Altres exemples d'\u00fas de l'operador assignaci\u00f3: int a, b, c; a = b = c = 10; // Tant a com b com c tindr\u00eden valor 10 int i = 3; i = i * 3; // i valdria 9 int j = 2; j *= 2; // Aquesta manera peculiar d'usar l'operador assignaci\u00f3 \u00e9s el mateix que j = j * 2;","title":"Operador assignaci\u00f3"},{"location":"Tema%202.%20Programaci%C3%B3%20Estructurada/#operadors-aritmetics","text":"Els operador aritm\u00e8tics en Java serveixen per realitzar operacions b\u00e0siques algebraiques com: la suma, resta, multiplicaci\u00f3 o divisi\u00f3. - Suma: s\u00edmbol (+). Exemple: 4+5 - Resta: s\u00edmbol (-). Exemple: 5-2 - Multiplicaci\u00f3: s\u00edmbol ( ). Exemple: 3 7 - Divisi\u00f3 (Quocient): s\u00edmbol (/). Exemple: 8/5. - Divisi\u00f3 (Residu): s\u00edmbol (%). Exemple 10%2.","title":"Operadors aritm\u00e8tics"},{"location":"Tema%202.%20Programaci%C3%B3%20Estructurada/#operadors-increment-i-decrement","text":"En programaci\u00f3 i com her\u00e8ncia de C i C++ existeixen els operadors increment (++) i decrement (--) que el que fan \u00e9s incrementar o decrementar en una unitat la variable a la qual s'apliquen. int x = 10; x ++; // Aquest codi seria equivalent a x = x + 1; x --; // Aquest codi seria equivalent a x = x -1 ; Aquestos operadors tamb\u00e9 es poden posar abans de la variable produint el mateix efecte int x = 10; ++ x; // Aquest codi seria equivalent a x = x + 1; -- x; // Aquest codi seria equivalent a x = x -1 ;","title":"Operadors increment i decrement"},{"location":"Tema%202.%20Programaci%C3%B3%20Estructurada/#operadors-relacionals","text":"Com hem explicat en l'apartat sobre Tipus de dades , existeix en Java el tipus boolean que nom\u00e9s pot tenir valors true o false. Aquest tipus de dades est\u00e0 relacionat amb els operadors relacionals, ja que tota expressi\u00f3 relacional ha de donar com a resultat b\u00e9 true o false. Els operadors relacionals a Java s\u00f3n: - == o igual a. Exemple d'\u00fas: a == b, compara si a i b s\u00f3n iguals o no. - != o distint de. Exemple d'\u00fas: a != b, comprova si a i b s\u00f3n distints. - > o major que. Exemple d'\u00fas: 'a>b' comprova si a \u00e9s major que b. - < o menor que. Exemple d'\u00fas: 'a = o major igual que. Exemple d'\u00fas: 'a>=b' comprova si a \u00e9s major o igual que b. - <=** o menor igual que. Exemple d'\u00fas: 'a<=b' comprova si a \u00e9s menor o igual que b.","title":"Operadors relacionals"},{"location":"Tema%202.%20Programaci%C3%B3%20Estructurada/#operadors-logics","text":"not (!) : negaci\u00f3 l\u00f2gica. and (&&) : and l\u00f2gic. or (||) : or l\u00f2gic. or exclusivo (^) : or exclusiu. Vegem alguns exemples.","title":"Operadors l\u00f2gics"},{"location":"Tema%202.%20Programaci%C3%B3%20Estructurada/#operador-condicional","text":"Java inclou un operador especial de tipus ternari que de vegades s'utilitza per substituir algunes estructures if then else. Aquest \u00e9s l'operador ? i la seua forma general \u00e9s: expressio1 ? expressio2 : expressio 3; Expressi\u00f3 1: \u00e9s l'expressi\u00f3 que avalua un valor boole\u00e0, d'aquesta forma, si l'expressi\u00f3 1 s'avalua com a true, s'executaria l'expressi\u00f3 2 mentre que si l'expressi\u00f3 1 s'avalua a false, s'executaria l'expressi\u00f3 2. Exemple double temperatura; // Variable que ens indica la temperatur ambient boolean AC_ON = false; // Variable booleana que ens indica si l'aire condicionat est\u00e0 en marxa temperatura > 25 ? AC_ON = true : AC_ON = false; // B\u00e0sicament el que faria aquesta espressi\u00f3 seria engegar l'aire condicionat si la temperatura // \u00e9s superior a 25 graus.","title":"Operador condicional"},{"location":"Tema%202.%20Programaci%C3%B3%20Estructurada/#estructures","text":"Com ja hem anomenat als primers putns d'aquest tema, el teorema de la programaci\u00f3 estructurada preveu una s\u00e8rie d'estrucutures b\u00e0siques amb les quals es podr\u00eden codificar tots els algorismes sense necessitat d'usar cap sent\u00e8ncia GOTO o similar. Aquestes estructures s\u00f3n: - Seq\u00fcencial - Condicional - Repetitiva Al final tot algorisme escrit en un llenguatge de programaci\u00f3 estrucuturada s'executa de forma seq\u00fcencial, \u00e9s a dir, es llig la primera sent\u00e8ncia s'executa i despr\u00e8s passem a la seg\u00fcent fins arribar al final. Les estructures condicional i repetitiva es poden interpretar com estructures seq\u00fcencials amb algunes particularitats. L'estructura condicional potser s'execute o no i l'estructura repetitiva s'executara un nombre de vegades.","title":"Estructures"},{"location":"Tema%202.%20Programaci%C3%B3%20Estructurada/#estructura-dun-programa-en-java","text":"El primer que s'ha de tenir en compte \u00e9s que tot programa escrit en Java ha de tindre almenys un main() a la classe principal per tal que s'execute. En resum, programa escrit en Java ha de tindre: - Declaracions d'importaci\u00f3 de paquets o inclusi\u00f3 d'altres llibreries. - Declaracions de les classes que el formen. - El m\u00e8tode main - M\u00e8todes definits pels usuaris dins de les classes. - Comentaris. // Programa principal import java.io.*; // Llibreries amb funcions d'entrada i eixida. public class nomPrograma { // Nom de la classe principal Calculadora calc; // Membres de la classe (una calculadora) public static void main (String [] args) { // M\u00e8tode principal main calc = new Calculadora(); // Instruccions del m\u00e8tode principal. int result = calc.suma(10,20) System.out.println(\"Resultat: \" + result ); } } // Una altra classe import java.io.*; public class Calculadora { // Nom de la classe public int suma(int a, int b) { // M\u00e8tode de la classe return a + b; } } Al programa anterior podem trobar una classe 'nomPrograma' que cont\u00e9 el m\u00e8tode principal main i que al mateix temps cont\u00e9 el conjunt d'instruccions que es van a executar seq\u00fcencialment al nostre programa. Aquesta classe nomPrograma t\u00e9 un memebre calc que \u00e9s un objecte (ja veurem classes i objectes m\u00e9s endavant) de tipus calculadora i que est\u00e0 definit m\u00e9s endavant amb la classe p\u00fablica calculadora. Les sent\u00e8ncies que executa el nostre programa d'exmemple s\u00f3n les seg\u00fcents: - Instancia l'objecte calc (calc = new Calculadora()). - Declara una variable de tipus enter result - Crida al m\u00e8tode suma de l'objecte calc passant-li els par\u00e0metres 10 i 20 - Deposita el resultat que retorna el m\u00e8tode suma de la classe calc a la variable result - Mostra per pantalla el resultat de la suma.","title":"Estructura d'un programa en Java"},{"location":"Tema%202.%20Programaci%C3%B3%20Estructurada/#estructura-sequencial","text":"Les ordres d'un programa s'executen per defecte en ordre seq\u00fcencial. El que significa que les instruccions s'executen, com hem comentat abans, una darrere de l'altra en el mateix ordre que apareixen escrites al programa. L'estructura seq\u00fcencial \u00e9s l'ordre natura d'execuci\u00f3. Les instruccions que formen part d'aquesta estructura s'executen en ordre una a continuaci\u00f3 de l'altra. Al final de cada instrucci\u00f3 hi ha un punt i coma per indicar-li al compilador el final de la sent\u00e8ncia individual. Les instruccions dintre d'una estructura seq\u00fcencial es solen agrupar en blocs ( {...} ) // Exemple de bloc - estructura seq\u00fcencial { Instrucci\u00f31; Instrucci\u00f32; ... Instrucci\u00f3N; } En resum podr\u00edem dir que l'estructura seq\u00fcencial no \u00e9s m\u00e9s que un conjunt de sent\u00e8ncies o instruccions individuals agrupades.","title":"Estructura Seq\u00fcencial"},{"location":"Tema%202.%20Programaci%C3%B3%20Estructurada/#estructures-de-seleccio","text":"\u00c9s una de les estructures que permeten modificar l'ordre d'execuci\u00f3 de les instruccions del programa. Una estructura condicional determina si s'executen unes accions o altres segons es compleixca o no una determinada condici\u00f3. La condici\u00f3 que es comprova per decidir si unes instruccions s'executen o no deu ser una expressi\u00f3 booleana, \u00e9s a dir, ha de donar com a resultat un valor boole\u00e0 true o false. En Java l'estructura de selecci\u00f3 pot ser: - Selecci\u00f3 simple - Selecci\u00f3 doble - Selecci\u00f3 multiple - Operador condicional ?","title":"Estructures de selecci\u00f3"},{"location":"Tema%202.%20Programaci%C3%B3%20Estructurada/#seleccio-simple","text":"\u00c9s l'estructura condicional m\u00e9s simple de Java. S'utilitza per determinar si una instrucci\u00f3 o bloc d'instruccions s'executa basat en una condici\u00f3. S'avalua la condici\u00f3 i si es true, s'executa la instrucci\u00f3 o bloc d'instruccions associat a la condici\u00f3. Si mirem b\u00e9 la imatge anterior, el codi que s'executaria seria: S'executa la instrucci\u00f3 1 S'executa la instrucci\u00f3 2 S'avalua a condici\u00f3 Si s'acompleix: S'executa la instrucci\u00f3 3 S'executa la instruccio 4 S'executa la instrucci\u00f3 5 S'executa la instrucci\u00f3 6 En definitiva, al codi anterior podr\u00eden passar dues coses: que s'acompleixca la condici\u00f3 (true) o que no s'acompleixca (false). Si s'avalua true la condici\u00f3 el codi seria: Instrucci\u00f31, Instrucci\u00f32, Instrucci\u00f33, Instrucci\u00f34, Instrucci\u00f35 i Instrucci\u00f36. Pel contrari si s'avalua la condici\u00f3 a false, les instruccions a executar serien: Instrucci\u00f31, Instrucci\u00f32, Instrucci\u00f35 i Instrucci\u00f36. \u00c9s a dir, no s'executarien la 3 i la 4. El seu codi en Java seria: if (condicio) instruccio; // O tamb\u00e9 if (condicio) { instruccio1; instruccio2; ... instruccioN; } En el primer cas si quan s'avalua la condici\u00f3 aquesta \u00e9s veritat, s'executaria la instrucci\u00f3 si pel contrari la condici\u00f3 \u00e9s falsa, no es fa res. Al segon cas \u00e9s igual que el primer per\u00f2 en cas d'avaluar-se possitivament la condici\u00f3 no s'executaria una sola instrucci\u00f3 si no que s'executaria (seq\u00fcencialment) el bloc d'instruccions seg\u00fcent: instrucci\u00f31, instrucci\u00f32 fins instrucci\u00f3N. Exemple: import java.util.*; public class condicioSimple { public static void main (String [] args) { Scanner sc = new Scanner (System.in); System.out.println(\"Quina hora \u00e9s?:\"); int hora = sc.nextInt(); if ( hora >= 9) System.out.println(\"A sopar\"); System.out.println(\"Adeu\"); } }","title":"Selecci\u00f3 Simple"},{"location":"Tema%202.%20Programaci%C3%B3%20Estructurada/#if-else","text":"Amb aquesta estructura condicional de la programaci\u00f3 estructurada es poden seguir camins distints depenent de si l'avaluaci\u00f3 de la condici\u00f3 \u00e9s true o false. En altres paraules, si la condici\u00f3 \u00e9s true, executaria una instrucci\u00f3 o bloc d'instruccions mentre que si s'avalua a false executaria una altra instrucci\u00f3 o bloc d'instruccions. El codi en Java seria instruccio1; instruccio2; if (condicio) { instruccio3; instruccio4; } else { instruccio5; instruccio6; } instruccio7; instruccio8; Si ens fixem en el codi anterior, podem trobar dues seq\u00fc\u00e8ncies d'execucio d'instruccions depenenet si la condici\u00f3 del 'if' s'avalua 'true' o 'false'. En el primer cas, amb la condici\u00f3 a true, s'executarien: instrucci\u00f31, instrucci\u00f32, instrucci\u00f33, instrucci\u00f34, instrucci\u00f37 i instrucci\u00f38. Mentre que si la condici\u00f3 del 'if' s'avaluara a 'false', les instruccions a executar serien: instrucci\u00f31, instrucci\u00f32, instrucci\u00f35, instrucci\u00f36, instrucci\u00f37 i instrucci\u00f38. Exemple import java.util.*; public class condicioDoble { public static void main (String [] args) { Scanner sc = new Scanner (System.in); System.out.println(\"Quina hora \u00e9s?:\"); int hora = sc.nextInt(); if ( hora >= 12) System.out.println(\"Encara \u00e9s de mat\u00ed\"); else System.out.println(\"Ja \u00e9s de vesprada\"); } }","title":"if .. else"},{"location":"Tema%202.%20Programaci%C3%B3%20Estructurada/#if-else-if-else","text":"Si volem avaluar m\u00e9s d'una condici\u00f3 al nostre codi, estariem parlant d'una estructura condicional m\u00faltiple que b\u00e0sicament consisteix en encadenar varios if..else. A continuaci\u00f3 es pot veure com seria un exemple de condicional m\u00faltiple en diagrama de flux. El mateix exemple en pseudocodi que teniu a la imatge anterior seria: instruccio1; if (condicio1) { instruccio2; instruccio3; } else if (condicio2) { instruccio4; } else if (condicio3) { instruccio5; instruccio6; instruccio7; } else { instruccio8; instruccio9; } instruccio10; Al codi anterior l'\u00fanic que s\u00ed sabem cert \u00e9s que s'executaran les instruccions 1 i 2 i depenent de quina condici\u00f3 s'avalua a true s'executar\u00e0 algun bloc d'instruccions que estan dins de l'estructura condicional. Exemple Seguint amb l'exemple de l'hora que hem utilitzat als apartats anteriors veiem com es podria usar una condici\u00f3 m\u00faltiple amb if else import java.util.*; public class condicioMultiple { public static void main (String [] args) { Scanner sc = new Scanner (System.in); System.out.println(\"Quina hora \u00e9s?:\"); int hora = sc.nextInt(); if (hora >= 7 && hora <= 9) System.out.println(\"Eres matiner\"); else if (hora > 9 && hora <= 12) System.out.println(\"Deuries haver esmorzat ja\"); else if (hora > 12 && hora <= 15) System.out.println(\"Es hora de dinar si no has dinat\"); else if (hora > 15 && hora <= 18) System.out.println(\"Si no has fet una migdiada oblidat\"); else System.out.println(\"Hora de la cervesa\"); } }","title":"if else if else"},{"location":"Tema%202.%20Programaci%C3%B3%20Estructurada/#switch-case","text":"La sent\u00e8ncia de control 'switch' \u00e9s una altra forma de codificar la condici\u00f3 m\u00f9ltiple que hem vist a l'apartat anterior per\u00f2 m\u00e9s senzilla de visualitzar a primer cop d'ull switch (condicio) { case 1: // Instruccions break; case 2: // INstrucciones 2 break; default: // Instruccions per defecte break; } Un altre exemple m\u00e9s clar //Programa que demana un numero i diu quin mes \u00e9s import java.util.*; public class ExempleSwitch { public static void main(String[] args) { int mes; Scanner sc = new Scanner(System.in); System.out.print(\"Introdueix el numero del mes: \"); mes = sc.nextInt(); switch (mes) { //inicio del switch case 1: System.out.println(\"GENER\"); break; case 2: System.out.println(\"FEBRER\"); break; case 3: System.out.println(\"MAR\u00c7\"); break; case 4: System.out.println(\"ABRIL\"); break; case 5: System.out.println(\"MAIG\"); break; case 6: System.out.println(\"JUNY\"); break; case 7: System.out.println(\"JULIOL\"); break; case 8: System.out.println(\"AGOST\"); break; case 9: System.out.println(\"SETEMBRE\"); break; case 10: System.out.println(\"OCTUBRE\"); break; case 11: System.out.println(\"NOVEMBRE\"); break; case 12: System.out.println(\"DESEEMBRE\"); break; default : System.out.println(\"No v\u00e0lid\"); } } }","title":"switch case"},{"location":"Tema%202.%20Programaci%C3%B3%20Estructurada/#estructures-de-repeticio","text":"Si les estructures condicionals serveixen per determinar quines instruccions o bloc d'instruccions s'executen, la programaci\u00f3 estructurada tamb\u00e9 disposa d'estrutctures repetitives o tamb\u00e9 anomenades bucles, que ens permeten executar una instrucci\u00f3 o bloc d'instruccions diverses vegades. Imaginem que tenim un vector d'enters de 100 elements i volem trobar un nombre concret. Usant les estrcutures condicionals ho podr\u00edem fer. int [] arrayNumeros; // Declarem un array d'enters arrayNumeros = new int [100]; // Reservem espai en mem\u00f2ria per 100 elements inicialitzaNumeros(arrayNumeros); // Emplenem de forma aleat\u00f2ria l'array // Comencem la recerca del n\u00famero 10 per exemple if ( array[0] == 10 ) System.out.println(\"N\u00famero trobat a la posici\u00f3 0\"); else if (array[1] == 10) System.out.println(\"N\u00famero trobat a la posici\u00f3 1\"); else if (array[2] == 10) System.out.println(\"N\u00famero trobat a la posici\u00f3 2\"); else if (array[3] == 10) System.out.println(\"N\u00famero trobat a la posici\u00f3 3\"); else if (array[4] == 10) System.out.println(\"N\u00famero trobat a la posici\u00f3 4\"); else if (array[5] == 10) System.out.println(\"N\u00famero trobat a la posici\u00f3 5\"); // I aix\u00ed fins 100 ... Com podeu observar, nom\u00e9s he necessitat escriure codi per als 5 primers elements del nostre array per adondar-me que aquest codi \u00e9s totalment ineficient i t\u00e9 un manteniment molt complicat. Imagineu un array amb 1000 elements i que ho hagurem de codificar com hem fet abans. Les estructures repetitives permetrien rec\u00f2rrer l'array de principi a final sense necessitat d'escriure tant de codi. Veiem els seg\u00fcents exemples.","title":"Estructures de repetici\u00f3"},{"location":"Tema%202.%20Programaci%C3%B3%20Estructurada/#while","text":"Mentre la condici\u00f3 (tamb\u00e9 anomenada condici\u00f3 d'eixida) siga avaluada com a true, s'executar\u00eden les instruccions que hi ha dins del bucle while. En aquest tipus de bucle, el bloc d'instruccions del bucle while, es poden executar zero o m\u00e9s vegades. Els passos que representen el diagrama anterior s\u00f3n: 1. S'executa la instrucci\u00f3 1 2. S'avalua la condici\u00f3 3. Si la condici\u00f3 \u00e9s true, s'executa el bloc d'instruccions del bucle i es torna a avaluar la condici\u00f3. 4. En cas que la condici\u00f3 s'avalue com a false, passar\u00edem a executar la instrucci\u00f3 2. Exemple: Com far\u00edem el codi necessari per rec\u00f2rrer el nostre array de 100 elements fins trobar el n\u00famero que busquem? int i = 0; // Inicialitzem una variable que ens servir\u00e0 de contador. while (i < 100) { if (arrarNumeros[i] == 10) System.out.println(\"N\u00famero trobat a la posici\u00f3 \" + i); i ++; // Important incrementar el contador o entrar\u00edem en un bucle infinit. }","title":"while"},{"location":"Tema%202.%20Programaci%C3%B3%20Estructurada/#do-while","text":"Molt semblant al bucle while per\u00f2 amb la difer\u00e8ncia que el bloc s'instruccions que cont\u00e9 l'estructura s'executaria almenys una vegada ja que la condici\u00f3 d'eixida s'avalua despr\u00e9s d'executar les instruccions. Els passos que representen el diagrama anterior s\u00f3n: 1. S'executa la instrucci\u00f3 1 2. S'executen les instruccions que cont\u00e9 el bloc 3. S'avalua la condici\u00f3 4. Si la condici\u00f3 \u00e9s true, s'executa el bloc d'instruccions del bucle i es torna a avaluar la condici\u00f3. 5. En cas que la condici\u00f3 s'avalue com a false, passar\u00edem a executar la instrucci\u00f3 2. Exemple: Com far\u00edem el codi necessari per rec\u00f2rrer el nostre array de 100 elements fins trobar el n\u00famero que busquem? int i = 0; // Inicialitzem una variable que ens servir\u00e0 de contador. do { if (arrarNumeros[i] == 10) System.out.println(\"N\u00famero trobat a la posici\u00f3 \" + i); i ++; // Important incrementar el contador o entrar\u00edem en un bucle infinit. } while (i < 100);","title":"do .. while"},{"location":"Tema%202.%20Programaci%C3%B3%20Estructurada/#bucle-for","text":"La m\u00e9s complicada de comprendre per\u00f2 tamb\u00e9 possiblement la m\u00e9s utilitzada. Mirem un exemple. Executem instrucci\u00f3 1 (aliena al bucle for) Inicialitzaci\u00f3 Avaluaci\u00f3 de la condici\u00f3 Si la condici\u00f3 \u00e9s true Executem les instruccions del bucle for Actualitzem \u00edndex Si la condici\u00f3 es false eixim del bucle i executem instrucci\u00f3 2 for (int i = 0; i < 100; i ++ ) { if (arrarNumeros[i] == 10) System.out.println(\"N\u00famero trobat a la posici\u00f3 \" + i); } Al codi anterior: 1. Inicialitzaci\u00f3: int i = 0; 2. Avaluaci\u00f3 de la condici\u00f3: \u00e9s i < 100 ? 3. Actualitzaci\u00f3: i ++","title":"bucle for"},{"location":"Tema%203.%20Programaci%C3%B3%20Modular/","text":"Tema 3. Programaci\u00f3 Modular Introducci\u00f3 La programaci\u00f3 modular \u00e9s un paradigma de programaci\u00f3 que consisteix a dividir un programa en m\u00f2duls o subprogrames per tal de fer-lo m\u00e9s llegible i manejable Es presenta hist\u00f2ricament com una evoluci\u00f3 de la programaci\u00f3 estructurada per solucionar problemes de programaci\u00f3 m\u00e9s grans i complexos del que aquesta pot resoldre. A l'aplicar la programaci\u00f3 modular, un problema complex ha de ser dividit en diversos subproblemes m\u00e9s simples, i aquests al seu torn en altres subproblemes m\u00e9s simples encara. Aix\u00f2 s'ha de fer fins a obtenir subproblemes prou simples com per poder ser resolts f\u00e0cilment amb algun llenguatge de programaci\u00f3. Aquesta t\u00e8cnica es diu refinament successiu, divideix i vencer\u00e0s o an\u00e0lisi descendent (Top-Down). Un 'm\u00f2dul' \u00e9s cadascuna de les parts d'un programa que resol un dels subproblemes en qu\u00e8 es divideix el problema complex original. Cadascun d'aquests m\u00f2duls t\u00e9 una tasca ben definida i alguns necessiten d'altres per poder operar. En cas que un m\u00f2dul necessiti d'un altre, pot comunicar-se amb aquest mitjan\u00e7ant una interf\u00edcie de comunicaci\u00f3 que tamb\u00e9 ha d'estar ben definida. Si b\u00e9 un m\u00f2dul es pot entendre com una part d'un programa en qualsevol de les seves formes i variats contextos, en la pr\u00e0ctica se'ls sol prendre com a sin\u00f2nims de procediments i funcions. Per\u00f2 no necess\u00e0ria ni estrictament un m\u00f2dul \u00e9s una funci\u00f3 o un procediment, ja que el mateix pot contenir molts d'ells. No s'ha de confondre el terme \"m\u00f2dul\" (en el sentit de programaci\u00f3 modular) amb termes com \"funci\u00f3\" o \"procediment\", propis de l'llenguatge que ho suporte. Abstracci\u00f3 L'abstracci\u00f3 \u00e9s la capacitat de, observada una realitat, quedar-se amb all\u00f2 important o essencial i obviar el detall. Aquest concepte ser\u00e0 un concepte b\u00e0sic en l'evoluci\u00f3 de la programaci\u00f3 estructurada i modular cap a la programaci\u00f3 orientada a objectes. Per exemple, per saber conduir un cotxe no necessite saber al detall el funcionament del seu motor sino on est\u00e0 l'accelerador, el fre i el volant. No hem de pensar mai en un programa com un tot sino com un conjunt de m\u00f2duls relacionats entre si on cada m\u00f2dul desenvolupa una tasca molt concreta independentment de la resta i que tots junts formen el programa o aplicaci\u00f3. Caracter\u00edstiques Es considera moudlaritat com la definici\u00f3 d'un programa com a conjunt de subprogrames (m\u00f2duls). Cada m\u00f2dul t\u00e9 una funci\u00f3 particular, \u00e9s semi-independent i tamb\u00e9 pot trobar-se en fitxers de codi distints. Avantatges El codi resultant \u00e9s m\u00e9s net i f\u00e0cil d'entendre. Permet la divisi\u00f3 del treball. Es pot provar de forma independent, millorant aix\u00ed la recerca i correcci\u00f3 d'errades. Facilita la definici\u00f3 de variables al crear diversos \u00e0mbits. Depenent del nivell de detall amb el que es tracten els m\u00f2duls, podem distindir tres tipus: - Llibreries - Classes - Funcions o m\u00e8todes Una funci\u00f3 \u00e9s un tro\u00e7 de codi que realitza una funci\u00f3 concreta i de vegades torna algun valor com a resultat. Funcions en Java Una funci\u00f3 en Java t\u00e9 la seg\u00fcent estructura: [acces] [modificador] tipus nomFuncio([tipus nomArgument,[tipo nomArgument]...]) { /* * Bloque de instrucciones */ return valor; } Tots aquells elements que estan entre claudators s\u00f3n opcionals On: - Acc\u00e9s: public, protected, private o package - Modificador: static o final - Tipo: int, boolean, float o qualsevol tipus predefinit per l'usuari. - nomFuncio: cadena alfanum\u00e8rica significativa que indique el que fa la funci\u00f3. - nomArgument: par\u00e0metres que se li passen a la funci\u00f3. Aquestos par\u00e0metres funcionaran com variables locals a la funci\u00f3. Exemples // Funci\u00f3 simple void diguesHola () { System.out.println(\"Hola Mon\"); } // Funci\u00f3 amb par\u00e0metres void sayMyName (String strNom) { System.out.println(\"Hola Mon: \" + strNom); } // Funci\u00f3 que torna algun valor String canviaNom (String strNom) { return strNom.reverse(); } Sobre els arguments Hi ha alguns detalls al respeecte dels arguments d'una funci\u00f3: - Una funci\u00f3 pot tindre una quantitat qualsevol de par\u00e0metres, \u00e9s a dir, poden tindre des de zero fins a un, dos, deu o cent par\u00e0metres. Normalment no sol passar de cinc m\u00e0xim. - Si la funci\u00f3 t\u00e9 m\u00e9s d'un par\u00e0metre cadascun d'ells ha d'anar separat per una coma. - Els arguments d'una funci\u00f3 tamb\u00e9 tenen un tipus i nom que els identifica. - El tipus dels arguments pot ser qualsevol i no ha de tindre relaci\u00f3 amb el tipus del m\u00e8tode. - Al rebre un argument res ens obliga a fer \u00fas d'aquest dins del m\u00e8tode. - Els par\u00e0metres poden passar-se per refer\u00e8ncia (es mantenen les modificacions que es facen dins del m\u00e8tode) o per valor (no afectarien les modificacions a l'element original). Sobre el return Has de tenir en compte dues coses importants amb la sent\u00e8ncia return: - Qualsevol instrucci\u00f3 que es trobe despr\u00e9s de l'execuci\u00f3 de return, NO ser\u00e0 executada. - \u00c9s com\u00fa trobar funcions amb m\u00faltiples sent\u00e8ncies return al seu codi, com per exemple en sentencies condicionals, per\u00f2 una vegada el codi execute una sent\u00e8ncia return all\u00f2 que vinga despr\u00e9s no s'executar\u00e0. - El tipus de valor que es torna en una funci\u00f3 ha de conicidir amb el tipus declarat a la funci\u00f3, \u00e9s a dir, si es declara int, el valor que ha de tornar ha de ser un nombre enter. - En el cas de les funcions que no tornen res (void), tamb\u00e9 conegues com a procediments, poden usar la sent\u00e8ncia return per\u00f2 sense cap valor i nom\u00e9s s'usaria per acabar amb l'execuci\u00f3 de la funci\u00f3. Crida a un funci\u00f3 Per tal de cridar una funci\u00f3 en Java s'ha de fer de la seg\u00fcent forma: nombre([valor,[valor]...]); Una funci\u00f3 en Java es crida utilitzant el nom del m\u00e8tode i entre par\u00e9ntesis s'han de passar els par\u00e0metres que s'indica a la declaraci\u00f3 de la funci\u00f3. Aquestos par\u00e0metres que es passen han de coincidir en n\u00famero, si la declaraci\u00f3 del funci\u00f3 t\u00e9 3 par\u00e0metres s'hauran de passar tres par\u00e0metres, i tamb\u00e9 han de coincidir en el t\u00edtol. Per\u00f2 millor vegem un exemple: Exemple 1. Funcions: declaraci\u00f3 i crida // Declaraci\u00f3 de la funci\u00f3 holaMon void holaMon (String strNom) { System.out.println(\"Hola: \" + strNom); } // Declaraci\u00f3 del funci\u00f3 suma int suma (int a, int b) { int res = a + b; return res; } // Crida correcta a la funci\u00f3 holaMon holaMon(\"Batiste\"); // Crida incorrecta a la funci\u00f3 holaMon holaMon(); holaMon(\"Batiste\",\"Ceba\"); // Crida correcta a suma int resultat = suma(10,5); suma(10,5); // Crides incorrectes. int resultat = suma(); suma(); int res = suma (10,3,10); Detalls per invocar funcions No importa si es tracta d\u2019un m\u00e8tode en Java o d\u2019una funci\u00f3 o d\u2019un m\u00e8tode, nom\u00e9s els debats ocupen d\u2019enviar els par\u00e0metres de la forma correcta per invocar-los. El nombre ha de coincidir exactament al moment d\u2019invocar, \u00e9s l\u2019\u00fanica forma d\u2019identificar-lo.L\u2019ordenaci\u00f3 dels par\u00e0metres i el tipus ha de coincidir. Cal tindre cura en el moment d'enviar els par\u00e0metres, hem de fer-ho en el mateix ordre en que varen ser declarats i han de ser del mateix tipus. Cada par\u00e0metre enviat tamb\u00e9 va separat per comes. Si una funci\u00f3 no rep par\u00e0metres, simplement no posem res a l'interior de la par\u00e8ntesi, per\u00f2 sempre debem posar la par\u00e8ntesi. Invocar una funci\u00f3 sigue sentint una sent\u00e8ncia comuna i corrent en Java, aix\u00ed que ha de finalitzar amb ';' com sempre. El valor retornat per un m\u00e8tode o funci\u00f3 pot ser assignat a una variable del mateix tipus, per\u00f2 no podem fer aix\u00f2 amb un procediment, no es pot retornar valor alg\u00fa. Una funci\u00f3 pot llamar a una altra dins de s\u00ed mateixa o fins i tot pot ser enviada com a par\u00e0metre a una altra (mira el seg\u00fcent exemple). Par\u00e0metres d'una funci\u00f3 \u00c9s possible passar un o m\u00e9s valors a una funci\u00f3 quan es crida. Recordeu que un valor passat a una funci\u00f3 es diu argument . Dins la funci\u00f3, la variable que rep l'argument es diu par\u00e0metre . Els par\u00e0metres es declaren dins dels par\u00e8ntesis que segueixen a el nom de m\u00e8tode. La sintaxi de declaraci\u00f3 de par\u00e0metre \u00e9s la mateixa que la utilitzada per a les variables. Un par\u00e0metre est\u00e0 dins de l'abast de la seua funci\u00f3, i a banda de la seva tasca especial de rebre un argument, actua com qualsevol altra variable local. Ac\u00ed hi ha un exemple simple de l'\u00fas de par\u00e0metres. Dins de la classe ComprobarNumero, el m\u00e8tode Espar () retorna true si el valor que es passa \u00e9s parell. Retorna false en cas contrari. Per tant, Espar () t\u00e9 un tipus de retorn boole\u00e0. // Un exemple simple de l'\u00fas de param\u00e8tres class ComprovarNumero { // Retorna true si x es parell boolean esParell(int x){ if ((x%2)==0) return true; else return false; } } class ParametroDemo { public static void main(String[] args) { ComprobarNumero e=new ComprobarNumero(); if (e.esPar(10)) System.out.println(\"10 es par.\"); if (e.esPar(9)) System.out.println(\"9 es par.\"); if (e.esPar(8)) System.out.println(\"8 es par.\"); } } Un m\u00e8tode pot tenir m\u00e9s d'un par\u00e0metre. Simplement declare cada par\u00e0metre, separant un el seg\u00fcent amb una coma. Per exemple, la classe Divisor defineix un m\u00e8tode anomenat esDivisor () que determina si el primer par\u00e0metre \u00e9s divisor de el segon. // Un exemple sempre de l'\u00fas de param\u00e8tres class Divisor { boolean esDivisor(int a, int b){ if ((b%a)==0) return true; else return false; } } class DivisorDemo { public static void main(String[] args) { Divisor x =new Divisor(); if (x.esDivisor(2,20)) System.out.println(\"2 es Divisor de 20\"); if (x.esDivisor(3,20)) System.out.println(\"3 es Divisor de 20\"); } } Depenent del tipus de dada que enviem a la funci\u00f3 com a argument, podem diferenciar dos comportaments: - Pas per valor: Es crea una c\u00f2pia local de la variable dins de la funci\u00f3. Pas per refer\u00e8ncia: Es maneja directament la variable, els canvis realitzats dins de la funci\u00f3 li afectaran tamb\u00e9 fora. Pas d'objectes a funcions Quan passem un tipus primitiu a una funci\u00f3, es passa per valor. Per\u00f2 quan vam passar un objecte a una funci\u00f3, la situaci\u00f3 canvia dr\u00e0sticament, perqu\u00e8 els objectes es passen pel que efectivament \u00e9s anomenat, per refer\u00e8ncia . Java fa aquesta cosa interessant que \u00e9s una classe d'h\u00edbrid entre passar per valor i passar per refer\u00e8ncia. B\u00e0sicament, la funci\u00f3 no pot canviar un par\u00e0metre, per\u00f2 la funci\u00f3 pot demanar-li a l'par\u00e0metre que es canvi\u00ef a si mateix cridant a algun m\u00e8tode dins d'ell. A l'crear una variable d'un tipus de classe (un objecte), nom\u00e9s vam crear una refer\u00e8ncia a un objecte. Per tant, quan passem aquesta refer\u00e8ncia a un m\u00e8tode, el par\u00e0metre que el rep es referir\u00e0 a el mateix objecte que el referit per l'argument. Aix\u00f2 vol dir efectivament que els objectes actuen com si es passessin als m\u00e8todes mitjan\u00e7ant l'\u00fas de trucada per refer\u00e8ncia. Els canvis en l'objecte dins el m\u00e8tode es reflecteixen en l'objecte utilitzat com a argument. // Programa Java per demostrar el pas d'objectes a funcions class Demo { int a, b; Demo(int i, int j) { a = i; b = j; } // Torna true si els valors s\u00f3n els mateixos boolean equalTo(Demo obj) { return (obj.a == a && obj.b == b); } } public class Test { public static void main(String args[]) { Demo ob1 = new Demo(100, 22); Demo ob2 = new Demo(100, 22); Demo ob3 = new Demo(-1, -1); System.out.println(\"ob1 == ob2: \" + ob1.equalTo(ob2)); System.out.println(\"ob1 == ob3: \" + ob1.equalTo(ob3)); } } Eixida obj1 == obj2: true obj1 == obj3: false Explicaci\u00f3 en imatges: 1. Es creen tres objectes: Demo ob1 = new Demo(100, 22); Demo ob2 = new Demo(100, 22); Demo ob3 = new Demo(-1, -1); Des del costat de la funci\u00f3, es declara una refer\u00e8ncia de tipus Demo amb un objecte obj i s'assigna inicialment null. Com cridem al m\u00e8tode equalTo, la refer\u00e8ncia 'obj' s'assignar\u00e0 a l'objecte que es passa com a par\u00e0metre, \u00e9s a dir, 'obj' es referir\u00e0 a 'obj2' quan la seg\u00fcent sent\u00e8ncia s'execute. System.out.println(\"ob1 == ob2: \" + ob1.equalTo(ob2)); Ara com podem observar, es crida al m\u00e8tode equalTo sobre 'obj1' i 'obj' fa refer\u00e8ncia a 'obj2'. Donat que els valors 'a' i 'b' s\u00f3n els mateixos per ambdues refer\u00e8ncies, aleshores si (condici\u00f3) \u00e9s veritat, aleshores tornar\u00e0 true. if(obj.a == a && obj.b == b) De nou 'obj' es reassignar\u00e0 a 'ob3' quan s'executa la seg\u00fcent sent\u00e8ncia. System.out.println(\"ob1 == ob3: \" + ob1.equalTo(ob3)); Ara, com podem observar, el m\u00e8tode equalTo es crida en 'ob1', i 'obj' fa refer\u00e8ncia a 'ob3'. Com que els valors 'a' i 'b' no s\u00f3n els mateixos per a les dues refer\u00e8ncies, aleshores torna false. Recursivitat En general, la recursivitat \u00e9s el proc\u00e9s de definir alguna cosa en termes de si mateix i \u00e9s una cosa semblant a una definici\u00f3 circular. El component clau d'un m\u00e8tode recursiu \u00e9s una declaraci\u00f3 que executa una crida a si mateix. La recursivitat \u00e9s un poder\u00f3s mecanisme de control. L'exemple cl\u00e0ssic de recursivitat \u00e9s el c\u00e0lcul de l'factorial d'un nombre. El factorial d'un nombre N \u00e9s el producte de tots els nombres enters que es trobin entre 1 i N. Per exemple, el factorial de 3 \u00e9s 1 \u00d7 2 \u00d7 3, \u00e9s a dir, \u00e9s de 6. El seg\u00fcent programa mostra una forma recursiva de calcular el factorial d'un nombre. Per a prop\u00f2sits de comparaci\u00f3, tamb\u00e9 s'inclou un equivalent no recursiu (iteratiu). // Un simple programa de recursividad class Factorial { // Esto es un m\u00e9todo recursivo int facR (int n){ int resultado; if (n==1) return 1; resultado=facR(n-1)*n; return resultado; } // Esto es un equivalente iterativo int facI (int n){ int t, resultado; resultado=1; for (t=1; t<=n; t++) resultado *=t; return resultado; } } class Recursividad{ public static void main(String[] args) { Factorial f= new Factorial(); System.out.println(\"Factorial utilizando un m\u00e9todo recursivo:\"); System.out.println(\"El factorial de 3 es: \"+f.facR(3)); System.out.println(\"El factorial de 6 es: \"+f.facR(6)); System.out.println(); System.out.println(\"Factorial utilizando un m\u00e9todo iterativo:\"); System.out.println(\"El factorial de 3 es: \"+f.facI(3)); System.out.println(\"El factorial de 6 es: \"+f.facI(6)); System.out.println(); } } Eixida Factorial utilizando un m\u00e9todo recursivo: El factorial de 3 es: 6 El factorial de 6 es: 720 Factorial utilizando un m\u00e9todo iterativo: El factorial de 3 es: 6 El factorial de 6 es: 720 Stack Overflow Les versions recursives de moltes rutines poden executar-se una mica m\u00e9s lentament que els seus equivalents iteratius causa de la sobrec\u00e0rrega addicional de les trucades a m\u00e8todes addicionals. Massa crides recursives a un m\u00e8tode podrien causar un desbordament de la pila. Com l'emmagatzematge per als par\u00e0metres i les variables locals est\u00e0 a la pila i cada trucada nova crea una nova c\u00f2pia d'aquestes variables, \u00e9s possible que la pila s 'ha esgotat. Si aix\u00f2 passa, el sistema de temps d'execuci\u00f3 (run-time) de Java causar\u00e0 una excepci\u00f3. No obstant aix\u00f2, probablement no haur\u00e0s de preocupar-te per aix\u00f2 a menys que una rutina recursiva es torni boja. El principal avantatge de la recursivitat \u00e9s que alguns tipus d'algoritmes es poden implementar de forma m\u00e9s clara i m\u00e9s recursiva del que poden ser iterativament. Per exemple, l'algorisme de classificaci\u00f3 Quicksort \u00e9s bastant dif\u00edcil d'implementar de manera iterativa. A m\u00e9s, alguns problemes, especialment els relacionats amb la IA, semblen prestar-se a solucions recursives. int fact(int n) { // condici\u00f3n base equivocada (esto causa // stack overflow). if (n == 100) return 1; else return n*fact(n-1); } En l'exemple anterior: Si es diu a fact (10), cridar\u00e0 a fac (9), fact (8), fact (7), etc., per\u00f2 el nombre mai arribar\u00e0 a 100. Per tant, no s'assoleix la condici\u00f3 base. Si la mem\u00f2ria s'esgota amb aquests m\u00e8todes en la pila, provocar\u00e0 un error de desbordament de pila. La API de Java L'API Java \u00e9s una interf\u00edcie de programaci\u00f3 d'aplicacions (API, per les seves sigles de l'angl\u00e8s: Application Programming Interface) prove\u00efda pels creadors de el llenguatge de programaci\u00f3 Java, que d\u00f3na als programadors els mitjans per desenvolupar aplicacions Java. Com el llenguatge Java \u00e9s un llenguatge orientat a objectes, l'API de Java proveeix d'un conjunt de classes utilit\u00e0ries per a efectuar tota mena de tasques necess\u00e0ries dins d'un programa. L'API Java est\u00e0 organitzada en paquets l\u00f2gics, on cada paquet cont\u00e9 un conjunt de classes relacionades sem\u00e0nticament.","title":"Tema 3. Programaci\u00f3 Modular"},{"location":"Tema%203.%20Programaci%C3%B3%20Modular/#tema-3-programacio-modular","text":"","title":"Tema 3. Programaci\u00f3 Modular"},{"location":"Tema%203.%20Programaci%C3%B3%20Modular/#introduccio","text":"La programaci\u00f3 modular \u00e9s un paradigma de programaci\u00f3 que consisteix a dividir un programa en m\u00f2duls o subprogrames per tal de fer-lo m\u00e9s llegible i manejable Es presenta hist\u00f2ricament com una evoluci\u00f3 de la programaci\u00f3 estructurada per solucionar problemes de programaci\u00f3 m\u00e9s grans i complexos del que aquesta pot resoldre. A l'aplicar la programaci\u00f3 modular, un problema complex ha de ser dividit en diversos subproblemes m\u00e9s simples, i aquests al seu torn en altres subproblemes m\u00e9s simples encara. Aix\u00f2 s'ha de fer fins a obtenir subproblemes prou simples com per poder ser resolts f\u00e0cilment amb algun llenguatge de programaci\u00f3. Aquesta t\u00e8cnica es diu refinament successiu, divideix i vencer\u00e0s o an\u00e0lisi descendent (Top-Down). Un 'm\u00f2dul' \u00e9s cadascuna de les parts d'un programa que resol un dels subproblemes en qu\u00e8 es divideix el problema complex original. Cadascun d'aquests m\u00f2duls t\u00e9 una tasca ben definida i alguns necessiten d'altres per poder operar. En cas que un m\u00f2dul necessiti d'un altre, pot comunicar-se amb aquest mitjan\u00e7ant una interf\u00edcie de comunicaci\u00f3 que tamb\u00e9 ha d'estar ben definida. Si b\u00e9 un m\u00f2dul es pot entendre com una part d'un programa en qualsevol de les seves formes i variats contextos, en la pr\u00e0ctica se'ls sol prendre com a sin\u00f2nims de procediments i funcions. Per\u00f2 no necess\u00e0ria ni estrictament un m\u00f2dul \u00e9s una funci\u00f3 o un procediment, ja que el mateix pot contenir molts d'ells. No s'ha de confondre el terme \"m\u00f2dul\" (en el sentit de programaci\u00f3 modular) amb termes com \"funci\u00f3\" o \"procediment\", propis de l'llenguatge que ho suporte.","title":"Introducci\u00f3"},{"location":"Tema%203.%20Programaci%C3%B3%20Modular/#abstraccio","text":"L'abstracci\u00f3 \u00e9s la capacitat de, observada una realitat, quedar-se amb all\u00f2 important o essencial i obviar el detall. Aquest concepte ser\u00e0 un concepte b\u00e0sic en l'evoluci\u00f3 de la programaci\u00f3 estructurada i modular cap a la programaci\u00f3 orientada a objectes. Per exemple, per saber conduir un cotxe no necessite saber al detall el funcionament del seu motor sino on est\u00e0 l'accelerador, el fre i el volant. No hem de pensar mai en un programa com un tot sino com un conjunt de m\u00f2duls relacionats entre si on cada m\u00f2dul desenvolupa una tasca molt concreta independentment de la resta i que tots junts formen el programa o aplicaci\u00f3.","title":"Abstracci\u00f3"},{"location":"Tema%203.%20Programaci%C3%B3%20Modular/#caracteristiques","text":"Es considera moudlaritat com la definici\u00f3 d'un programa com a conjunt de subprogrames (m\u00f2duls). Cada m\u00f2dul t\u00e9 una funci\u00f3 particular, \u00e9s semi-independent i tamb\u00e9 pot trobar-se en fitxers de codi distints. Avantatges El codi resultant \u00e9s m\u00e9s net i f\u00e0cil d'entendre. Permet la divisi\u00f3 del treball. Es pot provar de forma independent, millorant aix\u00ed la recerca i correcci\u00f3 d'errades. Facilita la definici\u00f3 de variables al crear diversos \u00e0mbits. Depenent del nivell de detall amb el que es tracten els m\u00f2duls, podem distindir tres tipus: - Llibreries - Classes - Funcions o m\u00e8todes Una funci\u00f3 \u00e9s un tro\u00e7 de codi que realitza una funci\u00f3 concreta i de vegades torna algun valor com a resultat.","title":"Caracter\u00edstiques"},{"location":"Tema%203.%20Programaci%C3%B3%20Modular/#funcions-en-java","text":"Una funci\u00f3 en Java t\u00e9 la seg\u00fcent estructura: [acces] [modificador] tipus nomFuncio([tipus nomArgument,[tipo nomArgument]...]) { /* * Bloque de instrucciones */ return valor; } Tots aquells elements que estan entre claudators s\u00f3n opcionals On: - Acc\u00e9s: public, protected, private o package - Modificador: static o final - Tipo: int, boolean, float o qualsevol tipus predefinit per l'usuari. - nomFuncio: cadena alfanum\u00e8rica significativa que indique el que fa la funci\u00f3. - nomArgument: par\u00e0metres que se li passen a la funci\u00f3. Aquestos par\u00e0metres funcionaran com variables locals a la funci\u00f3.","title":"Funcions en Java"},{"location":"Tema%203.%20Programaci%C3%B3%20Modular/#exemples","text":"// Funci\u00f3 simple void diguesHola () { System.out.println(\"Hola Mon\"); } // Funci\u00f3 amb par\u00e0metres void sayMyName (String strNom) { System.out.println(\"Hola Mon: \" + strNom); } // Funci\u00f3 que torna algun valor String canviaNom (String strNom) { return strNom.reverse(); }","title":"Exemples"},{"location":"Tema%203.%20Programaci%C3%B3%20Modular/#sobre-els-arguments","text":"Hi ha alguns detalls al respeecte dels arguments d'una funci\u00f3: - Una funci\u00f3 pot tindre una quantitat qualsevol de par\u00e0metres, \u00e9s a dir, poden tindre des de zero fins a un, dos, deu o cent par\u00e0metres. Normalment no sol passar de cinc m\u00e0xim. - Si la funci\u00f3 t\u00e9 m\u00e9s d'un par\u00e0metre cadascun d'ells ha d'anar separat per una coma. - Els arguments d'una funci\u00f3 tamb\u00e9 tenen un tipus i nom que els identifica. - El tipus dels arguments pot ser qualsevol i no ha de tindre relaci\u00f3 amb el tipus del m\u00e8tode. - Al rebre un argument res ens obliga a fer \u00fas d'aquest dins del m\u00e8tode. - Els par\u00e0metres poden passar-se per refer\u00e8ncia (es mantenen les modificacions que es facen dins del m\u00e8tode) o per valor (no afectarien les modificacions a l'element original).","title":"Sobre els arguments"},{"location":"Tema%203.%20Programaci%C3%B3%20Modular/#sobre-el-return","text":"Has de tenir en compte dues coses importants amb la sent\u00e8ncia return: - Qualsevol instrucci\u00f3 que es trobe despr\u00e9s de l'execuci\u00f3 de return, NO ser\u00e0 executada. - \u00c9s com\u00fa trobar funcions amb m\u00faltiples sent\u00e8ncies return al seu codi, com per exemple en sentencies condicionals, per\u00f2 una vegada el codi execute una sent\u00e8ncia return all\u00f2 que vinga despr\u00e9s no s'executar\u00e0. - El tipus de valor que es torna en una funci\u00f3 ha de conicidir amb el tipus declarat a la funci\u00f3, \u00e9s a dir, si es declara int, el valor que ha de tornar ha de ser un nombre enter. - En el cas de les funcions que no tornen res (void), tamb\u00e9 conegues com a procediments, poden usar la sent\u00e8ncia return per\u00f2 sense cap valor i nom\u00e9s s'usaria per acabar amb l'execuci\u00f3 de la funci\u00f3.","title":"Sobre el return"},{"location":"Tema%203.%20Programaci%C3%B3%20Modular/#crida-a-un-funcio","text":"Per tal de cridar una funci\u00f3 en Java s'ha de fer de la seg\u00fcent forma: nombre([valor,[valor]...]); Una funci\u00f3 en Java es crida utilitzant el nom del m\u00e8tode i entre par\u00e9ntesis s'han de passar els par\u00e0metres que s'indica a la declaraci\u00f3 de la funci\u00f3. Aquestos par\u00e0metres que es passen han de coincidir en n\u00famero, si la declaraci\u00f3 del funci\u00f3 t\u00e9 3 par\u00e0metres s'hauran de passar tres par\u00e0metres, i tamb\u00e9 han de coincidir en el t\u00edtol. Per\u00f2 millor vegem un exemple:","title":"Crida a un funci\u00f3"},{"location":"Tema%203.%20Programaci%C3%B3%20Modular/#exemple-1-funcions-declaracio-i-crida","text":"// Declaraci\u00f3 de la funci\u00f3 holaMon void holaMon (String strNom) { System.out.println(\"Hola: \" + strNom); } // Declaraci\u00f3 del funci\u00f3 suma int suma (int a, int b) { int res = a + b; return res; } // Crida correcta a la funci\u00f3 holaMon holaMon(\"Batiste\"); // Crida incorrecta a la funci\u00f3 holaMon holaMon(); holaMon(\"Batiste\",\"Ceba\"); // Crida correcta a suma int resultat = suma(10,5); suma(10,5); // Crides incorrectes. int resultat = suma(); suma(); int res = suma (10,3,10);","title":"Exemple 1. Funcions: declaraci\u00f3 i crida"},{"location":"Tema%203.%20Programaci%C3%B3%20Modular/#detalls-per-invocar-funcions","text":"No importa si es tracta d\u2019un m\u00e8tode en Java o d\u2019una funci\u00f3 o d\u2019un m\u00e8tode, nom\u00e9s els debats ocupen d\u2019enviar els par\u00e0metres de la forma correcta per invocar-los. El nombre ha de coincidir exactament al moment d\u2019invocar, \u00e9s l\u2019\u00fanica forma d\u2019identificar-lo.L\u2019ordenaci\u00f3 dels par\u00e0metres i el tipus ha de coincidir. Cal tindre cura en el moment d'enviar els par\u00e0metres, hem de fer-ho en el mateix ordre en que varen ser declarats i han de ser del mateix tipus. Cada par\u00e0metre enviat tamb\u00e9 va separat per comes. Si una funci\u00f3 no rep par\u00e0metres, simplement no posem res a l'interior de la par\u00e8ntesi, per\u00f2 sempre debem posar la par\u00e8ntesi. Invocar una funci\u00f3 sigue sentint una sent\u00e8ncia comuna i corrent en Java, aix\u00ed que ha de finalitzar amb ';' com sempre. El valor retornat per un m\u00e8tode o funci\u00f3 pot ser assignat a una variable del mateix tipus, per\u00f2 no podem fer aix\u00f2 amb un procediment, no es pot retornar valor alg\u00fa. Una funci\u00f3 pot llamar a una altra dins de s\u00ed mateixa o fins i tot pot ser enviada com a par\u00e0metre a una altra (mira el seg\u00fcent exemple).","title":"Detalls per invocar funcions"},{"location":"Tema%203.%20Programaci%C3%B3%20Modular/#parametres-duna-funcio","text":"\u00c9s possible passar un o m\u00e9s valors a una funci\u00f3 quan es crida. Recordeu que un valor passat a una funci\u00f3 es diu argument . Dins la funci\u00f3, la variable que rep l'argument es diu par\u00e0metre . Els par\u00e0metres es declaren dins dels par\u00e8ntesis que segueixen a el nom de m\u00e8tode. La sintaxi de declaraci\u00f3 de par\u00e0metre \u00e9s la mateixa que la utilitzada per a les variables. Un par\u00e0metre est\u00e0 dins de l'abast de la seua funci\u00f3, i a banda de la seva tasca especial de rebre un argument, actua com qualsevol altra variable local. Ac\u00ed hi ha un exemple simple de l'\u00fas de par\u00e0metres. Dins de la classe ComprobarNumero, el m\u00e8tode Espar () retorna true si el valor que es passa \u00e9s parell. Retorna false en cas contrari. Per tant, Espar () t\u00e9 un tipus de retorn boole\u00e0. // Un exemple simple de l'\u00fas de param\u00e8tres class ComprovarNumero { // Retorna true si x es parell boolean esParell(int x){ if ((x%2)==0) return true; else return false; } } class ParametroDemo { public static void main(String[] args) { ComprobarNumero e=new ComprobarNumero(); if (e.esPar(10)) System.out.println(\"10 es par.\"); if (e.esPar(9)) System.out.println(\"9 es par.\"); if (e.esPar(8)) System.out.println(\"8 es par.\"); } } Un m\u00e8tode pot tenir m\u00e9s d'un par\u00e0metre. Simplement declare cada par\u00e0metre, separant un el seg\u00fcent amb una coma. Per exemple, la classe Divisor defineix un m\u00e8tode anomenat esDivisor () que determina si el primer par\u00e0metre \u00e9s divisor de el segon. // Un exemple sempre de l'\u00fas de param\u00e8tres class Divisor { boolean esDivisor(int a, int b){ if ((b%a)==0) return true; else return false; } } class DivisorDemo { public static void main(String[] args) { Divisor x =new Divisor(); if (x.esDivisor(2,20)) System.out.println(\"2 es Divisor de 20\"); if (x.esDivisor(3,20)) System.out.println(\"3 es Divisor de 20\"); } } Depenent del tipus de dada que enviem a la funci\u00f3 com a argument, podem diferenciar dos comportaments: - Pas per valor: Es crea una c\u00f2pia local de la variable dins de la funci\u00f3. Pas per refer\u00e8ncia: Es maneja directament la variable, els canvis realitzats dins de la funci\u00f3 li afectaran tamb\u00e9 fora.","title":"Par\u00e0metres d'una funci\u00f3"},{"location":"Tema%203.%20Programaci%C3%B3%20Modular/#pas-dobjectes-a-funcions","text":"Quan passem un tipus primitiu a una funci\u00f3, es passa per valor. Per\u00f2 quan vam passar un objecte a una funci\u00f3, la situaci\u00f3 canvia dr\u00e0sticament, perqu\u00e8 els objectes es passen pel que efectivament \u00e9s anomenat, per refer\u00e8ncia . Java fa aquesta cosa interessant que \u00e9s una classe d'h\u00edbrid entre passar per valor i passar per refer\u00e8ncia. B\u00e0sicament, la funci\u00f3 no pot canviar un par\u00e0metre, per\u00f2 la funci\u00f3 pot demanar-li a l'par\u00e0metre que es canvi\u00ef a si mateix cridant a algun m\u00e8tode dins d'ell. A l'crear una variable d'un tipus de classe (un objecte), nom\u00e9s vam crear una refer\u00e8ncia a un objecte. Per tant, quan passem aquesta refer\u00e8ncia a un m\u00e8tode, el par\u00e0metre que el rep es referir\u00e0 a el mateix objecte que el referit per l'argument. Aix\u00f2 vol dir efectivament que els objectes actuen com si es passessin als m\u00e8todes mitjan\u00e7ant l'\u00fas de trucada per refer\u00e8ncia. Els canvis en l'objecte dins el m\u00e8tode es reflecteixen en l'objecte utilitzat com a argument. // Programa Java per demostrar el pas d'objectes a funcions class Demo { int a, b; Demo(int i, int j) { a = i; b = j; } // Torna true si els valors s\u00f3n els mateixos boolean equalTo(Demo obj) { return (obj.a == a && obj.b == b); } } public class Test { public static void main(String args[]) { Demo ob1 = new Demo(100, 22); Demo ob2 = new Demo(100, 22); Demo ob3 = new Demo(-1, -1); System.out.println(\"ob1 == ob2: \" + ob1.equalTo(ob2)); System.out.println(\"ob1 == ob3: \" + ob1.equalTo(ob3)); } } Eixida obj1 == obj2: true obj1 == obj3: false Explicaci\u00f3 en imatges: 1. Es creen tres objectes: Demo ob1 = new Demo(100, 22); Demo ob2 = new Demo(100, 22); Demo ob3 = new Demo(-1, -1); Des del costat de la funci\u00f3, es declara una refer\u00e8ncia de tipus Demo amb un objecte obj i s'assigna inicialment null. Com cridem al m\u00e8tode equalTo, la refer\u00e8ncia 'obj' s'assignar\u00e0 a l'objecte que es passa com a par\u00e0metre, \u00e9s a dir, 'obj' es referir\u00e0 a 'obj2' quan la seg\u00fcent sent\u00e8ncia s'execute. System.out.println(\"ob1 == ob2: \" + ob1.equalTo(ob2)); Ara com podem observar, es crida al m\u00e8tode equalTo sobre 'obj1' i 'obj' fa refer\u00e8ncia a 'obj2'. Donat que els valors 'a' i 'b' s\u00f3n els mateixos per ambdues refer\u00e8ncies, aleshores si (condici\u00f3) \u00e9s veritat, aleshores tornar\u00e0 true. if(obj.a == a && obj.b == b) De nou 'obj' es reassignar\u00e0 a 'ob3' quan s'executa la seg\u00fcent sent\u00e8ncia. System.out.println(\"ob1 == ob3: \" + ob1.equalTo(ob3)); Ara, com podem observar, el m\u00e8tode equalTo es crida en 'ob1', i 'obj' fa refer\u00e8ncia a 'ob3'. Com que els valors 'a' i 'b' no s\u00f3n els mateixos per a les dues refer\u00e8ncies, aleshores torna false.","title":"Pas d'objectes a funcions"},{"location":"Tema%203.%20Programaci%C3%B3%20Modular/#recursivitat","text":"En general, la recursivitat \u00e9s el proc\u00e9s de definir alguna cosa en termes de si mateix i \u00e9s una cosa semblant a una definici\u00f3 circular. El component clau d'un m\u00e8tode recursiu \u00e9s una declaraci\u00f3 que executa una crida a si mateix. La recursivitat \u00e9s un poder\u00f3s mecanisme de control. L'exemple cl\u00e0ssic de recursivitat \u00e9s el c\u00e0lcul de l'factorial d'un nombre. El factorial d'un nombre N \u00e9s el producte de tots els nombres enters que es trobin entre 1 i N. Per exemple, el factorial de 3 \u00e9s 1 \u00d7 2 \u00d7 3, \u00e9s a dir, \u00e9s de 6. El seg\u00fcent programa mostra una forma recursiva de calcular el factorial d'un nombre. Per a prop\u00f2sits de comparaci\u00f3, tamb\u00e9 s'inclou un equivalent no recursiu (iteratiu). // Un simple programa de recursividad class Factorial { // Esto es un m\u00e9todo recursivo int facR (int n){ int resultado; if (n==1) return 1; resultado=facR(n-1)*n; return resultado; } // Esto es un equivalente iterativo int facI (int n){ int t, resultado; resultado=1; for (t=1; t<=n; t++) resultado *=t; return resultado; } } class Recursividad{ public static void main(String[] args) { Factorial f= new Factorial(); System.out.println(\"Factorial utilizando un m\u00e9todo recursivo:\"); System.out.println(\"El factorial de 3 es: \"+f.facR(3)); System.out.println(\"El factorial de 6 es: \"+f.facR(6)); System.out.println(); System.out.println(\"Factorial utilizando un m\u00e9todo iterativo:\"); System.out.println(\"El factorial de 3 es: \"+f.facI(3)); System.out.println(\"El factorial de 6 es: \"+f.facI(6)); System.out.println(); } } Eixida Factorial utilizando un m\u00e9todo recursivo: El factorial de 3 es: 6 El factorial de 6 es: 720 Factorial utilizando un m\u00e9todo iterativo: El factorial de 3 es: 6 El factorial de 6 es: 720","title":"Recursivitat"},{"location":"Tema%203.%20Programaci%C3%B3%20Modular/#stack-overflow","text":"Les versions recursives de moltes rutines poden executar-se una mica m\u00e9s lentament que els seus equivalents iteratius causa de la sobrec\u00e0rrega addicional de les trucades a m\u00e8todes addicionals. Massa crides recursives a un m\u00e8tode podrien causar un desbordament de la pila. Com l'emmagatzematge per als par\u00e0metres i les variables locals est\u00e0 a la pila i cada trucada nova crea una nova c\u00f2pia d'aquestes variables, \u00e9s possible que la pila s 'ha esgotat. Si aix\u00f2 passa, el sistema de temps d'execuci\u00f3 (run-time) de Java causar\u00e0 una excepci\u00f3. No obstant aix\u00f2, probablement no haur\u00e0s de preocupar-te per aix\u00f2 a menys que una rutina recursiva es torni boja. El principal avantatge de la recursivitat \u00e9s que alguns tipus d'algoritmes es poden implementar de forma m\u00e9s clara i m\u00e9s recursiva del que poden ser iterativament. Per exemple, l'algorisme de classificaci\u00f3 Quicksort \u00e9s bastant dif\u00edcil d'implementar de manera iterativa. A m\u00e9s, alguns problemes, especialment els relacionats amb la IA, semblen prestar-se a solucions recursives. int fact(int n) { // condici\u00f3n base equivocada (esto causa // stack overflow). if (n == 100) return 1; else return n*fact(n-1); } En l'exemple anterior: Si es diu a fact (10), cridar\u00e0 a fac (9), fact (8), fact (7), etc., per\u00f2 el nombre mai arribar\u00e0 a 100. Per tant, no s'assoleix la condici\u00f3 base. Si la mem\u00f2ria s'esgota amb aquests m\u00e8todes en la pila, provocar\u00e0 un error de desbordament de pila.","title":"Stack Overflow"},{"location":"Tema%203.%20Programaci%C3%B3%20Modular/#la-api-de-java","text":"L'API Java \u00e9s una interf\u00edcie de programaci\u00f3 d'aplicacions (API, per les seves sigles de l'angl\u00e8s: Application Programming Interface) prove\u00efda pels creadors de el llenguatge de programaci\u00f3 Java, que d\u00f3na als programadors els mitjans per desenvolupar aplicacions Java. Com el llenguatge Java \u00e9s un llenguatge orientat a objectes, l'API de Java proveeix d'un conjunt de classes utilit\u00e0ries per a efectuar tota mena de tasques necess\u00e0ries dins d'un programa. L'API Java est\u00e0 organitzada en paquets l\u00f2gics, on cada paquet cont\u00e9 un conjunt de classes relacionades sem\u00e0nticament.","title":"La API de Java"},{"location":"Tema%205.%20Tipus%20compostos%20de%20dades/","text":"Tema 5. Tipus Compostos de Dades Introducci\u00f3 Fins ara hav\u00edem treballat amb tipus de dades simples: int, char, double, float, bool... per\u00f2 que passa si necessitarem guardar informaci\u00f3 relativa a una persona? Nom, cognoms, DNI, adre\u00e7a postal, data de naixement etc.. Amb els tipus de dades simples ens seria impossible representar aquesta informaci\u00f3. Es per aix\u00f2 que s\u2019utilitzen els tipus de dades compostos que ens permetran agrupar de diverses maneres aquesta informaci\u00f3. En aquest tema veurem: arrays, cadenes de car\u00e0cters, estructures i enumeracions. Per tal de fer les activitats d\u2019aquest tema es necessitar\u00e0 de la implementaci\u00f3 d\u2019una classe a la que anomenarem TAD que tindr\u00e0 les seg\u00fcents caracter\u00edstiques: - Classe p\u00fablica - Membres de la classe: arrayN\u00fameros i arrayCaracters - M\u00e8todes de la classe: recercaBinaria, recercaSequencial, ordenarInserci\u00f3, ordenarBombolla, ordenarShell, ordernarQuickSort De moment amb a\u00e7\u00f2 ser\u00e0 suficient, en apartats posteriors anirem afegint m\u00e9s membres i m\u00e8todes quan ho necessitem. Activitat 1 Crea la classe \u2018TAD\u2019 amb l\u2019IDE que sols utilitzar basada en les seg\u00fcents especificacions: - Ha de ser una classe p\u00fablica - Ha de tindre m\u00ednim una constant que ens indicar\u00e0 el total d\u2019elements que tindran els arrays, tant el d\u2019enters com el de car\u00e0cters. - Com membres de la classe ha de tindre almenys un array de car\u00e0cters i un d\u2019enters. Han de ser privats o p\u00fablics? - Tamb\u00e9 ha de tenir un m\u00e8tode main static on s\u2019iniciar\u00e0 el programa. Arrays Un array \u00e9s un tipus de dades compost que permet emmagatzemar un nombre x d\u2019elements del mateix tipus. Amb una \u00fanica declaraci\u00f3 podem tenir acc\u00e9s a un conjunt de valors agrupats. Aquestes agrupacions o arrays poden b\u00e9 ser de tipus simples o tamb\u00e9 de tipus compostos. Per tal d\u2019accedir a cadascun dels elements del array s\u2019utilitza un \u00edndex o posici\u00f3. La primera posici\u00f3 de tot array \u00e9s la 0 mentre que la segona seria la que t\u00e9 \u00edndex 1. A\u00e7\u00f2 pot marejar un poc al principi. Array d\u2019enters: {8,2,14,55,3,7} Array de car\u00e0cters: {\u2018n\u2019,\u2019a\u2019,\u2019t\u2019,\u2019o\u2019} \u00c9s molt important distingir entre valor i posici\u00f3. Mentre que el valor \u00e9s el contingut de l\u2019array en una posici\u00f3 determinada la posici\u00f3 \u00e9s l\u2019\u00edndex que ens permet recorres l\u2019array i tot el seu contingut. A l\u2019exemple anterior tenim un array de 8 enters, la part superior de color blau ens indica les posicions que van de la 0 a la 7, 8 posicions ens total. Mentre que a la fila inferior trobarem el valor que cont\u00e9 cadascuna de les posicions. Per exemple en la posici\u00f3 5 (la sisena) de l\u2019array tindr\u00edem emmagatzemat un valor de 8. Un altre concepte a tenir en compte \u00e9s la dimensi\u00f3 o grand\u00e0ria de l\u2019array que ens determina el total d\u2019elements que es poden guardar en aquest. En el nostre cas la mida seria de 8. DECLARACI\u00d3 I CREACI\u00d3 D\u2019UN ARRAY EN JAVA Un array en Java \u00e9s una estructura de dades que ens permet emmagatzemar un conjunt de dades del mateix tipus. El grand\u00e0ria de l\u2019array es determina en la seua declaraci\u00f3 i no es permet la seua modificaci\u00f3 posterior tipusBase nomArray []; nomArray = new tipusBase[grand\u00e0ria]; Alguns exemples: \u00b4\u00b4\u00b4 Java int mes []; mes = new int [30]; char grups []; grups = new char [5]; \u00b4\u00b4\u00b4 Aquesta forme de declarar i inicialitzar arrays es pot fer en una sola l\u00ednia de la seg\u00fcent forma: Java int agendaMensual = new int [30]; ### INICIALITZACI\u00d3 D\u2019UN ARRAY Per tal d\u2019accedir a les dades que cont\u00e9 un array necessitem l\u2019identificador d\u2019aquest aix\u00ed com tamb\u00e9 la posici\u00f3 concreta a la qual volem accedir. Per exemple, imaginem un array d\u2019enters que es diu n\u00fameros. Java int n\u00fameros. = new int [5]; // Declarem un array n\u00fameros. [] = {2,4,6,8,10}; // Inicialitzaci\u00f3 de valors D\u2019aquesta forma haur\u00edem creat un array de 5 enters que contindria els nombres parells fins al 10. ### Activitat 2 En aquest punt aprofitarem per crear un constructor a la nostra classe TAD. Un constructor de classe \u00e9s la funci\u00f3 que s\u2019executa en el moment que s\u2019instancia un objecte i \u00e9s en aquest punt on s\u2019haurien d'inicialitzar aquells elements de la classe que ho necessiten. En el nostre cas els arrays. Inicialitza l\u2019arrayNumeros amb 10 n\u00fameros aleatoris usant la funci\u00f3 rand. Fes el mateix per\u00f2 amb car\u00e0cters amb el nostre arrayCaracters. Recorda que els arrays s\u00f3n membres de la classe. ### ACC\u00c9S ALS ELEMENTS D\u2019UN ARRAY Una vegada ja tenim la declaraci\u00f3 de l\u2019array i la seua inicialitzaci\u00f3, si volem b\u00e9 accedir al seu contingut o modificar-ho, necessitar\u00edem l\u2019identificador de l\u2019array i l\u2019\u00edndex al qual volem accedir. \u00c9s molt important tenir en compte que el primer element d\u2019un array en Java est\u00e0 a la posici\u00f3 (\u00edndex) 0 i no a la posici\u00f3 1 com ens indicaria la l\u00f2gica. int primerNumero = n\u00fameros. [0]; // primerNumero valdria 2 n\u00fameros. [0] = 12; // Canviem el primer numero de l\u2019array ARRAYS DE CAR\u00c0CTERS Un array que cont\u00e9 car\u00e0cters en lloc de n\u00fameros funciona d\u2019una forma molt semblant al que s\u2019ha explicat en els apartats anteriors. Es pot veure de forma senzilla a l\u2019exemple que vos mostrem a continuaci\u00f3. char vocals = new char [5]; // Declaraci\u00f3 de l\u2019array vocals [] = {\u2018a\u2019,\u2019e\u2019,\u2019i\u2019,\u2019o\u2019,\u2019u\u2019} // Inicialitzaci\u00f3 vocals [0] = \u2018z\u2019; // Acc\u00e9s als elements de l\u2019array ARRAYS COM A PAR\u00c0METRES Com qualsevol altre tipus de dades, un array tamb\u00e9 es pot passar com a par\u00e0metre a un m\u00e8tode. Els arrays sempre es passen per refer\u00e8ncia, \u00e9s a dir, quan passem un array per par\u00e0metre a un m\u00e8tode, el que en realitat estem passant \u00e9s un adre\u00e7a de mem\u00f2ria que \u00e9s la que ens indicaria on est\u00e0 l\u2019inici del contingut d\u2019aquest. Passar per refer\u00e8ncia qualsevol par\u00e0metre significa que qualsevol modificaci\u00f3 que es faja dins del m\u00e8tode afectar\u00e0 tamb\u00e9 a l\u2019array fora d\u2019aquest. No passa el mateix si passem un element concret de l\u2019array, en aquest cas a l\u2019igual que amb els altres par\u00e0metres, aquestos es passen per valor, per tant les modificacions o canvis que es produeixquen dins del m\u00e8tode no afectaran fora d\u2019aquest. Activitat 3 Fes dos m\u00e8todes per la nostra classe que mostre, de forma amigable, l\u2019array de n\u00fameros i l\u2019array de car\u00e0cters. Els m\u00e8todes es podrien dir mostraEnters i mostraCaracters i seran privats. Activitat 4 En la seg\u00fcent activitat afegirem una funci\u00f3 a la nostra classe en la que ens mostre un men\u00fa de les accions que podem realitzar. Per tal de realitzar aquest men\u00fa afegirem un array d\u2019strings com a nou membre de la classe que inicialitzarem amb les seg\u00fcents opcions: Mostrar array enters Mostrar array caracters Reinicialitzar vectors Recerca seq\u00fcencial Recerca bin\u00e0ria Ordenar amb bombolla Ordenar amb Quicksort Ordenar amb Shell BUCLE FOR EN JAVA Per tal de rec\u00f3rrer arrays podem usar bucles for o while per\u00f2 aquests solen tindre l\u2019inconvenient de que \u00e9s el programador el que ha de controlar quan s\u2019arriba al final de l\u2019array per tal que l\u2019aplicaci\u00f3 no done una errada inesperada i aix\u00f2 de vegades no \u00e9s senzill. La millor forma de rec\u00f3rrer un array sense haver de controlar quan s\u2019arriba al final \u00e9s la sent\u00e8ncia for usada d\u2019una manera alternativa. Si per exemple tenim un array d\u2019enters que s\u2019anomena \u00abvector\u00bb i volem llistar tots els seus elements, podr\u00edem fer el seg\u00fcent: for (int i: vector){ // Accions a realitzar } Activitat 5 Fes una funci\u00f3 que mostre per pantalla el men\u00fa per\u00f2 esta vegada utilitzant el for com hem explicat a l\u2019exemple anterior. ALGORISMES DE RECERCA Existeixen dos algorismes de recerca que veurem en aquest apartat: la recerca seq\u00fcencial i la recerca binaria. A l\u2019element que estem buscant li direm clau. SEQUENCIAL Tamb\u00e9 anomenada recerca lineal, es recorren tots els elements de l\u2019array des del principi fins que es troba la clau (element que estem buscant) o fins que s\u2019arriba a l\u2019\u00faltim element de l\u2019array. int sequencial (int [] array, int clau) { for (int i = 0; i < array.length; i ++ ) if (array[i] == clau ) return i; return -1; } BIN\u00c0RIA En aquest algoritme existeix la precondici\u00f3 que l\u2019array o vector sobre el qual vaja a fer-se la recerca, ha d\u2019estar ordenat. Aquest m\u00e8tode \u00e9s m\u00e9s \u00f2ptim. El funcionament d\u2019aquest algorisme \u00e9s el seg\u00fcent: en una primera iteraci\u00f3 es compara la clau (element que estem buscant) amb el valor al centre, que s\u2019anomena pivot, de l\u2019array. Poden passar tres coses: - Que hajam trobat el que busquem, per tant s\u2019acaba la recerca - Que el pivot siga major que la clau. En aquest cas continuar\u00edem buscant a la meitat esquerra del vector desestimant la meitat dreta (pivot incl\u00f2s) - Que el pivot siga menor que la clau. Amb la qual cosa haur\u00edem de buscar a la part esquerra del vector. Activitat 6 Afegeix el m\u00e8tode de recerca seq\u00fcencial i el de recerca binaria a la classe TAD. Tamb\u00e9 has d\u2019implementar el codi necessari per tal que quan l\u2019usuari seleccione una de les dues opcions de la nostra aplicaci\u00f3, demane el n\u00famero a buscar i mostre el resultat per pantalla. En cas que es seleccione la recerca bin\u00e0ria, haur\u00edem de comprovar si el vector est\u00e0 ordenat int recercaBinaria (int array[], int clau) { int posCentre, posInici, posFinal, valorCentral; posInici = 0; posFinal = array.length \u2013 1; while (posInici <= posFinal ) { posCentre = (posInici+posFinal)/2; valorCentral=array[posCentre]; if (clau == valorCentral) { return posCentre; } else if (clau < valorCentral) { posFinal = posCentro \u2013 1; } else { posInici = posCentro + 1; } } } Activitat 7 Comparem l\u2019efici\u00e8ncia dels dos algorismes de recerca vistos. Fes una funci\u00f3 a la nostra classe TAD en la que es compten el total de vegades que s\u2019accedeix l\u2019array de n\u00fameros per arribar a trobar la clau. Haur\u00e0s de posar una opci\u00f3 m\u00e9s al men\u00fa, per exemple: \u00abComparar efici\u00e8ncia dels algoritmes\u00bb. Aquesta nova opci\u00f3 haur\u00e0 d\u2019executar varies vegades els dos algorismes de recerca amb vectors de n\u00fameros diferents. ALGORISMES D'ORDENACI\u00d3 Els algorismes d\u2019ordenaci\u00f3 permeten ordenar un array en funci\u00f3 d\u2019un criteri establert al propi algorisme. Hi han diferents tipus d\u2019algorismes d\u2019ordenaci\u00f3: selecci\u00f3, inserci\u00f3, bombolla, Shell i Quicksort. SEL\u00b7LECCI\u00d3 El procediment d\u2019ordenaci\u00f3 per inserci\u00f3 \u00e9s el seg\u00fcent: 1. Busquem l\u2019element m\u00e9s menut de l\u2019array i el col\u00b7loquem a la posici\u00f3 0 intercanviant els dos elements 2. A partir de la posici\u00f3 1 busquem l\u2019element m\u00e9s menut seg\u00fcent i fem el mateix que al pas anterior per\u00f2 aquesta vegada a la posici\u00f3 1 de l\u2019array 3. Repetim el pas 2 fins arribar a l\u2019\u00faltima posici\u00f3 de l\u2019array. Activitat 8 Implementa l\u2019algorisme d\u2019ordenaci\u00f3 per selecci\u00f3 a la classe TAD i vicula-la a l\u2019opci\u00f3 del men\u00fa corresponent. INSERCI\u00d3 Aquest algorisme consisteix en generar un nou array a partir del que ja es t\u00e9, tal que cada nou element inserit es posa a la seua posici\u00f3 correcta. Imaginem que tenim el seg\u00fcent array d\u2019enters per ordenar: {12, 5, 3, 13, 2, 9, 7} Generem un nou array amb el primer element de l\u2019array a ordenar { 12 } El seg\u00fcent valor de l\u2019array original \u00e9s 5. \u00c9s major o menor que el que ja est\u00e0 inserit? Com que la resposta \u00e9s menor, aquest s\u2019haur\u00e0 d\u2019inserir abans quedant de la seg\u00fcent forma: { 5 , 12} El nou array es genera ja ordenat. El seg\u00fcent valor de l\u2019array desordenat \u00e9s 3. On l\u2019haurem de col\u00b7locar? Just abans del 5 quedant aix\u00ed: { 3 , 5, 12} Repetim la mateixa operaci\u00f3 per cada element de l\u2019array original: {3, 5, 12, 13 } { 2 , 3, 5, 12, 13} {2, 3, 5, 9 , 12, 13} {2, 3, 5, 7 , 9, 12, 13} void insercio ( int [] array ) { int i, j, aux; for (i=1; i < array.legnth; i++ ) { j = i; aux = array [i]; while ( j > 0 && aux < array[j-1]) { array [j] = array [j-1]; j--; } } array[j] = aux; } ### Activitat 9 Implementa l\u2019algorisme d\u2019ordenaci\u00f3 per inserci\u00f3 a la classe TAD i vincula-la a l\u2019opci\u00f3 del men\u00fa corresponent. ## BOMBOLLA L\u2019algorisme d\u2019ordenaci\u00f3 per bombolla \u00e9s el m\u00e9s conegut i tamb\u00e9 el menys eficient, ja que a cada passada per ordenar un element compara cadascun d\u2019ells amb el seu adjacent de forma que si les seues posicions s\u00f3n incorrectes, s\u2019intercanvien. Al finalitzar cada passada l\u2019element m\u00e9s gran es va posant al final de la llista Donat el seg\u00fcent array: {12, 5, 3, 13, 2, 9, 7} Pas 1. Comparem les posicions 0 i 1, \u00e9s a dir, 12 i 5 i com que estan desordenats (el primer \u00e9s major que el segon), s\u2019intercanvien. {5, 12, 3, 13, 2, 9, 7} Pas 2. A continuaci\u00f3 comparem les posicions 1 i 2 de l\u2019array, que s\u00f3n 12 i 3. Com que tamb\u00e9 estan desordenades, les intercanviem {5, 3, 12, 13, 2, 9, 7} Pas 3. Ara anem a comparar les posicions 2 i 3 que contenen els valors 12 i 13 respectivament. Com que estan ben ordenades no es realitza cap acci\u00f3: Pas 4. Posicions 3 i 4 que s\u00f3n 13 i 2. Les intercanviem. {5, 3, 12, 2, 13, 9, 7} Pas 5. Posicions 4 i 5 que tamb\u00e9 estan desordenades per tant executem l\u2019intercanviem {5, 3, 12, 2, 9, 13, 7} Pas 6. Comparem posicions 5 i 6 que tenen els valors 13 i 7 i s\u2019han d\u2019intercanviar {5, 3, 13, 2, 9, 7, 13} Una vegada finalitzada la primera passada hem aconseguit que l\u2019element major de l\u2019array estiga posicionat a l\u2019\u00faltima posici\u00f3. A la seg\u00fcent passada recorrerem l\u2019array fins la posici\u00f3 anterior a on es troba ara el n\u00famero 13, \u00e9s a dir la posici\u00f3 5 i aquest procediment es repeteix fins arribar a la posici\u00f3 0 Finalment el codi quedaria aix\u00ed: void bombolla ( int [] arrayNumeros) { for (int i = 0; i < arrayNumeros.length-1; i++) { for(int j = i + 1; j < arrayNumeros.length; j++) { if (arrayNumeros[i] > arrayNumeros[j]) { int canvi = arrayNumeros[i]; arrayNumeros[i] = arrayNumeros[j]; arrayNumeros[j] = canvi; } } } } Activitat 10 Implementa l\u2019algorisme d\u2019ordenaci\u00f3 per bombolla a la classe TAD i vincula-la a l\u2019opci\u00f3 del men\u00fa corresponent. SHELL L\u2019algorisme Shell \u00e9s una millora de l\u2019algorisme d\u2019inserci\u00f3 directa. Compara elements separats per un espai de v\u00e0ries posicions el que permet que un element faja passos m\u00e9s grans fins trobar la seua posici\u00f3 esperada. Els passos m\u00faltiples sobre els elements de l\u2019array es fan amb espais de posicions cada vegada m\u00e9s menuts. L\u2019\u00faltim pas de l\u2019algorisme Shell \u00e9s una simple ordenaci\u00f3 per inserci\u00f3 per\u00f2 arribats a aquest punt es pot garantir que l\u2019array esta ja quasi ordenat, el que fa que l\u2019ordenaci\u00f3 per inserci\u00f3 siga molt eficient. Vegem com actuaria aquest algorisme aplicat sobre l\u2019array que estem utilitzant com exemple: {12, 5, 3, 13, 2, 9, 7}. Aquest array t\u00e9 un total de 7 elements (n=7). Creem n/2 grups, separats n/2 n\u00fameros entre ells. n/2=7/2=3, \u00e9s a dir, el nostre interval per crear grups val 3 Marquem en negreta els valors de la primera subllista. {12, 5, 3, 13, 2, 9, 7} Donats els elements 12, 13 i 7 els hem d\u2019ordenar correctament {7, 5, 3, 12, 2, 9, 13} Continuem formant grups de 3 a partir del segon valor de l\u2019array {7, 5, 3, 12, 2, 9, 13} Ordenem els n\u00fameros en cas de no estar-ho, quedant l\u2019array aix\u00ed: {7, 2, 3, 12, 5, 9, 13} Passem a l\u2019element 3 de l\u2019array i apliquem el mateix procediment. {7, 2, 3, 12, 5, 9, 13} Els valors ja estan ordenats en aquest cas, per tant no hem de fer res. {7, 2, 3, 12, 5, 9, 13} No podem m\u00e9s grups ja que hem arribat al final del vector. Ara el que hem de fer \u00e9s tornar a dividir el nostre interval entre 2. El nou interval \u00e9s 3/2 = 1. void shellSort ( int [] array) { int interval, i, j, k, temp; interval = array.length / 2; while ( interval > 0 ) { for (i=interval; i<n; i++) { j=i-interval; while(j>=0) { k=j+interval; if(array[j] <= array[k] j = -1; else { temp = array[j]; array[j] = array[k]; array[k] = temp; j -= interval; } } } interval = interval / 2; } } Activitat 11 Implementa l\u2019algorisme d\u2019ordenaci\u00f3 shell a la classe TAD i vincula-la a l\u2019opci\u00f3 del men\u00fa corresponent. QUICKSORT Aquest \u00e9s un dels algorismes d\u2019ordenaci\u00f3 m\u00e9s r\u00e0pids i eficients. Utilitza la t\u00e8cnica \u00abdivideix i vencer\u00e0s\u00bb de tal forma que divideix l\u2019array a ordenar en parts que ordenar\u00e0 al mateix temps. B\u00e0sicament es tria l\u2019element de l\u2019array com a pivot tal que es forme dos subArrays, en un d\u2019ells s\u2019emmagatzemen els elements menors que l\u2019element que hem triat com a pivot i a l\u2019altre array es guarden els element majors que el pivot. Una vegada fet, s\u2019aplica el mateix procediment als subarrays obtinguts. Seguint amb el mateix array dels exemples anteriors, aplicarem l\u2019algorisme d\u2019ordenaci\u00f3 quicksort. {12, 5, 3, 13, 2, 9, 7} Triem un valor que fara el paper de pivot, per exmple el primer element de l\u2019array, el 12 i a partir d\u2019aquest creem dos arrays, un amb els n\u00fameros menors que el pivot i l\u2019altre amb els n\u00fameros majors que el pivot: pivot: {12}; menors: {5, 3, 2, 9, 7}; majors {13} El subarray de majors ja est\u00e0 ordenada ja que nom\u00e9s t\u00e9 un n\u00famero. Ara ordenem el subarray de menors: {5, 3, 2, 9, 7} per la qual cosa escollim com a pivot el primer element de l\u2019array, \u00e9s a dir, el 5. pivot: {5}; menors {3, 2}; majors: {9, 7}. Seguim dividint en subarrays, Una vegada els subarrays estan ordenats sempre sempre s\u2019ensamblaran col\u00b7locant subarrays de menors, seguides de pivot i subarrays de majors void Quicksort ( int [] array, int primer, int ultim) { int i, j, central, pivot, tmp; central = (primer + ultim)/2; pivot = array[central]; i = primer; j = ultim; do { while (array[i] < pivot) i ++; while (array[j] > pivot) j --; if (i <= j) { tmp = array[i]; array[i] = array[j]; array[j] = tmp; i ++; j \u2013-; } } while (i<=j); if (primer < j) Quicksort (array, primer, j); if ( i < ultim ) Quicksort (array, i, ultim); } Activitat 12 Implementa l\u2019algorisme d\u2019ordenaci\u00f3 quicksort a la classe TAD i vincula-la a l\u2019opci\u00f3 del men\u00fa corresponent. Activitat 13 Fes que en cada algorisme d\u2019ordenaci\u00f3 es mostre una tra\u00e7a on a cada passada de l\u2019algoritme, \u00e9s a dir, cada vegada que mou un element a l\u2019array, mostre aquest per pantalla. Activitat 14 Entrega mitjan\u00e7ant la plataforma aules la classe TAD que inclou de les activitats 1 a la 13 amb totes les funcions tant de recerca com d\u2019ordenaci\u00f3 sobre arrays unidimensionals. ARRAYS MULTIDIMENSIONALS Fins ara hem estan utilitzant arrays d\u2019una sola dimensi\u00f3, coneguts tamb\u00e9 com vectors, taules o llistes. Aquests arrays es recorren amb ajuda d\u2019un sol \u00edndex (tenen una sola dimensi\u00f3). En aquest apartat estudiarem arrays de m\u00e9s d\u2019una dimensi\u00f3 per als que necessitarem m\u00e9s d\u2019un \u00edndex a l\u2019hora de ser recorreguts. Els arrays multidimensionals m\u00e9s comuns s\u00f3n els de dues dimensions o bidimensionals, tamb\u00e9 coneguts com matrius. \u00c9s com\u00fa representar aquest tipus de dades com una taula composta per una s\u00e8rie de files i columnes: 0,0 0,1 0,2 0,3 ... 0,N 1,0 1,1 1,2 1,3 ... 1,N 2,0 2,1 2,2 2,3 ... 2,N ... ... ... ... ... ... N,0 N,1 N,2 N,3 ... N,N Al contrari del que passava amb els arrays d\u2019una sola dimensi\u00f3 on nom\u00e9s necessitavem un \u00edndex per accedir al valor, en els arrays de dues dimensions com el de l\u2019exemple anterior, necessitarem dos \u00edndex per accedir al valor de l\u2019array. Les matrius, com es coneixen els arrays bidimensionals es forme per files i columnes. DECLARACI\u00d3 I CREACI\u00d3 Per tal de declarar una matriu en java, \u00e9s a dir, un array de dues dimensions, ho farem de la seg\u00fcent forma:\u00c7 tipusBase matriu [][]; Si es fixeu, mentre quan declaravem un array d\u2019una sola dimensi\u00f3 utilitzavem nom\u00e9s un parell de claud\u00e0tors: tipusBase array[]; Ara que volem crear una matriu (array de dues dimensions) utilitzarem dos parells de claud\u00e0tors. \u00c9s f\u00e0cil deduir que si vulguerem declarar un array de tres dimensions, hauriem d\u2019utilitzar tres parells de claud\u00e0tors. Amb aquesta instrucci\u00f3 el que estem fent es declarar la matriu per\u00f2 no li hem dit quina grand\u00e0ria tindr\u00e0. Eixa \u00e9s la difer\u00e8ncia entre declaraci\u00f3 i creaci\u00f3. Per tal de crear, \u00e9s a dir, reservar espai per a la nostra matriu, hem de fer el seg\u00fcent: matriu = new tipusBase[n][m]; On n i m s\u00f3n valors enters que ens indiquen la grand\u00e0ria de cada dimensi\u00f3. Per exemple, per declarar i crear una matriu d\u2019enters de 5 files i 10 columnes fariem el seg\u00fcent: int matriuEnters [][]; matriuEnters = new int [5][10]; // Tamb\u00e9 ho podriem fer en una sola instrucci\u00f3 int matriuEnters[][] = new int [5][10]; INICIALITZACI\u00d3 I ACC\u00c9S El proc\u00e9s d\u2019inicialitzaci\u00f3 d\u2019un vector, dona igual les dimensions que tinga, consisteix en donar-li valor a les cel\u00b7les que inicialment estan buides. Aquesta inicialitzaci\u00f3 es pot fer de tres formes diferents: - De forma individual. - En el moment de la declaraci\u00f3. - Mitjan\u00e7ant l\u2019\u00fas d\u2019una sent\u00e8ncia de control repetitiva. INICIALITZACI\u00d3 I ACC\u00c9S A CADA ELEMENT DE L\u2019ARRAY Per accedir a una dada en un array multimensional hem de coneixer els \u00edndex de posici\u00f3 d\u2019aquest. En un array de dues dimensions, per accedir a una dada s\u2019ha d\u2019indicar la fila i la columna d\u2019on es troba aquesta informaci\u00f3. Per exemple, imaginem que tenim la seg\u00fcent taula (array de dos dimensions) 12 13 5 9 22 14 21 11 8 56 23 7 6 10 32 36 24 99 78 55 57 79 18 14 Per tal d\u2019inicialitzar-la element a element hauriem d\u2019executar les seg\u00fcents sent\u00e8ncies: for (int i = 0; i < FILES; i ) { for (int j=0; j< COLUMNES; j++ ) { array [i][j] = 0; } } Per tal d\u2019entendre el concepte de matriu o array bidimensional, realitzarem un exercici on treballarem amb les t\u00edpiques matrius matem\u00e0tiques, realitzant les operacions pr\u00f2pies d\u2019aquestes. Activitat 15 Es tracta de desenvolupar una aplicaci\u00f3 que realitze operacions utilitzant matrius de 3x3. El men\u00fa ha de mostrar el seg\u00fcent: 1. Emplena la primera matriu 2. Emplena la segona matriu 3. Visualitza les matrius 4. Suma les matrius 5. Multiplica per un escalar 6. Producte de matrius 7. Transposta 8. Eixir Per a cadascuna de les operacions anteriors s\u2019ha d\u2019implementar un m\u00e8tode Mireu el seg\u00fcent exemple: Activitat 16 Imagina que has de mantindre les notes dels alumnes de tres assignatures. A cada assignatura tens 15 alumnes, tal que s\u2019ha de mantenir la informaci\u00f3 mitjan\u00e7ant una variable que gr\u00e0ficament presenta la seg\u00fcent estructura Assignatura 1 5 6 7,3 2,3 4,5 Assignatura 2 7,8 8,7 7,7 3,3 4,8 Assignatura 3 7 9 10 8,2 2,8 Crea una aplicaci\u00f3 en la que pugues: 1. Inserir notes de l\u2019assignatura sel\u00b7leccionada. 2. Inserir totes les notes 3. Calcular la nota mitjana de l\u2019assignatura sel\u00b7leccionada. 4. Ordenar les assignatures de forma ascendent. 5. Estad\u00edstica 6. Eixir de l\u2019aplicaci\u00f3. L\u2019opci\u00f3 estad\u00edstica mostra la quantitat de notes entre 0 i 3, entre 3,1 i 5, entre 5,1 i 7, entre 7.1 i 9 i entre 9,1 i 10. ARRAYS IRREGULARS Una matriu irregular o escalonada no \u00e9s m\u00e9s que un array de taules, on cadascuna de les taules que formen l\u2019array no necess\u00e0riament han de tenir la mateixa grand\u00e0ria. La declaraci\u00f3 d\u2019un array irregular en java seria de la seg\u00fcent manera: // Declaraci\u00f3 d\u2019una matriu (files) int [][] mat; // Primer creem la quantitat de files deixant les columnes buit mat=new int[3][]; // Despr\u00e9s creem cada fila indicant la quantitat d\u2019elements mat[0]=new int[5]; mat[1]=new int[3]; mat[2]=new int[2]; CADENES DE CARACTERS En Java hem vist que quan volem emmagatzemar un valor enter, definim una variable de tipus int, si pel contrari, el que volem \u00e9s emmagatzemar un valor amb decimals, definim una variable de tipus double o float. Ara b\u00e9, si el que volem \u00e9s emmagatzemar una cadena de caracters, per exemple el nom d\u2019una pesona, hem de definir un objecte de tipus String // Crear un objecte string String strNom = \u00abManolo el del bombo\u00bb; Aquest codi el que fa \u00e9s crear un objectes string strNom que cont\u00e9 el nom: \u00abManolo el del bombo\u00bb. Tamb\u00e9 podriem crear un string de la seg\u00fcent manera: String strNome = new String(\u00abManolo el del bombo\u00bb); Al tractar-se d\u2019una classe, la forma natural de treballar amb ella ser\u00e0 mitjan\u00e7ant l\u2019\u00fas dels m\u00e8todes que disposa la classe. Aquests m\u00e8todes s\u00f3n: int length(): retorna la llarg\u00e0ria de la cadena en un enter. char charAt (int i): ens diu quin caracter est\u00e0 a la posici\u00f3 \u2018i\u2019 String substring(int i): ens retorna la subcadena que hi ha a partir de la posici\u00f3 \u2018i\u2019 fins el final de la cadena String substring(int i, int j): ens retorna la subcadena que es troba des de l\u2019\u00edndex i fins el j String concat(String str): concadena la cadena \u2018str\u2019 que es passa com a par\u00e0metre al final de la cadena. Per exemple: tring s1 = \u00abJava\u00bb; String s2 = \u00abPego\u00bb; String s3 = s1.concat(s2); // El resultat seria \u00abJavaPego\u00bb int indexOf(String s): Ens retorna l\u2019index dins de la cadena de la primera aparici\u00f3 de la subcadena s. Per exemple: String s1 = \u00abJava a Pego\u00bb; int pos = s1.indexOf(\u00abPego\u00bb); // Retorna 7 int indexOf(String s, int i): retorna l\u2019\u00edndex dins de la cadena de la primera aparici\u00f3 de la subcadena s a partir de l\u2019\u00edndex i int lastIndexOf(int ch): torna l\u2019\u00edndex de l\u2019\u00faltima vegada que apareix el caracter \u2018ch\u2019 dins de la cadena. boolean equals(Sring str): Compara l\u2019string amb l\u2019objecte que es passa per par\u00e0metre. boolean equalsIgnoreCase (String otroString): Compara dues cadenes sense tenir en compte maj\u00fascules i min\u00fascules. int compareTo (String otroString): compara dues cadenes lexicogr\u00e0ficament. En altres paraules, diu quina \u00e9s major que l\u2019altra. int compareToIgnoreCase (String otroString): com el m\u00e8tode anterior per\u00f2 sense tenir en compte maj\u00fascules ni min\u00fascules. String toLowerCase(): converteix la cadena a min\u00fascules. String toUpperCase(): converteix la cadena a maj\u00fascules. String trim(): suprimeix els espais en blanc que puguen haver als extremps de la cadena String replace (char oldChar, char newChar): substitueix totes les ocurr\u00e8ncies de oldChar que hi ha a la cadena per newChar ENUMERACIONS Una enumeraci\u00f3 \u00e9s un tipus especial de \u2018classe\u2019 que representa un grup de constants. Cada element d\u2019aquesta estructura est\u00e0 associada a un valor de un tipus de dades concret (normalment enter) on el primer element de l\u2019enumeraci\u00f3 sol agafar el valor 0 // Exemple 1. Dies de la setmana enum Dies { Dilluns, Dimarts, Dimecres, Dijous, Divendres, Dissabte, Diumenge } // Exemple 2. Talles de roba enum Talles { XXL, XL, L, M, S, XS }","title":"Tema 5. Tipus Compostos de Dades"},{"location":"Tema%205.%20Tipus%20compostos%20de%20dades/#tema-5-tipus-compostos-de-dades","text":"","title":"Tema 5. Tipus Compostos de Dades"},{"location":"Tema%205.%20Tipus%20compostos%20de%20dades/#introduccio","text":"Fins ara hav\u00edem treballat amb tipus de dades simples: int, char, double, float, bool... per\u00f2 que passa si necessitarem guardar informaci\u00f3 relativa a una persona? Nom, cognoms, DNI, adre\u00e7a postal, data de naixement etc.. Amb els tipus de dades simples ens seria impossible representar aquesta informaci\u00f3. Es per aix\u00f2 que s\u2019utilitzen els tipus de dades compostos que ens permetran agrupar de diverses maneres aquesta informaci\u00f3. En aquest tema veurem: arrays, cadenes de car\u00e0cters, estructures i enumeracions. Per tal de fer les activitats d\u2019aquest tema es necessitar\u00e0 de la implementaci\u00f3 d\u2019una classe a la que anomenarem TAD que tindr\u00e0 les seg\u00fcents caracter\u00edstiques: - Classe p\u00fablica - Membres de la classe: arrayN\u00fameros i arrayCaracters - M\u00e8todes de la classe: recercaBinaria, recercaSequencial, ordenarInserci\u00f3, ordenarBombolla, ordenarShell, ordernarQuickSort De moment amb a\u00e7\u00f2 ser\u00e0 suficient, en apartats posteriors anirem afegint m\u00e9s membres i m\u00e8todes quan ho necessitem.","title":"Introducci\u00f3"},{"location":"Tema%205.%20Tipus%20compostos%20de%20dades/#activitat-1","text":"Crea la classe \u2018TAD\u2019 amb l\u2019IDE que sols utilitzar basada en les seg\u00fcents especificacions: - Ha de ser una classe p\u00fablica - Ha de tindre m\u00ednim una constant que ens indicar\u00e0 el total d\u2019elements que tindran els arrays, tant el d\u2019enters com el de car\u00e0cters. - Com membres de la classe ha de tindre almenys un array de car\u00e0cters i un d\u2019enters. Han de ser privats o p\u00fablics? - Tamb\u00e9 ha de tenir un m\u00e8tode main static on s\u2019iniciar\u00e0 el programa.","title":"Activitat 1"},{"location":"Tema%205.%20Tipus%20compostos%20de%20dades/#arrays","text":"Un array \u00e9s un tipus de dades compost que permet emmagatzemar un nombre x d\u2019elements del mateix tipus. Amb una \u00fanica declaraci\u00f3 podem tenir acc\u00e9s a un conjunt de valors agrupats. Aquestes agrupacions o arrays poden b\u00e9 ser de tipus simples o tamb\u00e9 de tipus compostos. Per tal d\u2019accedir a cadascun dels elements del array s\u2019utilitza un \u00edndex o posici\u00f3. La primera posici\u00f3 de tot array \u00e9s la 0 mentre que la segona seria la que t\u00e9 \u00edndex 1. A\u00e7\u00f2 pot marejar un poc al principi. Array d\u2019enters: {8,2,14,55,3,7} Array de car\u00e0cters: {\u2018n\u2019,\u2019a\u2019,\u2019t\u2019,\u2019o\u2019} \u00c9s molt important distingir entre valor i posici\u00f3. Mentre que el valor \u00e9s el contingut de l\u2019array en una posici\u00f3 determinada la posici\u00f3 \u00e9s l\u2019\u00edndex que ens permet recorres l\u2019array i tot el seu contingut. A l\u2019exemple anterior tenim un array de 8 enters, la part superior de color blau ens indica les posicions que van de la 0 a la 7, 8 posicions ens total. Mentre que a la fila inferior trobarem el valor que cont\u00e9 cadascuna de les posicions. Per exemple en la posici\u00f3 5 (la sisena) de l\u2019array tindr\u00edem emmagatzemat un valor de 8. Un altre concepte a tenir en compte \u00e9s la dimensi\u00f3 o grand\u00e0ria de l\u2019array que ens determina el total d\u2019elements que es poden guardar en aquest. En el nostre cas la mida seria de 8.","title":"Arrays"},{"location":"Tema%205.%20Tipus%20compostos%20de%20dades/#declaracio-i-creacio-dun-array-en-java","text":"Un array en Java \u00e9s una estructura de dades que ens permet emmagatzemar un conjunt de dades del mateix tipus. El grand\u00e0ria de l\u2019array es determina en la seua declaraci\u00f3 i no es permet la seua modificaci\u00f3 posterior tipusBase nomArray []; nomArray = new tipusBase[grand\u00e0ria]; Alguns exemples: \u00b4\u00b4\u00b4 Java int mes []; mes = new int [30]; char grups []; grups = new char [5]; \u00b4\u00b4\u00b4 Aquesta forme de declarar i inicialitzar arrays es pot fer en una sola l\u00ednia de la seg\u00fcent forma: Java int agendaMensual = new int [30]; ### INICIALITZACI\u00d3 D\u2019UN ARRAY Per tal d\u2019accedir a les dades que cont\u00e9 un array necessitem l\u2019identificador d\u2019aquest aix\u00ed com tamb\u00e9 la posici\u00f3 concreta a la qual volem accedir. Per exemple, imaginem un array d\u2019enters que es diu n\u00fameros. Java int n\u00fameros. = new int [5]; // Declarem un array n\u00fameros. [] = {2,4,6,8,10}; // Inicialitzaci\u00f3 de valors D\u2019aquesta forma haur\u00edem creat un array de 5 enters que contindria els nombres parells fins al 10. ### Activitat 2 En aquest punt aprofitarem per crear un constructor a la nostra classe TAD. Un constructor de classe \u00e9s la funci\u00f3 que s\u2019executa en el moment que s\u2019instancia un objecte i \u00e9s en aquest punt on s\u2019haurien d'inicialitzar aquells elements de la classe que ho necessiten. En el nostre cas els arrays. Inicialitza l\u2019arrayNumeros amb 10 n\u00fameros aleatoris usant la funci\u00f3 rand. Fes el mateix per\u00f2 amb car\u00e0cters amb el nostre arrayCaracters. Recorda que els arrays s\u00f3n membres de la classe. ### ACC\u00c9S ALS ELEMENTS D\u2019UN ARRAY Una vegada ja tenim la declaraci\u00f3 de l\u2019array i la seua inicialitzaci\u00f3, si volem b\u00e9 accedir al seu contingut o modificar-ho, necessitar\u00edem l\u2019identificador de l\u2019array i l\u2019\u00edndex al qual volem accedir. \u00c9s molt important tenir en compte que el primer element d\u2019un array en Java est\u00e0 a la posici\u00f3 (\u00edndex) 0 i no a la posici\u00f3 1 com ens indicaria la l\u00f2gica. int primerNumero = n\u00fameros. [0]; // primerNumero valdria 2 n\u00fameros. [0] = 12; // Canviem el primer numero de l\u2019array","title":"DECLARACI\u00d3 I CREACI\u00d3 D\u2019UN ARRAY EN JAVA"},{"location":"Tema%205.%20Tipus%20compostos%20de%20dades/#arrays-de-caracters","text":"Un array que cont\u00e9 car\u00e0cters en lloc de n\u00fameros funciona d\u2019una forma molt semblant al que s\u2019ha explicat en els apartats anteriors. Es pot veure de forma senzilla a l\u2019exemple que vos mostrem a continuaci\u00f3. char vocals = new char [5]; // Declaraci\u00f3 de l\u2019array vocals [] = {\u2018a\u2019,\u2019e\u2019,\u2019i\u2019,\u2019o\u2019,\u2019u\u2019} // Inicialitzaci\u00f3 vocals [0] = \u2018z\u2019; // Acc\u00e9s als elements de l\u2019array","title":"ARRAYS DE CAR\u00c0CTERS"},{"location":"Tema%205.%20Tipus%20compostos%20de%20dades/#arrays-com-a-parametres","text":"Com qualsevol altre tipus de dades, un array tamb\u00e9 es pot passar com a par\u00e0metre a un m\u00e8tode. Els arrays sempre es passen per refer\u00e8ncia, \u00e9s a dir, quan passem un array per par\u00e0metre a un m\u00e8tode, el que en realitat estem passant \u00e9s un adre\u00e7a de mem\u00f2ria que \u00e9s la que ens indicaria on est\u00e0 l\u2019inici del contingut d\u2019aquest. Passar per refer\u00e8ncia qualsevol par\u00e0metre significa que qualsevol modificaci\u00f3 que es faja dins del m\u00e8tode afectar\u00e0 tamb\u00e9 a l\u2019array fora d\u2019aquest. No passa el mateix si passem un element concret de l\u2019array, en aquest cas a l\u2019igual que amb els altres par\u00e0metres, aquestos es passen per valor, per tant les modificacions o canvis que es produeixquen dins del m\u00e8tode no afectaran fora d\u2019aquest.","title":"ARRAYS COM A PAR\u00c0METRES"},{"location":"Tema%205.%20Tipus%20compostos%20de%20dades/#activitat-3","text":"Fes dos m\u00e8todes per la nostra classe que mostre, de forma amigable, l\u2019array de n\u00fameros i l\u2019array de car\u00e0cters. Els m\u00e8todes es podrien dir mostraEnters i mostraCaracters i seran privats.","title":"Activitat 3"},{"location":"Tema%205.%20Tipus%20compostos%20de%20dades/#activitat-4","text":"En la seg\u00fcent activitat afegirem una funci\u00f3 a la nostra classe en la que ens mostre un men\u00fa de les accions que podem realitzar. Per tal de realitzar aquest men\u00fa afegirem un array d\u2019strings com a nou membre de la classe que inicialitzarem amb les seg\u00fcents opcions: Mostrar array enters Mostrar array caracters Reinicialitzar vectors Recerca seq\u00fcencial Recerca bin\u00e0ria Ordenar amb bombolla Ordenar amb Quicksort Ordenar amb Shell","title":"Activitat 4"},{"location":"Tema%205.%20Tipus%20compostos%20de%20dades/#bucle-for-en-java","text":"Per tal de rec\u00f3rrer arrays podem usar bucles for o while per\u00f2 aquests solen tindre l\u2019inconvenient de que \u00e9s el programador el que ha de controlar quan s\u2019arriba al final de l\u2019array per tal que l\u2019aplicaci\u00f3 no done una errada inesperada i aix\u00f2 de vegades no \u00e9s senzill. La millor forma de rec\u00f3rrer un array sense haver de controlar quan s\u2019arriba al final \u00e9s la sent\u00e8ncia for usada d\u2019una manera alternativa. Si per exemple tenim un array d\u2019enters que s\u2019anomena \u00abvector\u00bb i volem llistar tots els seus elements, podr\u00edem fer el seg\u00fcent: for (int i: vector){ // Accions a realitzar }","title":"BUCLE FOR EN JAVA"},{"location":"Tema%205.%20Tipus%20compostos%20de%20dades/#activitat-5","text":"Fes una funci\u00f3 que mostre per pantalla el men\u00fa per\u00f2 esta vegada utilitzant el for com hem explicat a l\u2019exemple anterior.","title":"Activitat 5"},{"location":"Tema%205.%20Tipus%20compostos%20de%20dades/#algorismes-de-recerca","text":"Existeixen dos algorismes de recerca que veurem en aquest apartat: la recerca seq\u00fcencial i la recerca binaria. A l\u2019element que estem buscant li direm clau.","title":"ALGORISMES DE RECERCA"},{"location":"Tema%205.%20Tipus%20compostos%20de%20dades/#sequencial","text":"Tamb\u00e9 anomenada recerca lineal, es recorren tots els elements de l\u2019array des del principi fins que es troba la clau (element que estem buscant) o fins que s\u2019arriba a l\u2019\u00faltim element de l\u2019array. int sequencial (int [] array, int clau) { for (int i = 0; i < array.length; i ++ ) if (array[i] == clau ) return i; return -1; }","title":"SEQUENCIAL"},{"location":"Tema%205.%20Tipus%20compostos%20de%20dades/#binaria","text":"En aquest algoritme existeix la precondici\u00f3 que l\u2019array o vector sobre el qual vaja a fer-se la recerca, ha d\u2019estar ordenat. Aquest m\u00e8tode \u00e9s m\u00e9s \u00f2ptim. El funcionament d\u2019aquest algorisme \u00e9s el seg\u00fcent: en una primera iteraci\u00f3 es compara la clau (element que estem buscant) amb el valor al centre, que s\u2019anomena pivot, de l\u2019array. Poden passar tres coses: - Que hajam trobat el que busquem, per tant s\u2019acaba la recerca - Que el pivot siga major que la clau. En aquest cas continuar\u00edem buscant a la meitat esquerra del vector desestimant la meitat dreta (pivot incl\u00f2s) - Que el pivot siga menor que la clau. Amb la qual cosa haur\u00edem de buscar a la part esquerra del vector.","title":"BIN\u00c0RIA"},{"location":"Tema%205.%20Tipus%20compostos%20de%20dades/#activitat-6","text":"Afegeix el m\u00e8tode de recerca seq\u00fcencial i el de recerca binaria a la classe TAD. Tamb\u00e9 has d\u2019implementar el codi necessari per tal que quan l\u2019usuari seleccione una de les dues opcions de la nostra aplicaci\u00f3, demane el n\u00famero a buscar i mostre el resultat per pantalla. En cas que es seleccione la recerca bin\u00e0ria, haur\u00edem de comprovar si el vector est\u00e0 ordenat int recercaBinaria (int array[], int clau) { int posCentre, posInici, posFinal, valorCentral; posInici = 0; posFinal = array.length \u2013 1; while (posInici <= posFinal ) { posCentre = (posInici+posFinal)/2; valorCentral=array[posCentre]; if (clau == valorCentral) { return posCentre; } else if (clau < valorCentral) { posFinal = posCentro \u2013 1; } else { posInici = posCentro + 1; } } }","title":"Activitat 6"},{"location":"Tema%205.%20Tipus%20compostos%20de%20dades/#activitat-7","text":"Comparem l\u2019efici\u00e8ncia dels dos algorismes de recerca vistos. Fes una funci\u00f3 a la nostra classe TAD en la que es compten el total de vegades que s\u2019accedeix l\u2019array de n\u00fameros per arribar a trobar la clau. Haur\u00e0s de posar una opci\u00f3 m\u00e9s al men\u00fa, per exemple: \u00abComparar efici\u00e8ncia dels algoritmes\u00bb. Aquesta nova opci\u00f3 haur\u00e0 d\u2019executar varies vegades els dos algorismes de recerca amb vectors de n\u00fameros diferents.","title":"Activitat 7"},{"location":"Tema%205.%20Tipus%20compostos%20de%20dades/#algorismes-dordenacio","text":"Els algorismes d\u2019ordenaci\u00f3 permeten ordenar un array en funci\u00f3 d\u2019un criteri establert al propi algorisme. Hi han diferents tipus d\u2019algorismes d\u2019ordenaci\u00f3: selecci\u00f3, inserci\u00f3, bombolla, Shell i Quicksort.","title":"ALGORISMES D'ORDENACI\u00d3"},{"location":"Tema%205.%20Tipus%20compostos%20de%20dades/#selleccio","text":"El procediment d\u2019ordenaci\u00f3 per inserci\u00f3 \u00e9s el seg\u00fcent: 1. Busquem l\u2019element m\u00e9s menut de l\u2019array i el col\u00b7loquem a la posici\u00f3 0 intercanviant els dos elements 2. A partir de la posici\u00f3 1 busquem l\u2019element m\u00e9s menut seg\u00fcent i fem el mateix que al pas anterior per\u00f2 aquesta vegada a la posici\u00f3 1 de l\u2019array 3. Repetim el pas 2 fins arribar a l\u2019\u00faltima posici\u00f3 de l\u2019array.","title":"SEL\u00b7LECCI\u00d3"},{"location":"Tema%205.%20Tipus%20compostos%20de%20dades/#activitat-8","text":"Implementa l\u2019algorisme d\u2019ordenaci\u00f3 per selecci\u00f3 a la classe TAD i vicula-la a l\u2019opci\u00f3 del men\u00fa corresponent.","title":"Activitat 8"},{"location":"Tema%205.%20Tipus%20compostos%20de%20dades/#insercio","text":"Aquest algorisme consisteix en generar un nou array a partir del que ja es t\u00e9, tal que cada nou element inserit es posa a la seua posici\u00f3 correcta. Imaginem que tenim el seg\u00fcent array d\u2019enters per ordenar: {12, 5, 3, 13, 2, 9, 7} Generem un nou array amb el primer element de l\u2019array a ordenar { 12 } El seg\u00fcent valor de l\u2019array original \u00e9s 5. \u00c9s major o menor que el que ja est\u00e0 inserit? Com que la resposta \u00e9s menor, aquest s\u2019haur\u00e0 d\u2019inserir abans quedant de la seg\u00fcent forma: { 5 , 12} El nou array es genera ja ordenat. El seg\u00fcent valor de l\u2019array desordenat \u00e9s 3. On l\u2019haurem de col\u00b7locar? Just abans del 5 quedant aix\u00ed: { 3 , 5, 12} Repetim la mateixa operaci\u00f3 per cada element de l\u2019array original: {3, 5, 12, 13 } { 2 , 3, 5, 12, 13} {2, 3, 5, 9 , 12, 13} {2, 3, 5, 7 , 9, 12, 13} void insercio ( int [] array ) { int i, j, aux; for (i=1; i < array.legnth; i++ ) { j = i; aux = array [i]; while ( j > 0 && aux < array[j-1]) { array [j] = array [j-1]; j--; } } array[j] = aux; } ### Activitat 9 Implementa l\u2019algorisme d\u2019ordenaci\u00f3 per inserci\u00f3 a la classe TAD i vincula-la a l\u2019opci\u00f3 del men\u00fa corresponent. ## BOMBOLLA L\u2019algorisme d\u2019ordenaci\u00f3 per bombolla \u00e9s el m\u00e9s conegut i tamb\u00e9 el menys eficient, ja que a cada passada per ordenar un element compara cadascun d\u2019ells amb el seu adjacent de forma que si les seues posicions s\u00f3n incorrectes, s\u2019intercanvien. Al finalitzar cada passada l\u2019element m\u00e9s gran es va posant al final de la llista Donat el seg\u00fcent array: {12, 5, 3, 13, 2, 9, 7} Pas 1. Comparem les posicions 0 i 1, \u00e9s a dir, 12 i 5 i com que estan desordenats (el primer \u00e9s major que el segon), s\u2019intercanvien. {5, 12, 3, 13, 2, 9, 7} Pas 2. A continuaci\u00f3 comparem les posicions 1 i 2 de l\u2019array, que s\u00f3n 12 i 3. Com que tamb\u00e9 estan desordenades, les intercanviem {5, 3, 12, 13, 2, 9, 7} Pas 3. Ara anem a comparar les posicions 2 i 3 que contenen els valors 12 i 13 respectivament. Com que estan ben ordenades no es realitza cap acci\u00f3: Pas 4. Posicions 3 i 4 que s\u00f3n 13 i 2. Les intercanviem. {5, 3, 12, 2, 13, 9, 7} Pas 5. Posicions 4 i 5 que tamb\u00e9 estan desordenades per tant executem l\u2019intercanviem {5, 3, 12, 2, 9, 13, 7} Pas 6. Comparem posicions 5 i 6 que tenen els valors 13 i 7 i s\u2019han d\u2019intercanviar {5, 3, 13, 2, 9, 7, 13} Una vegada finalitzada la primera passada hem aconseguit que l\u2019element major de l\u2019array estiga posicionat a l\u2019\u00faltima posici\u00f3. A la seg\u00fcent passada recorrerem l\u2019array fins la posici\u00f3 anterior a on es troba ara el n\u00famero 13, \u00e9s a dir la posici\u00f3 5 i aquest procediment es repeteix fins arribar a la posici\u00f3 0 Finalment el codi quedaria aix\u00ed: void bombolla ( int [] arrayNumeros) { for (int i = 0; i < arrayNumeros.length-1; i++) { for(int j = i + 1; j < arrayNumeros.length; j++) { if (arrayNumeros[i] > arrayNumeros[j]) { int canvi = arrayNumeros[i]; arrayNumeros[i] = arrayNumeros[j]; arrayNumeros[j] = canvi; } } } }","title":"INSERCI\u00d3"},{"location":"Tema%205.%20Tipus%20compostos%20de%20dades/#activitat-10","text":"Implementa l\u2019algorisme d\u2019ordenaci\u00f3 per bombolla a la classe TAD i vincula-la a l\u2019opci\u00f3 del men\u00fa corresponent.","title":"Activitat 10"},{"location":"Tema%205.%20Tipus%20compostos%20de%20dades/#shell","text":"L\u2019algorisme Shell \u00e9s una millora de l\u2019algorisme d\u2019inserci\u00f3 directa. Compara elements separats per un espai de v\u00e0ries posicions el que permet que un element faja passos m\u00e9s grans fins trobar la seua posici\u00f3 esperada. Els passos m\u00faltiples sobre els elements de l\u2019array es fan amb espais de posicions cada vegada m\u00e9s menuts. L\u2019\u00faltim pas de l\u2019algorisme Shell \u00e9s una simple ordenaci\u00f3 per inserci\u00f3 per\u00f2 arribats a aquest punt es pot garantir que l\u2019array esta ja quasi ordenat, el que fa que l\u2019ordenaci\u00f3 per inserci\u00f3 siga molt eficient. Vegem com actuaria aquest algorisme aplicat sobre l\u2019array que estem utilitzant com exemple: {12, 5, 3, 13, 2, 9, 7}. Aquest array t\u00e9 un total de 7 elements (n=7). Creem n/2 grups, separats n/2 n\u00fameros entre ells. n/2=7/2=3, \u00e9s a dir, el nostre interval per crear grups val 3 Marquem en negreta els valors de la primera subllista. {12, 5, 3, 13, 2, 9, 7} Donats els elements 12, 13 i 7 els hem d\u2019ordenar correctament {7, 5, 3, 12, 2, 9, 13} Continuem formant grups de 3 a partir del segon valor de l\u2019array {7, 5, 3, 12, 2, 9, 13} Ordenem els n\u00fameros en cas de no estar-ho, quedant l\u2019array aix\u00ed: {7, 2, 3, 12, 5, 9, 13} Passem a l\u2019element 3 de l\u2019array i apliquem el mateix procediment. {7, 2, 3, 12, 5, 9, 13} Els valors ja estan ordenats en aquest cas, per tant no hem de fer res. {7, 2, 3, 12, 5, 9, 13} No podem m\u00e9s grups ja que hem arribat al final del vector. Ara el que hem de fer \u00e9s tornar a dividir el nostre interval entre 2. El nou interval \u00e9s 3/2 = 1. void shellSort ( int [] array) { int interval, i, j, k, temp; interval = array.length / 2; while ( interval > 0 ) { for (i=interval; i<n; i++) { j=i-interval; while(j>=0) { k=j+interval; if(array[j] <= array[k] j = -1; else { temp = array[j]; array[j] = array[k]; array[k] = temp; j -= interval; } } } interval = interval / 2; } }","title":"SHELL"},{"location":"Tema%205.%20Tipus%20compostos%20de%20dades/#activitat-11","text":"Implementa l\u2019algorisme d\u2019ordenaci\u00f3 shell a la classe TAD i vincula-la a l\u2019opci\u00f3 del men\u00fa corresponent.","title":"Activitat 11"},{"location":"Tema%205.%20Tipus%20compostos%20de%20dades/#quicksort","text":"Aquest \u00e9s un dels algorismes d\u2019ordenaci\u00f3 m\u00e9s r\u00e0pids i eficients. Utilitza la t\u00e8cnica \u00abdivideix i vencer\u00e0s\u00bb de tal forma que divideix l\u2019array a ordenar en parts que ordenar\u00e0 al mateix temps. B\u00e0sicament es tria l\u2019element de l\u2019array com a pivot tal que es forme dos subArrays, en un d\u2019ells s\u2019emmagatzemen els elements menors que l\u2019element que hem triat com a pivot i a l\u2019altre array es guarden els element majors que el pivot. Una vegada fet, s\u2019aplica el mateix procediment als subarrays obtinguts. Seguint amb el mateix array dels exemples anteriors, aplicarem l\u2019algorisme d\u2019ordenaci\u00f3 quicksort. {12, 5, 3, 13, 2, 9, 7} Triem un valor que fara el paper de pivot, per exmple el primer element de l\u2019array, el 12 i a partir d\u2019aquest creem dos arrays, un amb els n\u00fameros menors que el pivot i l\u2019altre amb els n\u00fameros majors que el pivot: pivot: {12}; menors: {5, 3, 2, 9, 7}; majors {13} El subarray de majors ja est\u00e0 ordenada ja que nom\u00e9s t\u00e9 un n\u00famero. Ara ordenem el subarray de menors: {5, 3, 2, 9, 7} per la qual cosa escollim com a pivot el primer element de l\u2019array, \u00e9s a dir, el 5. pivot: {5}; menors {3, 2}; majors: {9, 7}. Seguim dividint en subarrays, Una vegada els subarrays estan ordenats sempre sempre s\u2019ensamblaran col\u00b7locant subarrays de menors, seguides de pivot i subarrays de majors void Quicksort ( int [] array, int primer, int ultim) { int i, j, central, pivot, tmp; central = (primer + ultim)/2; pivot = array[central]; i = primer; j = ultim; do { while (array[i] < pivot) i ++; while (array[j] > pivot) j --; if (i <= j) { tmp = array[i]; array[i] = array[j]; array[j] = tmp; i ++; j \u2013-; } } while (i<=j); if (primer < j) Quicksort (array, primer, j); if ( i < ultim ) Quicksort (array, i, ultim); }","title":"QUICKSORT"},{"location":"Tema%205.%20Tipus%20compostos%20de%20dades/#activitat-12","text":"Implementa l\u2019algorisme d\u2019ordenaci\u00f3 quicksort a la classe TAD i vincula-la a l\u2019opci\u00f3 del men\u00fa corresponent.","title":"Activitat 12"},{"location":"Tema%205.%20Tipus%20compostos%20de%20dades/#activitat-13","text":"Fes que en cada algorisme d\u2019ordenaci\u00f3 es mostre una tra\u00e7a on a cada passada de l\u2019algoritme, \u00e9s a dir, cada vegada que mou un element a l\u2019array, mostre aquest per pantalla.","title":"Activitat 13"},{"location":"Tema%205.%20Tipus%20compostos%20de%20dades/#activitat-14","text":"Entrega mitjan\u00e7ant la plataforma aules la classe TAD que inclou de les activitats 1 a la 13 amb totes les funcions tant de recerca com d\u2019ordenaci\u00f3 sobre arrays unidimensionals.","title":"Activitat 14"},{"location":"Tema%205.%20Tipus%20compostos%20de%20dades/#arrays-multidimensionals","text":"Fins ara hem estan utilitzant arrays d\u2019una sola dimensi\u00f3, coneguts tamb\u00e9 com vectors, taules o llistes. Aquests arrays es recorren amb ajuda d\u2019un sol \u00edndex (tenen una sola dimensi\u00f3). En aquest apartat estudiarem arrays de m\u00e9s d\u2019una dimensi\u00f3 per als que necessitarem m\u00e9s d\u2019un \u00edndex a l\u2019hora de ser recorreguts. Els arrays multidimensionals m\u00e9s comuns s\u00f3n els de dues dimensions o bidimensionals, tamb\u00e9 coneguts com matrius. \u00c9s com\u00fa representar aquest tipus de dades com una taula composta per una s\u00e8rie de files i columnes: 0,0 0,1 0,2 0,3 ... 0,N 1,0 1,1 1,2 1,3 ... 1,N 2,0 2,1 2,2 2,3 ... 2,N ... ... ... ... ... ... N,0 N,1 N,2 N,3 ... N,N Al contrari del que passava amb els arrays d\u2019una sola dimensi\u00f3 on nom\u00e9s necessitavem un \u00edndex per accedir al valor, en els arrays de dues dimensions com el de l\u2019exemple anterior, necessitarem dos \u00edndex per accedir al valor de l\u2019array. Les matrius, com es coneixen els arrays bidimensionals es forme per files i columnes.","title":"ARRAYS MULTIDIMENSIONALS"},{"location":"Tema%205.%20Tipus%20compostos%20de%20dades/#declaracio-i-creacio","text":"Per tal de declarar una matriu en java, \u00e9s a dir, un array de dues dimensions, ho farem de la seg\u00fcent forma:\u00c7 tipusBase matriu [][]; Si es fixeu, mentre quan declaravem un array d\u2019una sola dimensi\u00f3 utilitzavem nom\u00e9s un parell de claud\u00e0tors: tipusBase array[]; Ara que volem crear una matriu (array de dues dimensions) utilitzarem dos parells de claud\u00e0tors. \u00c9s f\u00e0cil deduir que si vulguerem declarar un array de tres dimensions, hauriem d\u2019utilitzar tres parells de claud\u00e0tors. Amb aquesta instrucci\u00f3 el que estem fent es declarar la matriu per\u00f2 no li hem dit quina grand\u00e0ria tindr\u00e0. Eixa \u00e9s la difer\u00e8ncia entre declaraci\u00f3 i creaci\u00f3. Per tal de crear, \u00e9s a dir, reservar espai per a la nostra matriu, hem de fer el seg\u00fcent: matriu = new tipusBase[n][m]; On n i m s\u00f3n valors enters que ens indiquen la grand\u00e0ria de cada dimensi\u00f3. Per exemple, per declarar i crear una matriu d\u2019enters de 5 files i 10 columnes fariem el seg\u00fcent: int matriuEnters [][]; matriuEnters = new int [5][10]; // Tamb\u00e9 ho podriem fer en una sola instrucci\u00f3 int matriuEnters[][] = new int [5][10];","title":"DECLARACI\u00d3 I CREACI\u00d3"},{"location":"Tema%205.%20Tipus%20compostos%20de%20dades/#inicialitzacio-i-acces","text":"El proc\u00e9s d\u2019inicialitzaci\u00f3 d\u2019un vector, dona igual les dimensions que tinga, consisteix en donar-li valor a les cel\u00b7les que inicialment estan buides. Aquesta inicialitzaci\u00f3 es pot fer de tres formes diferents: - De forma individual. - En el moment de la declaraci\u00f3. - Mitjan\u00e7ant l\u2019\u00fas d\u2019una sent\u00e8ncia de control repetitiva. INICIALITZACI\u00d3 I ACC\u00c9S A CADA ELEMENT DE L\u2019ARRAY Per accedir a una dada en un array multimensional hem de coneixer els \u00edndex de posici\u00f3 d\u2019aquest. En un array de dues dimensions, per accedir a una dada s\u2019ha d\u2019indicar la fila i la columna d\u2019on es troba aquesta informaci\u00f3. Per exemple, imaginem que tenim la seg\u00fcent taula (array de dos dimensions) 12 13 5 9 22 14 21 11 8 56 23 7 6 10 32 36 24 99 78 55 57 79 18 14 Per tal d\u2019inicialitzar-la element a element hauriem d\u2019executar les seg\u00fcents sent\u00e8ncies: for (int i = 0; i < FILES; i ) { for (int j=0; j< COLUMNES; j++ ) { array [i][j] = 0; } } Per tal d\u2019entendre el concepte de matriu o array bidimensional, realitzarem un exercici on treballarem amb les t\u00edpiques matrius matem\u00e0tiques, realitzant les operacions pr\u00f2pies d\u2019aquestes.","title":"INICIALITZACI\u00d3 I ACC\u00c9S"},{"location":"Tema%205.%20Tipus%20compostos%20de%20dades/#activitat-15","text":"Es tracta de desenvolupar una aplicaci\u00f3 que realitze operacions utilitzant matrius de 3x3. El men\u00fa ha de mostrar el seg\u00fcent: 1. Emplena la primera matriu 2. Emplena la segona matriu 3. Visualitza les matrius 4. Suma les matrius 5. Multiplica per un escalar 6. Producte de matrius 7. Transposta 8. Eixir Per a cadascuna de les operacions anteriors s\u2019ha d\u2019implementar un m\u00e8tode Mireu el seg\u00fcent exemple:","title":"Activitat 15"},{"location":"Tema%205.%20Tipus%20compostos%20de%20dades/#activitat-16","text":"Imagina que has de mantindre les notes dels alumnes de tres assignatures. A cada assignatura tens 15 alumnes, tal que s\u2019ha de mantenir la informaci\u00f3 mitjan\u00e7ant una variable que gr\u00e0ficament presenta la seg\u00fcent estructura Assignatura 1 5 6 7,3 2,3 4,5 Assignatura 2 7,8 8,7 7,7 3,3 4,8 Assignatura 3 7 9 10 8,2 2,8 Crea una aplicaci\u00f3 en la que pugues: 1. Inserir notes de l\u2019assignatura sel\u00b7leccionada. 2. Inserir totes les notes 3. Calcular la nota mitjana de l\u2019assignatura sel\u00b7leccionada. 4. Ordenar les assignatures de forma ascendent. 5. Estad\u00edstica 6. Eixir de l\u2019aplicaci\u00f3. L\u2019opci\u00f3 estad\u00edstica mostra la quantitat de notes entre 0 i 3, entre 3,1 i 5, entre 5,1 i 7, entre 7.1 i 9 i entre 9,1 i 10.","title":"Activitat 16"},{"location":"Tema%205.%20Tipus%20compostos%20de%20dades/#arrays-irregulars","text":"Una matriu irregular o escalonada no \u00e9s m\u00e9s que un array de taules, on cadascuna de les taules que formen l\u2019array no necess\u00e0riament han de tenir la mateixa grand\u00e0ria. La declaraci\u00f3 d\u2019un array irregular en java seria de la seg\u00fcent manera: // Declaraci\u00f3 d\u2019una matriu (files) int [][] mat; // Primer creem la quantitat de files deixant les columnes buit mat=new int[3][]; // Despr\u00e9s creem cada fila indicant la quantitat d\u2019elements mat[0]=new int[5]; mat[1]=new int[3]; mat[2]=new int[2];","title":"ARRAYS IRREGULARS"},{"location":"Tema%205.%20Tipus%20compostos%20de%20dades/#cadenes-de-caracters","text":"En Java hem vist que quan volem emmagatzemar un valor enter, definim una variable de tipus int, si pel contrari, el que volem \u00e9s emmagatzemar un valor amb decimals, definim una variable de tipus double o float. Ara b\u00e9, si el que volem \u00e9s emmagatzemar una cadena de caracters, per exemple el nom d\u2019una pesona, hem de definir un objecte de tipus String // Crear un objecte string String strNom = \u00abManolo el del bombo\u00bb; Aquest codi el que fa \u00e9s crear un objectes string strNom que cont\u00e9 el nom: \u00abManolo el del bombo\u00bb. Tamb\u00e9 podriem crear un string de la seg\u00fcent manera: String strNome = new String(\u00abManolo el del bombo\u00bb); Al tractar-se d\u2019una classe, la forma natural de treballar amb ella ser\u00e0 mitjan\u00e7ant l\u2019\u00fas dels m\u00e8todes que disposa la classe. Aquests m\u00e8todes s\u00f3n: int length(): retorna la llarg\u00e0ria de la cadena en un enter. char charAt (int i): ens diu quin caracter est\u00e0 a la posici\u00f3 \u2018i\u2019 String substring(int i): ens retorna la subcadena que hi ha a partir de la posici\u00f3 \u2018i\u2019 fins el final de la cadena String substring(int i, int j): ens retorna la subcadena que es troba des de l\u2019\u00edndex i fins el j String concat(String str): concadena la cadena \u2018str\u2019 que es passa com a par\u00e0metre al final de la cadena. Per exemple: tring s1 = \u00abJava\u00bb; String s2 = \u00abPego\u00bb; String s3 = s1.concat(s2); // El resultat seria \u00abJavaPego\u00bb int indexOf(String s): Ens retorna l\u2019index dins de la cadena de la primera aparici\u00f3 de la subcadena s. Per exemple: String s1 = \u00abJava a Pego\u00bb; int pos = s1.indexOf(\u00abPego\u00bb); // Retorna 7 int indexOf(String s, int i): retorna l\u2019\u00edndex dins de la cadena de la primera aparici\u00f3 de la subcadena s a partir de l\u2019\u00edndex i int lastIndexOf(int ch): torna l\u2019\u00edndex de l\u2019\u00faltima vegada que apareix el caracter \u2018ch\u2019 dins de la cadena. boolean equals(Sring str): Compara l\u2019string amb l\u2019objecte que es passa per par\u00e0metre. boolean equalsIgnoreCase (String otroString): Compara dues cadenes sense tenir en compte maj\u00fascules i min\u00fascules. int compareTo (String otroString): compara dues cadenes lexicogr\u00e0ficament. En altres paraules, diu quina \u00e9s major que l\u2019altra. int compareToIgnoreCase (String otroString): com el m\u00e8tode anterior per\u00f2 sense tenir en compte maj\u00fascules ni min\u00fascules. String toLowerCase(): converteix la cadena a min\u00fascules. String toUpperCase(): converteix la cadena a maj\u00fascules. String trim(): suprimeix els espais en blanc que puguen haver als extremps de la cadena String replace (char oldChar, char newChar): substitueix totes les ocurr\u00e8ncies de oldChar que hi ha a la cadena per newChar","title":"CADENES DE CARACTERS"},{"location":"Tema%205.%20Tipus%20compostos%20de%20dades/#enumeracions","text":"Una enumeraci\u00f3 \u00e9s un tipus especial de \u2018classe\u2019 que representa un grup de constants. Cada element d\u2019aquesta estructura est\u00e0 associada a un valor de un tipus de dades concret (normalment enter) on el primer element de l\u2019enumeraci\u00f3 sol agafar el valor 0 // Exemple 1. Dies de la setmana enum Dies { Dilluns, Dimarts, Dimecres, Dijous, Divendres, Dissabte, Diumenge } // Exemple 2. Talles de roba enum Talles { XXL, XL, L, M, S, XS }","title":"ENUMERACIONS"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/","text":"Tema 9. Gr\u00e0fics. Java Swing Introducci\u00f3 Fins ara hem estat utilitzant la consola i el teclat a les nostres aplicacions per tal de comunicar-nos amb l'usuari. En aquest tema utilitzarem l'API de Java per al desenvolupament de components gr\u00e0fics Swing. Swing \u00e9s un conjunt d'eines per a Java. \u00c9s una API que proporciona interf\u00edcie gr\u00e0fica d'usuari (GUI) per a programes de Java. Entre d'altres Swing cont\u00e9: frames, botons, textbox, men\u00fas a banda dels events associats als elements. Swing va ser desenvolupat per a proporcionar un conjunt m\u00e9s complex de components GUI que l'anterior Abstract Window Toolkit (AWT). Swing proporciona un aspecte i aparen\u00e7a natiu que emula diverses plataformes, tamb\u00e9 d\u00f3na suport a extensions d'aspecte i aparen\u00e7a que permeten a les aplicacions tindre un aspecte i apare\u00e7a que no guarda relaci\u00f3 amb la plataforma subjacent. Hu\u00ed en dia la majoria de desenvolupadors Java utilitzen Swing o JavaFX per construir interf\u00edcies d'usuari La llibreria Swing Com tot en Java, swing no anava a ser menys, est\u00e0 dissenyat com una llibreria de classes, interf\u00edcies, recursos, etc.. per la construcci\u00f3 d'insterf\u00edcies gr\u00e0fiques. Swing cont\u00e9 tres APIs una per a components 2D, una altra per al Drag & Drop i l'\u00faltima per facilitar l'acc\u00e9s. Swing est\u00e0 basada en AWT per\u00f2 \u00e9s independent de la plataforma, \u00e9s a dir, sempre mostra la mateixa aparen\u00e7a independentment del sistema en el que s'execute l'aplicaci\u00f3 a difer\u00e8ncia d'AWT. Amb Swing podem fer: - Marcs: Finestres amb de t\u00edtol, men\u00fa, botons maximitzar, minimitzar i tancar. - Contenidors: poden agrupar diversos controls. - Botons - Etiqutes: text - Camps i arees de text. - Desplegables Per tal de poder utilitzar les llibreries Swing de Java hauriem d'afegir al nostre codi el seg\u00fcent: import javax.swing.*; Components i contenidors En general, els components Swing es deriven de la classe JComponent. Les \u00faniques excepcions s\u00f3n els quatre contenidors de nivell superior. JComponent proporciona la funcionalitat que \u00e9s com\u00fa a tots els components. Per exemple, JComponent admet la look & feel conectables. JComponent hereta les classes AWT Container i Component. Per tant, un component Swing est\u00e0 integrat i es compatible amb un component AWT. Tots els components de Swing estan representats per classes definides dins del paquet javax.swing com hem explicat abans. La seg\u00fcent taula mostra els noms de classe per als components Swing inclosos els contenidors. Components Java Swing JApplet JButton JCheckBox JCheckBoxMenuItem JColorChooser JComboBox JComponent JDesktopPane JDialog JEditorPane JFileChooser JFormattedTextField JFrame JInternalFrame JLabel JLayer JLayeredPane JList JMenu JMenuBar JMenuItem JOptionPane JPanel JPasswordField JPopUpMenu JProgressBar JRadioButton JRadioButtonMenuItem JRootPane JScrollBar JScrollPane JSeparator JSlider JSpineer JSplitPane JTabbedPane JTable JTextArea JTextField JTextPane JTogglebutton JToolBar JToolTip JTree JViewport JWindows La majora de noms solen ser prou significatius i resulta intuitiu a primer cop d'ull saber quina \u00e9s la finalitat de cadascun dels components. Contenidors Java Swing Swing defineix dos tipus de contenidors. Els primers s\u00f3n contenidors de nivell superior: JFrame, JApplet, JWindow i JDialog. (JApplet, que admet applets basats en Swing, ha estat descartat per JDK 9.) Aquests contenidors no hereten JComponent. No obstant aix\u00f2, hereten les classes AWT Component i Container. A difer\u00e8ncia d'altres components de Swing, que s\u00f3n lightweight, els contenidors de nivell superior s\u00f3n heavyweight. Aix\u00f2 fa que els contenidors de nivell superior siguin un cas especial a la biblioteca de components Swing. Com el seu nom indica, un contenidor de nivell superior ha d'estar a la part superior d'una jerarquia de contenci\u00f3. Un contenidor de nivell superior no est\u00e0 contingut en cap altre contenidor. A m\u00e9s, cada jerarquia de contenci\u00f3 ha de comen\u00e7ar amb un contenidor de nivell superior. El m\u00e9s comunament utilitzat per les aplicacions \u00e9s JFrame. El segon tipus de contenidor compatible amb Swing \u00e9s el contenidor lightweight. Els contenidors lightweight hereten JComponent. Exemples de contenidors lightweight s\u00f3n JPanel, JScrollPane i JRootPane. Els contenidors lightweight sovint es fan servir per a organitzar i administrar col\u00b7lectivament grups de components relacionats perqu\u00e8 un contenidor lightweight es pot contenir dins d'un altre contenidor. Per tant, pot utilitzar contenidors lightweight per crear subgrups de controls relacionats que estan continguts dins d'un contenidor extern. Swing vs AWT \u00c9s possible utilitzar Swing i AWT a la mateixa interf\u00edcie, per\u00f2 podria donar problemes. \u00c9s recomanable utilitzar nom\u00e9s components Swing, ja que tot component AWT t\u00e9 el seu equivalent Swing. La majoria de classes Swing comencen per J, per exemple: JButton, JFrame... encara que tamb\u00e9 existeixen Frame i Button que pertanyen a la llibreria AWT. Cal tindre molta cura en no oblidar de posar la 'J' davant dels components ja que si no podria portar a inconsist\u00e8ncies a causa de mesclar components. A l'actualitat quasi tota la programaci\u00f3 gr\u00e0fica en Java es fa amb Swing que implemente una interf\u00edcie gr\u00e0fica normalment va a tenir quatre tipus d'elements: 1. Un contenidor de nivell superior: un marc (JFrame), un applet (JApplet) o b\u00e9 objectes JDialog. Aquests contenidors no estan dins d'una altra finestra, s\u00f3n les finestres principals. 2. Components de la interf\u00edcie gr\u00e0fica: botons, camps de text, etc\u00e8tera, que se situen a la finestra principal o en contenidors. 3. Contenidors dissenyats per altres elements de la interf\u00edcie; JPanel i JScrollPane s\u00f3n dos contenidors i, a el mateix temps, s\u00f3n components. 4. Elements per a la gesti\u00f3 d'esdeveniments. Els components sempre s'afegeixen a una l\u00e0mina o panell; pot ser la de el marc, o b\u00e9 un panell tipus JPanel. En general, sempre es creen classes derivades de les classes contenidors de nivell superior; tot marc ser\u00e0 una subclasse de JFrame, a l'igual que un applet \u00e9s una subclasse de JApplet. Creaci\u00f3 d'un JFrame La difer\u00e8ncia entre crear programes que es comuniquen amb l'usuari mitjan\u00e7ant el terminal i el teclat i fer programes amb Swing \u00e9s considerable. Al crear una aplicaci\u00f3 Swing s'han de tenir en compte conceptes nous com el threading . Per\u00f2 per entendre-ho tot millor, farem un programa Swing d'exemple. Per al programa d'exemple crearem un JFrame al qual li posarem una JLabel Exemple 1. Programa simple Swing // Un simple programa Swing import javax.swing.*; public class SwingDemo { SwingDemo(){ JFrame jfrm=new JFrame(\"Aplicaci\u00f3 Simple Swing\"); // Crea un nou contenidor JFrame. jfrm.setSize(475,200); // Establim el tamany inicial jfrm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // Acabe el programa quan l'usuari tanque l'aplicaci\u00f3. JLabel jLabel= new JLabel(\"Programaci\u00f3 GUI amb Swing.\"); // Creem una etiqueta jLabel.setHorizontalAlignment(SwingConstants.CENTER); // Situem l'etiqueta al centre del frame jfrm.add(jLabel); // Afegim l'etiqueta al frame jfrm.setVisible(true); // Visualitzem el marc. } public static void main(String[] args) { SwingUtilities.invokeLater(new Runnable() { public void run(){ new SwingDemo(); } }); } } El resultat del codi anterior seria el seg\u00fcent: JFrame \u00e9s un contenidor de nivell superior que s'utilitza de forma com\u00fa a les aplicacions Swing, mentre que JLabel \u00e9s una etiqueta que ens servir\u00e0 per posar text. Expliquem amb m\u00e9s detall el que fa la funci\u00f3 main: - SwingUtilities.invokeLater() - static void invokeLater(Runnable doRun): Executa un doRun.run() per tal que s'execute de forma asincrona al AWT event dispatching thread. A aquets m\u00e8tode se li ha de passar un objecte Runnable - new Runnable() { }: - Objecte Runnable que s'ha de passar al m\u00e8tode invokeLater - public void run() { }: M\u00e8tode run que s'executa de l'objecte runnable que se li passa a InvokeLater - new SwingDemo() - Codi del m\u00e8tode run de l'objecte runnable. Una aplicaci\u00f3 que implemente una interf\u00edcie gr\u00e0fica normalment va a tindre quatre tipus d'elements. 1. Un contenidor de nivell superior: un marc (JFrame), un applet (JApplet) o b\u00e9 di\u00e0legs (JDialog) que faran el paper de finestra principal. 2. Components de la interf\u00edcie gr\u00e0fica: botons, camps de text, etc, que s'afegiran al contenidor de nivell superior anterior. 3. Contenidors dissenyats per altres elements de la interf\u00edcie: JPanel i JScrollPane s\u00f3n dos contenidors i al mateix temps s\u00f3n components. 4. Elements per la gesti\u00f3 d'events. Els components sempre s'afegeixen a una l\u00e0mina o paper; pot ser la del marc o b\u00e9 un panel tipus JPanel. En general, sempre es creen classes derivades de les classes contenidores de nivell superior. Tot marc ser\u00e0 una subclasse de JFrame, de la mateixa forma que un applet \u00e9s una subclasse de JApplet JFrame La classe JFrame \u00e9s un tipus de contenidor que hereta de la classe java.awt.Frame. JFrame funciona com la finestra principal on components com etiquetes, botons, camps de text etc, s'afegeixen per crear una interf\u00edcie gr\u00e0fica. M\u00e8todes M\u00e8tode Descripci\u00f3 JFrame() Constructor de la classe. Crea un marca sense t\u00edtol JFrame (String titol) Crea un marc amb t\u00edtol. void setTitle (String titlo) Estableix el t\u00edtol del marc void setIconImage ( Image img ) Estableix la icona del marc void setDefaultCloseOperation (int op ) programa el comportament del marca quan es tanca. Possibles valors: EXIT_ON_CLOSE, DO_NOTHING_ON_CLOSE, DISPOSE_ON_CLOSE, HIDE_ON_CLOSE Container getContentPane () proporciona el layout de continguts del marc, \u00e9s a dir, les vores void setResizable ( boolean r ) si r val true, es pot redimensionar el marc void add (Component c) Afegeix el component c al marc void removeComponent (Component c) elimina el component c del marc Component add (Component c, int p) Coloca el component c a la posici\u00f3 p del marc void setLayout (LayoutManager mngr) estableix la forma de distribuir el components al marc, els quals normalment es distribueixen en posicions relatives, segons el layout que tinga associat el marc void setVisible (boolean b) fa visible el component si b \u00e9s true void setBounds (int x, int y, int ample, int alt) situa el component i canvia el seu tamany void setLocation (int x, int y) situa el component a les coordenades x i y void setLocation (Point p) situa el component al punt p void setSize (int ample, int alt) estableix les dimensions del component void setSize (Dimension dim) estableix la dimensi\u00f3 del component a dim Layout Manager - Gestor de posicionament A difer\u00e8ncia d'altres aplicacions que es dediquen al disseny d'interf\u00edcies gr\u00e0fiques, les posicions dels elements dintre del nostre contenidor no es fan en pixels ni valors absoluts, s'utilitzen els Layout Manager que ho podriem traduir com \"gestors de disposici\u00f3\" o \"gestor de plantilla\" o \"gestor de posicionament\". Aquestos gestors de posicionament s\u00f3n elements que implementen la interf\u00edcie \"LayoutManager\". Cada cotenidor t\u00e9 associat un Layout Manager que pot ser: BorderLayout, FlowLayout, GridLayout, BoxLayout, GridBagLayout, CardLayout, SpringLayout... Veiem un exemple: Exemple 2. Marc de prova JFrame marc = new JFrame(\"MarcProva\"); marco.setLayout(new GridLayout(3,4)); El que hem fet al codi anterior \u00e9s crear i instanciar un nou marc de tipus JFrame amb el t\u00edtol \"MarcProva\" i despr\u00e9s hem establert el seu gestor de posicionament de tipus GridLayout. A continuaci\u00f3 detallarem els m\u00e9s utilitzats BorderLayout Gestor de posicionament per defecte dels marcs (JFrame) i di\u00e0legs (JDialog). Divideix al contenidor en cinc zones: nord, sud, est, oest i centre, que es corresponen a: BorderLayout.NORTH, BorderLayout.SOUTH, BorderLayout.EAST, BorderLayout.WEST i BorderLayout.CENTER Veiem un exemple: Exemple 3. Marc amb vora import javax.swing.*; import java.awt.*; public class MarcBorder extends JFrame { static int AMPLE =350; static int ALT = 200; public MarcBorder() { super(\"T\u00edtol Marc\"); add(new JLabel(\"Nord\", SwingConstants.CENTER), BorderLayout.NORTH); add(new JLabel(\"Sud\", SwingConstants.CENTER), BorderLayout.SOUTH); add(new JLabel(\"Centre\", SwingConstants.CENTER), BorderLayout.CENTER); add(new JLabel(\"Oest\", SwingConstants.CENTER), BorderLayout.WEST); add(new JLabel(\"Est\", SwingConstants.CENTER), BorderLayout.EAST); setSize(AMPLE,ALT); setVisible(true); } public static void main(String args[]) { MarcBorder marc = new MarcBorder(); marc.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } El resultat del codi anterior \u00e9s: FlowLayout Amb aquest gestor podem colocar els elements d'esquerra cap a dreta i de dalt cap avall. La classe FlowLayout disposa de diversos constructors, un d'ells ens permet establir l'alineaci\u00f3 dels components FlowLayout(int align) on align pot ser: FlowLayout.RIGHT, FlowLayout.CENTER, FlowLayout.LEFT. Exemple 4. Flowlayout import java.awt.*; import javax.swing.*; public class MarcFlow extends JFrame { static int AMPLE =175; static int ALT = 100; public MarcFlow() { super(\"El meu marc\"); setLayout(new FlowLayout()); add( new JLabel(\"Primera\")); add(new JLabel(\"Segona\")); add(new JLabel(\"Tercera\")); add(new JLabel(\"Quarta\")); add(new JLabel(\"Cinquena\")); add(new JLabel(\"Sisena\")); setSize(AMPLE,ALT); setVisible(true); } public static void main(String args[]) { MarcFlow marc = new MarcFlow(); marc.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } I aquest \u00e9s el resultat: GridLayout Aquest gestor de posicionament distribueix els components del container associat en forma de graella de cel\u00b7les iguals en forma de quadricula de dalt cap avall i de esquerra a dreta, \u00e9s a dir, en files i columnes. Exemple 5. GridLayout import java.awt.*; import javax.swing.*; public class MarcGrid extends JFrame { static int AMPLE =175; static int ALT = 100; public MarcGrid() { super(\"El meu marc\"); setLayout(new GridLayout(3,2,15,15)); add(new JLabel(\"Primera\")); add(new JLabel(\"Segona\")); add(new JLabel(\"Tercera\")); add(new JLabel(\"Quarta\")); add(new JLabel(\"Cinquena\")); add(new JLabel(\"Sisena\")); setSize(AMPLE,ALT); setVisible(true); } public static void main(String args[]) { MarcGrid marc = new MarcGrid(); marc.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } Resultat del codi anterior: BoxLayout Aquest gestor coloca els components en una \u00fanica fila o una \u00fanica columna, s'assembla a una caixa amb orientaci\u00f3 horitzontal o vertical; el constructor necessita un argument amb el contenidor que es va a utilitzar i l'orientaci\u00f3 que pot ser: BoxLayout.X_AXIS o BoxLayout.Y_AXIS. El format del constructor \u00e9s: BoxLayout (Container desti, int orientacio) Exemple 6. BoxLayout import javax.swing.*; import java.awt.*; public class MarcBox extends JFrame { static int AMPLE =175; static int ALT = 150; public MarcBox() { super(\"El meu marcBox\"); JPanel panel = new JPanel() ; panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS)); panel.add(new JLabel(\"Primera\")); panel.add(new JLabel(\"Segona\")); panel.add(new JLabel(\"Tercera\")); panel.add(new JLabel(\"Quarta\")); panel.add(new JLabel(\"Cinquena\")); panel.add(new JLabel(\"Sisena\")); add(panel); setSize(AMPLE,ALT); setVisible(true); } public static void main(String args[]) { MarcBox miMarcBox = new MarcBox(); miMarcBox.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } BoxLayout - Box Box o caixa, \u00e9s un contenidor que t\u00e9 com gestor de posicionament (LayoutManager) predeterminat un BoxLayout; utilitzant aquest contenidor no cal crear un panel perqu\u00e8 directament es crea un objecte Box i a continuaci\u00f3 s'afegeixen els components. La classe Box disposa de dos m\u00e8todes static (m\u00e8todes factoria) que creen l'objecte, i s\u00f3n: Box.createHorizontalBox(); Box.createVerticalBox(); Aleshores, per crear un Box no s'utilitza el constructor sino que es crida a un d'aquestos dos m\u00e8todes; per un objecte Box amb orientaci\u00f3 horitzontal, per exemple: Box caixaHoriz = Box.createHorizontalBox(); Al contenidor se li afegeix el component caixaHoriz.add(element) i despr\u00e9s el contenidor al marc. Exemple 7. BoxLayout - Box import javax.swing.*; import java.awt.*; public class Marc2Box extends JFrame { static int AMPLE =275; static int ALT = 175; public Marc2Box() { super(\"El meu marc\"); JButton b1 = new JButton(\"Boto1\"); JButton b2 = new JButton(\"Boto2\"); JButton b3 = new JButton(\"Boto3\"); JButton b4 = new JButton(\"Boto4\"); JButton b5 = new JButton(\"Boto5\"); JButton b6 = new JButton(\"Boto6\"); Box caixaH = Box.createHorizontalBox(); // m\u00e9todo factor\u00eda caixaH.add(b1); // separaci\u00f3n horizontal de 10 pixeles caixaH.add(Box.createHorizontalStrut(10)); caixaH.add(b2); // zona r\u00edgida, separaci\u00f3n horizontal caixaH.add(Box.createRigidArea(new Dimension(5,5))); caixaH.add(b3); add(caixaH,BorderLayout.NORTH); Box caixaV = Box.createVerticalBox(); caixaV.add(Box.createHorizontalStrut(70)); caixaV.add(b4); // separaci\u00f3n horizontal 10 pixeles caixaV.add(Box.createVerticalStrut(10)); caixaV.add(b5); caixaV.add(Box.createRigidArea(new Dimension(5,5))); caixaV.add(b6); add(caixaV,BorderLayout.CENTER); setSize(AMPLE,ALT); setVisible(true); } public static void main(String args[]) { Marc2Box marcBox2 = new Marc2Box(); marcBox2.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } Combinar Layouts JFrame, JDialog i JPanel nom\u00e9s poden tindre un gestor de posicionament per\u00f2 si agafem un contenidor de primer nivell com un marc, podr\u00edem combinar diversos layouts niats (nested). Al seg\u00fcent exemple podem veure una combinaci\u00f3 de tres gestors de posicionament en un mateix contenidor. Exemple 8. Combinaci\u00f3 de disposicions (layouts) import javax.swing.*; import java.awt.*; public class MarcGestors extends JFrame { public MarcGestors() { JPanel pa1 = new JPanel(new FlowLayout()); JPanel pa2 = new JPanel(new BorderLayout()); JPanel pa3 = new JPanel(); pa3.setLayout(new BoxLayout(pa3, BoxLayout.Y_AXIS)); // componentes del panel 1 String [] opc = {\"Alta mar\", \"Baixa mar\", \" Muntanya\"}; pa1.add(new JLabel (\"Tria..\", JLabel.CENTER)); pa1.add(new JList(opc)); pa1.add(new JButton(\"Pr\u00e8mer\")); // componentes del panel 2 JTextField j = new JTextField(\"Raons \"); j.setEditable(false); pa2.add(j,BorderLayout.WEST); pa2.add(new JButton(\"Bot\u00f3\"),BorderLayout.EAST); // componentes del panel 3 pa3.add(new JCheckBox(\"Box \",false)); pa3.add(new JLabel (\"Calendari\", JLabel.CENTER)); pa3.add(new JRadioButton(\"Bot Radio\", true)); // asigna layout al marco y se ponen los paneles setLayout( new BorderLayout(10, 15)); add(pa1,BorderLayout.NORTH); add(pa2,BorderLayout.CENTER); add(pa3,BorderLayout.SOUTH); } public static void main(String[] args) { MarcGestors m; m = new MarcGestors(); m.setSize(200,300); m.setLocation(20,200); m.setResizable(false); m.setVisible(true); m.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } El resultat seria: Desactivar gestor de posicionament Per defecte un contenidor sempre t\u00e9 associat un gestor de posicionament (layout) per\u00f2 de vegades ens pot resultar interessant desactivar aquest gestor de posicionament. Utilitzarem el m\u00e8tode setLayout i li passarem per parametre null. Etiqutes Una etiqueta \u00e9s un component nom\u00e9s lectura al qual li podem modificar el text que cont\u00e9 i que normalment s'utilitza per posar algun missatge significatiu de la nostra interf\u00edcie a l'usuari final. En altres paraules, s\u00f3n components de text fixe que nom\u00e9s mostren text per\u00f2 que no reben cap event. Per gestionar les etiquetes a Java utilitzem la classe JLabel M\u00e8todes JLabel (): Crea una etiqueta sense text associat. JLabel (String msg): Crea una etiqueta amb el text msg. JLabel (String msg, Icon icona): Crea una etiqueta amb el text msg i la icona icon. JLabel (String msg, int align): crea una etiqueta amb el text msg alineat segons el segon argument que pot ser SwingConstants.CENTER, SwingConstants.LEFT o SwingConstants.RIGHT. public String getText (): torna el text de l'etiqueta public void setText (String msg): estableix el text de l'etiqueta. Botons A Swing es defineixe diversos tipus de botons, la classe base dels quals \u00e9s Abstract Button , \u00e9s una classe abstracta que encapsula propietats i m\u00e8todes comuns als diversos tipus de botons M\u00e8todes void setText (String text) : Estableix el text del bot\u00f3. String getText () : Obt\u00e9 el text del bot\u00f3. boolean isSelected() : true si s'ha seleccionat el bot\u00f3. void setSelectes (boolean b) : selecciona el bot\u00f3. void doClick (int temps) : tria el bot\u00f3 durant temps milisegons void setIcon (Icon icona) : estableix la icona del bot\u00f3. void setMnemonic (int mnemonic) : relaciona una tecla amb el bot\u00f3. void addActionListener(ActionListener al) : assigna un listener per controlar events. JButton La classe JButton representa el bot\u00f3 com\u00fa; es crea especificament una cadena, una icona, ambdos, o un element encara sense especificar; els constructors de la classe s\u00f3n: - JButton() : Constructor de la classe - JButton(String text) : Constructor amb text del bot\u00f3. - JButton(String text, Icon icona) : Constructor amb text i icona. La classe deriva d'AbstractButton per tant tots els seus m\u00e8todes estaran disponibles tamb\u00e9. JButton b1, b2, b3; b1 = new JButton(); b2 = new JButton(\"GROC\"); b3 = new JButton(new LibroIcon()); Botons amb dos estats JToogleButton \u00e9s la classe base dels botons amb dos estats; JRadioButton que s'utilitza per definir un grup de botons d'opci\u00f3 \u00fanica; per agrupar botons d'opci\u00f3 \u00fanica s'utilitza la classe ButtonGroup, primer es crea un objecte ButtonGroup (constructor sense arguments); a continuaci\u00f3 s'afegeix JRadioButton amb el m\u00e8tode de ButtonGroup, add(AbstracButton b). Constructors de JRadioButton JRadioButton() : Constructor per defecte. JRadioButton(String msg) : Constructor amb text del bot\u00f3. JRadioButton(String msg, boolean sel) : Constructor amb el text i si sel \u00e9s true, el bot\u00f3 ja estaria seleccionat. Exemple 9. Diversons botons import javax.swing.*; class PanelJRadio extends JPanel { ButtonGroup grb; JRadioButton jr1, jr2, jr3; public PanelJRadio() { grb = new ButtonGroup(); setLayout(new GridLayout(4,1)); add (new JLabel(\"Selecci\u00f3 excloent\")); // se crea bot\u00f3n de radio, se a\u00f1ade al panel y a la agrupaci\u00f3n jr1 = new JRadioButton(\"Avi\u00f3\", false); add(jr1); grb.add(jr1); // se crea bot\u00f3n de radio, se a\u00f1ade al panel y a la agrupaci\u00f3n jr2 = new JRadioButton(\"Tren\", false); add(jr2); grb.add(jr2); // se crea bot\u00f3n de radio, se a\u00f1ade al panel y a la agrupaci\u00f3n jr3 = new JRadioButton(\"Cotxe\", false); add(jr3); grb.add(jr3); } } JCheckBox o tamb\u00e9 anomenat: casella de verificaci\u00f3, check o checkbox. Constructors de JCheckBox JCheckBox(): Constructor per defecte. JCheckBox(String text): : Constructor amb el text associat. JCheckBox(String text, boolean sel): Constructor amb text i si sel \u00e9s true, la casella vindria ja marcada. La classe JComboBox no est\u00e0 a la jerarquia de botons, no deriva d'AbstractButton; combina en un sol component un bot\u00f3 amb una llista d'elements. Una JComboBox s'utilitza per crear una llista desplegable a la que es poden afegir opcions, editarles o fer seleccions. Constructors de JComboBox JComboBox(): Constructor per defecte. JComboBox(Object llista[]): Constructor amb una llista d'objectes per par\u00e0metre. Alguns dels seus m\u00e8todes s\u00f3n: - public void addItem(Object q): afegeix un element a la llista (pel final). - public insertItemAt(Object q, int indice): insereix en \u00edndex l'element. - public void setEditable(boolean flag): si flag \u00e9s true l'element de llista seleccionat \u00e9s editable. - public void setMaximumRowCount(int n): posa el m\u00e0xim d'elements a mostrar en el combo, si hi ha m\u00e9s elements apareix la barra d'scroll. - public Object getSelectedItem(): torna l'element seleccionat. Els m\u00e8todes seg\u00fcents s\u00f3n per la gesti\u00f3 d'events al combobox: - public void actionPerformed(ActionEvent ev); - public void addActionListener(ActionListener ae); - public void addItemListener(ItemListener it); - public void addStateChanged(ItemEvent ev); Exemple 10. ComboBox import javax.swing.*; import java.awt.*; import java.awt.event.*; class PanelJCombo extends JPanel { private JComboBox jcb; public PanelJCombo() { jcb = new JComboBox(); setLayout(new BorderLayout()); jcb.addItem(\"MAD - BCN\"); jcb.addItem(\"MAD - AGP\"); jcb.addItem(\"MAD - XRY\"); jcb.addItem(\"BRU - TFN\"); jcb.addItem(\"LEN - BCN\"); jcb.addItem(\"ROM - BCN\"); jcb.setMaximumRowCount(4); add(jcb,BorderLayout.NORTH); } } Components de text Els components Swing que s'utilitzen per editar o mostrar text formen una jerarquia de classes la base de la qual \u00e9s JTextComponent; aquesta \u00faltima \u00e9s una classe abstracta que es troba al paquet java.swing.text JTextComponent Els components de text suporten una ampla varietat de caracters de c\u00f2dis alfab\u00e8tics; en ells es pot inserir, esborrar o seleccionar caracters; \u00e9s text modificable per l'usuari; la classe disposa del constructor JTextComponent() que crea una component de text editable. Els seus m\u00e8todes s\u00f3n: - String getText(): torna el text que t\u00e9 el component. - String getText(int dspl,int lon): torna el text del component a partir del despla\u00e7ament dspl i de la longitud lon. - void setText(String txt): : substituieix el text del component per txt; si txt \u00e9s null o \u00e9s una cadena buida, esborra el text del component. - void setEditable(boolean b): un component de text \u00e9s editable per omisi\u00f3; amb aquest m\u00e8tode s'especifica si \u00e9s o no. JTextField, JPasswordText La classe JTextField representa un camp de text modificable per l'usuar; amb aquest component s'edita una l\u00ednia de text amb l'ample, alineaci\u00f3 i tipus de lletra que es desitge. JPasswordField es deriva de JTextField; representa un camp de text amb la particularitat de que emmascara els caracters quan es visualitza; s'utilitza per editar una clau secreta, contrasenya o password; per omisi\u00f3, cada caracter de un JPasswordField es substitueix per un '*'. Els constructors de JTextField s\u00f3n: - JTextField(): camp de text buit de 0 columnes. - JTextField(int cols): camp de text buit de cols columnes. - JTextField(String msg): camp de text ajustat a la cadena msg. - JTextField(String msg,int col): camp de text amb la cadena msg i de cols columnes. Els constructors de JPasswordField tenen els mateixos arguments que JTextField; els seus m\u00e8todes s\u00f3n: - void setFont(Font tipo) - void setHorizontalAlignment(int alig): alineaci\u00f3 del text; els valors possibles d'alig son les constants de SwingConstants : RIGHT, LEFT, CENTER, TRAILING, LEADING (aquest \u00e9s el predeterminat) - void setColumns(int cols): posa el n\u00famero de columnes preferit per al camp. JPasswordField hereta els m\u00e8todes anteriors i a m\u00e9s a m\u00e9s disposa d'aquestos: - void setEchoChar(char c): coloca c per emmascarar els caracters del camp. - char getEchoChar(): torna el caracter que emmascara; per defecte ' '. - char[] getPassword(): * torna la cadena del camp en un array de caracters. Exemple 11. Passwords i Labels import javax.swing.*; import java.awt.*; import java.awt.event.*; public class MarcPassWord extends JFrame { private static final int AMPLE=300, ALT=150; private JPasswordField clau = null; private JLabel et1 = null; private JLabel res = null; public MarcPassWord(String c) { super(c); setSize(ANCHO,ALTO); creaComponentes(); pack(); } private void creaComponents() { clau = new JPasswordField(20); et1= new JLabel(); // oyente para proceso de la acci\u00f3n del usuario clave.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent evt) { procesoAccionUser(evt); } }); // pone el campo de texto con la clave add(clau, BorderLayout.CENTER); // crea y pone la etiqueta en el marco et1.setFont(new java.awt.Font(\"Times New Roman\", 3, 12)); et1.setHorizontalAlignment(javax.swing.SwingConstants.CENTER); et1.setText(\"PASSWORD \"); et1.setToolTipText(\"Exemple\"); add(et1,BorderLayout.NORTH); // m\u00e9todo que se ejecuta al actuar el usuario sobre el campo private void procesoAccionUser(ActionEvent evt) { char pas[]; pas = clau.getPassword(); res= new JLabel(\" \"); res.setFont(new Font(\"Book Antiqua\", 3, 14)); if (pas.length == 0) { System.out.println(\"Teclejar Password \"); et1.setText(\"PASSWORD(teclejar) \"); } else { clau.setEditable(false); res.setText(\"Es valida la clau\"); } add(res, BorderLayout.SOUTH); validate(); pack(); } public static void main(String args[]) { MarcPassWord marc; marc = new MarcPassWord(\"Marc amb password\"); marc.setVisible(true); marc.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } } Resultat JTextArea El component JTextArea s'utilitza amb la finalitat de mostrar moltes l\u00ednies de text; disposa de m\u00e8todes per fixar l'ample de cada l\u00ednia i l'acci\u00f3 a realitzar si la l\u00ednia que s'insereix \u00e9s major que l'ample prefixat; tamb\u00e9 permet decidir si es trenquen o no les paraules al canvi de l\u00ednia. Aquest component no disposa de barra d'scroll JScrollPane , cal crear l'scroll i associar-lo al component; per exemple: es crea el component areaText: JTextArea areaText = new JTextArea(); // A continuaci\u00f3 es crea l'scroll i s'associa a **areaText**: JScrollPane barra = new JScrollPane(areaText); // Per \u00faltim, l'scroll es posa al marc areaText.add(barra); Els constructors s\u00f3n: - JTextArea(): crea el component amb cadena nula, zero files i columnes. - JTextArea(int filas,int cols): crea amb cadena nula i el n\u00famero de files i columnes especificat. - JTextArea(String t): crea el component amb cadena t i zero files i columnes. - JTextArea(String t,int filas, int col): crea el component amb cadena t i el n\u00famero de files i columnes especificat. Els seus m\u00e8todes s\u00f3n: - public void append(String t): afegeix la cadena t al final del document. - public void insert(String t,int p): insereix la cadena t a partir de la posici\u00f3 p. - void replaceRange(String t, int inici, int fi): substitueix el text del document al rang inici-fi per la cadena t. - public void setColumns(int cols): fixa l'ample de cada l\u00ednia. - public void setLineWrap(boolean f): si f \u00e9s true activa el canvi autom\u00e0tica de l\u00ednia. - public void setWrapStyleWord(boolean f): si f \u00e9s true no 'trenca' les paraules en el canvi de l\u00ednia.","title":"Tema 9. Gr\u00e0fics. Java Swing"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#tema-9-grafics-java-swing","text":"","title":"Tema 9. Gr\u00e0fics. Java Swing"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#introduccio","text":"Fins ara hem estat utilitzant la consola i el teclat a les nostres aplicacions per tal de comunicar-nos amb l'usuari. En aquest tema utilitzarem l'API de Java per al desenvolupament de components gr\u00e0fics Swing. Swing \u00e9s un conjunt d'eines per a Java. \u00c9s una API que proporciona interf\u00edcie gr\u00e0fica d'usuari (GUI) per a programes de Java. Entre d'altres Swing cont\u00e9: frames, botons, textbox, men\u00fas a banda dels events associats als elements. Swing va ser desenvolupat per a proporcionar un conjunt m\u00e9s complex de components GUI que l'anterior Abstract Window Toolkit (AWT). Swing proporciona un aspecte i aparen\u00e7a natiu que emula diverses plataformes, tamb\u00e9 d\u00f3na suport a extensions d'aspecte i aparen\u00e7a que permeten a les aplicacions tindre un aspecte i apare\u00e7a que no guarda relaci\u00f3 amb la plataforma subjacent. Hu\u00ed en dia la majoria de desenvolupadors Java utilitzen Swing o JavaFX per construir interf\u00edcies d'usuari","title":"Introducci\u00f3"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#la-llibreria-swing","text":"Com tot en Java, swing no anava a ser menys, est\u00e0 dissenyat com una llibreria de classes, interf\u00edcies, recursos, etc.. per la construcci\u00f3 d'insterf\u00edcies gr\u00e0fiques. Swing cont\u00e9 tres APIs una per a components 2D, una altra per al Drag & Drop i l'\u00faltima per facilitar l'acc\u00e9s. Swing est\u00e0 basada en AWT per\u00f2 \u00e9s independent de la plataforma, \u00e9s a dir, sempre mostra la mateixa aparen\u00e7a independentment del sistema en el que s'execute l'aplicaci\u00f3 a difer\u00e8ncia d'AWT. Amb Swing podem fer: - Marcs: Finestres amb de t\u00edtol, men\u00fa, botons maximitzar, minimitzar i tancar. - Contenidors: poden agrupar diversos controls. - Botons - Etiqutes: text - Camps i arees de text. - Desplegables Per tal de poder utilitzar les llibreries Swing de Java hauriem d'afegir al nostre codi el seg\u00fcent: import javax.swing.*;","title":"La llibreria Swing"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#components-i-contenidors","text":"En general, els components Swing es deriven de la classe JComponent. Les \u00faniques excepcions s\u00f3n els quatre contenidors de nivell superior. JComponent proporciona la funcionalitat que \u00e9s com\u00fa a tots els components. Per exemple, JComponent admet la look & feel conectables. JComponent hereta les classes AWT Container i Component. Per tant, un component Swing est\u00e0 integrat i es compatible amb un component AWT. Tots els components de Swing estan representats per classes definides dins del paquet javax.swing com hem explicat abans. La seg\u00fcent taula mostra els noms de classe per als components Swing inclosos els contenidors.","title":"Components i contenidors"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#components-java-swing","text":"JApplet JButton JCheckBox JCheckBoxMenuItem JColorChooser JComboBox JComponent JDesktopPane JDialog JEditorPane JFileChooser JFormattedTextField JFrame JInternalFrame JLabel JLayer JLayeredPane JList JMenu JMenuBar JMenuItem JOptionPane JPanel JPasswordField JPopUpMenu JProgressBar JRadioButton JRadioButtonMenuItem JRootPane JScrollBar JScrollPane JSeparator JSlider JSpineer JSplitPane JTabbedPane JTable JTextArea JTextField JTextPane JTogglebutton JToolBar JToolTip JTree JViewport JWindows La majora de noms solen ser prou significatius i resulta intuitiu a primer cop d'ull saber quina \u00e9s la finalitat de cadascun dels components.","title":"Components Java Swing"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#contenidors-java-swing","text":"Swing defineix dos tipus de contenidors. Els primers s\u00f3n contenidors de nivell superior: JFrame, JApplet, JWindow i JDialog. (JApplet, que admet applets basats en Swing, ha estat descartat per JDK 9.) Aquests contenidors no hereten JComponent. No obstant aix\u00f2, hereten les classes AWT Component i Container. A difer\u00e8ncia d'altres components de Swing, que s\u00f3n lightweight, els contenidors de nivell superior s\u00f3n heavyweight. Aix\u00f2 fa que els contenidors de nivell superior siguin un cas especial a la biblioteca de components Swing. Com el seu nom indica, un contenidor de nivell superior ha d'estar a la part superior d'una jerarquia de contenci\u00f3. Un contenidor de nivell superior no est\u00e0 contingut en cap altre contenidor. A m\u00e9s, cada jerarquia de contenci\u00f3 ha de comen\u00e7ar amb un contenidor de nivell superior. El m\u00e9s comunament utilitzat per les aplicacions \u00e9s JFrame. El segon tipus de contenidor compatible amb Swing \u00e9s el contenidor lightweight. Els contenidors lightweight hereten JComponent. Exemples de contenidors lightweight s\u00f3n JPanel, JScrollPane i JRootPane. Els contenidors lightweight sovint es fan servir per a organitzar i administrar col\u00b7lectivament grups de components relacionats perqu\u00e8 un contenidor lightweight es pot contenir dins d'un altre contenidor. Per tant, pot utilitzar contenidors lightweight per crear subgrups de controls relacionats que estan continguts dins d'un contenidor extern.","title":"Contenidors Java Swing"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#swing-vs-awt","text":"\u00c9s possible utilitzar Swing i AWT a la mateixa interf\u00edcie, per\u00f2 podria donar problemes. \u00c9s recomanable utilitzar nom\u00e9s components Swing, ja que tot component AWT t\u00e9 el seu equivalent Swing. La majoria de classes Swing comencen per J, per exemple: JButton, JFrame... encara que tamb\u00e9 existeixen Frame i Button que pertanyen a la llibreria AWT. Cal tindre molta cura en no oblidar de posar la 'J' davant dels components ja que si no podria portar a inconsist\u00e8ncies a causa de mesclar components. A l'actualitat quasi tota la programaci\u00f3 gr\u00e0fica en Java es fa amb Swing que implemente una interf\u00edcie gr\u00e0fica normalment va a tenir quatre tipus d'elements: 1. Un contenidor de nivell superior: un marc (JFrame), un applet (JApplet) o b\u00e9 objectes JDialog. Aquests contenidors no estan dins d'una altra finestra, s\u00f3n les finestres principals. 2. Components de la interf\u00edcie gr\u00e0fica: botons, camps de text, etc\u00e8tera, que se situen a la finestra principal o en contenidors. 3. Contenidors dissenyats per altres elements de la interf\u00edcie; JPanel i JScrollPane s\u00f3n dos contenidors i, a el mateix temps, s\u00f3n components. 4. Elements per a la gesti\u00f3 d'esdeveniments. Els components sempre s'afegeixen a una l\u00e0mina o panell; pot ser la de el marc, o b\u00e9 un panell tipus JPanel. En general, sempre es creen classes derivades de les classes contenidors de nivell superior; tot marc ser\u00e0 una subclasse de JFrame, a l'igual que un applet \u00e9s una subclasse de JApplet.","title":"Swing vs AWT"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#creacio-dun-jframe","text":"La difer\u00e8ncia entre crear programes que es comuniquen amb l'usuari mitjan\u00e7ant el terminal i el teclat i fer programes amb Swing \u00e9s considerable. Al crear una aplicaci\u00f3 Swing s'han de tenir en compte conceptes nous com el threading . Per\u00f2 per entendre-ho tot millor, farem un programa Swing d'exemple. Per al programa d'exemple crearem un JFrame al qual li posarem una JLabel","title":"Creaci\u00f3 d'un JFrame"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#exemple-1-programa-simple-swing","text":"// Un simple programa Swing import javax.swing.*; public class SwingDemo { SwingDemo(){ JFrame jfrm=new JFrame(\"Aplicaci\u00f3 Simple Swing\"); // Crea un nou contenidor JFrame. jfrm.setSize(475,200); // Establim el tamany inicial jfrm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // Acabe el programa quan l'usuari tanque l'aplicaci\u00f3. JLabel jLabel= new JLabel(\"Programaci\u00f3 GUI amb Swing.\"); // Creem una etiqueta jLabel.setHorizontalAlignment(SwingConstants.CENTER); // Situem l'etiqueta al centre del frame jfrm.add(jLabel); // Afegim l'etiqueta al frame jfrm.setVisible(true); // Visualitzem el marc. } public static void main(String[] args) { SwingUtilities.invokeLater(new Runnable() { public void run(){ new SwingDemo(); } }); } } El resultat del codi anterior seria el seg\u00fcent: JFrame \u00e9s un contenidor de nivell superior que s'utilitza de forma com\u00fa a les aplicacions Swing, mentre que JLabel \u00e9s una etiqueta que ens servir\u00e0 per posar text. Expliquem amb m\u00e9s detall el que fa la funci\u00f3 main: - SwingUtilities.invokeLater() - static void invokeLater(Runnable doRun): Executa un doRun.run() per tal que s'execute de forma asincrona al AWT event dispatching thread. A aquets m\u00e8tode se li ha de passar un objecte Runnable - new Runnable() { }: - Objecte Runnable que s'ha de passar al m\u00e8tode invokeLater - public void run() { }: M\u00e8tode run que s'executa de l'objecte runnable que se li passa a InvokeLater - new SwingDemo() - Codi del m\u00e8tode run de l'objecte runnable. Una aplicaci\u00f3 que implemente una interf\u00edcie gr\u00e0fica normalment va a tindre quatre tipus d'elements. 1. Un contenidor de nivell superior: un marc (JFrame), un applet (JApplet) o b\u00e9 di\u00e0legs (JDialog) que faran el paper de finestra principal. 2. Components de la interf\u00edcie gr\u00e0fica: botons, camps de text, etc, que s'afegiran al contenidor de nivell superior anterior. 3. Contenidors dissenyats per altres elements de la interf\u00edcie: JPanel i JScrollPane s\u00f3n dos contenidors i al mateix temps s\u00f3n components. 4. Elements per la gesti\u00f3 d'events. Els components sempre s'afegeixen a una l\u00e0mina o paper; pot ser la del marc o b\u00e9 un panel tipus JPanel. En general, sempre es creen classes derivades de les classes contenidores de nivell superior. Tot marc ser\u00e0 una subclasse de JFrame, de la mateixa forma que un applet \u00e9s una subclasse de JApplet","title":"Exemple 1. Programa simple Swing"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#jframe","text":"La classe JFrame \u00e9s un tipus de contenidor que hereta de la classe java.awt.Frame. JFrame funciona com la finestra principal on components com etiquetes, botons, camps de text etc, s'afegeixen per crear una interf\u00edcie gr\u00e0fica.","title":"JFrame"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#metodes","text":"M\u00e8tode Descripci\u00f3 JFrame() Constructor de la classe. Crea un marca sense t\u00edtol JFrame (String titol) Crea un marc amb t\u00edtol. void setTitle (String titlo) Estableix el t\u00edtol del marc void setIconImage ( Image img ) Estableix la icona del marc void setDefaultCloseOperation (int op ) programa el comportament del marca quan es tanca. Possibles valors: EXIT_ON_CLOSE, DO_NOTHING_ON_CLOSE, DISPOSE_ON_CLOSE, HIDE_ON_CLOSE Container getContentPane () proporciona el layout de continguts del marc, \u00e9s a dir, les vores void setResizable ( boolean r ) si r val true, es pot redimensionar el marc void add (Component c) Afegeix el component c al marc void removeComponent (Component c) elimina el component c del marc Component add (Component c, int p) Coloca el component c a la posici\u00f3 p del marc void setLayout (LayoutManager mngr) estableix la forma de distribuir el components al marc, els quals normalment es distribueixen en posicions relatives, segons el layout que tinga associat el marc void setVisible (boolean b) fa visible el component si b \u00e9s true void setBounds (int x, int y, int ample, int alt) situa el component i canvia el seu tamany void setLocation (int x, int y) situa el component a les coordenades x i y void setLocation (Point p) situa el component al punt p void setSize (int ample, int alt) estableix les dimensions del component void setSize (Dimension dim) estableix la dimensi\u00f3 del component a dim","title":"M\u00e8todes"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#layout-manager-gestor-de-posicionament","text":"A difer\u00e8ncia d'altres aplicacions que es dediquen al disseny d'interf\u00edcies gr\u00e0fiques, les posicions dels elements dintre del nostre contenidor no es fan en pixels ni valors absoluts, s'utilitzen els Layout Manager que ho podriem traduir com \"gestors de disposici\u00f3\" o \"gestor de plantilla\" o \"gestor de posicionament\". Aquestos gestors de posicionament s\u00f3n elements que implementen la interf\u00edcie \"LayoutManager\". Cada cotenidor t\u00e9 associat un Layout Manager que pot ser: BorderLayout, FlowLayout, GridLayout, BoxLayout, GridBagLayout, CardLayout, SpringLayout... Veiem un exemple:","title":"Layout Manager - Gestor de posicionament"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#exemple-2-marc-de-prova","text":"JFrame marc = new JFrame(\"MarcProva\"); marco.setLayout(new GridLayout(3,4)); El que hem fet al codi anterior \u00e9s crear i instanciar un nou marc de tipus JFrame amb el t\u00edtol \"MarcProva\" i despr\u00e9s hem establert el seu gestor de posicionament de tipus GridLayout. A continuaci\u00f3 detallarem els m\u00e9s utilitzats","title":"Exemple 2. Marc de prova"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#borderlayout","text":"Gestor de posicionament per defecte dels marcs (JFrame) i di\u00e0legs (JDialog). Divideix al contenidor en cinc zones: nord, sud, est, oest i centre, que es corresponen a: BorderLayout.NORTH, BorderLayout.SOUTH, BorderLayout.EAST, BorderLayout.WEST i BorderLayout.CENTER Veiem un exemple:","title":"BorderLayout"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#exemple-3-marc-amb-vora","text":"import javax.swing.*; import java.awt.*; public class MarcBorder extends JFrame { static int AMPLE =350; static int ALT = 200; public MarcBorder() { super(\"T\u00edtol Marc\"); add(new JLabel(\"Nord\", SwingConstants.CENTER), BorderLayout.NORTH); add(new JLabel(\"Sud\", SwingConstants.CENTER), BorderLayout.SOUTH); add(new JLabel(\"Centre\", SwingConstants.CENTER), BorderLayout.CENTER); add(new JLabel(\"Oest\", SwingConstants.CENTER), BorderLayout.WEST); add(new JLabel(\"Est\", SwingConstants.CENTER), BorderLayout.EAST); setSize(AMPLE,ALT); setVisible(true); } public static void main(String args[]) { MarcBorder marc = new MarcBorder(); marc.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } El resultat del codi anterior \u00e9s:","title":"Exemple 3. Marc amb vora"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#flowlayout","text":"Amb aquest gestor podem colocar els elements d'esquerra cap a dreta i de dalt cap avall. La classe FlowLayout disposa de diversos constructors, un d'ells ens permet establir l'alineaci\u00f3 dels components FlowLayout(int align) on align pot ser: FlowLayout.RIGHT, FlowLayout.CENTER, FlowLayout.LEFT.","title":"FlowLayout"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#exemple-4-flowlayout","text":"import java.awt.*; import javax.swing.*; public class MarcFlow extends JFrame { static int AMPLE =175; static int ALT = 100; public MarcFlow() { super(\"El meu marc\"); setLayout(new FlowLayout()); add( new JLabel(\"Primera\")); add(new JLabel(\"Segona\")); add(new JLabel(\"Tercera\")); add(new JLabel(\"Quarta\")); add(new JLabel(\"Cinquena\")); add(new JLabel(\"Sisena\")); setSize(AMPLE,ALT); setVisible(true); } public static void main(String args[]) { MarcFlow marc = new MarcFlow(); marc.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } I aquest \u00e9s el resultat:","title":"Exemple 4. Flowlayout"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#gridlayout","text":"Aquest gestor de posicionament distribueix els components del container associat en forma de graella de cel\u00b7les iguals en forma de quadricula de dalt cap avall i de esquerra a dreta, \u00e9s a dir, en files i columnes.","title":"GridLayout"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#exemple-5-gridlayout","text":"import java.awt.*; import javax.swing.*; public class MarcGrid extends JFrame { static int AMPLE =175; static int ALT = 100; public MarcGrid() { super(\"El meu marc\"); setLayout(new GridLayout(3,2,15,15)); add(new JLabel(\"Primera\")); add(new JLabel(\"Segona\")); add(new JLabel(\"Tercera\")); add(new JLabel(\"Quarta\")); add(new JLabel(\"Cinquena\")); add(new JLabel(\"Sisena\")); setSize(AMPLE,ALT); setVisible(true); } public static void main(String args[]) { MarcGrid marc = new MarcGrid(); marc.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } Resultat del codi anterior:","title":"Exemple 5. GridLayout"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#boxlayout","text":"Aquest gestor coloca els components en una \u00fanica fila o una \u00fanica columna, s'assembla a una caixa amb orientaci\u00f3 horitzontal o vertical; el constructor necessita un argument amb el contenidor que es va a utilitzar i l'orientaci\u00f3 que pot ser: BoxLayout.X_AXIS o BoxLayout.Y_AXIS. El format del constructor \u00e9s: BoxLayout (Container desti, int orientacio)","title":"BoxLayout"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#exemple-6-boxlayout","text":"import javax.swing.*; import java.awt.*; public class MarcBox extends JFrame { static int AMPLE =175; static int ALT = 150; public MarcBox() { super(\"El meu marcBox\"); JPanel panel = new JPanel() ; panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS)); panel.add(new JLabel(\"Primera\")); panel.add(new JLabel(\"Segona\")); panel.add(new JLabel(\"Tercera\")); panel.add(new JLabel(\"Quarta\")); panel.add(new JLabel(\"Cinquena\")); panel.add(new JLabel(\"Sisena\")); add(panel); setSize(AMPLE,ALT); setVisible(true); } public static void main(String args[]) { MarcBox miMarcBox = new MarcBox(); miMarcBox.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } }","title":"Exemple 6. BoxLayout"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#boxlayout-box","text":"Box o caixa, \u00e9s un contenidor que t\u00e9 com gestor de posicionament (LayoutManager) predeterminat un BoxLayout; utilitzant aquest contenidor no cal crear un panel perqu\u00e8 directament es crea un objecte Box i a continuaci\u00f3 s'afegeixen els components. La classe Box disposa de dos m\u00e8todes static (m\u00e8todes factoria) que creen l'objecte, i s\u00f3n: Box.createHorizontalBox(); Box.createVerticalBox(); Aleshores, per crear un Box no s'utilitza el constructor sino que es crida a un d'aquestos dos m\u00e8todes; per un objecte Box amb orientaci\u00f3 horitzontal, per exemple: Box caixaHoriz = Box.createHorizontalBox(); Al contenidor se li afegeix el component caixaHoriz.add(element) i despr\u00e9s el contenidor al marc.","title":"BoxLayout - Box"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#exemple-7-boxlayout-box","text":"import javax.swing.*; import java.awt.*; public class Marc2Box extends JFrame { static int AMPLE =275; static int ALT = 175; public Marc2Box() { super(\"El meu marc\"); JButton b1 = new JButton(\"Boto1\"); JButton b2 = new JButton(\"Boto2\"); JButton b3 = new JButton(\"Boto3\"); JButton b4 = new JButton(\"Boto4\"); JButton b5 = new JButton(\"Boto5\"); JButton b6 = new JButton(\"Boto6\"); Box caixaH = Box.createHorizontalBox(); // m\u00e9todo factor\u00eda caixaH.add(b1); // separaci\u00f3n horizontal de 10 pixeles caixaH.add(Box.createHorizontalStrut(10)); caixaH.add(b2); // zona r\u00edgida, separaci\u00f3n horizontal caixaH.add(Box.createRigidArea(new Dimension(5,5))); caixaH.add(b3); add(caixaH,BorderLayout.NORTH); Box caixaV = Box.createVerticalBox(); caixaV.add(Box.createHorizontalStrut(70)); caixaV.add(b4); // separaci\u00f3n horizontal 10 pixeles caixaV.add(Box.createVerticalStrut(10)); caixaV.add(b5); caixaV.add(Box.createRigidArea(new Dimension(5,5))); caixaV.add(b6); add(caixaV,BorderLayout.CENTER); setSize(AMPLE,ALT); setVisible(true); } public static void main(String args[]) { Marc2Box marcBox2 = new Marc2Box(); marcBox2.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } }","title":"Exemple 7. BoxLayout - Box"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#combinar-layouts","text":"JFrame, JDialog i JPanel nom\u00e9s poden tindre un gestor de posicionament per\u00f2 si agafem un contenidor de primer nivell com un marc, podr\u00edem combinar diversos layouts niats (nested). Al seg\u00fcent exemple podem veure una combinaci\u00f3 de tres gestors de posicionament en un mateix contenidor.","title":"Combinar Layouts"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#exemple-8-combinacio-de-disposicions-layouts","text":"import javax.swing.*; import java.awt.*; public class MarcGestors extends JFrame { public MarcGestors() { JPanel pa1 = new JPanel(new FlowLayout()); JPanel pa2 = new JPanel(new BorderLayout()); JPanel pa3 = new JPanel(); pa3.setLayout(new BoxLayout(pa3, BoxLayout.Y_AXIS)); // componentes del panel 1 String [] opc = {\"Alta mar\", \"Baixa mar\", \" Muntanya\"}; pa1.add(new JLabel (\"Tria..\", JLabel.CENTER)); pa1.add(new JList(opc)); pa1.add(new JButton(\"Pr\u00e8mer\")); // componentes del panel 2 JTextField j = new JTextField(\"Raons \"); j.setEditable(false); pa2.add(j,BorderLayout.WEST); pa2.add(new JButton(\"Bot\u00f3\"),BorderLayout.EAST); // componentes del panel 3 pa3.add(new JCheckBox(\"Box \",false)); pa3.add(new JLabel (\"Calendari\", JLabel.CENTER)); pa3.add(new JRadioButton(\"Bot Radio\", true)); // asigna layout al marco y se ponen los paneles setLayout( new BorderLayout(10, 15)); add(pa1,BorderLayout.NORTH); add(pa2,BorderLayout.CENTER); add(pa3,BorderLayout.SOUTH); } public static void main(String[] args) { MarcGestors m; m = new MarcGestors(); m.setSize(200,300); m.setLocation(20,200); m.setResizable(false); m.setVisible(true); m.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } El resultat seria:","title":"Exemple 8. Combinaci\u00f3 de disposicions (layouts)"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#desactivar-gestor-de-posicionament","text":"Per defecte un contenidor sempre t\u00e9 associat un gestor de posicionament (layout) per\u00f2 de vegades ens pot resultar interessant desactivar aquest gestor de posicionament. Utilitzarem el m\u00e8tode setLayout i li passarem per parametre null.","title":"Desactivar gestor de posicionament"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#etiqutes","text":"Una etiqueta \u00e9s un component nom\u00e9s lectura al qual li podem modificar el text que cont\u00e9 i que normalment s'utilitza per posar algun missatge significatiu de la nostra interf\u00edcie a l'usuari final. En altres paraules, s\u00f3n components de text fixe que nom\u00e9s mostren text per\u00f2 que no reben cap event. Per gestionar les etiquetes a Java utilitzem la classe JLabel","title":"Etiqutes"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#metodes_1","text":"JLabel (): Crea una etiqueta sense text associat. JLabel (String msg): Crea una etiqueta amb el text msg. JLabel (String msg, Icon icona): Crea una etiqueta amb el text msg i la icona icon. JLabel (String msg, int align): crea una etiqueta amb el text msg alineat segons el segon argument que pot ser SwingConstants.CENTER, SwingConstants.LEFT o SwingConstants.RIGHT. public String getText (): torna el text de l'etiqueta public void setText (String msg): estableix el text de l'etiqueta.","title":"M\u00e8todes"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#botons","text":"A Swing es defineixe diversos tipus de botons, la classe base dels quals \u00e9s Abstract Button , \u00e9s una classe abstracta que encapsula propietats i m\u00e8todes comuns als diversos tipus de botons","title":"Botons"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#metodes_2","text":"void setText (String text) : Estableix el text del bot\u00f3. String getText () : Obt\u00e9 el text del bot\u00f3. boolean isSelected() : true si s'ha seleccionat el bot\u00f3. void setSelectes (boolean b) : selecciona el bot\u00f3. void doClick (int temps) : tria el bot\u00f3 durant temps milisegons void setIcon (Icon icona) : estableix la icona del bot\u00f3. void setMnemonic (int mnemonic) : relaciona una tecla amb el bot\u00f3. void addActionListener(ActionListener al) : assigna un listener per controlar events.","title":"M\u00e8todes"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#jbutton","text":"La classe JButton representa el bot\u00f3 com\u00fa; es crea especificament una cadena, una icona, ambdos, o un element encara sense especificar; els constructors de la classe s\u00f3n: - JButton() : Constructor de la classe - JButton(String text) : Constructor amb text del bot\u00f3. - JButton(String text, Icon icona) : Constructor amb text i icona. La classe deriva d'AbstractButton per tant tots els seus m\u00e8todes estaran disponibles tamb\u00e9. JButton b1, b2, b3; b1 = new JButton(); b2 = new JButton(\"GROC\"); b3 = new JButton(new LibroIcon());","title":"JButton"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#botons-amb-dos-estats","text":"JToogleButton \u00e9s la classe base dels botons amb dos estats; JRadioButton que s'utilitza per definir un grup de botons d'opci\u00f3 \u00fanica; per agrupar botons d'opci\u00f3 \u00fanica s'utilitza la classe ButtonGroup, primer es crea un objecte ButtonGroup (constructor sense arguments); a continuaci\u00f3 s'afegeix JRadioButton amb el m\u00e8tode de ButtonGroup, add(AbstracButton b).","title":"Botons amb dos estats"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#constructors-de-jradiobutton","text":"JRadioButton() : Constructor per defecte. JRadioButton(String msg) : Constructor amb text del bot\u00f3. JRadioButton(String msg, boolean sel) : Constructor amb el text i si sel \u00e9s true, el bot\u00f3 ja estaria seleccionat.","title":"Constructors de JRadioButton"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#exemple-9-diversons-botons","text":"import javax.swing.*; class PanelJRadio extends JPanel { ButtonGroup grb; JRadioButton jr1, jr2, jr3; public PanelJRadio() { grb = new ButtonGroup(); setLayout(new GridLayout(4,1)); add (new JLabel(\"Selecci\u00f3 excloent\")); // se crea bot\u00f3n de radio, se a\u00f1ade al panel y a la agrupaci\u00f3n jr1 = new JRadioButton(\"Avi\u00f3\", false); add(jr1); grb.add(jr1); // se crea bot\u00f3n de radio, se a\u00f1ade al panel y a la agrupaci\u00f3n jr2 = new JRadioButton(\"Tren\", false); add(jr2); grb.add(jr2); // se crea bot\u00f3n de radio, se a\u00f1ade al panel y a la agrupaci\u00f3n jr3 = new JRadioButton(\"Cotxe\", false); add(jr3); grb.add(jr3); } } JCheckBox o tamb\u00e9 anomenat: casella de verificaci\u00f3, check o checkbox.","title":"Exemple 9. Diversons botons"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#constructors-de-jcheckbox","text":"JCheckBox(): Constructor per defecte. JCheckBox(String text): : Constructor amb el text associat. JCheckBox(String text, boolean sel): Constructor amb text i si sel \u00e9s true, la casella vindria ja marcada. La classe JComboBox no est\u00e0 a la jerarquia de botons, no deriva d'AbstractButton; combina en un sol component un bot\u00f3 amb una llista d'elements. Una JComboBox s'utilitza per crear una llista desplegable a la que es poden afegir opcions, editarles o fer seleccions.","title":"Constructors de JCheckBox"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#constructors-de-jcombobox","text":"JComboBox(): Constructor per defecte. JComboBox(Object llista[]): Constructor amb una llista d'objectes per par\u00e0metre. Alguns dels seus m\u00e8todes s\u00f3n: - public void addItem(Object q): afegeix un element a la llista (pel final). - public insertItemAt(Object q, int indice): insereix en \u00edndex l'element. - public void setEditable(boolean flag): si flag \u00e9s true l'element de llista seleccionat \u00e9s editable. - public void setMaximumRowCount(int n): posa el m\u00e0xim d'elements a mostrar en el combo, si hi ha m\u00e9s elements apareix la barra d'scroll. - public Object getSelectedItem(): torna l'element seleccionat. Els m\u00e8todes seg\u00fcents s\u00f3n per la gesti\u00f3 d'events al combobox: - public void actionPerformed(ActionEvent ev); - public void addActionListener(ActionListener ae); - public void addItemListener(ItemListener it); - public void addStateChanged(ItemEvent ev);","title":"Constructors de JComboBox"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#exemple-10-combobox","text":"import javax.swing.*; import java.awt.*; import java.awt.event.*; class PanelJCombo extends JPanel { private JComboBox jcb; public PanelJCombo() { jcb = new JComboBox(); setLayout(new BorderLayout()); jcb.addItem(\"MAD - BCN\"); jcb.addItem(\"MAD - AGP\"); jcb.addItem(\"MAD - XRY\"); jcb.addItem(\"BRU - TFN\"); jcb.addItem(\"LEN - BCN\"); jcb.addItem(\"ROM - BCN\"); jcb.setMaximumRowCount(4); add(jcb,BorderLayout.NORTH); } }","title":"Exemple 10. ComboBox"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#components-de-text","text":"Els components Swing que s'utilitzen per editar o mostrar text formen una jerarquia de classes la base de la qual \u00e9s JTextComponent; aquesta \u00faltima \u00e9s una classe abstracta que es troba al paquet java.swing.text","title":"Components de text"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#jtextcomponent","text":"Els components de text suporten una ampla varietat de caracters de c\u00f2dis alfab\u00e8tics; en ells es pot inserir, esborrar o seleccionar caracters; \u00e9s text modificable per l'usuari; la classe disposa del constructor JTextComponent() que crea una component de text editable. Els seus m\u00e8todes s\u00f3n: - String getText(): torna el text que t\u00e9 el component. - String getText(int dspl,int lon): torna el text del component a partir del despla\u00e7ament dspl i de la longitud lon. - void setText(String txt): : substituieix el text del component per txt; si txt \u00e9s null o \u00e9s una cadena buida, esborra el text del component. - void setEditable(boolean b): un component de text \u00e9s editable per omisi\u00f3; amb aquest m\u00e8tode s'especifica si \u00e9s o no.","title":"JTextComponent"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#jtextfield-jpasswordtext","text":"La classe JTextField representa un camp de text modificable per l'usuar; amb aquest component s'edita una l\u00ednia de text amb l'ample, alineaci\u00f3 i tipus de lletra que es desitge. JPasswordField es deriva de JTextField; representa un camp de text amb la particularitat de que emmascara els caracters quan es visualitza; s'utilitza per editar una clau secreta, contrasenya o password; per omisi\u00f3, cada caracter de un JPasswordField es substitueix per un '*'. Els constructors de JTextField s\u00f3n: - JTextField(): camp de text buit de 0 columnes. - JTextField(int cols): camp de text buit de cols columnes. - JTextField(String msg): camp de text ajustat a la cadena msg. - JTextField(String msg,int col): camp de text amb la cadena msg i de cols columnes. Els constructors de JPasswordField tenen els mateixos arguments que JTextField; els seus m\u00e8todes s\u00f3n: - void setFont(Font tipo) - void setHorizontalAlignment(int alig): alineaci\u00f3 del text; els valors possibles d'alig son les constants de SwingConstants : RIGHT, LEFT, CENTER, TRAILING, LEADING (aquest \u00e9s el predeterminat) - void setColumns(int cols): posa el n\u00famero de columnes preferit per al camp. JPasswordField hereta els m\u00e8todes anteriors i a m\u00e9s a m\u00e9s disposa d'aquestos: - void setEchoChar(char c): coloca c per emmascarar els caracters del camp. - char getEchoChar(): torna el caracter que emmascara; per defecte ' '. - char[] getPassword(): * torna la cadena del camp en un array de caracters.","title":"JTextField, JPasswordText"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#exemple-11-passwords-i-labels","text":"import javax.swing.*; import java.awt.*; import java.awt.event.*; public class MarcPassWord extends JFrame { private static final int AMPLE=300, ALT=150; private JPasswordField clau = null; private JLabel et1 = null; private JLabel res = null; public MarcPassWord(String c) { super(c); setSize(ANCHO,ALTO); creaComponentes(); pack(); } private void creaComponents() { clau = new JPasswordField(20); et1= new JLabel(); // oyente para proceso de la acci\u00f3n del usuario clave.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent evt) { procesoAccionUser(evt); } }); // pone el campo de texto con la clave add(clau, BorderLayout.CENTER); // crea y pone la etiqueta en el marco et1.setFont(new java.awt.Font(\"Times New Roman\", 3, 12)); et1.setHorizontalAlignment(javax.swing.SwingConstants.CENTER); et1.setText(\"PASSWORD \"); et1.setToolTipText(\"Exemple\"); add(et1,BorderLayout.NORTH); // m\u00e9todo que se ejecuta al actuar el usuario sobre el campo private void procesoAccionUser(ActionEvent evt) { char pas[]; pas = clau.getPassword(); res= new JLabel(\" \"); res.setFont(new Font(\"Book Antiqua\", 3, 14)); if (pas.length == 0) { System.out.println(\"Teclejar Password \"); et1.setText(\"PASSWORD(teclejar) \"); } else { clau.setEditable(false); res.setText(\"Es valida la clau\"); } add(res, BorderLayout.SOUTH); validate(); pack(); } public static void main(String args[]) { MarcPassWord marc; marc = new MarcPassWord(\"Marc amb password\"); marc.setVisible(true); marc.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } } Resultat","title":"Exemple 11. Passwords i Labels"},{"location":"Tema%209.%20Gr%C3%A0fics%201.%20Java%20Swing/#jtextarea","text":"El component JTextArea s'utilitza amb la finalitat de mostrar moltes l\u00ednies de text; disposa de m\u00e8todes per fixar l'ample de cada l\u00ednia i l'acci\u00f3 a realitzar si la l\u00ednia que s'insereix \u00e9s major que l'ample prefixat; tamb\u00e9 permet decidir si es trenquen o no les paraules al canvi de l\u00ednia. Aquest component no disposa de barra d'scroll JScrollPane , cal crear l'scroll i associar-lo al component; per exemple: es crea el component areaText: JTextArea areaText = new JTextArea(); // A continuaci\u00f3 es crea l'scroll i s'associa a **areaText**: JScrollPane barra = new JScrollPane(areaText); // Per \u00faltim, l'scroll es posa al marc areaText.add(barra); Els constructors s\u00f3n: - JTextArea(): crea el component amb cadena nula, zero files i columnes. - JTextArea(int filas,int cols): crea amb cadena nula i el n\u00famero de files i columnes especificat. - JTextArea(String t): crea el component amb cadena t i zero files i columnes. - JTextArea(String t,int filas, int col): crea el component amb cadena t i el n\u00famero de files i columnes especificat. Els seus m\u00e8todes s\u00f3n: - public void append(String t): afegeix la cadena t al final del document. - public void insert(String t,int p): insereix la cadena t a partir de la posici\u00f3 p. - void replaceRange(String t, int inici, int fi): substitueix el text del document al rang inici-fi per la cadena t. - public void setColumns(int cols): fixa l'ample de cada l\u00ednia. - public void setLineWrap(boolean f): si f \u00e9s true activa el canvi autom\u00e0tica de l\u00ednia. - public void setWrapStyleWord(boolean f): si f \u00e9s true no 'trenca' les paraules en el canvi de l\u00ednia.","title":"JTextArea"},{"location":"Tema%209.%20Gr%C3%A0fics%202.%20Components%20i%20Events/","text":"Tema 9. Gr\u00e0fics 2. Components i Esdeveniments Introducci\u00f3 En aquest tema tractarem l'\u00fas dels esdeveniments per tal que la nostra aplicaci\u00f3 interactue amb l'usuari. Esdeveniment: All\u00f2 que s'esdev\u00e9. Fet considerat extraordinari o molt important en la vida d'una persona o col\u00b7lectivitat. Esdeveniment (Inform\u00e0tica): Fet que s'esdev\u00e9 o canvi d'un conjunt particular de circumst\u00e0ncies. En altres paraules un esdeveniment en una aplicaci\u00f3 inform\u00e0tica \u00e9s all\u00f3 que passa sense que necessariament estiga controlat al codi. Exemples d'esdeveniments: - Fer clic a un bot\u00f3. - Fer clic dins d'un textbox. - Minimitzar una finestra. - Escriure al teclat - etc Esdeveniments Arribats a aquest punt podriem tindre una interf\u00edcie totalment dissenyada per\u00f2 no completament funcional, \u00e9s a dir, imagineu que hem dissenyat la interf\u00edcie per a una calculadora amb tots els seus controls necessaris. Qu\u00e8 passa si fem clic en algun bot\u00f3 de la calculadora? No res ,veritat. Encara hem de programar el comportament d'aquesta calculadora i per tal d'aconseguir-ho hem de fer \u00fas de la programaci\u00f3 d'esdeveniments. Aquest procediment es diu Event Handling i es pot aplicar a aquells elements gr\u00e0fics que produeixen algun esdeveniment. Els esdeveniments s\u00f3n essencials per als usuaris interactuen amb els components de una aplicaci\u00f3 gr\u00e0fica; el model d'esdeveniments segueix el AWT de Java. Aquest cap\u00edtol estudia la forma general de captura d'esdeveniments, la jerarquia de classes del model i les interfaces desenvolupades per a la seva captura; inclou exemples senzills de captura d\u2019esdeveniments de los botons. Veiem un exemple import java.awt.*; import java.awt.event.*; import javax.swing.*; public class EventDemo { JLabel lab; public EventDemo () { JFrame jfrm = new JFrame (\"Esdeveniments\"); jfrm.setLayout(new FlowLayout()); jfrm.setSize(220,90); jfrm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JButton btnAlpha = new JButton(\"Alpha\"); JButton btnBeta = new JButton(\"Beta\" ); btnAlpha.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent ae) { lab.setText(\"Alpha Pressed\"); } }); btnBeta.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent ae) { lab.setText(\"Beta Pressed\"); } }); jfrm.add(btnAlpha); jfrm.add(btnBeta); lab = new JLabel(\"Apreta un bot\u00f3\"); jfrm.add(lab); jfrm.setVisible(true); } public static void main (String [] args) { SwingUtilities.invokeLater(new Runnable() { public void run() { new EventDemo(); } }); } } El resultat seria","title":"Tema 9. Gr\u00e0fics 2. Components i Esdeveniments"},{"location":"Tema%209.%20Gr%C3%A0fics%202.%20Components%20i%20Events/#tema-9-grafics-2-components-i-esdeveniments","text":"","title":"Tema 9. Gr\u00e0fics 2. Components i Esdeveniments"},{"location":"Tema%209.%20Gr%C3%A0fics%202.%20Components%20i%20Events/#introduccio","text":"En aquest tema tractarem l'\u00fas dels esdeveniments per tal que la nostra aplicaci\u00f3 interactue amb l'usuari. Esdeveniment: All\u00f2 que s'esdev\u00e9. Fet considerat extraordinari o molt important en la vida d'una persona o col\u00b7lectivitat. Esdeveniment (Inform\u00e0tica): Fet que s'esdev\u00e9 o canvi d'un conjunt particular de circumst\u00e0ncies. En altres paraules un esdeveniment en una aplicaci\u00f3 inform\u00e0tica \u00e9s all\u00f3 que passa sense que necessariament estiga controlat al codi. Exemples d'esdeveniments: - Fer clic a un bot\u00f3. - Fer clic dins d'un textbox. - Minimitzar una finestra. - Escriure al teclat - etc","title":"Introducci\u00f3"},{"location":"Tema%209.%20Gr%C3%A0fics%202.%20Components%20i%20Events/#esdeveniments","text":"Arribats a aquest punt podriem tindre una interf\u00edcie totalment dissenyada per\u00f2 no completament funcional, \u00e9s a dir, imagineu que hem dissenyat la interf\u00edcie per a una calculadora amb tots els seus controls necessaris. Qu\u00e8 passa si fem clic en algun bot\u00f3 de la calculadora? No res ,veritat. Encara hem de programar el comportament d'aquesta calculadora i per tal d'aconseguir-ho hem de fer \u00fas de la programaci\u00f3 d'esdeveniments. Aquest procediment es diu Event Handling i es pot aplicar a aquells elements gr\u00e0fics que produeixen algun esdeveniment. Els esdeveniments s\u00f3n essencials per als usuaris interactuen amb els components de una aplicaci\u00f3 gr\u00e0fica; el model d'esdeveniments segueix el AWT de Java. Aquest cap\u00edtol estudia la forma general de captura d'esdeveniments, la jerarquia de classes del model i les interfaces desenvolupades per a la seva captura; inclou exemples senzills de captura d\u2019esdeveniments de los botons. Veiem un exemple import java.awt.*; import java.awt.event.*; import javax.swing.*; public class EventDemo { JLabel lab; public EventDemo () { JFrame jfrm = new JFrame (\"Esdeveniments\"); jfrm.setLayout(new FlowLayout()); jfrm.setSize(220,90); jfrm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JButton btnAlpha = new JButton(\"Alpha\"); JButton btnBeta = new JButton(\"Beta\" ); btnAlpha.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent ae) { lab.setText(\"Alpha Pressed\"); } }); btnBeta.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent ae) { lab.setText(\"Beta Pressed\"); } }); jfrm.add(btnAlpha); jfrm.add(btnBeta); lab = new JLabel(\"Apreta un bot\u00f3\"); jfrm.add(lab); jfrm.setVisible(true); } public static void main (String [] args) { SwingUtilities.invokeLater(new Runnable() { public void run() { new EventDemo(); } }); } } El resultat seria","title":"Esdeveniments"}]}