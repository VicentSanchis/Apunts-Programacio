{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CONTINGUTS DEL CURS Tema 1. Introducci\u00f3 Programaci\u00f3 \u00cdNDEX 1. Introducci\u00f3: Hola m\u00f3n! Benvinguts al m\u00f3n de la programaci\u00f3. 2. Conceptes b\u00e0sics: els essencials per poder programar. 3. Fases de desenvolupament: an\u00e0lisi, disseny, codificaci\u00f3, prova i documentaci\u00f3. 4. Proc\u00e9s de compilaci\u00f3: Convertir codi en executables. 5. Entorns integrats de desenvolupament: aplicacions que faciliten la tasca de programar. Tema 2. Programaci\u00f3 Estructurada \u00cdNDEX 1. Introducci\u00f3: Qu\u00e8 \u00e9s la programaci\u00f3 estructurada i que suposa. 2. Conceptes b\u00e0sics: all\u00f2 essencial per poder comen\u00e7ar a entendre la programaci\u00f3. 3. Diagrames de flux: t\u00e8cnica gr\u00e0fica de disseny d'algorismes. 4. Estructures: Estructures derivades del Teorema d'estructura 5. Estructura seq\u00fcencial: una darrere de l'altra 6. Estructura selecci\u00f3: estructura per poder triar diversos fluxos d'execuci\u00f3 7. Estructura iterativa: estructura per poder repetir instruccions i fer bucles. Tema 03. El llenguatge Java \u00cdNDEX 1. Introducci\u00f3: Com apliquem tot all\u00f2 vist als temes anteriors a un llenguatge de programaci\u00f3 concret com es Java? 2. Dades, variables i identificadors: o com usem la informaci\u00f3 i les dades en un llenguatge de programaci\u00f3 3. Paraules reservades: aquelles paraules o mots propietat del llenguatge de programaci\u00f3 4. Tipus de dades: tipus d'informaci\u00f3 que pot usar el llenguatge i com 5. Variables: contenidors d'informaci\u00f3 amb una etiqueta i un tipus de dades associats 6. Constants: valors immutables durant l'execuci\u00f3 del programa 7. Comentaris: text no compilable i part de la documentaci\u00f3 de les aplicacions 8. Operadors i expressions: simbols utilitzats per fer operacions 9. Operador assignaci\u00f3: per donar valor a les expressions 10. Operadors aritm\u00e8tics: suma, resta, multiplicaci\u00f3, divisi\u00f3... 11. Operadors relacionals: major, menor, igual... 12. Operadors l\u00f2gics: and, or, not... 13. Estructures en Java: agrupacions de diferents tipus de dades 14. Eclipse: Entorn de programaci\u00f3 per a Java d'\u00fas general 15. Processing IDE: Entorn de programaci\u00f3 orientat a l'art Tema 04. Programaci\u00f3 Modular \u00cdNDEX 1. Introducci\u00f3: Qu\u00e8 \u00e9s el paradigma de programaci\u00f3 modular? 2. Caracter\u00edstiques: propietats principals del paradigma 3. Funcions en Java: Com dissenyar i utilitzar funcions en Java. 4. Arguments i par\u00e0metres: Valors que es passen als m\u00e8todes o funcions en Java 5. Declaraci\u00f3 i crida: Difer\u00e8ncies 6. Valor i refer\u00e8ncia: par\u00e0metres modificable o no. 7. Recursivitat: T\u00e8cnica de programaci\u00f3 modular. Tema 05. Tipus Compostos de Dades \u00cdNDEX 1. Introducci\u00f3: que s\u00f3n el tipus compostos de dades. 2. Arrays: declaraci\u00f3 i \u00fas, inicialitzaci\u00f3, bucles... 3. Algorismes de recerca: per tal de buscar elements coincidents dins d'un array 4. Algorismes d'ordenaci\u00f3: per ordenar un array segons algun criteri d'ordenaci\u00f3. 5. Arrays multidimensionals: arrays amb tres o m\u00e9s dimensions. 6. API de Java: tipus compostos de dades predefinits a Java. Tema 06. Programaci\u00f3 Orientada a Objectes \u00cdNDEX 1. Introducci\u00f3: Qu\u00e8 \u00e9s el paradigma de programaci\u00f3 orientada a objectes? 2. Caracter\u00edstiques: abstracci\u00f3, modularitat, encapsulament, jerarquia i polimorfisme 3. Classes i objectes: Difer\u00e8ncia entre classes i objectes. 4. Definici\u00f3 de classes en Java: Com declarar una classe en Java. 5. Propietats i m\u00e8todes: Membre principals de les classes a Java. 6. Instanciaci\u00f3 d'objectes: Com crear objectes a partir de les classes Java 7. Constructors: Funci\u00f3 principal per a la creaci\u00f3 d'objectes. Tema 07. Her\u00e8ncia, polimorfisme i interf\u00edcies \u00cdNDEX 1. Introducci\u00f3: Her\u00e8ncia i polimorfisme: t\u00e8cniques molt potents de POO. 2. Her\u00e8ncia: Mecanisme d'her\u00e8ncia en POO 3. Disseny de superclasses: super classes o classes pares 3. Disseny de subclasses: com fer classes derivades o subclasses d'una superclasses 4. Sobrec\u00e0rrega de constructors: un mateix constructor que realitza funcions diferents en diferent subclasses. 5. Polimorfisme: les mateixes funcions realitzant tasques diferents 6. Interf\u00edcies: prototips de funcions que serveixen per implementar classes noves. Tema 08. Entrada, eixida i excepcions \u00cdNDEX 1. Introducci\u00f3: Com es realitza la comunicaci\u00f3 de Java amb dispositius externs 2. Entrada i eixida b\u00e0siques: consola i fitxers b\u00e0sics. 3. Flux a nivell de byte: Streams de comunicaci\u00f3 a nivell de byte o baix nivell. 3. Flux a nivell de caracter: Streams de comunicaci\u00f3 a nivell de caracter o de nivell alt. 4. Persist\u00e8ncia d'objectes: Com desar objectes i estat a dispositius externs o fitxers. 5. Excepcions: Control d'errors en temps d'execuci\u00f3. Tema 09. Gr\u00e0fics. Java Swing \u00cdNDEX 1. Introducci\u00f3: disseny de formularis a nivell gr\u00e0fic. 2. Llibreria SWING: llibreria de disseny gr\u00e0fic amb Java 3. JFrame i JPanel: Controls principals en la creaci\u00f3 d'aplicacions gr\u00e0fiques. 3. Gestors de posicionament: controls que determinen la forma en la que es col\u00b7locaran els controls al formulari. 4. Controls: JLabel, JText... 5. Taules: Com treballar amb taules i SWING 6. Esdeveniments: Interacci\u00f3 amb l'usuari. Tema 10. Acc\u00e9s a dades \u00cdNDEX 1. Introducci\u00f3: com treballar amb Java i bases de dades relacionals. 2. Drivers: programari addicional necessari 3. JDBC: Java Database Connectivity 3. Connexi\u00f3 a la BD: Codi necessari per connectar a una BD 4. Realitzaci\u00f3 de consultes: SQL, Insert, Update, Select ...","title":"Index"},{"location":"#continguts-del-curs","text":"Tema 1. Introducci\u00f3 Programaci\u00f3 \u00cdNDEX 1. Introducci\u00f3: Hola m\u00f3n! Benvinguts al m\u00f3n de la programaci\u00f3. 2. Conceptes b\u00e0sics: els essencials per poder programar. 3. Fases de desenvolupament: an\u00e0lisi, disseny, codificaci\u00f3, prova i documentaci\u00f3. 4. Proc\u00e9s de compilaci\u00f3: Convertir codi en executables. 5. Entorns integrats de desenvolupament: aplicacions que faciliten la tasca de programar. Tema 2. Programaci\u00f3 Estructurada \u00cdNDEX 1. Introducci\u00f3: Qu\u00e8 \u00e9s la programaci\u00f3 estructurada i que suposa. 2. Conceptes b\u00e0sics: all\u00f2 essencial per poder comen\u00e7ar a entendre la programaci\u00f3. 3. Diagrames de flux: t\u00e8cnica gr\u00e0fica de disseny d'algorismes. 4. Estructures: Estructures derivades del Teorema d'estructura 5. Estructura seq\u00fcencial: una darrere de l'altra 6. Estructura selecci\u00f3: estructura per poder triar diversos fluxos d'execuci\u00f3 7. Estructura iterativa: estructura per poder repetir instruccions i fer bucles. Tema 03. El llenguatge Java \u00cdNDEX 1. Introducci\u00f3: Com apliquem tot all\u00f2 vist als temes anteriors a un llenguatge de programaci\u00f3 concret com es Java? 2. Dades, variables i identificadors: o com usem la informaci\u00f3 i les dades en un llenguatge de programaci\u00f3 3. Paraules reservades: aquelles paraules o mots propietat del llenguatge de programaci\u00f3 4. Tipus de dades: tipus d'informaci\u00f3 que pot usar el llenguatge i com 5. Variables: contenidors d'informaci\u00f3 amb una etiqueta i un tipus de dades associats 6. Constants: valors immutables durant l'execuci\u00f3 del programa 7. Comentaris: text no compilable i part de la documentaci\u00f3 de les aplicacions 8. Operadors i expressions: simbols utilitzats per fer operacions 9. Operador assignaci\u00f3: per donar valor a les expressions 10. Operadors aritm\u00e8tics: suma, resta, multiplicaci\u00f3, divisi\u00f3... 11. Operadors relacionals: major, menor, igual... 12. Operadors l\u00f2gics: and, or, not... 13. Estructures en Java: agrupacions de diferents tipus de dades 14. Eclipse: Entorn de programaci\u00f3 per a Java d'\u00fas general 15. Processing IDE: Entorn de programaci\u00f3 orientat a l'art Tema 04. Programaci\u00f3 Modular \u00cdNDEX 1. Introducci\u00f3: Qu\u00e8 \u00e9s el paradigma de programaci\u00f3 modular? 2. Caracter\u00edstiques: propietats principals del paradigma 3. Funcions en Java: Com dissenyar i utilitzar funcions en Java. 4. Arguments i par\u00e0metres: Valors que es passen als m\u00e8todes o funcions en Java 5. Declaraci\u00f3 i crida: Difer\u00e8ncies 6. Valor i refer\u00e8ncia: par\u00e0metres modificable o no. 7. Recursivitat: T\u00e8cnica de programaci\u00f3 modular. Tema 05. Tipus Compostos de Dades \u00cdNDEX 1. Introducci\u00f3: que s\u00f3n el tipus compostos de dades. 2. Arrays: declaraci\u00f3 i \u00fas, inicialitzaci\u00f3, bucles... 3. Algorismes de recerca: per tal de buscar elements coincidents dins d'un array 4. Algorismes d'ordenaci\u00f3: per ordenar un array segons algun criteri d'ordenaci\u00f3. 5. Arrays multidimensionals: arrays amb tres o m\u00e9s dimensions. 6. API de Java: tipus compostos de dades predefinits a Java. Tema 06. Programaci\u00f3 Orientada a Objectes \u00cdNDEX 1. Introducci\u00f3: Qu\u00e8 \u00e9s el paradigma de programaci\u00f3 orientada a objectes? 2. Caracter\u00edstiques: abstracci\u00f3, modularitat, encapsulament, jerarquia i polimorfisme 3. Classes i objectes: Difer\u00e8ncia entre classes i objectes. 4. Definici\u00f3 de classes en Java: Com declarar una classe en Java. 5. Propietats i m\u00e8todes: Membre principals de les classes a Java. 6. Instanciaci\u00f3 d'objectes: Com crear objectes a partir de les classes Java 7. Constructors: Funci\u00f3 principal per a la creaci\u00f3 d'objectes. Tema 07. Her\u00e8ncia, polimorfisme i interf\u00edcies \u00cdNDEX 1. Introducci\u00f3: Her\u00e8ncia i polimorfisme: t\u00e8cniques molt potents de POO. 2. Her\u00e8ncia: Mecanisme d'her\u00e8ncia en POO 3. Disseny de superclasses: super classes o classes pares 3. Disseny de subclasses: com fer classes derivades o subclasses d'una superclasses 4. Sobrec\u00e0rrega de constructors: un mateix constructor que realitza funcions diferents en diferent subclasses. 5. Polimorfisme: les mateixes funcions realitzant tasques diferents 6. Interf\u00edcies: prototips de funcions que serveixen per implementar classes noves. Tema 08. Entrada, eixida i excepcions \u00cdNDEX 1. Introducci\u00f3: Com es realitza la comunicaci\u00f3 de Java amb dispositius externs 2. Entrada i eixida b\u00e0siques: consola i fitxers b\u00e0sics. 3. Flux a nivell de byte: Streams de comunicaci\u00f3 a nivell de byte o baix nivell. 3. Flux a nivell de caracter: Streams de comunicaci\u00f3 a nivell de caracter o de nivell alt. 4. Persist\u00e8ncia d'objectes: Com desar objectes i estat a dispositius externs o fitxers. 5. Excepcions: Control d'errors en temps d'execuci\u00f3. Tema 09. Gr\u00e0fics. Java Swing \u00cdNDEX 1. Introducci\u00f3: disseny de formularis a nivell gr\u00e0fic. 2. Llibreria SWING: llibreria de disseny gr\u00e0fic amb Java 3. JFrame i JPanel: Controls principals en la creaci\u00f3 d'aplicacions gr\u00e0fiques. 3. Gestors de posicionament: controls que determinen la forma en la que es col\u00b7locaran els controls al formulari. 4. Controls: JLabel, JText... 5. Taules: Com treballar amb taules i SWING 6. Esdeveniments: Interacci\u00f3 amb l'usuari. Tema 10. Acc\u00e9s a dades \u00cdNDEX 1. Introducci\u00f3: com treballar amb Java i bases de dades relacionals. 2. Drivers: programari addicional necessari 3. JDBC: Java Database Connectivity 3. Connexi\u00f3 a la BD: Codi necessari per connectar a una BD 4. Realitzaci\u00f3 de consultes: SQL, Insert, Update, Select ...","title":"CONTINGUTS DEL CURS"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/","text":"Tema 1 - Introducci\u00f3 Programaci\u00f3 Hola m\u00f3n! Hola a tots i benvinguts al m\u00f3n de la programaci\u00f3. En aquest curs aprendrem com escriure codi utilitzant el llenguatge de programaci\u00f3 Java . Com podreu observar, programar b\u00e0sicament consisteix en poder comunicar-se amb una m\u00e0quina per tal que segueixi adequadament les instruccions que li donem, \u00e9s a dir, aprendre a programar \u00e9s aprendre un idioma nou , per\u00f2 no patiu, no es tracta d'un idioma com l'angl\u00e8s o el llenguatge musical, ja que per tal que aquesta comunicaci\u00f3 entre persona i m\u00e0quina siga eficient i efectiva, el llenguatge a aprendre ha de ser molt m\u00e9s simple i sobre tot lliure d'ambig\u00fcitats. Per\u00f2 no avancem esdeveniments. Millor comencem pel principi. Qu\u00e8 \u00e9s un programa? segons el DNV: Diccionari Normatiu Valencia Conjunt d'instruccions detallades i codificades que es donen a un sistema inform\u00e0tic perqu\u00e8 execute unes determinades operacions segons el Termcat: Centre de Terminologia en llengua catalana Conjunt de dades i d'instruccions codificades que s\u00f3n l'expressi\u00f3 completa d'un procediment que pot executar un sistema inform\u00e0tic Conclusi\u00f3 Podr\u00edem dir que programar \u00e9s l\u2019acci\u00f3 d\u2019elaborar un programa. En altres paraules un programa \u00e9s un conjunt d\u2019instruccions escrites en un llenguatge de programaci\u00f3 que s\u2019utilitzen per donar ordres o indicacions a un ordinador. El m\u00e9s paregut a programar que hi ha en el m\u00f3n real seria elaborar un conjunt d'instruccions de tal forma que una altra persona siga capa\u00e7 de llegir, interpretar i executar satisfact\u00f2riament obtenint un resultat. Una recepta de cuina per exemple \u00e9s un conjunt d'instruccions que qualsevol \u00e9s capa\u00e7 de llegir, interpretar i executar obtenint al final un resultat. Si seguim la met\u00e0fora de la recepta i la comparem amb un model de comunicaci\u00f3 cl\u00e0ssica els elements que ens podem trobar s\u00f3n: Origen: persona que diu les instruccions o ordres, el que escriu la recepta. Dest\u00ed: persona que les ha de llegir, interpretar i executar, el cuiner i el llenguatge usat (valenci\u00e0) Canal: medi f\u00edsic pel qual es transmet el missatge. Aire, televisi\u00f3, tel\u00e8fon, internet... Missatge: f\u00e0cil no? La recepta. Observa l'esquema seg\u00fcent: Doncs b\u00e9, en inform\u00e0tica tindr\u00edem els mateixos elements on l'origen seria el programador , el dest\u00ed l'ordinador , el llenguatge seria el llenguatge de programaci\u00f3 i el missatge seria el programa . Podriem concloure que aprendre a programar \u00e9s aprendre l'idioma que parlen els ordinadors per tal de poder comunicar-nos amb ells i donar-los ordres o instruccions. En aquest primer tema, veurem una s\u00e8rie de conceptes b\u00e0sics que seran necessaris per entendre que \u00e9s la programaci\u00f3. Conceptes b\u00e0sics Com ja hem explicat a la introducci\u00f3 d'aquest tema, programar consisteix en b\u00e0sicament donar ordres a un dispositiu mitjan\u00e7ant un algorisme en un llenguatge de programaci\u00f3 concret que a l'executar-se en una m\u00e0quina es converteix en programa . Veiem amb un poc m\u00e9s de detall aquests conceptes: Algorisme vs Programa Si el que farem en aquest curs \u00e9s programar, per qu\u00e8 parlem tant d'algorismes. Qu\u00e8 \u00e9s un algorisme? Quina difer\u00e8ncia hi ha entre un algorisme i un programa? En aquest primer tema treballarem tots aquests conceptes. Definici\u00f3 d'algorisme Un algorisme \u00e9s un conjunt ordenat i finit d\u2019operacions o instruccions a seguir que permeten trobar la soluci\u00f3 a un problema. Per exemple: algorisme de la suma, la resta, la multiplicaci\u00f3 o la divisi\u00f3. Per tal de fer una suma de xifres de m\u00e9s d\u2019un digit cadascuna, el que es diu comunament sumar portant, hem de seguir unes instruccions que si les realitzem de forma correcta, obtenim el resultat. Doncs b\u00e9, eixes \u2018instruccions\u2019 serien l\u2019algorisme. Un programa no \u00e9s m\u00e9s que un algorisme les \u2018instruccions\u2019 del qual les executa un ordinador. Caracter\u00edstiques Un algorisme posteriorment convertit a programa ha de complir una s\u00e8rie de caracter\u00edstiques: Finit: ha de comen\u00e7ar i acabar. Llegible: un programa s'escriu una vegada per\u00f2 es llig moltes. Modificable: ha de poder evolucionar. Eficient: No utilitza m\u00e9s recursos dels necessaris Modular: s'ha de dividir en parts el qual millora la legibilitat. Estructurat: utilitza les estructures del paradigma de la programaci\u00f3 estructurada. Algorisme del sandwich de Nutella Una de les dificultats inicials a l'hora d'aprendre a programar \u00e9s desfer-se de l'ambig\u00fcitat amb la s'utilitza el llenguatge natural, l'esser hum\u00e0 t\u00e9 la capacitat de contextualitzar i desambiguar per\u00f2 una m\u00e0quina no, per tant, \u00e9s necessari que el llenguatge amb el que es donen ordres a un ordinador, estiga lliure d'ambig\u00fcitat i siga el m\u00e9s exacte possible. A continuaci\u00f3 observa el seg\u00fcent v\u00eddeo on uns fills li donen instruccions \"precises\" al pare per tal que els faja un sandwich. Punxa ac\u00ed per veure el v\u00eddeo Activitat 101. Interpreta i reescriu l'algorisme Al v\u00eddeo anterior uns xiquets intenten explicar-li al pare els passos que ha de seguir per fer-los un sandwich. Intenta reescriure l'algorisme de com fer un sandwich de Nutella. \u00c9s molt important que tingues en compte els seg\u00fcents aspectes: Les instruccions han de ser breus i concises. les instruccions han d'anar adequades al seu destinatari. S'ha d'evitar en tot cas l'ambig\u00fcitat a les instruccions L'algorisme no pot ser m\u00e9s complicat que fer un sandwich. En acabar d'escriure l'algorisme, dona-lo a alg\u00fa i que intente seguir les instruccions per a veure que \u00e9s el que ix. Recorda advertir a la persona que t'ajude que siga el menys ambigua possible i que interprete el m\u00e9s estrictament possible que puga les instruccions que li has passat. Llenguatges programaci\u00f3 De la mateixa manera que dues persones es comuniquen entre s\u00ed utilitzant un llenguatge natural, una persona es comunica amb una m\u00e0quina utilitzant un llenguatge de programaci\u00f3. Evidentment, un llenguatge de programaci\u00f3 ha de ser m\u00e9s simple i gens ambigu al contrari de com passa amb els llenguatges naturals. Els llenguatges de programaci\u00f3 solen complir les seg\u00fcents caracter\u00edstiques: Existeix un nombre finit de paraules reservades que podem usar: per, var, int, mentre, repetir... \u00c9s a dir, un llenguatge de programaci\u00f3 t\u00e9 un conjunt l\u00e8xic de paraules amb un significat associat com passa amb els llenguatges naturals. Les frases com a combinaci\u00f3 de diferents paraules amb les que ens comuniquem en llenguatge natural es diuen instruccions Cada instrucci\u00f3 finalitza d\u2019una manera concreta, per exemple, utilitzant un \u2018;\u2019 per tal que la m\u00e0quina sapiga quan acaba una instrucci\u00f3 i comen\u00e7a una altra. Classificaci\u00f3 Els llenguatges de programaci\u00f3 es poden classificar segons els seg\u00fcents criteris PROXIMITAT A LA M\u00c0QUINA Les m\u00e0quines en realitat nom\u00e9s entenen 0 i 1, hi han llenguatges de programaci\u00f3 molts pr\u00f2xims a aquest tipus de codificaci\u00f3 bin\u00e0ria per\u00f2 que s\u00f3n complicats d\u2019entendre per un \u00e9sser hum\u00e0. D\u2019una altra banda existeixen llenguatges que utilitzen un conjunt de paraules reservades que fan que siga m\u00e9s f\u00e0cil d\u2019entendre per una persona. Al final de tot aquest llenguatge m\u00e9s pr\u00f2xim al llenguatge hum\u00e0 acaba convertint-se en una seq\u00fc\u00e8ncia de 0 i 1 la m\u00e0quina pot entendre en el proc\u00e9s de compilaci\u00f3 que veurem m\u00e9s endavant. Llenguatges de baix nivell: s\u00f3n els llenguatges m\u00e9s pr\u00f2xims al llenguatge m\u00e0quina com per exemple el llenguatge assemblador. Llenguatges de nivell mitj\u00e0: llenguatges que s\u2019aproximen un poc m\u00e9s al llenguatge natural utilitzant una s\u00e8rie de paraules reservades que s\u2019utilitzen en llenguatge natural com per exemple el llenguatge C Llenguatges d\u2019alt nivell: Els m\u00e9s pr\u00f2xims al llenguatge natural per\u00f2 sense ambig\u00fcitats. PROPOSIT DEL LLENGUATGE \u00c9s a dir segons quins tipus de programes poden generar, quina \u00e9s la seua finalitat. Llenguatges de prop\u00f2sit general: que s\u00f3n capa\u00e7os de crear qualsevol tipus de programa. Llenguatge C Llenguatges de prop\u00f2sit espec\u00edfic: que es dissenyen per realitzar una tasca m\u00e9s espec\u00edfica. SEGONS GENERACI\u00d3 Primera Generaci\u00f3: llenguatges m\u00e0quina i llenguatges assemblador. Anys 40 \u2013 50. En aquesta \u00e8poca s\u2019usaven targetes perforades i es programava utilitzant seq\u00fcencies d\u2019uns i zeros indicant quin c\u00e0lcul havien de realitzar els programes. Els llenguatges assemblador afegeixen la primera capa d\u2019abstracci\u00f3 sobre el binari de forma que una s\u00e8rie d\u2019instruccions simples s\u00f3n despr\u00e9s tradu\u00efdes a binari per la mateixa m\u00e0quina. Aquestes instruccions estaven directament relacionades amb el processador, \u00e9s a dir, cada processador tenia el seu conjunt d'instruccions propi. Segona Generaci\u00f3: Apareixen els llenguatges de nivell mitj\u00e0 i els primers compiladors, que per que ho entenem de moment, s\u00f3n els encarregats de traduir d\u2019un llenguatge de programaci\u00f3 a llenguatge m\u00e0quina o binari. Exemple de llenguatge de nivell mitj\u00e0: FORTRAN (FORmula TRANSlating system) de l\u2019any 1956 Tercera Generaci\u00f3: Apareix la programaci\u00f3 estructurada, ja no nom\u00e9s s\u2019utilitzen els llenguatges de programaci\u00f3 per realitzar c\u00e0lculs matem\u00e0tics com fins ara. Apareix tamb\u00e9 l\u2019\u00fas de variables, subprogrames, estructures etc.. En aquesta generaci\u00f3 podem trobar llenguatges de programaci\u00f3 com C, Pascal o Modula. Quarta Generaci\u00f3: En aquesta generaci\u00f3 trobarem llenguatges desenvolupats per crear un determinat tipus de programari, es configuren per tasques molt concretes. Cinquena Generaci\u00f3: on estarien els llenguatges dissenyats per afrontar la intel\u00b7lig\u00e8ncia artificial com per exemple Prolog. Comen\u00e7a tamb\u00e9 a posar-se en pr\u00e0ctica la programaci\u00f3 orientada a objectes com a nou paradigma de programaci\u00f3. Generaci\u00f3 Visual: nascuda a principis dels anys 90 i com a conseq\u00fc\u00e8ncia de la necessitat de usar interf\u00edcies cada vegada m\u00e9s amigables i f\u00e0cils. FORMA D'EXECUCI\u00d3 Com havien dit abans, abans d\u2019executar un programa escrit en un llenguatge de programaci\u00f3 qualsevol, s\u2019ha de traduir al llenguatge que pot entendre la m\u00e0quina, binari. Aquest proc\u00e9s es pot fer de dues formes: Llenguatges compilats: per tal de compilar un programa es realitzen les seg\u00fcents tasques: an\u00e0lisi l\u00e8xic, sint\u00e0ctic i sem\u00e0ntic del programa, traducci\u00f3 a codi objecte, enlla\u00e7 amb altres llibreries i creaci\u00f3 de l\u2019executable. El proc\u00e9s de compilaci\u00f3 \u00e9s un proc\u00e9s de traducci\u00f3 del llenguatge d'alt nivell utilitzat al llenguatge m\u00e0quina que pot entendre l'ordinador. Llenguatges interpretats: Aquest tipus de codis es lligen,Un diagrama de flux \u00e9s una representaci\u00f3 gr\u00e0fica d'un algorisme. S'utilitza en disciplines com la programaci\u00f3 inform\u00e0tica, l'economia, els processos industrials o la psicologia cognitiva. Aquests diagrames utilitzen s\u00edmbols amb significats ben definits que representen els passos de l'algorisme, i representen el flux d'execuci\u00f3 mitjan\u00e7ant fletxes que connecten els punts d'inici i de finalitzaci\u00f3. Un diagrama de flux sempre t\u00e9 un \u00fanic punt d'inici i un \u00fanic punt de finalitzaci\u00f3. A m\u00e9s, tot cam\u00ed d'execuci\u00f3 ha de permetre arribar des de l'inici fins al final. PARADIGMA DE PROGRAMACI\u00d3 Programaci\u00f3 estructurada: Utilitzen les estructures b\u00e0siques de programaci\u00f3: seq\u00fcencial, alternativa i iterativa combinats amb la programaci\u00f3 modular per dissenyar programes. Els exemples podrien ser C i Pascal. Programaci\u00f3 orientada a objectes: Entenen els programes com un conjunt d\u2019objectes que tenen unes caracter\u00edstiques pr\u00f2pies, uns m\u00e8todes i que interactuen amb els altres objectes que formen part del sistema. Entre aquests ens podrem trobar: C++ o Java SEGONS NOMBRE DE PROCESSOS \u00c9s a dir, si permeten la execuci\u00f3 concurrent, m\u00e9s d\u2019un proc\u00e9s al mateix temps o no. Per tant ens podem trobar: Llenguatges de programaci\u00f3 concurrents que permeten la concurr\u00e8ncia, \u00e9s a dir, aquells llenguatges de programaci\u00f3 que disposen de les eines necess\u00e0ries per definir i treballar amb diverses tasques (fils d'execuci\u00f3 o threads) dins del mateix programa. La concurr\u00e8ncia \u00e9s l'habilitat que t\u00e9 un ordinador per realitzar diverses tasques al mateix temps. Llenguatges de programaci\u00f3 no concurrents . Nom\u00e9s una tasca al mateix temps. SEGONS INTERACTIVITAT \u00c9s el procediment per escriure parts d'un programa mentre est\u00e0 actiu. Programaci\u00f3 interactiva . Modificaci\u00f3 d'un programa mentre aquest estiga actiu. El terme de programaci\u00f3 interactiva no t\u00e9 a veure amb l'estil en qu\u00e8 est\u00e0 escrit un programa, sin\u00f3 amb el proc\u00e9s d'escriptura del codi. VISUALS O NO Permeten la programaci\u00f3 per reutilitzaci\u00f3 de components mitjan\u00e7ant drag and drop en un entorn gr\u00e0fic o no. L'exemple m\u00e9s conegut \u00e9s l'Scratch. Activitat 102. Busca i classifica llenguatges de programaci\u00f3 Busca llenguatges de programaci\u00f3 que s'adequen a cadascuna de les categories que s'han descrit a l'apartat anterior. Per exemple: 1. Llenguatges de baix nivell: Assemblador. 2. Llenguatges de nivell mitja: C, Pascal MAPA MENTAL mindmap root ((LLENGUATGES)) Proximitat baix mitj\u00e0 alt Proposit general espec\u00edfic Execuci\u00f3 compilats interpretats Generaci\u00f3 1G 2G 3G 4G 5G Gen Visual Paradigma estructurats orientat a a objectes Processos concurrents No concurrents Visuals visuals No visuals Segons interactivitat Interactius No interactius Paraules reservades Els llenguatges de programaci\u00f3 utilitzen una s\u00e8rie de paraules o s\u00edmbols que fan una funci\u00f3 espec\u00edfica dins d\u2019un programa. A aquest conjunt de signes o combinaci\u00f3 d\u2019ells se les anomena paraules reservades. Aquestes paraules nom\u00e9s poden usar-se en un concepte determinat, mai lliurement per l\u2019usuari. Per exemple, el llenguatge C t\u00e9 com a paraules reservades if o while. Ambdues nom\u00e9s podran ser utilitzades en cas que es vullga iniciar una sent\u00e8ncia de control condicional o bucle. Paraules Reservades Les paraules reservades s\u00f3n identificadors o etiquetes reservades predefinides que tenen un significat especial i no es poden utilitzar com identificadors o etiquetes en els programes. Fases de desenvolupament d'una aplicaci\u00f3 A l\u2019hora d\u2019afrontar la realitzaci\u00f3 d\u2019un programa hem de tindre clar que hem de fer. \u00c9s un error comen\u00e7ar a crear programari a lo loco ja que nom\u00e9s aconseguirem dedicar a aquest menester m\u00e9s temps que el que es necessita. A m\u00e9s a m\u00e9s el proc\u00e9s de creaci\u00f3 d\u2019un programa no nom\u00e9s \u00e9s picar codi. D\u2019aquesta manera a l\u2019hora de construir un programa es deurien seguir una s\u00e8rie de fases o pautes. Aquestes fase s\u00f3n: an\u00e0lisi, disseny, codificaci\u00f3, prova i documentaci\u00f3 An\u00e0lisi del problema Estudi del problema, quina \u00e9s la seua finalitat, a qui va dirigit, quins elements ha d\u2019incloure, quines tasques ha de realitzar. En aquesta fase es realitzen entrevistes amb els usuaris o clients entre d\u2019altres t\u00e8cniques. La finalitat d\u2019aquesta fase \u00e9s fer un recull dels diferents requeriments que ha de tenir el nostre producte. Per tant al final d'aquesta fase deuriem tindre una llista amb els requisits que ha de tindre la nostra aplicaci\u00f3. Aquesta fase respon al QU\u00c8 del nostre projecte, es a dir, s'intenta esbrinar qu\u00e8 \u00e9s el que realment es necessita i s'arriba a una comprensi\u00f3 adequada dels requeriments del sistema . FruitApp - An\u00e0lisi Imaginem que ens disposem a fer una aplicaci\u00f3 que gestione la fruiteria del barri . En aquesta fase \u00e9s on hauriem d'esbrinar, entre altres coses: quins productes es venen, quin preu tenen, l'agenda de clients, quina informaci\u00f3 volem saber dels clients, quina informaci\u00f3 volem saber de prove\u00efdors etc. Suposem que ens farem c\u00e0rrec d'una part xicoteta d'aquesta aplicaci\u00f3: la introducci\u00f3 de tickets de compra nous . En aquesta fase, l'encarregat de la tenda, ens ha dit que necessitaria que els per cada client que compre es necessita un ticket, amb c\u00f2pia per al venedor, que mostrara el nom de la botiga , adre\u00e7a completa juntament amb la data i hora de la compra. A continuaci\u00f3 el ticket reflectir\u00e0 els productes que s'han comprat tenint en compte que s'ha de mostrar per cada producte: quantitat , nom del producte , preu per unitat i preu total (preu per unitat per quantitat). Finalment tamb\u00e9 ha de mostrar la base imposable , suma del total dels productes comprats, IVA (21%), descompte i preu total de la compra. Per acabar, al ticket tamb\u00e9 es reflectir\u00e0 la quantitat de diners rebuts per part del client i els diners que li hem tornat . Mira el seg\u00fcent exemple: Producte - An\u00e0lisi Requeriments del sistema o aplicaci\u00f3 en base a la informaci\u00f3 que hem aconseguit per mitjan\u00e7ant entrevistes, enquestes etc.. En altres paraules: el que ha de fer la nostra aplicaci\u00f3, finalitat, objectius. S'hauria de descriure detalladament el que realitza el sistema i com reacciona en les diferents situacions en les que ens podr\u00edem trobar. El producte d'aquesta fase podria ser per exemple una llista de requeriments a partir de la quan podrem comen\u00e7ar a treballar a la fase seg\u00fcent. 1. Els tiquets tindran una cap\u00e7alera amb la informaci\u00f3 de la botiga. 2. En la cap\u00e7alera tamb\u00e9 es reflectir\u00e0 la data i hora en que s'ha fet la compra. 3. Per cada producte que es compre, hem de coneixer el nom del producte, la quantitat, el preu unitari i el total. 4. Cada l\u00ednia del tiquet nom\u00e9s mostra informaci\u00f3 relativa a un producte. 5. Una vegada tancada la compra, es mostrar\u00e0 un footer que tindra: preu, IVA, descompte i preu final. 6. El preu o base imposable \u00e9s la suma del total de cadascuna de les l\u00ednies de productes anteriors 7. L'IVA \u00e9s del 21% 8. El descompte \u00e9s un percentatge que s'aplica al preu total amb IVA i que podria anar des del 0% fins al 15%. 9. Del c\u00e0lcul anterior obtindrem el preu total que ha de pagar el client. 10. Es guardar\u00e0 informaci\u00f3 al sistema de la quantitat de diners que ha entregat el client. 11. Al tiquet tamb\u00e9 es mostrar\u00e0 quin \u00e9s el canvi que se li ha tornat a client. 12. Finalment el tiquet s'imprimir\u00e0 en paper per duplicat: un per al client i un per a la botiga. Disseny de l'algorisme Es refereix a com anem a solucionar els requeriments obtinguts a la fase anterior. En aquesta fase s'estudien possibles opcions d'implementaci\u00f3 per a l'aplicaci\u00f3 que hem de construir, aix\u00ed com decidir l'estructura general de la mateixa. El disseny \u00e9s una etapa complexa i el seu proc\u00e9s s'ha de realitzar d'una forma iterativa. Es possible que la soluci\u00f3 inicial no siga la m\u00e9s adequada, per tant en tal cas s'hauria de redefinir. Tanmateix, hi ha cat\u00e0legs de patrons de disseny molt \u00fatils que recullen errades que altres han com\u00e9s per no caure a la mateixa trampa. Aquesta fase respon al QUAN del nostre projecte. FruitApp - Disseny Continuant en la nostra aplicaci\u00f3 de la fruiteria , en aquesta fase i una vegada acabada la fase d'an\u00e0lisi d'on s'obtenen els requeriments, hauriem de, per un costat triar el paradigma de programaci\u00f3 que escollirem: programaci\u00f3 estructurada o programaci\u00f3 orientada a objectes (Normalment aquest \u00faltim). El llenguatge de programaci\u00f3 a utilitzar. Una vegada ja ho hem triat, hem de decidir com el nostre programa va a complir amb els requeriments obtinguts a la fase d'analisi, \u00e9s a dir, com crearem el nou ticket de compra, com afegirem els productes i com calcularem el preu final i imprimirem el document. Producte - Disseny Si hem triat el paradigma de programaci\u00f3 estructurada hauriem de dissenyar els diagrames flux de les diferents funcionalitats de l'aplicaci\u00f3, el pseudocodi, etc.. Aquestes funcionalitats s'hauran de deduir dels requeriments de la fase anterior. Per exemple, si utilitzem el paradigma de programaci\u00f3 estructurada, en aquesta fase es dissenyaria l'algorisme en pseudocodi o diagrama de flux de cadascuna de les funcionalitats que ha de tindre la nostra aplicaci\u00f3. \u00c9s a dir, si FruitApp ha de poder, crear tickets nous, cobrar i calcular les tornes, hauriem de dissenyar dos diagrames de flux, un per a cada funcionalitat. En canvi, si pel contrari escollim el paradigma de programaci\u00f3 orientada a objectes obtindriem casos d'\u00fas, diagrames de classes, diagrames de comportament en UML. Un resultat possible d'aquesta fase \u00e9s l'algorisme que resol el problema. Seguint l'exemple de les receptes anteriors, una possible soluci\u00f3 a aquesta fase seria: 1. Obre un nou ticket. 2. Agafa el primer producte que porta el client 3. Selecciona el producte al sistema inform\u00e0tic. 4. Pesa o compta la quantitat de producte que vol comprar. 5. Introdueix les dades anteriors. 6. Repeteix els passos 2, 3, 4 i 5 mentre queden productes per enregistrar. 7. Aplica descompte en cas necessari. 8. Tanca el ticket. 9. Imprimeix el ticket. Codificaci\u00f3 Ha arribat el moment de picar codi . A la fase de codificaci\u00f3, ens arriben els documents (pseudocodi, flux, diagrames de classes, UML) necessaris per poder comen\u00e7ar a programar . En aquesta fase hem d'escollir les eines (IDEs) adequades per poder desenvolupar el nostre projecte i tamb\u00e9 escollirem (va lligat en realitat) el llenguatge de programaci\u00f3 FruitApp - Codificaci\u00f3 Seguint amb la fruiteria i suposant que ens han passat un diagrama de flux, pseudocodi o diferents diagrames en UML de la nostra aplicaci\u00f3 de generaci\u00f3 de tickets, podriem per exemple triar l'IDE Visual Studio Code i C# com a llenguatge de programaci\u00f3 o l'IDE Eclipse i Java o Visual Studio i Java, per despr\u00e9s, traduir de la t\u00e8cnica de disseny utilitzada a un llenguatge de programaci\u00f3 concret. Producte - Codificaci\u00f3 El projecte amb tots els fitxers que tenen el codi desenvolupat aix\u00ed com tamb\u00e9 els executables o binaris ja compilats i funcionant. 1 2 3 4 5 6 7 8 9 Ticket t = new Ticket (); while ( quedenProductesPerPesar ) { Producte p = new Producte ( \"Nom\" ); p . pesa (); t . afegir ( p ); } t . aplicaDescompte ( 10 ); t . close (); t . print (); Prova i depuraci\u00f3 Com que errar es d'humans , la fase de proves del cicle de vida de programari busca detectar els errors comesos en les etapes anteriors per tal de poder corregir-los. Per suposat, all\u00f2 ideal \u00e9s fer-ho abans que l'usuari final se'ls trobe. Es diu que una prova amb exit \u00e9s una prova que detecta algun error. Seguint amb la nostra aplicaci\u00f3 podria passar que una vegada posada en marxa ens adonem que no hem contemplat la possibilitat d'esborrar l\u00ednies del ticket. Com ho solucionariem? Primer agafariem el diagrama de flux d'aquesta funci\u00f3 i el modificariem per tal que s'adapte a la nova realitat. Despr\u00e9s hauriem de modificar el codi a la fase de codificaci\u00f3 per tornar finalment a la fase de prova i depuraci\u00f3. Documentaci\u00f3 Aquesta \u00e9s la fase que a cap programador li agrada fer, per\u00f2 en realitat \u00e9s una fase que no est\u00e0 necess\u00e0riament al final del cicle de vida del programa, sino que es fa de forma transversal en totes les etapes del desenvolupament. Es considera documentaci\u00f3 des dels requeriments inicials al manual d'usuari passant per el pseudocodi, diagrames de classes i \u00fas, i tamb\u00e9 els comentaris que es posen al codi. Activitat 103. Simula les fases de desenvolupament software Imagina que tens el projecte d'una aplicaci\u00f3 t\u00e9 com a finalitat gestionar les diverses llistes de compra que poden haver a una casa. Simula que passes per cadascuna de les fases de desenvolupament de programari vistes a l'apartat anterior i genera tota la documentaci\u00f3 necess\u00e0ria. Considera que la fase d'an\u00e0lisi l'has de fer a partir d'aquest enunciat, \u00e9s a dir, els requeriments o requisits d'aquesta fase els haur\u00e0s de treure d'ac\u00ed. La idea \u00e9s tenir una app que controle les diverses llistes de compra que pots tindre a casa. B\u00e0sicament seria digitalitzar la t\u00edpica llibreta que hi ha, normalment, a la nevera on anotem aquelles coses que hem de comprar la propera vegada que anem al supermercat, per exemple: si estem cuinant i veiem que no hi ha: ous, sal o oli; o anotem a la llibreta per comprar-ho. O si estem posant la llavador i s'acaba el suavitzant, o anotem per tal de recordar-nos de comprar-ho. Quan s'obre l'aplicaci\u00f3 m'apareix una primera pantalla amb les llistes, que es diferencien pel nom que tenen, de la compra que tinc. Una vegada seleccione la llista que vull, m'apareix un llistat amb els productes que tinc pendent per comprar. En aquesta mateixa pantalla he de poder afegir productes o esborrar-los si ja els he comprat. Com podeu observar \u00e9s una aplicaci\u00f3 relativament senzilla . A l'hora de fer aquesta activitat, vos aconselle que la manteniu all\u00f2 m\u00e9s senzilla possible per tal de poder fer-la correctament. Proc\u00e9s de compilaci\u00f3 \u00c9s el proc\u00e9s pel qual es tradueixen les instruccions escrites en un determinat llenguatge de programaci\u00f3 a llenguatge m\u00e0quina. A m\u00e9s d'un traductor, es poden necessitar altres programes per crear un programa objecte executable. Un programa font es pot dividir en m\u00f2duls emmagatzemats en arxius diferents. La tasca de reunir el programa font sovint es confia a un programa diferent, anomenat preprocessador. El preprocessador tamb\u00e9 pot expandir abreviatures, crides a macros, a proposicions del llenguatge font. Normalment la creaci\u00f3 d'un programa executable (un t\u00edpic.exe per a Microsoft Windows o DOS) comporta dos passos. El primer pas es diu compilaci\u00f3 ( pr\u00f2piament dit) i tradueix el codi font escrit en un llenguatge de programaci\u00f3 emmagatzemat en un arxiu a codi de baix nivell (normalment en codi objecte, no directament a llenguatge m\u00e0quina). El segon pas es diu enlla\u00e7at en el qual s'enlla\u00e7a el codi de baix nivell generat de tots els fitxers i subprogrames que s'han enviat compilar i s'afegeix el codi de les funcions que hi ha a les biblioteques del compilador perqu\u00e8 l'executable pugui comunicar-se directament amb el sistema operatiu, traduint aix\u00ed finalment el codi objecte a codi m\u00e0quina, i generant un m\u00f2dul executable. Aquests dos passos es poden fer per separat, emmagatzemant el resultat de la fase de compilaci\u00f3 en arxius objectes (un t\u00edpic .obj per a Microsoft Windows, DOS o per a Unix ), per a enlla\u00e7ar-los en fases posteriors, o crear directament l'executable, amb la qual cosa la fase de compilaci\u00f3 s'emmagatzema nom\u00e9s temporalment. Un programa podria tenir parts escrites en diversos llenguatges (per exemple C, C + + i Asm), que es podrien compilar de forma independent i despr\u00e9s enlla\u00e7ar juntes per formar un \u00fanic m\u00f2dul executable. IDE's Un entorn de desenvolupament integrat o IDE (de l'angl\u00e8s Integrated Development Environment) \u00e9s una eina inform\u00e0tica per al desenvolupament de programari de manera c\u00f2moda i r\u00e0pida. Aix\u00ed doncs \u00e9s un entorn de desenvolupament que agrupa diferents funcions en un sol programa, habitualment: editor de codi, compilador, depurador i un programa de disseny d'interf\u00edcie gr\u00e0fica. Els IDE estan dissenyats per maximitzar la productivitat del programador proporcionant components molt units amb interf\u00edcies d'usuari similars. Els IDE presenten un \u00fanic programa en qu\u00e8 es porta a terme tot el desenvolupament. Generalment, aquest programa sol oferir moltes caracter\u00edstiques per a la creaci\u00f3, modificaci\u00f3, compilaci\u00f3, implementaci\u00f3 i depuraci\u00f3 de programari. Durant el curs utilitzarem principalment dos IDEs: Processing IDE i Eclipse IDE . Una alternativa a Eclipse pot ser tamb\u00e9 Visual Studio Code Processing IDE Processing \u00e9s un llenguatge de programaci\u00f3 i entorn de desenvolupament integrat de codi obert basat en Java, de f\u00e0cil utilitzaci\u00f3, i que serveix com a mitj\u00e0 per a l'ensenyament i la producci\u00f3 de projectes multim\u00e8dia i interactius de disseny digital. Va ser iniciat per Ben Fry i Casey Reas, ambd\u00f3s membres d'Aesthetics and Computation Group del MIT Media Lab dirigit per John Maeda. Un dels objectius declarats de Processing \u00e9s actuar com a eina perqu\u00e8 artistes, dissenyadors visuals i membres d'altres comunitats aliens al llenguatge de la programaci\u00f3, n'aprenguessin les bases a trav\u00e9s d'una mostra gr\u00e0fica instant\u00e0nia i visual de la informaci\u00f3. El llenguatge de Processing es basa en Java, tot i que fa servir una sintaxi simplificada i un model de programaci\u00f3 de gr\u00e0fics. Caracter\u00edstiques Processing inclou una finestra visual com a complement al contorn de l'entorn de desenvolupament integrat (IDE) per organitzar-les als projectes. Cada esquema de Processing \u00e9s en realitat una subclasse de PApplet, un tipus Java que posa en funcionament la majoria de les caracter\u00edstiques del llenguatge del Processing. En programar a Processing, totes les classes addicionals definides seran tractades com a classes internes quan el codi es tradueix en pur Java abans de compilar. Aix\u00f2 vol dir que l'\u00fas de variables est\u00e0tiques i m\u00e8todes de les classes est\u00e0 prohibit llevat que s'indiqui espec\u00edficament a Processing qu\u00e8 vol el codi en mode pur Java. Processing tamb\u00e9 permet als usuaris crear les seves pr\u00f2pies classes de PApplet a la finestra. Aix\u00f2 permet que els tipus de dades complexes puguin incloure qualsevol nombre d'arguments i evita les limitacions a l'\u00fas de tipus de dades est\u00e0ndard com int (sencer), char (car\u00e0cters), float (nombre real) o color (RGB, hexadecimal ARGB). Estructura en Processing IDE Per tal de treballar amb les estructures b\u00e0siques del paradigma de programaci\u00f3 estructurada, utilitzarem Processing IDE que \u00e9s un IDE lleuger que ens permet programar en Java sense necessitat de fer estructures de classes molt complexes. Concretament Processing IDE \u00e9s un entorn integrat de desenvolupament juntament amb una llibreria gr\u00e0fica que inicialment es va construir per a arts electr\u00f2niques i disseny visual per tal de poder ensenyar els fonaments de la programaci\u00f3 a no-programadors en un context visual. \u00c9s per aix\u00f2 que aquesta eina ens resultar\u00e0 molt \u00fatil per tal d'aprendre els conceptes b\u00e0sics de la programaci\u00f3 estructurada. A continuaci\u00f3 vos mostrem un exemple d'estructura de programa en Processing IDE 1 2 3 4 5 6 7 8 9 10 11 12 13 // Refer\u00e8ncies a altres llibreries. // Variables globals a l'aplicaci\u00f3. // Funci\u00f3 setup: nom\u00e9s s'executa una vegada a l'inici de l'execuci\u00f3. void setup () { // Sent\u00e8ncies d'inicialitzaci\u00f3 de la nostra aplicaci\u00f3. } // Funci\u00f3 draw: s'executa 60 vegades per segon (60Hz freq\u00fc\u00e8ncia del monitor) void draw () { // Codi principal del programa. } // Declaraci\u00f3 d'altres funcions Activitat 104. Instal\u00b7la Processing IDE Descarrega l'aplicaci\u00f3 Processing IDE de la seua p\u00e0gina oficial i instal\u00b7la-la al teu ordinador. Despr\u00e9s copia i apega qualsevol codi (compatible amb Processing IDE) que trobes per Internet i prova el que passa. Fes-li modificacions al codi per que actue de forma diferent a l'original. Eclipse IDE Eclipse \u00e9s una plataforma de programari compost per un conjunt d'eines de programaci\u00f3 de codi obert multiplataforma per desenvolupar el que el projecte anomena \"Aplicacions de Client Enriquit\", oposat a les aplicacions \"Client-lleuger\" basades en navegadors. Aquesta plataforma, t\u00edpicament ha estat usada per desenvolupar entorns de desenvolupament integrats (de l'angl\u00e8s IDE), com l'IDE de Java anomenat Java Development Toolkit (JDT) i el compilador (ECJ) que es lliura com a part d'Eclipse (i que s\u00f3n usats tamb\u00e9 per desenvolupar el mateix Eclipse). Eclipse tamb\u00e9 \u00e9s una comunitat d'usuaris, estenent constantment les \u00e0rees d'aplicaci\u00f3 cobertes. Un exemple \u00e9s el recentment creat Eclipse Modeling Project, cobrint gaireb\u00e9 totes les \u00e0rees de Model Driven Engineering. Eclipse va ser desenvolupat originalment per IBM com el successor de la seva fam\u00edlia d'eines per a VisualAge. Eclipse \u00e9s ara desenvolupat per la Fundaci\u00f3 Eclipse, una organitzaci\u00f3 independent sense \u00e0nim de lucre que fomenta una comunitat de codi obert i un conjunt de productes complementaris, capacitats i serveis. Eclipse va ser alliberat originalment sota la Common Public License, per\u00f2 despr\u00e9s va ser re-llicenciat sota l'Eclipse Public License. La Free Software Foundation ha dit que ambdues llic\u00e8ncies s\u00f3n llic\u00e8ncies de programari lliure, per\u00f2 s\u00f3n incompatibles amb Llic\u00e8ncia p\u00fablica general de GNU (GNU GPL). Estructura d'un programa en Java El primer que s'ha de tenir en compte \u00e9s que tot programa escrit en Java ha de tindre almenys un main() a la classe principal per tal que s'execute. En resum, un programa escrit en Java ha de tindre: Declaracions d'importaci\u00f3 de paquets o inclusi\u00f3 d'altres llibreries. Declaracions de les classes que el formen. El m\u00e8tode main M\u00e8todes definits pels usuaris dins de les classes. Comentaris. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // Programa principal // Llibreries amb funcions d'entrada i eixida. import java.io.* ; // Nom de la classe principal public class nomPrograma { // Membres de la classe (una calculadora) Calculadora calc ; // M\u00e8tode principal main public static void main ( String [] args ) { // Instruccions del m\u00e8tode principal. calc = new Calculadora (); int result = calc . suma ( 10 , 20 ); System . out . println ( \"Resultat: \" + result ); } } // Una altra classe import java.io.* ; // Nom de la classe public class Calculadora { // M\u00e8tode de la classe public int suma ( int a , int b ) { return a + b ; } } Al programa anterior podem trobar una classe 'nomPrograma' que cont\u00e9 el m\u00e8tode principal main i que al mateix temps cont\u00e9 el conjunt d'instruccions que es van a executar de forma seq\u00fcencial al nostre programa. Aquesta classe nomPrograma t\u00e9 un membre calc que \u00e9s un objecte (ja veurem classes i objectes m\u00e9s endavant) de tipus calculadora i que est\u00e0 definit m\u00e9s endavant amb la classe p\u00fablica calculadora. Les sent\u00e8ncies que executa el nostre programa d'exemple s\u00f3n les seg\u00fcents: Instancia l'objecte calc (calc = new Calculadora()). Declara una variable de tipus enter result Crida al m\u00e8tode suma de l'objecte calc passant-li els par\u00e0metres 10 i 20 Deposita el resultat que retorna el m\u00e8tode suma de la classe calc a la variable result Mostra per pantalla el resultat de la suma. Activitat 105. Instal\u00b7la Eclipse IDE for Developers Descarrega l'IDE d'Eclipse de la seua p\u00e0gina oficial i instal\u00b7la'l a la teua m\u00e0quina. Despr\u00e9s intenta crear un projecte amb una sola classe i prova d'executar.","title":"1.- Introducci\u00f3 programaci\u00f3"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#tema-1-introduccio-programacio","text":"","title":"Tema 1 - Introducci\u00f3 Programaci\u00f3"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#hola-mon","text":"Hola a tots i benvinguts al m\u00f3n de la programaci\u00f3. En aquest curs aprendrem com escriure codi utilitzant el llenguatge de programaci\u00f3 Java . Com podreu observar, programar b\u00e0sicament consisteix en poder comunicar-se amb una m\u00e0quina per tal que segueixi adequadament les instruccions que li donem, \u00e9s a dir, aprendre a programar \u00e9s aprendre un idioma nou , per\u00f2 no patiu, no es tracta d'un idioma com l'angl\u00e8s o el llenguatge musical, ja que per tal que aquesta comunicaci\u00f3 entre persona i m\u00e0quina siga eficient i efectiva, el llenguatge a aprendre ha de ser molt m\u00e9s simple i sobre tot lliure d'ambig\u00fcitats. Per\u00f2 no avancem esdeveniments. Millor comencem pel principi. Qu\u00e8 \u00e9s un programa? segons el DNV: Diccionari Normatiu Valencia Conjunt d'instruccions detallades i codificades que es donen a un sistema inform\u00e0tic perqu\u00e8 execute unes determinades operacions segons el Termcat: Centre de Terminologia en llengua catalana Conjunt de dades i d'instruccions codificades que s\u00f3n l'expressi\u00f3 completa d'un procediment que pot executar un sistema inform\u00e0tic Conclusi\u00f3 Podr\u00edem dir que programar \u00e9s l\u2019acci\u00f3 d\u2019elaborar un programa. En altres paraules un programa \u00e9s un conjunt d\u2019instruccions escrites en un llenguatge de programaci\u00f3 que s\u2019utilitzen per donar ordres o indicacions a un ordinador. El m\u00e9s paregut a programar que hi ha en el m\u00f3n real seria elaborar un conjunt d'instruccions de tal forma que una altra persona siga capa\u00e7 de llegir, interpretar i executar satisfact\u00f2riament obtenint un resultat. Una recepta de cuina per exemple \u00e9s un conjunt d'instruccions que qualsevol \u00e9s capa\u00e7 de llegir, interpretar i executar obtenint al final un resultat. Si seguim la met\u00e0fora de la recepta i la comparem amb un model de comunicaci\u00f3 cl\u00e0ssica els elements que ens podem trobar s\u00f3n: Origen: persona que diu les instruccions o ordres, el que escriu la recepta. Dest\u00ed: persona que les ha de llegir, interpretar i executar, el cuiner i el llenguatge usat (valenci\u00e0) Canal: medi f\u00edsic pel qual es transmet el missatge. Aire, televisi\u00f3, tel\u00e8fon, internet... Missatge: f\u00e0cil no? La recepta. Observa l'esquema seg\u00fcent: Doncs b\u00e9, en inform\u00e0tica tindr\u00edem els mateixos elements on l'origen seria el programador , el dest\u00ed l'ordinador , el llenguatge seria el llenguatge de programaci\u00f3 i el missatge seria el programa . Podriem concloure que aprendre a programar \u00e9s aprendre l'idioma que parlen els ordinadors per tal de poder comunicar-nos amb ells i donar-los ordres o instruccions. En aquest primer tema, veurem una s\u00e8rie de conceptes b\u00e0sics que seran necessaris per entendre que \u00e9s la programaci\u00f3.","title":"Hola m\u00f3n!"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#conceptes-basics","text":"Com ja hem explicat a la introducci\u00f3 d'aquest tema, programar consisteix en b\u00e0sicament donar ordres a un dispositiu mitjan\u00e7ant un algorisme en un llenguatge de programaci\u00f3 concret que a l'executar-se en una m\u00e0quina es converteix en programa . Veiem amb un poc m\u00e9s de detall aquests conceptes:","title":"Conceptes b\u00e0sics"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#fases-de-desenvolupament-duna-aplicacio","text":"A l\u2019hora d\u2019afrontar la realitzaci\u00f3 d\u2019un programa hem de tindre clar que hem de fer. \u00c9s un error comen\u00e7ar a crear programari a lo loco ja que nom\u00e9s aconseguirem dedicar a aquest menester m\u00e9s temps que el que es necessita. A m\u00e9s a m\u00e9s el proc\u00e9s de creaci\u00f3 d\u2019un programa no nom\u00e9s \u00e9s picar codi. D\u2019aquesta manera a l\u2019hora de construir un programa es deurien seguir una s\u00e8rie de fases o pautes. Aquestes fase s\u00f3n: an\u00e0lisi, disseny, codificaci\u00f3, prova i documentaci\u00f3","title":"Fases de desenvolupament d'una aplicaci\u00f3"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#proces-de-compilacio","text":"\u00c9s el proc\u00e9s pel qual es tradueixen les instruccions escrites en un determinat llenguatge de programaci\u00f3 a llenguatge m\u00e0quina. A m\u00e9s d'un traductor, es poden necessitar altres programes per crear un programa objecte executable. Un programa font es pot dividir en m\u00f2duls emmagatzemats en arxius diferents. La tasca de reunir el programa font sovint es confia a un programa diferent, anomenat preprocessador. El preprocessador tamb\u00e9 pot expandir abreviatures, crides a macros, a proposicions del llenguatge font. Normalment la creaci\u00f3 d'un programa executable (un t\u00edpic.exe per a Microsoft Windows o DOS) comporta dos passos. El primer pas es diu compilaci\u00f3 ( pr\u00f2piament dit) i tradueix el codi font escrit en un llenguatge de programaci\u00f3 emmagatzemat en un arxiu a codi de baix nivell (normalment en codi objecte, no directament a llenguatge m\u00e0quina). El segon pas es diu enlla\u00e7at en el qual s'enlla\u00e7a el codi de baix nivell generat de tots els fitxers i subprogrames que s'han enviat compilar i s'afegeix el codi de les funcions que hi ha a les biblioteques del compilador perqu\u00e8 l'executable pugui comunicar-se directament amb el sistema operatiu, traduint aix\u00ed finalment el codi objecte a codi m\u00e0quina, i generant un m\u00f2dul executable. Aquests dos passos es poden fer per separat, emmagatzemant el resultat de la fase de compilaci\u00f3 en arxius objectes (un t\u00edpic .obj per a Microsoft Windows, DOS o per a Unix ), per a enlla\u00e7ar-los en fases posteriors, o crear directament l'executable, amb la qual cosa la fase de compilaci\u00f3 s'emmagatzema nom\u00e9s temporalment. Un programa podria tenir parts escrites en diversos llenguatges (per exemple C, C + + i Asm), que es podrien compilar de forma independent i despr\u00e9s enlla\u00e7ar juntes per formar un \u00fanic m\u00f2dul executable.","title":"Proc\u00e9s de compilaci\u00f3"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#ides","text":"Un entorn de desenvolupament integrat o IDE (de l'angl\u00e8s Integrated Development Environment) \u00e9s una eina inform\u00e0tica per al desenvolupament de programari de manera c\u00f2moda i r\u00e0pida. Aix\u00ed doncs \u00e9s un entorn de desenvolupament que agrupa diferents funcions en un sol programa, habitualment: editor de codi, compilador, depurador i un programa de disseny d'interf\u00edcie gr\u00e0fica. Els IDE estan dissenyats per maximitzar la productivitat del programador proporcionant components molt units amb interf\u00edcies d'usuari similars. Els IDE presenten un \u00fanic programa en qu\u00e8 es porta a terme tot el desenvolupament. Generalment, aquest programa sol oferir moltes caracter\u00edstiques per a la creaci\u00f3, modificaci\u00f3, compilaci\u00f3, implementaci\u00f3 i depuraci\u00f3 de programari. Durant el curs utilitzarem principalment dos IDEs: Processing IDE i Eclipse IDE . Una alternativa a Eclipse pot ser tamb\u00e9 Visual Studio Code","title":"IDE's"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/","text":"Tema 2 - Programaci\u00f3 Estructurada Introducci\u00f3 A l'inici dels temps del la inform\u00e0tica moderna segona meitat dels segle XX i considerant ordinador programable aquell que seguia l'arquitectura de von Neumann , els primers programes s'escrivien en binari (llenguatge m\u00e0quina) en targetes perforades. Aquestes targetes perforades s'utilitzaven per escriure programes sencers amb una finalitat molt concreta . Les targetes s'utilitzaven com a entrada de dades a la m\u00e0quina que s'encarregava de llegir les instruccions escrites en binari, i una a una, carregar-les a mem\u00f2ria i executar-les. Un problema d'aquest incipient paradigma de programaci\u00f3 \u00e9s que cada conjunt d'instruccions \u00e9s espec\u00edfic a cada m\u00e0quina. Amb el temps i conforme augmenta la capacitat de computaci\u00f3 dels ordinadors i tamb\u00e9 la complexitat dels programes, les targetes deixen de ser funcionals i apareixen els primers llenguatges de programaci\u00f3 generalistes com FORTRAN, COBOL o LISP per\u00f2 aquests encara no utilitzen el paradigma de programaci\u00f3 estructurada. A la decada dels anys 60, B\u00f6hm i Jacopini escriuen el teorema de la programaci\u00f3 estructurada, basant-se per suposat en part en aquells llenguatges de programaci\u00f3 que ja existien, i arriben a la conclusi\u00f3 qu\u00e8: la sent\u00e8ncia GOTO era una sent\u00e8ncia considerada perjudicial per a la programaci\u00f3 i per entendre els programes escrits en qualsevol llenguatge i tamb\u00e9 que amb nom\u00e9s les estructures seq\u00fcencial, iterativa i condicional era suficient per escriure qualsevol programa. En aquest tema veurem quines s\u00f3n les estructures de control de la programaci\u00f3 estructurada i com s'utilitzen, aix\u00ed com tamb\u00e9 les seues corresponents representacions gr\u00e0fiques en programes escrits en diagrames de flux, pseudocodi o algun llenguatge de programaci\u00f3 d'alt nivell. Conceptes b\u00e0sics El teorema de el programa estructurat \u00e9s un resultat en la teoria de llenguatges de programaci\u00f3. Estableix que tota funci\u00f3 computable pot ser implementada en un llenguatge de programaci\u00f3 que combine nom\u00e9s tres estructures l\u00f2giques. Aquestes tres formes tamb\u00e9 anomenades estructures de control espec\u00edficament s\u00f3n: Seq\u00fc\u00e8ncia: execuci\u00f3 d'una instrucci\u00f3 despr\u00e9s d'una altra. Selecci\u00f3: execuci\u00f3 d'una de dues instruccions (o conjunts), segons el valor d'una variable booleana. Iteraci\u00f3: execuci\u00f3 d'una instrucci\u00f3 (o conjunt) mentre una variable booleana siga 'veritable'. Aquesta estructura l\u00f2gica tamb\u00e9 es coneix com a cicle o bucle. Aquest teorema demostra que la instrucci\u00f3 GOTO no \u00e9s estrictament necess\u00e0ria i que per a tot programa que l'utilitze existeix un altre equivalent que no fa \u00fas d'aquesta instrucci\u00f3. Els cient\u00edfics de la computaci\u00f3 usualment acrediten el teorema a un article de 1966 escrit per Corrado B\u00f6hm i Giuseppe Jacopini . No obstant aix\u00f2, David Harel va rastrejar els seus or\u00edgens fins a la descripci\u00f3 de 1946 de l'arquitectura de von Neumann i el teorema de la forma normal de Kleene. Diagrames de flux Abans d'entrar en el detall del que serien les estructures proposades en el teorema de programaci\u00f3 estructurada, \u00e9s necessari que mirem amb detall una de les t\u00e8cniques de disseny d'algorismes m\u00e9s utilitzada i que ens servira per entendre un poc millor i de forma gr\u00e0fica que fa cada estructura. Un diagrama de flux \u00e9s una representaci\u00f3 gr\u00e0fica d'un algorisme. S'utilitza en disciplines com la programaci\u00f3 inform\u00e0tica, l'economia, els processos industrials o la psicologia cognitiva. Aquests diagrames utilitzen s\u00edmbols amb significats ben definits que representen els passos de l'algorisme, i representen el flux d'execuci\u00f3 mitjan\u00e7ant fletxes que connecten els punts d'inici i de finalitzaci\u00f3. Un diagrama de flux sempre t\u00e9 un \u00fanic punt d'inici i un \u00fanic punt de finalitzaci\u00f3. A m\u00e9s, tot cam\u00ed d'execuci\u00f3 ha de permetre arribar des de l'inici fins al final. Les seg\u00fcents s\u00f3n accions pr\u00e8vies a la realitzaci\u00f3 del diagrama de flux: Identificar les idees principals que s'han d'incloure en el diagrama de flux. Han d'estar presents el propietari o responsable del proc\u00e9s, els propietaris o responsables del proc\u00e9s anterior i posterior i d'altres processos interrelacionats, aix\u00ed com les terceres parts interessades. Definir qu\u00e8 s'espera obtenir del diagrama de flux. Identificar qui ho far\u00e0 servir i com. Establir el nivell de detall requerit. Determinar els l\u00edmits del proc\u00e9s a descriure. Els passos a seguir per construir el diagrama de flux s\u00f3n: Establir l'abast del proc\u00e9s a descriure. D'aquesta manera quedar\u00e0 fixat el comen\u00e7ament i el final del diagrama. Sovint el comen\u00e7ament \u00e9s la sortida del proc\u00e9s previ i el final l'entrada al proc\u00e9s seg\u00fcent. Identificar i llistar les principals activitats/subprocessos que estan incloses en el proc\u00e9s a descriure i el seu ordre cronol\u00f2gic. Si el nivell de detall definit inclou activitats menors, llistar-les tamb\u00e9. Identificar i llistar els punts de decisi\u00f3. Construir el diagrama respectant la seq\u00fc\u00e8ncia cronol\u00f2gica i assignant els corresponents s\u00edmbols. Assignar un t\u00edtol al diagrama i verificar que estigui complet i descrigui amb exactitud el proc\u00e9s escollit. Simbologia i significat Oval o el\u00b7lipse: inici i final (obre i/o tanca el diagrama). Rectangle: activitat (representa l'execuci\u00f3 d'una o m\u00e9s activitats o procediments). Rombe: decisi\u00f3 (formula una pregunta o q\u00fcesti\u00f3). Cercle: connector (representa l'enlla\u00e7 d'activitats amb una altra dins d'un procediment). Triangle cap per avall: fitxer definitiu (guarda un document de forma permanent). Triangle cap per amunt: fitxer temporal (proporciona un temps per a l'emmagatzematge del document). A l'esquema seg\u00fcent pots revisar la simbologia gr\u00e0fica que usarem en aquest curs per tal de representar diagrames de flux. S\u00edmbols dels diagrames de flux graph LR class B classNode Ini((Ini)) style Ini fill:#0F0 Ini-->|L\u00ednia de flux|A[/Entrada eixida/] A-->B[Procediment o Instrucci\u00f3] B-->C{Decisi\u00f3} C-->Fi((Fi)) style Fi fill:#F00 Exemples A continuaci\u00f3 vegem alguns exemples que ens ajudaran a entendre-ho millor. Et recomane que intentes dissenyar una soluci\u00f3 utilitzant la t\u00e8cnica dels diagrames de flux abans de mirar a la soluci\u00f3. Exemple 1. La nostra fruiteria Es pret\u00e9n implementar un algorisme que s'encarregue, de la forma m\u00e9s eficient possible, la creaci\u00f3 i impressi\u00f3 de tiquets de compra per a tots els clients que entren a la nostra botiga. A la imatge seg\u00fcent podem observar un exemple d'algorisme de creaci\u00f3 d'un nou tiquet (nova compra). graph LR Id1((Inici))-->B[Crear Tiquet Nou]; style Id1 fill:#0F0; B-->C[Afegir Item]; C-->D{Compra acabada?}; D-->|NO|C; D-->|SI|E[Calcular Preu Final]; E-->F[Imprimir]; F-->Id2((Final)); style Id2 fill:#F00; Expliquem breument el que fa aquest diagrama: primer crea un nou tiquet i afegeix un nou element (fruita o verdura), aquesta acci\u00f3 \u00faltima es repeteix fins que acabe de comprar. Quan s'acaba d'afegir items al nou tiquet, es calcula el preu final i s'imprimeix. Exemple 2. Trobar les claus de casa Imagineu que vull eixir de casa per\u00f2 no recorde on he posat les claus i sense elles no puc anar a cap lloc. Les he de buscar. El seg\u00fcent algorisme representat utilitzant un diagrama de flux, ens podria ajudar a trobar-les. graph LR Id1((Inici))-->B[Buscar on sempre]; style Id1 fill:#0F0; B-->P1(fa:fa-spinner); P1-->D{Trobades?}; D-->|NO|C[Buscar altre lloc]; C-->P1; D-->|SI|E[Eixir de casa]; E-->Id2((Fi)); style Id2 fill:#F00; Exemple 3. Com anar de l'ajuntament al passeig Ens trobem a la pla\u00e7a de l'ajuntament i un visitant ens pregunta com arribar al passeig Cervantes. Observa el seg\u00fcent diagrama de flux. Al tractar-se d'un exemple un poc m\u00e9s extens, primer descriurem les instruccions en llenguatge natural i despr\u00e9s farem el diagrama. Camina pel carrer major en direcci\u00f3 sud Quan arribes a l'encreuament amb el Carrer Ramon i Cajal gira a la dreta Camina fins la farmacia Quan arribes a la farm\u00e0cia gira a l'esquerra Caminar fins encreuament amb el carrer Moreral. Agafa el carrer moreral Al final del carrer moreral a l'esquerra. Una possible soluci\u00f3 al problema anterior seria: graph LR subgraph 1 Inici((Inici))-->A[Caminar carrer major direcci\u00f3 sud]; style Inici fill:#0F0; A-->B{Hem arribat al Ram\u00f3n i Cajal?}; B-->|NO|A; B-->|SI|C[Gira a la dreta]; C-->D[Camina pel Ram\u00f3n i Cajal]; end subgraph 2 D-->E; E{Hem arribat a la farmacia?}-->|SI|F[Gira a l'esquerra]; E-->|NO|C; F-->G[Camina pel Mestre Esteve]; G-->H{Hem arribat al carrer Moreral?} H-->|NO|G; end subgraph 3 H-->|SI|I[Baixa pel carrer Moreral]; I-->J{Has arribat al final del carrer?}; J-->|SI|K[Gira a l'esquerra]; J-->|NO|H; K-->L[Camina fins el Passeig]; L-->Final((Fi)); style Final fill:#F00; end Exemple 4. Fer Zapping Agafare el comandament Engegar la tele M'agrada el canal? Si no m'agrada canvie de canal Si s\u00ed que m'agrada, deixe el comandament i em pose comode. graph LR Ini((Inici))-->A[Agafar Comandament TV]; style Ini fill:#0F0; A-->B[Engegar TV]; B-->P1(fa:fa-spinner); P1-->C1{M'agrada el que fan?}; C1-->|NO|C[Canvia de Canal]; C-->P1; C1-->|SI|D[Posat Comode] D-->Fi((Fi)); style Fi fill:#F00; Exemple 5. Adolesc\u00e8ncia (Spoiler: no t\u00e9 soluci\u00f3) Durant l'adolesc\u00e8ncia cal marcar b\u00e9 les prioritats abans de les diversions. Tot adolescent abans de poder eixir amb els amics primer ha de fer els deures i despr\u00e9s tindre el quarto arreglat. Dissenya un algorisme que solucione aquest problema sense que l'adolescent haja de consultar a sa mare si pot eixir o no. graph LR Ini((Inici))-->A{Has fet els deures?}; style Ini fill:#0F0; A-->|NO|B[Fes els deures]; B-->A; A-->|SI|C{Has ordenat l'habitaci\u00f3?}; C-->|NO|D[Ordena l'habitaci\u00f3]; C-->|SI|E[Pots eixir]; E-->Fi((Fi)); style Fi fill:#F00; Activitats Activitat 201. \u00das del transport p\u00fablic. Acabes d'arribar a l'estaci\u00f3 del Nord de Val\u00e8ncia i necessites anar al Campus de tarongers, concretament a l'UPV, utilitzant els transports p\u00fablics de la ciutat. Per tal d'arribar a l'UPV hi han dues opcions: en autobus o en metro. Si agafes l'autob\u00fas, primer t'has de despla\u00e7ar caminant fins a la parada d'autobus que es troba a la Gran Via Marqu\u00e9s del Turia, trobar la marquesina i esperar a que arribe l'autob\u00fas amb el n\u00famero 93. Despr\u00e9s d'un trajecte d'uns 30 minuts quan arribes a la parada d'autobus del Campus de Tarongers, et baixes i ja estaries. Si pel contrari uses el metro pots agafar-lo directament des de la mateixa eixida de l'estaci\u00f3 del Nord baixant al metro. Una vegada al metro, has d'agafar la l\u00ednia roja (3) fins la parada de \"Vicent Saragoss\u00e0\". Arribats a la parada has de pujar a superf\u00edcie fins la parada del tramvia. Quan arribe el tramvia, has d'agafar el que va en direcci\u00f3 \"Doctor Lluch\" fins arribar a la parada de \"La Carrasca\". Baixes del tramvia i ja estaries. Utilitzant la t\u00e8cnica dels diagrames de flux , dissenya un algorisme que solucione el problema anterior. Et recomane que primer escriguen una seq\u00fc\u00e8ncia d'instruccions i despr\u00e9s ho passes a diagrama de flux. Els exemples de dissenys d'algorismes que hem vist abans, s\u00f3n exemples gr\u00e0fics per a la soluci\u00f3 de problemes quotidians on, normalment, serien v\u00e0lides tot tipus d'instruccions com per exemple: \"Camina cap al sud\", \"espera fins que arribe l'autobus\", \"busca\", \"ix de casa\" etc .. Per\u00f2 quan estem parlant d'ordinadors el conjunt d'instruccions amb el que ens podem comunicar amb la m\u00e0quina no \u00e9s el mateix que el llenguatge natural amb una persona amb totes les ambiguitats. \u00c9s molt important que un llenguatge de programaci\u00f3, que \u00e9s la llengua amb la que ens comuniquem amb les m\u00e0quines, siga clar, conc\u00eds, simple i sobre totes les coses lliure d'ambig\u00fcitats . Per exemple: la Thermomix \u00ae \u00e9s un dels robots de cuina m\u00e9s coneguts del mercat. Aquest robot t\u00e9 una interf\u00edcie molt senzilla formada per tres controls: Temps, Velocitat, Temperatura. Amb el temps podem establir el tems (segons) que estar\u00e0 la m\u00e0quina treballant, el control de velocitat determina la velocitat (0-10) a la que roden les aspes depenent si vols triturar molt els aliments o deixar-los sencers. Per \u00faltim la temperatura a la qual treballa el robot la podem regular des de 0 graus fins a 120. Finalment ens quedaria nom\u00e9s el bot\u00f3 d'inici/parada que com b\u00e9 indica el que fa \u00e9s engegar quan est\u00e0 parada i parar quan est\u00e0 en marxa. Com podeu observar les instruccions que se li poden donar a la Thermomix \u00ae a trav\u00e9s de la seua interf\u00edcie s\u00f3n molt reduides per\u00f2 si investigueu un poc per Internet trobareu que el total de receptes que es poden fer amb aquest set d'instruccions \u00e9s molt abundant. Activitat 202. Recepta Thermomix\u00ae Problema Instruccions Thermomix Busca per Internet una recepta que t'agrade i amb la t\u00e8cnica abans vista dels diagrames de flux, dissenya un algorisme per al robot de cuina Thermomix \u00ae, tenint el seu repertori d'instruccions que hem vist abans. Recorda que depenent de la recepta que tries, pot ser que estiga dividida en parts i hi haja una part de l'algorisme on s'indiquen instruccions per al/la cuiner/a. A la Thermomix se li poden donar tres tipus de ordres: a quina temperatura ha de cuinar des de 0 fins a 120 graus, la velocitat de les aspes de 0 fins a 7 i el temps de cocci\u00f3 en minuts i segons. Temperatura: des de 0 graus fins a 120 graus. Velocitats: enrere, 0, SL (Slow), o de 0 fins a 7 Temps: minuts i segons Per exemple, si volgu\u00e9rem bullir aigua, donariem les seg\u00fcents instruccions: - Temperatura: 100 graus. - Temps: 5:00 - Velocitat: SL Estructures Com ja hem anomenat als primers punts d'aquest tema, el teorema de la programaci\u00f3 estructurada preveu una s\u00e8rie d'estructures b\u00e0siques amb les quals es podrien codificar tots els algorismes sense necessitat d'usar cap sent\u00e8ncia GOTO o similar. Aquestes estructures s\u00f3n: Seq\u00fcencial: una sentencia s'executa despr\u00e8s d'acabar l'anterior. Condicional: s'avalua una condici\u00f3 i depenent del seu resultat s'executaran unes instruccions o altres. Repetitiva: repetici\u00f3 d'un grup d'instruccions que depenen d'una s\u00e8rie de condicions. Al final tot algorisme escrit en un llenguatge de programaci\u00f3 estructurada s'executa de forma seq\u00fcencial, \u00e9s a dir, es llig la primera sent\u00e8ncia s'executa i despr\u00e8s passem a la seg\u00fcent fins arribar al if niat. Les estructures condicional i repetitiva es poden interpretar com estructures seq\u00fcencials amb algunes particularitats. L'estructura condicional potser s'execute o no i l'estructura repetitiva s'executara un nombre de vegades. graph TD A(Estructures de Control)-->B(Seq\u00fcencial) A(Estructures de Control)-->C(condicional) A(Estructures de Control)-->D(Repetitiva) A(Estructures de Control)-->E(Salt) C-->F(if) C-->G(if else) C-->H(if niat) C-->I(switch) D-->J(while) D-->K(do while) D-->L(for) E-->M(break) E-->N(continue) Estructura Seq\u00fcencial Les ordres d'un programa s'executen per defecte en ordre seq\u00fcencial. El que significa que les instruccions s'executen, com hem comentat abans, una darrere de l'altra en el mateix ordre que apareixen escrites al programa. graph LR id1((Inici))-->Instrucci\u00f31; style id1 fill:#0F0 Instrucci\u00f31-->Instrucci\u00f32; Instrucci\u00f32-->Instrucci\u00f33; Instrucci\u00f33-->Instrucci\u00f34; Instrucci\u00f34-->Instrucci\u00f35; Instrucci\u00f35-->Instrucci\u00f36; Instrucci\u00f36-->id2([Fi]); style id2 fill:#F00 L'estructura seq\u00fcencial \u00e9s l'ordre natura d'execuci\u00f3. Les instruccions que formen part d'aquesta estructura s'executen en ordre una a continuaci\u00f3 de l'altra. Al final de cada instrucci\u00f3 hi ha un punt i coma per indicar-li al compilador el final de la sent\u00e8ncia individual. Les instruccions dintre d'una estructura seq\u00fcencial es solen agrupar en blocs ( {...} ) 1 2 3 4 5 6 7 // Exemple de bloc - estructura seq\u00fcencial { Instrucci\u00f31 ; Instrucci\u00f32 ; ... Instrucci\u00f3N ; } Exemple d'estructura seq\u00fcencial Un exemple d'estructura seq\u00fcencial al m\u00f3n real seria com li podem donar ordres a alg\u00fa per tal que puga veure la tele. Seguint el nostre exemple, s'haurien de seguir els seg\u00fcents passos: agafar el comandament a dist\u00e0ncia, despr\u00e9s premer el bot\u00f3 ON/OFF per tal que s'engegue i finalment hauriem de escollir el canal que m\u00e9s ens agrade amb els controls pertinents del comandament a dist\u00e0ncia. 1 2 3 4 5 6 7 // Exemple d'estructura seq\u00fcencial. // Com engegar la TV { AgafarComandament (); PremerBotoOn (); TriarCanal (); } En resum podr\u00edem dir que l'estructura seq\u00fcencial no \u00e9s m\u00e9s que un conjunt de sent\u00e8ncies o instruccions individuals agrupades. Activitat 203: Millora el codi anterior. Estructura seq\u00fcencial. La seq\u00fcencia d'instruccions anterior, \u00e9s molt simple i segurament no cobriria una soluci\u00f3 factible per els diversos escenaris en els que ens podriem trobar. Com milloraries el codi anterior per tal de fer-lo m\u00e9s eficient? Escriu el codi utilitzant nom\u00e9s l'estructura seq\u00fcencial. Estructures de selecci\u00f3 \u00c9s una de les estructures que permeten modificar l'ordre d'execuci\u00f3 de les instruccions del programa. Una estructura condicional determina si s'executen unes accions o altres segons es compleixi o no una determinada condici\u00f3. La condici\u00f3 que es comprova per decidir si unes instruccions s'executen o no deu ser una expressi\u00f3 booleana, \u00e9s a dir, ha de donar com a resultat un valor boole\u00e0 true o false. En programaci\u00f3 estructurada ens podem trobar les seg\u00fcents: Selecci\u00f3 simple: si la condici\u00f3 s'acompleix, executa l'acci\u00f3, sino no fa res. Selecci\u00f3 doble: si la condici\u00f3 s'acompleix, executa una acci\u00f3 sino executa una altra acci\u00f3. Selecci\u00f3 multiple: davant una opci\u00f3 existeixen m\u00faltiples accions a realitzar. Operador condicional ?: expressi\u00f3 matem\u00e0tica que simula l'estructura condicional o de selecci\u00f3. Selecci\u00f3 Simple \u00c9s l'estructura condicional m\u00e9s simple en programaci\u00f3 estructurada. S'utilitza per determinar si una instrucci\u00f3 o bloc d'instruccions s'executa basat en una condici\u00f3. S'avalua la condici\u00f3 i si es true, s'executa la instrucci\u00f3 o bloc d'instruccions associat a la condici\u00f3. graph LR id1((Inici))-->Instrucci\u00f31; style id1 fill:#0F0; Instrucci\u00f31-->Instrucci\u00f32; Instrucci\u00f32-->Cond1{Condici\u00f3}; Cond1-->|SI|Instrucci\u00f33; Instrucci\u00f33-->Instrucci\u00f34; Instrucci\u00f34-->con1; style con1 fill:#000; Cond1-->|NO|con1(fa:fa-spinner); con1-->Instrucci\u00f35; Instrucci\u00f35-->id2([Fi]); style id2 fill:#F00; Si mirem b\u00e9 la imatge anterior, el codi que s'executaria seria: S'executa la instrucci\u00f3 1 S'executa la instrucci\u00f3 2 S'avalua a condici\u00f3 Si s'acompleix: S'executa la instrucci\u00f3 3 S'executa la instruccio 4 S'executa la instrucci\u00f3 5 S'acaba l'execuci\u00f3 de l'algorisme. En definitiva, al codi anterior podrien passar dues coses: que s'acompleixi la condici\u00f3 (true) o que no s'acompleixi (false). Si s'avalua true la condici\u00f3 el codi seria: Instrucci\u00f31, Instrucci\u00f32, Instrucci\u00f33, Instrucci\u00f34, Instrucci\u00f35 i Instrucci\u00f36. Pel contrari si s'avalua la condici\u00f3 a false, les instruccions a executar serien: Instrucci\u00f31, Instrucci\u00f32, Instrucci\u00f35 i Instrucci\u00f36. \u00c9s a dir, no s'executarien la 3 i la 4. El seu codi en pseudocodi seria: 1 2 3 4 5 6 7 8 9 10 11 si ( condicio ) aleshores instruccio fsi // O tamb\u00e9 si ( condicio ) aleshores instruccio1 instruccio2 ... instruccioN fsi En el primer cas si quan s'avalua la condici\u00f3 aquesta \u00e9s veritat, s'executaria la instrucci\u00f3 si pel contrari la condici\u00f3 \u00e9s falsa, no es fa res. Al segon cas \u00e9s igual que el primer per\u00f2 en cas d'avaluar-se positivament la condici\u00f3 no s'executaria una sola instrucci\u00f3 si no que s'executaria (de forma seq\u00fcencial) el bloc d'instruccions seg\u00fcent: instrucci\u00f31, instrucci\u00f32 fins instrucci\u00f3N. Exemple de selecci\u00f3 simple A continuaci\u00f3 expliquem un algorisme en el qual expliquem a alg\u00fa que ha de fer si plou a l'eixir de casa. B\u00e0sicament el que estem dient \u00e9s si est\u00e0 plovent que agafe el paraig\u00fces abans d'eixir de casa. 1 2 3 4 5 6 // Exemple de selecci\u00f3 simple si ( plou ) aleshores AgafaParaig\u00fces (); fsi ObrelaPorta (); IxDeCasa (); Activitat 204. Selecci\u00f3 Simple Escriu un algorisme que simule una situaci\u00f3 al m\u00f3n real, diferent a l'exemple anterior, en el que utilitzes una estructura de selecci\u00f3 simple. Has de dissenyar el codi primer en diagrames de flux i despr\u00e9s en pseudocodi. Selecci\u00f3 doble Amb aquesta estructura condicional de la programaci\u00f3 estructurada es poden seguir camins distints depenent de si l'avaluaci\u00f3 de la condici\u00f3 \u00e9s true o false. En altres paraules, si la condici\u00f3 \u00e9s true, executaria una instrucci\u00f3 o bloc d'instruccions mentre que si s'avalua a false executaria una altra instrucci\u00f3 o bloc d'instruccions. graph LR id1((Inici))-->Instrucci\u00f31; style id1 fill:#0F0; Instrucci\u00f31-->Instrucci\u00f32 Instrucci\u00f32-->C1{Condici\u00f3} C1-->|SI|Instrucci\u00f33; Instrucci\u00f33-->Instrucci\u00f34; C1-->|NO|Instrucci\u00f35; Instrucci\u00f35-->Instrucci\u00f36; style con1 fill:#000; Instrucci\u00f34-->con1(fa:fa-spinner); Instrucci\u00f36-->con1; con1-->Instrucci\u00f37; Instrucci\u00f37-->Instrucci\u00f38; Instrucci\u00f38-->id2((FI)); style id2 fill:#F00 El codi en pseudocodi del diagrama de flux anterior seria el seg\u00fcent: 1 2 3 4 5 6 7 8 9 10 11 instruccio1 ; instruccio2 ; si ( condicio ) aleshores instruccio3 ; instruccio4 ; sino instruccio5 ; instruccio6 ; fsi instruccio7 ; instruccio8 ; Si ens fixem en el codi anterior, podem trobar dues seq\u00fc\u00e8ncies d'execucio d'instruccions depenent si la condici\u00f3 del 'si' s'avalua 'veritable' o 'fals'. En el primer cas, amb la condici\u00f3 a 'true' , s'executarien: instrucci\u00f31, instrucci\u00f32, instrucci\u00f33, instrucci\u00f34, instrucci\u00f37 i instrucci\u00f38. Mentre que si la condici\u00f3 del 'si' s'avaluara a 'false' , les instruccions a executar serien: instrucci\u00f31, instrucci\u00f32, instrucci\u00f35, instrucci\u00f36, instrucci\u00f37 i instrucci\u00f38. Exemple de selecci\u00f3 doble Al seg\u00fcent exemple, utilitzarem l'estructura de selecci\u00f3 doble per tal de millorar l'exemple anterior de com entrar a casa amb les claus. Qu\u00e8 passaria si no tenim les claus de casa a la butxaca quan intentem entrar a casa? Que podriem fer? Fixa't en el seg\u00fcent codi. 1 2 3 4 5 6 7 8 // Exemple de selecci\u00f3 doble si ( plou ) aleshores AgafaParaig\u00fces (); sino PosatXancles (); fsi ObreLaPorta (); IxDeCasa (); Activitat 203. Selecci\u00f3 Doble Seguint amb l'exemple de l'activitat 202, converteix el teu exemple, si es pot, en un algorisme que utilitze l'estructura de selecci\u00f3 doble. Igualment que a l'activitat anterior has de dissenyar el teu codi en diagrama de flux primer i despr\u00e9s en pseudocodi. En altres paraules, millora o amplia l'exemple de la vida real afegint-li les estructures noves. Condicionals niats Si volem avaluar m\u00e9s d'una condici\u00f3 al nostre codi, estariem parlant d'una estructura condicional m\u00faltiple que b\u00e0sicament consisteix en encadenar diversos if..else. A continuaci\u00f3 es pot veure com seria un exemple de condicional m\u00faltiple en diagrama de flux. graph LR id1((Inici))-->Instrucci\u00f31; style id1 fill:#0F0; Instrucci\u00f31-->|NO|C1{Condici\u00f3 1}; C1-->|NO|C2{Condici\u00f3 2}; C2-->|NO|C3{Condici\u00f3 3}; C1-->|SI|Instrucci\u00f32; Instrucci\u00f32-->Instrucci\u00f33; C2-->|SI|Instrucci\u00f34; C3-->|SI|Instrucci\u00f35; Instrucci\u00f35-->Instrucci\u00f36; Instrucci\u00f36-->Instrucci\u00f37; style con1 fill:#000; Instrucci\u00f33-->con1(fa:fa-spinner); Instrucci\u00f34-->con1; Instrucci\u00f37-->con1; con1-->Instrucci\u00f310; Instrucci\u00f310-->Id2((FI)); style Id2 fill:#F00; El mateix exemple en pseudocodi que teniu a la imatge anterior seria: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 instruccio1 si ( condicio1 ) aleshores instruccio2 instruccio3 sino si ( condicio2 ) aleshores instruccio4 sino si ( condicio3 ) aleshores instruccio5 instruccio6 instruccio7 sino instruccio8 instruccio9 fsi instruccio10 Al codi anterior l'\u00fanic que s\u00ed sabem cert \u00e9s que s'executaran les instruccions 1, 2 i 10 i depenent de quina condici\u00f3 s'avalua a true s'executar\u00e0 algun bloc d'instruccions que estan dins de l'estructura condicional. Exemple d'estructura condicional niada Un repartidor de Mirinda segueix el seg\u00fcent horari de feina: el dilluns reparteix a Pego, el dimarts a Oliva, el dimecres a Ondara, el dijous a El Verger i el divendres a Els poblets. Al seg\u00fcent algorisme utilitzarem els condicionals niats per dissenyar un algorisme que solucione el problema del repartidor de Mirinda. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Exemple: El repartidor de Mirinda si huiEsDilluns aleshores repartirPego (); sino si huiEsDimarts aleshores repartirOliva (); sino si huiEsDimecres aleshores repartirOndara (); fa : fa - spinner sino si huiEsDijous aleshores repartirElVerger (); sino si huiEsDivendres aleshores repartirElsPoblets (); sino NoEsTreballaHui (); fsi Activitat 204. Condicional niada M\u00e9s dif\u00edcil encara, modifica els exemples anteriors i per tal d'acoblar-hi al teu algorisme una estructura condicional niada. Condicional m\u00faltiple La sent\u00e8ncia de control 'switch' \u00e9s una altra forma de codificar la condici\u00f3 m\u00faltiple que hem vist a l'apartat anterior per\u00f2 m\u00e9s senzilla de visualitzar a primer cop d'ull. Fixa't en la imatge seg\u00fcent: graph LR id1((Inici))-->Instrucci\u00f31; style id1 fill:#F00; Instrucci\u00f31-->C1{Condici\u00f3 1}; C1-->|A|Instrucci\u00f32; C1-->|B|Instrucci\u00f33; C1-->|C|Instrucci\u00f34; style D fill:#000; Instrucci\u00f32-->D(fa:fa-spinner); Instrucci\u00f33-->D; Instrucci\u00f34-->D; D-->Instrucci\u00f35; Instrucci\u00f35-->id3((FI)); style id3 fill:#0F0; Al diagrama de flux anterior, s'avalua una condici\u00f3 (que pot resultar en m\u00e8s d'un cas diferent) i segons el resultat d'aquesta avaluaci\u00f3 de la condici\u00f3, realitzar\u00e0 una acci\u00f3 o una altra. Mira com s'escriuria el codi de la condicional m\u00faltiple. 1 2 3 4 5 6 7 8 9 10 11 12 13 enCasDe ( expressi\u00f3 ) fer cas < opcio1 > Instruccio1 Instruccio2 cas < opcio2 > Instruccio3 Instruccio4 sino Instruccio5 Instruccio6 fiCas L'exemple del repartidor ens serviria per veure aquesta estructura. La condici\u00f3 a avaluar seria: **Quin dia es hu\u00ed?\". La resposta a aquesta pregunta, com tots podem intuir, pot donar diversos resultats, concretament 7: dilluns, dimarts, dimecres, dijous, divendres, dissabte o diumenge. Ara es tractaria d'establir les accions a realitzar segons el resultat de l'avaluaci\u00f3 anterior com mostra el seg\u00fcent codi. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 enCasDe ( huiQuinDiaEs ) fer cas < Dilluns > RepartirPego (); cas < Dimarts > RepartirOliva (); cas < Dimecres > RepartirOndara (); cas < Dijous > RepartirElVerger (); cas < Divendres > RepartirElsPoblets (); sino HuiNoEsTreballa (); fiCas Activitat 205. Estructura condicional m\u00faltiple. Dissenya un algorisme que t'ajude a decidir quina roba posar-te abans d'eixir de casa en funci\u00f3 del temps que faja. Cal tenir en compte les seg\u00fcents consideracions geogr\u00e0fiques: estem a Pego i l'oratge pot ser molt variable. Es poden donar les seg\u00fcents condicions meteorol\u00f2giques: ploure a c\u00e0nters, fer un sol que bada penyes, fa frescoreta i tamb\u00e9 pot fer un fred que pela. El mateix programa l'has d'escriure utilitzant l'estructura encasde i la de selecci\u00f3 m\u00faltiple niada. Estructures de repetici\u00f3 Si les estructures condicionals serveixen per determinar quines instruccions o bloc d'instruccions s'executen, la programaci\u00f3 estructurada tamb\u00e9 disposa d'estructures repetitives o tamb\u00e9 anomenades bucles , que ens permeten executar una instrucci\u00f3 o bloc d'instruccions v\u00e0ries vegades . mentre Mentre la condici\u00f3 (tamb\u00e9 anomenada condici\u00f3 d'eixida) siga avaluada com a true, s'executarien les instruccions que hi ha dins del bucle while. graph LR Id1((Inici))-->Instrucci\u00f31; style Id1 fill:#0F0; style D fill:#000; Instrucci\u00f31-->D(fa:fa-spinner); D-->C1{Condici\u00f3}; C1-->|V|Instrucci\u00f32; Instrucci\u00f32-->P2((Fi)); style P2 fill:#F00; C1-->|F|D; En aquest tipus de bucle, el bloc d'instruccions del bucle while, es poden executar zero o m\u00e9s vegades. Els passos que representen el diagrama anterior s\u00f3n: S'executa la instrucci\u00f3 S'avalua la condici\u00f3 Si la condici\u00f3 \u00e9s true, s'executa el bloc d'instruccions del bucle i es torna a avaluar la condici\u00f3. En cas que la condici\u00f3 s'avalue com a false, passar\u00edem a executar la instrucci\u00f3 2. El codi escrit de l'estructura mentre explicada anteriorment seria: 1 2 3 4 mentre ( condicio ) fer Instruccio1 Instruccio2 fmentre Activitat 206: Obrir tots els calaixos. Mentre fer Imagina que estas buscant el m\u00f2bil. Recordes que l'has guardat a un calaix de la teua habitaci\u00f3. El problema \u00e9s que a la teua habitaci\u00f3 entre armaris, escriptoris, tauletes de nit i altres mobles, hi ham m\u00e9s de 30 calaixos. Dissenya un codi en el que busques el m\u00f2bil obrint tots els calaixos fins que el trobes. repetir .. mentre Molt semblant al bucle while per\u00f2 amb la difer\u00e8ncia que el bloc s'instruccions que cont\u00e9 l'estructura s'executaria almenys una vegada ja que la condici\u00f3 d'eixida s'avalua despr\u00e9s d'executar les instruccions. graph LR Id1((Inici))-->Instrucci\u00f31; style Id1 fill:#F00; style P1 fill:#000; Instrucci\u00f31-->P1(fa:fa-spinner); P1-->Instrucci\u00f32; Instrucci\u00f32-->C1{Condici\u00f3}; C1-->|V|Instrucci\u00f33; C1-->|F|P1; Instrucci\u00f33-->Id2((Fi)); style Id2 fill:#0F0; Els passos que representen el diagrama anterior s\u00f3n: S'executa la instrucci\u00f3 1 S'executen les instruccions que cont\u00e9 el bloc S'avalua la condici\u00f3 Si la condici\u00f3 \u00e9s true, s'executa el bloc d'instruccions del bucle i es torna a avaluar la condici\u00f3. En cas que la condici\u00f3 s'avalue com a false, passar\u00edem a executar la instrucci\u00f3 2. Exemple: Com far\u00edem el codi necessari per rec\u00f3rrer el nostre array de 100 elements fins trobar el n\u00famero que busquem? 1 2 3 4 fer Instruccio1 Instruccio2 mentre ( condicio ) Activitat 207. La formigonera. Fer mentre Algorisme de la formigonera. Tenim una formigonera preparada amb l'aigua i el cement necessaris i nom\u00e9s ens faltaria posar-li l'arena necess\u00e0ria que est\u00e0 en un munt\u00f3 a prop de la formigonera. Disposem d'una pala per passar l'arena del munt\u00f3 a dins de la formigonera. Dissenya un algorisme que tire arena, pala a pala, dins de la formigonera fins que aquesta estiga plena. bucle per Aquesta estructura de repetici\u00f3 \u00e9s possiblement la m\u00e9s complicada de comprendre per\u00f2 tamb\u00e9 possiblement la m\u00e9s utilitzada. Aquesta estructura de control sol utilitzar-se la majoria de les vegades quan sabem la quantitat de vegades que es repetir\u00e0 la instrucci\u00f3 o conjunt d'instruccions que t\u00e9 dintre d'ella. Per\u00f2 mirem un exemple: graph LR Id1((Inici))-->Instrucci\u00f31; style Id1 fill:#0F0; Instrucci\u00f31-->Inicialitzaci\u00f3; style D fill:#000; Inicialitzaci\u00f3-->D(fa:fa-spinner); D-->C1{Condici\u00f3} C1-->|NO|Instrucci\u00f32; C1-->|SI|Instruccions; Instruccions-->Actualitzaci\u00f3; Actualitzaci\u00f3-->D; Instrucci\u00f32-->Id3([Fi]) style Id3 fill:#F00; El diagrama anterior est\u00e0 executant les seg\u00fcents accions: Executem instrucci\u00f3 1 (aliena al bucle for) Inicialitzaci\u00f3 Avaluaci\u00f3 de la condici\u00f3 Si la condici\u00f3 \u00e9s true Executem les instruccions del bucle for Actualitzem \u00edndex Si la condici\u00f3 es false eixim del bucle i executem instrucci\u00f3 2 Aquest mateix diagrama de flux es pot escriure en pseudocodi de la seg\u00fcent forma: 1 2 3 4 per i = 0 mentre i < 100 incrementa i en 1 fer Instruccio1 Instruccio2 fiper Al codi anterior: Inicialitzaci\u00f3: int i = 0; Avaluaci\u00f3 de la condici\u00f3: \u00e9s mentre i < 100 Instruccio1 i Instruccio2 Actualitzaci\u00f3: incrementa i en 1 Activitat 208. Busca aigua. Bucle per Dissenya un algorisme en diagrames de flux que busque la paraula \"aigua\" en qualsevol llibre en una p\u00e0gina qualsevol. \u00c9s a dir, el nostre algorisme el que far\u00e0 ser\u00e0 llegir una p\u00e0gina d'un llibre qualsevol i comptar\u00e0 quantes vegades ha trobat la paraula aigua en total. Has de dissenyar l'algorisme tant en diagrama de flux com en pseudocodi. Activitats Exposem a continuaci\u00f3 algunes activitats per tal d'assolir els coneixements exposats als punts anteriors. Activitat 209. Iniciar sessi\u00f3 a Facebook Dibuixa un diagrama de flux per iniciar sessi\u00f3 en un compte de Facebook. Obrim el navegador web. Escrivim facebook.com Aquesta sol\u00b7licitud s'envia a Facebook i respon enviant-nos a la p\u00e0gina d'inici o login. Escrivim les nostres credencials, email i contrasenya i fem clic a iniciar. Si es correcte es mostrar\u00e0 la p\u00e0gina del nostre perfil. En cas contrari, es produir\u00e0 un error i ens demanar\u00e0 una altra vegada usuari i contrasenya. Activitat 210. \u00c0rea d'un rectangle Calcula l'\u00e0rea d'un rectangle donades les seues dimensions Inserim la base. Especifiquem l'al\u00e7ada. Calculem l'\u00e0rea: base per al\u00e7ada Mostrem el resultat per pantalla Activitat 211. Hola m\u00f3n 10 vegades Escriu el diagrama de flux necessari per imprimir per pantalla 10 vegades \"hola m\u00f3n\" Resolem aquesta activitat utilitzant el concepte bucle. Creem la variable \"compte\" i l'inicialitzem a 0. Despr\u00e9s imprimim \"Hola m\u00f3n\" i incrementem la variable \"compte\" en uno. Verifiquem si \"compte\" encara \u00e9s menor que 10. En cas veritable, imprimim \"Hola m\u00f3n\" i tornem a incrementar. Quan la \"compte\" valga 10 eixim del programa. comptador = 0; Imprimir \"Hola m\u00f3n\" Incrementem compte Si comptador < 10 tornem al pas 2 en cas contrari s'acaba l'execuci\u00f3 Activitat 212. Preparar el t\u00e9 Dibuixa el diagrama de flux amb els passos necessaris per preparar el t\u00e9. Comprar t\u00e9 i/o sucre. Tindre tassa i cullera. Posar a bullir aigua. Posar la bossa de t\u00e9 a la tassa. Posar aigua a la tassa amb la bossa (de t\u00e9). Esperar uns minuts a que es dissolga el t\u00e9. Retirar la bossa (de t\u00e9) Vols sucre? Si la resposta \u00e9s s\u00ed, posar sucre i mesclar. Si la resposta \u00e9s no s'acabat el proc\u00e9s. Activitat 213. N\u00famero major Escriu el diagrama de flux de tal forma que donats dos n\u00fameros ens indique quin \u00e9s m\u00e9s gran. Introduir els valors A i B Llegir els seus valors Si A == B tornar al pas 1 Si A > B escriure per pantalla: \"A \u00e9s major que B\" En cas contrari escriure: \"B \u00e9s major que A\". Acabar el proc\u00e9s. Activitat 214. Suma dos n\u00fameros Algorisme que demana dos n\u00fameros i els suma mostrant el resultat per pantalla. Declarem la variable suma i la inicialitzem a 0. Inserim dos n\u00fameros. Sumem els dos n\u00fameros i els afegim a suma. Mostrem suma per pantalla. Activitat 215. Llevar la fam Ens trobem a casa i tenim fam. Qu\u00e8 fem? Preguntem si tenim fam. Si la resposta \u00e9s no s'acaba el procediment, ja estem satisfets. Si la resposta \u00e9s si busquem el menjar a la nevera. Si hi ha menjar a la nevera la calfem i mengem Si no hi ha res a la nevera, Ini((Inici))-->A[/Introdueix un nombre:/]; Activitat 216. Parell o senar Algorisme que determina si el n\u00fameroJ que inserim \u00e9s parell o senar. Introduim un n\u00famero 'N' Si 'N' es divideix entre 2 i el residu \u00e9s 0 (N mod 2 = 0), aleshores 'N' \u00e9s parell. En cas contrari \u00e9s senar. Activitat 217. Agafar el paraig\u00fces Algorisme per determinar quan ixc de casa si necessite o no agafar un paraig\u00fces. Comprovem si est\u00e0 plovent. Si la resposta \u00e9s No, eixim al carrer sense paraig\u00fces. Si la resposta \u00e9s S\u00ed, busquem el paraig\u00fces Si el trobem eixim al carrer En cas contrari tornem al pas 1. Activitat 218. Mitjana Algorisme que calcula la mitjana d'un alumne amb tres notes i mostra per pantalla si est\u00e0 \"Aprovat\" o \"Susp\u00e8s\". La nota m\u00ednima per aprovar \u00e9s 11. Declarem les variables a utilitzar: Nota1, Nota2, Nota3, Mitjana. Inserim les notes per teclat. Calculem la mitjana Verifiquem si la mitjana \u00e9s major o igual a 5. Si \u00e9s major que 5, escrivim per pantalla \"Aprovat\" En cas contrari escrivim \"Susp\u00e8s\"","title":"2.- Programaci\u00f3 Estructurada"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#tema-2-programacio-estructurada","text":"","title":"Tema 2 - Programaci\u00f3 Estructurada"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#introduccio","text":"A l'inici dels temps del la inform\u00e0tica moderna segona meitat dels segle XX i considerant ordinador programable aquell que seguia l'arquitectura de von Neumann , els primers programes s'escrivien en binari (llenguatge m\u00e0quina) en targetes perforades. Aquestes targetes perforades s'utilitzaven per escriure programes sencers amb una finalitat molt concreta . Les targetes s'utilitzaven com a entrada de dades a la m\u00e0quina que s'encarregava de llegir les instruccions escrites en binari, i una a una, carregar-les a mem\u00f2ria i executar-les. Un problema d'aquest incipient paradigma de programaci\u00f3 \u00e9s que cada conjunt d'instruccions \u00e9s espec\u00edfic a cada m\u00e0quina. Amb el temps i conforme augmenta la capacitat de computaci\u00f3 dels ordinadors i tamb\u00e9 la complexitat dels programes, les targetes deixen de ser funcionals i apareixen els primers llenguatges de programaci\u00f3 generalistes com FORTRAN, COBOL o LISP per\u00f2 aquests encara no utilitzen el paradigma de programaci\u00f3 estructurada. A la decada dels anys 60, B\u00f6hm i Jacopini escriuen el teorema de la programaci\u00f3 estructurada, basant-se per suposat en part en aquells llenguatges de programaci\u00f3 que ja existien, i arriben a la conclusi\u00f3 qu\u00e8: la sent\u00e8ncia GOTO era una sent\u00e8ncia considerada perjudicial per a la programaci\u00f3 i per entendre els programes escrits en qualsevol llenguatge i tamb\u00e9 que amb nom\u00e9s les estructures seq\u00fcencial, iterativa i condicional era suficient per escriure qualsevol programa. En aquest tema veurem quines s\u00f3n les estructures de control de la programaci\u00f3 estructurada i com s'utilitzen, aix\u00ed com tamb\u00e9 les seues corresponents representacions gr\u00e0fiques en programes escrits en diagrames de flux, pseudocodi o algun llenguatge de programaci\u00f3 d'alt nivell.","title":"Introducci\u00f3"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#conceptes-basics","text":"El teorema de el programa estructurat \u00e9s un resultat en la teoria de llenguatges de programaci\u00f3. Estableix que tota funci\u00f3 computable pot ser implementada en un llenguatge de programaci\u00f3 que combine nom\u00e9s tres estructures l\u00f2giques. Aquestes tres formes tamb\u00e9 anomenades estructures de control espec\u00edficament s\u00f3n: Seq\u00fc\u00e8ncia: execuci\u00f3 d'una instrucci\u00f3 despr\u00e9s d'una altra. Selecci\u00f3: execuci\u00f3 d'una de dues instruccions (o conjunts), segons el valor d'una variable booleana. Iteraci\u00f3: execuci\u00f3 d'una instrucci\u00f3 (o conjunt) mentre una variable booleana siga 'veritable'. Aquesta estructura l\u00f2gica tamb\u00e9 es coneix com a cicle o bucle. Aquest teorema demostra que la instrucci\u00f3 GOTO no \u00e9s estrictament necess\u00e0ria i que per a tot programa que l'utilitze existeix un altre equivalent que no fa \u00fas d'aquesta instrucci\u00f3. Els cient\u00edfics de la computaci\u00f3 usualment acrediten el teorema a un article de 1966 escrit per Corrado B\u00f6hm i Giuseppe Jacopini . No obstant aix\u00f2, David Harel va rastrejar els seus or\u00edgens fins a la descripci\u00f3 de 1946 de l'arquitectura de von Neumann i el teorema de la forma normal de Kleene.","title":"Conceptes b\u00e0sics"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#diagrames-de-flux","text":"Abans d'entrar en el detall del que serien les estructures proposades en el teorema de programaci\u00f3 estructurada, \u00e9s necessari que mirem amb detall una de les t\u00e8cniques de disseny d'algorismes m\u00e9s utilitzada i que ens servira per entendre un poc millor i de forma gr\u00e0fica que fa cada estructura. Un diagrama de flux \u00e9s una representaci\u00f3 gr\u00e0fica d'un algorisme. S'utilitza en disciplines com la programaci\u00f3 inform\u00e0tica, l'economia, els processos industrials o la psicologia cognitiva. Aquests diagrames utilitzen s\u00edmbols amb significats ben definits que representen els passos de l'algorisme, i representen el flux d'execuci\u00f3 mitjan\u00e7ant fletxes que connecten els punts d'inici i de finalitzaci\u00f3. Un diagrama de flux sempre t\u00e9 un \u00fanic punt d'inici i un \u00fanic punt de finalitzaci\u00f3. A m\u00e9s, tot cam\u00ed d'execuci\u00f3 ha de permetre arribar des de l'inici fins al final. Les seg\u00fcents s\u00f3n accions pr\u00e8vies a la realitzaci\u00f3 del diagrama de flux: Identificar les idees principals que s'han d'incloure en el diagrama de flux. Han d'estar presents el propietari o responsable del proc\u00e9s, els propietaris o responsables del proc\u00e9s anterior i posterior i d'altres processos interrelacionats, aix\u00ed com les terceres parts interessades. Definir qu\u00e8 s'espera obtenir del diagrama de flux. Identificar qui ho far\u00e0 servir i com. Establir el nivell de detall requerit. Determinar els l\u00edmits del proc\u00e9s a descriure. Els passos a seguir per construir el diagrama de flux s\u00f3n: Establir l'abast del proc\u00e9s a descriure. D'aquesta manera quedar\u00e0 fixat el comen\u00e7ament i el final del diagrama. Sovint el comen\u00e7ament \u00e9s la sortida del proc\u00e9s previ i el final l'entrada al proc\u00e9s seg\u00fcent. Identificar i llistar les principals activitats/subprocessos que estan incloses en el proc\u00e9s a descriure i el seu ordre cronol\u00f2gic. Si el nivell de detall definit inclou activitats menors, llistar-les tamb\u00e9. Identificar i llistar els punts de decisi\u00f3. Construir el diagrama respectant la seq\u00fc\u00e8ncia cronol\u00f2gica i assignant els corresponents s\u00edmbols. Assignar un t\u00edtol al diagrama i verificar que estigui complet i descrigui amb exactitud el proc\u00e9s escollit.","title":"Diagrames de flux"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#estructures","text":"Com ja hem anomenat als primers punts d'aquest tema, el teorema de la programaci\u00f3 estructurada preveu una s\u00e8rie d'estructures b\u00e0siques amb les quals es podrien codificar tots els algorismes sense necessitat d'usar cap sent\u00e8ncia GOTO o similar. Aquestes estructures s\u00f3n: Seq\u00fcencial: una sentencia s'executa despr\u00e8s d'acabar l'anterior. Condicional: s'avalua una condici\u00f3 i depenent del seu resultat s'executaran unes instruccions o altres. Repetitiva: repetici\u00f3 d'un grup d'instruccions que depenen d'una s\u00e8rie de condicions. Al final tot algorisme escrit en un llenguatge de programaci\u00f3 estructurada s'executa de forma seq\u00fcencial, \u00e9s a dir, es llig la primera sent\u00e8ncia s'executa i despr\u00e8s passem a la seg\u00fcent fins arribar al if niat. Les estructures condicional i repetitiva es poden interpretar com estructures seq\u00fcencials amb algunes particularitats. L'estructura condicional potser s'execute o no i l'estructura repetitiva s'executara un nombre de vegades. graph TD A(Estructures de Control)-->B(Seq\u00fcencial) A(Estructures de Control)-->C(condicional) A(Estructures de Control)-->D(Repetitiva) A(Estructures de Control)-->E(Salt) C-->F(if) C-->G(if else) C-->H(if niat) C-->I(switch) D-->J(while) D-->K(do while) D-->L(for) E-->M(break) E-->N(continue)","title":"Estructures"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#activitats_1","text":"Exposem a continuaci\u00f3 algunes activitats per tal d'assolir els coneixements exposats als punts anteriors. Activitat 209. Iniciar sessi\u00f3 a Facebook Dibuixa un diagrama de flux per iniciar sessi\u00f3 en un compte de Facebook. Obrim el navegador web. Escrivim facebook.com Aquesta sol\u00b7licitud s'envia a Facebook i respon enviant-nos a la p\u00e0gina d'inici o login. Escrivim les nostres credencials, email i contrasenya i fem clic a iniciar. Si es correcte es mostrar\u00e0 la p\u00e0gina del nostre perfil. En cas contrari, es produir\u00e0 un error i ens demanar\u00e0 una altra vegada usuari i contrasenya. Activitat 210. \u00c0rea d'un rectangle Calcula l'\u00e0rea d'un rectangle donades les seues dimensions Inserim la base. Especifiquem l'al\u00e7ada. Calculem l'\u00e0rea: base per al\u00e7ada Mostrem el resultat per pantalla Activitat 211. Hola m\u00f3n 10 vegades Escriu el diagrama de flux necessari per imprimir per pantalla 10 vegades \"hola m\u00f3n\" Resolem aquesta activitat utilitzant el concepte bucle. Creem la variable \"compte\" i l'inicialitzem a 0. Despr\u00e9s imprimim \"Hola m\u00f3n\" i incrementem la variable \"compte\" en uno. Verifiquem si \"compte\" encara \u00e9s menor que 10. En cas veritable, imprimim \"Hola m\u00f3n\" i tornem a incrementar. Quan la \"compte\" valga 10 eixim del programa. comptador = 0; Imprimir \"Hola m\u00f3n\" Incrementem compte Si comptador < 10 tornem al pas 2 en cas contrari s'acaba l'execuci\u00f3 Activitat 212. Preparar el t\u00e9 Dibuixa el diagrama de flux amb els passos necessaris per preparar el t\u00e9. Comprar t\u00e9 i/o sucre. Tindre tassa i cullera. Posar a bullir aigua. Posar la bossa de t\u00e9 a la tassa. Posar aigua a la tassa amb la bossa (de t\u00e9). Esperar uns minuts a que es dissolga el t\u00e9. Retirar la bossa (de t\u00e9) Vols sucre? Si la resposta \u00e9s s\u00ed, posar sucre i mesclar. Si la resposta \u00e9s no s'acabat el proc\u00e9s. Activitat 213. N\u00famero major Escriu el diagrama de flux de tal forma que donats dos n\u00fameros ens indique quin \u00e9s m\u00e9s gran. Introduir els valors A i B Llegir els seus valors Si A == B tornar al pas 1 Si A > B escriure per pantalla: \"A \u00e9s major que B\" En cas contrari escriure: \"B \u00e9s major que A\". Acabar el proc\u00e9s. Activitat 214. Suma dos n\u00fameros Algorisme que demana dos n\u00fameros i els suma mostrant el resultat per pantalla. Declarem la variable suma i la inicialitzem a 0. Inserim dos n\u00fameros. Sumem els dos n\u00fameros i els afegim a suma. Mostrem suma per pantalla. Activitat 215. Llevar la fam Ens trobem a casa i tenim fam. Qu\u00e8 fem? Preguntem si tenim fam. Si la resposta \u00e9s no s'acaba el procediment, ja estem satisfets. Si la resposta \u00e9s si busquem el menjar a la nevera. Si hi ha menjar a la nevera la calfem i mengem Si no hi ha res a la nevera, Ini((Inici))-->A[/Introdueix un nombre:/]; Activitat 216. Parell o senar Algorisme que determina si el n\u00fameroJ que inserim \u00e9s parell o senar. Introduim un n\u00famero 'N' Si 'N' es divideix entre 2 i el residu \u00e9s 0 (N mod 2 = 0), aleshores 'N' \u00e9s parell. En cas contrari \u00e9s senar. Activitat 217. Agafar el paraig\u00fces Algorisme per determinar quan ixc de casa si necessite o no agafar un paraig\u00fces. Comprovem si est\u00e0 plovent. Si la resposta \u00e9s No, eixim al carrer sense paraig\u00fces. Si la resposta \u00e9s S\u00ed, busquem el paraig\u00fces Si el trobem eixim al carrer En cas contrari tornem al pas 1. Activitat 218. Mitjana Algorisme que calcula la mitjana d'un alumne amb tres notes i mostra per pantalla si est\u00e0 \"Aprovat\" o \"Susp\u00e8s\". La nota m\u00ednima per aprovar \u00e9s 11. Declarem les variables a utilitzar: Nota1, Nota2, Nota3, Mitjana. Inserim les notes per teclat. Calculem la mitjana Verifiquem si la mitjana \u00e9s major o igual a 5. Si \u00e9s major que 5, escrivim per pantalla \"Aprovat\" En cas contrari escrivim \"Susp\u00e8s\"","title":"Activitats"},{"location":"Tema%2003.%20El%20llenguatge%20Java/","text":"Tema 3. El llenguatge Java Introducci\u00f3 Una vegada estudiat el teorema del programa estructurat juntament amb els diagrames de flux i pseudocodi, passem a veure aquests conceptes te\u00f2rics en un llenguatge de programaci\u00f3 d'alt nivell concret com \u00e9s el llenguatge de programaci\u00f3 Java. El Java \u00e9s un llenguatge de programaci\u00f3 dissenyat el 1990 per James Gosling amb altres companys de Sun Microsystems a partir del llenguatge C . Des del seu naixement fou pensat com un llenguatge orientat a objectes. Entre el 13 de novembre de 2006 i el maig del 2007 Sun va alliberar parts de Java com a programari lliure de codi obert amb llic\u00e8ncia GPL . \u00c9s un dels llenguatges de programaci\u00f3 m\u00e9s utilitzats, i s'utilitza tant per aplicacions web com per aplicacions d'escriptori. El Java \u00e9s un llenguatge compilat amb una m\u00e0quina virtual d'intermediari i, per tant, pot semblar lent en comparaci\u00f3 amb altres llenguatges, per\u00f2 ofereix un \u00edndex de re-utilitzaci\u00f3 de codi molt elevat, sent possible trobar moltes llibreries lliures de Java . \u00c9s un llenguatge flexible i potent tot i la facilitat amb la qual es programa i dels resultats que ofereix. Un dels trets que el caracteritza i que el fa una eina molt valorada a l'hora de desenvolupar aplicacions distribu\u00efdes, \u00e9s el fet que \u00e9s un llenguatge multi-plataforma. Generalment els programes de Java es compilen en un bytecode (fitxer .class) que pot c\u00f3rrer en una M\u00e0quina Virtual Java. Sun Microsystems disposa de tres implementacions diferents de Java: J2SE per a aplicacions d'escriptori; J2EE per a aplicacions distribu\u00efdes i J2ME per a plataformes amb recursos m\u00e9s redu\u00efts com ara m\u00f2bils o PDAs. Per a cada una de les tres implementacions \u00e9s possible descarregar el JRE (entorn d'execuci\u00f3 Java) per a executar aplicacions o el SDK (Eines per al desenvolupament d'aplicacions) per a programar aplicacions en Java, aquest \u00faltim tamb\u00e9 inclou el JRE. CARACTER\u00cdSTIQUES DE JAVA Senzill: Java s'ha creat perqu\u00e8 sigui un llenguatge senzill amb una sintaxi elegant. \u00danicament consta de tres tipus de dades prim\u00e0ries, eliminant els punters i l'her\u00e8ncia m\u00faltiple Orientat a objectes: Java segueix els paradigmes de la programaci\u00f3 orientada a objectes, ja que la programaci\u00f3 amb Java se centralitza en la manipulaci\u00f3, creaci\u00f3 i construcci\u00f3 d'objectes. Distribu\u00eft: Java permet la construcci\u00f3 d'aplicacions distribu\u00efdes per mitj\u00e0 d'una col.lecci\u00f3 espec\u00edfica de classes. Interpretat: Es necessita un int\u00e8rpret per executar els programes de Java, aix\u00f2 alenteix als programes per\u00f2 els hi dona flexibilitat. Robust: Java \u00e9s un llenguatge robust i fiable, s'ha escrit pensant a poder verificar errors i est\u00e0 molt tipificat. Segur: Java t\u00e9 pocs problemes de seguretat, caracter\u00edstica molt important en les aplicacions distribu\u00efdes d'Internet. Arquitectura neutral: Java \u00e9s independent de la plataforma final on s'executar\u00e0 el programa. Portable: Java \u00e9s un llenguatge d'alt nivell i de plataforma independent, aix\u00f2 li dona portabilitat. Alt rendiment: Els compiladors Java han anat millorant les seves prestacions. Els nous compiladors coneguts com a JIT permeten un rendiment molt semblant als llenguatges convencionals compilats. Concurrent: Java permet l'execuci\u00f3 de m\u00faltiples fils d'execuci\u00f3, o diverses tasques de forma simult\u00e0nia. Din\u00e0mic: En temps d'execuci\u00f3, l'entorn Java es pot ampliar mitjan\u00e7ant enlla\u00e7os a classes que poden estar localitzades en servidors remots o en xarxa. Un programa desenvolupat amb Java no necessita compilar-se de nou per a poder executar-se en qualsevol de les plataformes que disposi d'una versi\u00f3 instal\u00b7lada de JRE prou actualitzada per al programa. En aquest tema veurem la sintaxis b\u00e0sica de Java: paraules reservades, dades, variables, constants, identificadors i com tamb\u00e9 es codifiquen les estructures de control vistes al tema anterior en llenguatge Java. Dades, Variables, identificadors. Eventualment la inform\u00e0tica el que tracta de fer \u00e9s interpretar i processar informaci\u00f3 , per tant, el primer pas hauria de ser implementar el mecanisme que s'encarregue de representar la informaci\u00f3 tal i com la interpretem nosaltres al m\u00f3n real. La informaci\u00f3 en inform\u00e0tica \u00e9s el contingut d'una o m\u00e9s dades , fent abstracci\u00f3 de la representaci\u00f3 concreta que adopta. Dit d'una altra manera. Imagineu el caixer d'un supermercat. Al final del dia el treballador que est\u00e0 a c\u00e0rrec del caixer, traur\u00e0 tota la recaptaci\u00f3 del dia i la comptar\u00e0. En aquest cas la informaci\u00f3 seria la quantitat total de diners que s'han recaptat, i es representa en forma de dada num\u00e8rica utilitzant nombres i algun signe de puntuaci\u00f3, 1.200,45\u20ac seria la dada que representa la informaci\u00f3 que es vol saber al final del dia. Qu\u00e8 s\u00f3n les Dades Una dada \u00e9s \"la representaci\u00f3 convencional de la informaci\u00f3 en un format adequat perqu\u00e8 puga ser processada, comunicada o interpretada per mitjans manuals o autom\u00e0tics.\" Ara la q\u00fcesti\u00f3 \u00e9s com aquesta informaci\u00f3 que al m\u00f3n real es representa utilitzant n\u00fameros la podem representar en forma de dada per tal que una m\u00e0quina siga capa\u00e7 de processar. En qualsevol llenguatge de programaci\u00f3, la informaci\u00f3 es pot representar de forma constant, amb literals per exemple, o de forma variable utilitzant identificadors . Mirem a continuaci\u00f3 amb m\u00e9s detall aquests conceptes. Qu\u00e8 s\u00f3n les Variables Una variable en el camp de les matem\u00e0tiques \u00e9s una quantitat que pot cr\u00e9ixer o decr\u00e9ixer d'una manera cont\u00ednua o discont\u00ednua. Mentre que en inform\u00e0tica \u00e9s un s\u00edmbol emprat en programaci\u00f3 per a emmagatzemar en mem\u00f2ria valors canviants. En resum, la realitat cont\u00e9 una informaci\u00f3 en forma de dada que representarem en un programa inform\u00e0tic de diverses formes, b\u00e9 a trav\u00e9s de literals o de variables a les quals accedirem utilitzant identificadors . Per\u00f2 no ens avancem encara i estudiem b\u00e9 qu\u00e8 \u00e9s un identificador . En tot llenguatge de programaci\u00f3 existeixen una s\u00e8rie d'elements com variables, constants, funcions, llibreries. Aquests elements requereixen d'un nom per tal de distingir-lo de la resta. Aquests noms es diuen identificadors Qu\u00e8 s\u00f3n els identificadors Un identificador \u00e9s una cadena alfanum\u00e8rica que representa o dona un nom a un element dins del nostre programa. Els identificadors de les variables s\u00f3n noms que s'inventa el programador i s'hauria de tindre en consideraci\u00f3 al seg\u00fcent m\u00e0xima: han de ser significatius En altres paraules, un identificador \u00e9s una etiqueta que podem utilitzar per anomenar \"coses\" en un programa inform\u00e0tic. Pel que fa al concepte de significatiu , vol dir que el nom que escollim per a l'etiqueta hauria de ser suficientment esclaridor per saber qu\u00e8 \u00e9s el que representa. Per exemple, si volem posar una etiqueta (amb un adhesiu) a una botella d'aigua que tenim a la nevera, una bona elecci\u00f3 seria: AIGUA . Una \u00faltima cosa, com en tot llenguatge de programaci\u00f3, Java t\u00e9 una s\u00e8rie de normes que hem de seguir per construir identificadors v\u00e0lids. LLig i revisa les normes de construcci\u00f3 d'identificadors de Java, que d'altra banda, s\u00f3n molt semblants a la majoria de llenguatges de programaci\u00f3. Normes per construir identificadors en Java Quan triem el nom per identificar a una variable, ha de ser significatiu, \u00e9s a dir, que el mateix identificador ja done alguna pista de que \u00e9s el que representa. 1. Estan formats per caracters i/o digits. 2. No poden comen\u00e7ar per digit. 3. No poden usar els seg\u00fcents caracters especials: + - * / = % & # ! ? ^ \u201c \u2018 ~ \\ | < > ( ) [ ] { } : ; . , 4. No poden ser cap paraula reservada de Java. 5. Els identificadors de Java distingeixen entre maj\u00fascules i min\u00fascules (case sensitive). 6. No hi ha l\u00edmit a la llarg\u00e0ria de l'identificador, per\u00f2 \u00e9s aconsellable utilitzar una grand\u00e0ria \u00f2ptima entre 4 i 15 caracters. Vejam a continuaci\u00f3 alguns exemples d'identificadors inventats per un programador qualsevol: Exemples d'identificadors Observa la llista d'identificadors seg\u00fcents: Identificadors Correctes H0la: malgrat tindre un n\u00famero comen\u00e7a per un caracter alfanum\u00e8ric. $vicent: v\u00e0lid ja que el s\u00edmbol de dollar \u00e9s un caracter alfanum\u00e8ric v\u00e0lid per inicia un identificador. _strNom: els identificadors poden comen\u00e7ar per '_' \u00e9s m\u00e9s de vegades \u00e9s un convencionalisme per algun tipus concret de variable. _3variable: seria incorrecta si no tingu\u00e9s '_' com a primer caracter de l'identificador. VarTest: totalment correcta. variabletest: cap incorrecci\u00f3 aci_tens_una_variable_valida_que_representa_un_enter: identificador totalment v\u00e0lid, altra cosa \u00e9s que els noms tan llargs siguen \u00fatils. valor_max: el subratllat tamb\u00e9 sol ser una t\u00e8cnica que s'utilitza per a separar dues paraules que formen un identificador. Identificadors Incorrectes 8exemple: comen\u00e7a per n\u00famero exa+mple: el signe + no est\u00e0 perm\u00e8s prova variable: espai en blanc esta_variable_no_es_valida_no_per_llarga_sino_per_este-guionet: a banda del gui\u00f3 del final tampoc \u00e9s massa aconsellable utilitzar noms tan llargs. Activitat 301. Classifica els seg\u00fcents identificadors Com ja hem explicat a l'apartat anterior, per formar un identificador s'han de seguir unes normes. Revisa els identificadors seg\u00fcents i digues-me quins s\u00f3n v\u00e0lids i quins no. Si no s\u00f3n v\u00e0lids explica el motiu. Identificadors Soluci\u00f3 Identificador Es v\u00e0lid? Motiu Identificador Es v\u00e0lid? Motiu Registre1 S\u00ed 1registre No Els identificadors no poden comen\u00e7ar per n\u00famero while $impost a\u00f1o primer cognom primer_cognom primer-cognom primerCognom Tom's C3PO 123# PesM\u00e0xim %descompte Weight $$preuM\u00e0xim pes.maxim Preu_____ matricula? muchoVale high bar\u00e7a pirag\u00fcista B_011 X012AB 70Llibre nom&cognom 0X1A else Identificador Es v\u00e0lid? Motiu Identificador Es v\u00e0lid? Motiu Registre1 S\u00ed 1registre No Els identificadors no poden comen\u00e7ar per n\u00famero while No Paraula reservada $impost S\u00ed a\u00f1o S\u00ed I primer cognom No No es permeten espais en blanc enmig de l'identificadors primer_cognom S\u00ed primer-cognom No \"-\" no est\u00e0 perm\u00e8s per a la creaci\u00f3 d'identificadors primerCognom S\u00ed Tom's No \"'\" no \u00e9s un caracter perm\u00e8s C3PO S\u00ed 123# No Un identificador no pot comen\u00e7ar per n\u00famero PesM\u00e0xim S\u00ed %descompte No \"%\" no \u00e9s un caracter perm\u00e8s Weight S\u00ed $$preuM\u00e0xim S\u00ed pes.maxim S\u00ed \".\" no \u00e9s un caracter v\u00e0lid Preu_____ S\u00ed matricula? No \"?\" no \u00e9s un caracter v\u00e0lid MuchoVale S\u00ed high S\u00ed bar\u00e7a S\u00ed pirag\u00fcista S\u00ed B_011 S\u00ed X012AB No Comen\u00e7a per n\u00famero hexadecimal 70Llibre No Comen\u00e7a per n\u00famero nom&cognom No \"&\" caracter no v\u00e0lid 0X1A No Comen\u00e7a per n\u00famero else No Paraula reservada Algunes idees per crear identificadors Observa els identificadors seg\u00fcents i apren com crear identificadors significatius, alguns exemples: estatura: pot identificar l'estatura (al\u00e7ada) d'una persona per exemple. RAM: podria indicar la capacitat RAM d'un ordinador. oratge: ens podria servir per emmagatzemar informaci\u00f3 relativa a l'oratge: solejat, nuvol, plovent, vent... resolucio: indicaria la resoluci\u00f3 d'una pantalla Activitat 302. Crea identificadors Identificadors Soluci\u00f3 Inventa noms d'identificadors per als seg\u00fcents escenaris. Una etiqueta que identificar\u00e0 l'edat d'una persona: Un nom d'assignatura: Una mitjana aritm\u00e8tica de notes: La profunditat d'una piscina: Els litres d'aigua que hi han a la nevera: La dist\u00e0ncia al supermercat m\u00e9s pr\u00f2xim: En aquesta activitat existeixen m\u00faltiples respostes per a cada identificadors, ac\u00ed teniu una possible soluci\u00f3 al problema anterior. Una etiqueta que identificar\u00e0 l'edat d'una persona: edat Un nom d'assignatura: nomAssignatura Una mitjana aritm\u00e8tica de notes: mijanaNotes La profunditat d'una piscina: profunditatPiscina Els litres d'aigua que hi han a la nevera: litresNevera La dist\u00e0ncia al supermercat m\u00e9s pr\u00f2xim: distanciaSuper Paraules reservades Uns dels principals identificadors que ens trobarem a tot llenguatge de programaci\u00f3 s\u00f3n les paraules reservades . Per entendre-ho, el conjunt de paraules reservades d'un llenguatge de programaci\u00f3 s\u00f3n el diccionari de totes les paraules que t\u00e9 aquest llenguatge. Aquestes paraules reservades no poden utilitzar-se per cap altra cosa m\u00e9s, per exemple, si Java t\u00e9 la paraula reservada public , el programador no podr\u00e0 crear cap variable utilitzant l'identificador public. Paraules reservades abstract continue for new switch assert default goto package sychronized boolean do if private this break double implements protected throw byte else import public throws case enum instanceof return transient catch extends int short try char final interface static void finally long strictfp volatile const float native super while class Identificadors reservats de l'API de Processing IDE Com que Processing IDE no \u00e9s m\u00e9s que una capa afegida a l'entorn de programaci\u00f3 en Java, t\u00e9 les mateixes paraules reservades que Java i a m\u00e9s a m\u00e9s, com que disposa d'una API (Application Programming Interface) amb moltes funcionalitats, ja hi han una s\u00e8rie d'identificadors d'aquestes funcions que s'hauran de tindre en compte i no les podrem utilitzar. A continuaci\u00f3 una breu llista d'aquests identificadors: setup, draw, mouseClicked, keyPressed, delay, background, size, clear, rect, ellipse, circle, triangle, pushMatrix, popMatrix, translate, PVector, PImage, etc.. No existeix una taula on les podem consultar totes, \u00e9s q\u00fcesti\u00f3 d'anar treballant amb Processing i aprendre-les conforme les anem utilitzant. Activitat 303. Identifica i classifica identificadors Llig el seg\u00fcent codi amb atenci\u00f3, localitza tots els identificadors i digues-me quins s\u00f3n paraules reservades i quins no. D'aquells que no s\u00f3n paraules reservades, quina informaci\u00f3 penses que volen representar? Codi en Java Soluci\u00f3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void setup () { size ( 640 , 480 ); } void draw () { clear (); background ( 255 ); float a = random ( 640 ); float b = random ( 480 ); dibuixaUnaBoleta ( a , b ); delay ( 500 ); } void dibuixaUnaBoleta ( float num1 , float num2 ) { fill ( 0 ); ellipse ( a , b , 30 , 30 ); } Identificadors Classificaci\u00f3 Identificadors Classificaci\u00f3 void Paraula reservada de java a Identificador d'usuari setup Funci\u00f3 de l'API de Processing b Identificador d'usuari size Funci\u00f3 de l'API de Processing dibuixaUnaBoleta Identificador d'usuari float Paraula reservada de java delay Funci\u00f3 de l'API de Processing draw Funci\u00f3 de l'API de Processing num1 Identificador d'usuari clear Funci\u00f3 de l'API de Processing num2 Identificador d'usuari background Funci\u00f3 de l'API de Processing fill Funci\u00f3 de l'API de Processing random Funci\u00f3 de l'API de Processing ellipse Funci\u00f3 de l'API de Processing Tipus de dades Fins ara tot ha girat al voltant d'informaci\u00f3, dades, identificadors, literals i variables, ja que s\u00f3n la base per poder representar la informaci\u00f3 i les dades d'un problema. Per\u00f2, quins tipus de dades es poden representar en Java? Tot llenguatge de programaci\u00f3 porta una s\u00e8rie de tipus de dades predefinits que es poden usar. Aquests tipus de dades tamb\u00e9 es coneixen com a tipus primitius o tipus simples. . Java defineix 8 tipus diferents de dades: byte, short, int, long, char, float, double i boolean. Aquests tipus es poden agrupar en quatre blocs: Nombres enters: on podem trobar el byte, short, long i int. Aquests tipus admeten valors no fraccionables en parts m\u00e9s xicotetes que la unitat. Per exemple: 1, 3, 5, 15, 20, 132... Punt flotant: aquest grup inclou el float i el double on es representen els nombres decimals, \u00e9s a dir, aquells que s\u00ed admeten fraccions. Per exemple: 1.3, 5.802039, etc.. Caracters: char representa a tot el conjunt de caracters del nostre sistema alfab\u00e8tic inclosos els s\u00edmbols. Per exemple: a, b, c, $, ?... Boole\u00e0: boolean \u00e9s un tipus especial que nom\u00e9s pot tindre dos possibles valors: true o false . Qu\u00e8 s\u00f3n els dos valors l\u00f2gics de l'algebra de George Boole. Taula de tipus de dades en Java Tipus Bytes Representaci\u00f3 Categoria byte 1 de -128 a 127 enter short 2 de -32.768, 32.767 enter int 4 de -2^31 a 2^31-1 enter long 8 de -2^63 a 2^63-1 enter float 4 de 1.4x10^-45 a 3.4028235x10^38 decimal double 8 de 4.9x10^-324 a 1.7976931348623157x10^308 decimal char 2 caracters UTF-16 caracter bool 1 true o false boole\u00e0 En resum del que hem vist fins ara, el primer que s'ha d'establir en tot llenguatge de programaci\u00f3 d'alt nivell, s\u00f3n els mecanismes necessaris per tal de poder representar en totes les seues variants possibles la informaci\u00f3 del m\u00f3n real que volem informatitzar i processar. Aquests mecanismes s\u00f3n: Tipus de dades, Identificadors, Paraules reservades i Variables Variables Al final tot programa s'encarrega de processar informaci\u00f3 i aquesta informaci\u00f3 ha d'estar disponible en algun lloc del nostre codi. Per exemple si volem fer un programa que sume dos n\u00fameros enters, haurem de tindre la informaci\u00f3 o el valor d'aquests dos n\u00fameros en algun lloc. Una variable \u00e9s com un contenidor ( una caixeta ) que t\u00e9 associat un tipus de dades (int, float, double, char) i cont\u00e9 un valor , si es tracta d'una variable de tipus enter contindr\u00e0 un valor enter, si per contra es tracta d'una variable de tipus caracter contindr\u00e0 una lletra o s\u00edmbol alfanum\u00e8ric. La variable \u00e9s l'unitat b\u00e0sica d'emmagatzemament en Java. Una variable en java es defineix amb la combinaci\u00f3 d'un identificador i el seu tipus de dades . Mira els exemples a continuaci\u00f3: 1 2 3 4 5 6 7 8 9 10 // Declaraci\u00f3 d'una variable en Java // type identifier; // On type \u00e9s algun dels tipus de dades que hem vist a l'apartat anterior // i identifier \u00e9s l'identificador que volem utilitzar. // Per exemple: int a ; // Declaraci\u00f3 d'una variable entera amb nom a float b ; // Variable flotant de nom b char c ; // Variable caracter amb nom c int i = 0 ; // En aquesta declaraci\u00f3 s'inclou tamb\u00e9 la inicialitzaci\u00f3 del seu valor. long j ; Les variables com a contenidors d'informaci\u00f3, poden variar (d'ac\u00ed el nom de variable) el seu valor durant l'execuci\u00f3 del programa. Per\u00f2 millor vegem un exemple, imaginem una aplicaci\u00f3 en la que volem controlar la posici\u00f3 d'un element qualsevol, per exemple un cercle a una pantalla 2D (o una boleta). Per determinar la posici\u00f3 de qualsevol element en un escenari 2D necessitem dues coordenades: x i y . Les variables que podriem utilitzar serien dos variables de tipus enter on al seu nom s'indique clarament el que intenten representar. Si volguerem fer un sistema on les posicions tingueren m\u00e9s precisi\u00f3, podriem usar floats en lloc d' int. 1 2 3 4 5 int posX ; // Variables que representa la posici\u00f3 X de l'element. int posY ; // Variable que representa la posici\u00f3 Y de l'element. float posXPrecisa ; // Variable que representa la posici\u00f3 X de l'element amb precisi\u00f3 flotant. float posYPrecisa ; // Variable que representa la posici\u00f3 Y de l'element amb precisi\u00f3 flotant. Observa el codi anterior i basant-se en la norma de creaci\u00f3 de variables type identifier; que hem vist abans, raona quins s\u00f3n els tipus de dades de les variables i quins els seus identificadors? Si hi han moltes variables que tenen el mateix tipus base, podem agrupar les declaracions per tipus separant els identificadors amb coma excepte a l'\u00faltim identificador, on a continuaci\u00f3 seguir\u00edem posat un punt i coma per indicar el final de la sent\u00e8ncia. 1 2 int a , b , c , d , e , f , g ; // Declaracio de m\u00faltiples variables de tipus enter float m , n , o , p , q ; // Declaraci\u00f3 de m\u00faltiples variables de tipus flotant Activitat 304. Declaraci\u00f3 de variables Problema Soluci\u00f3 Imagina que fem un programa en el que es pret\u00e9n portar el control de la informaci\u00f3 personal d'un equip de basquet. Per a cadascun dels jugadors necessitariem emmagatzemar la informaci\u00f3 relativa a: Nom, cognoms, pes, al\u00e7ada i tota aquella informaci\u00f3 que consideres que \u00e9s important saber sobre un jugador qualsevol. Declara com hem vist als apartats anteriors les variables necess\u00e0ries per poder gestionar eixa informaci\u00f3. 1 2 3 4 5 6 7 8 9 10 // Declaraci\u00f3 de variables per a un jugador de b\u00e0squet String nomJugador ; // El nom d'un jugador \u00e9s una cadena de caracters. String primerCognom ; // El primer cognom tamb\u00e9 \u00e9s una cadena String segonCognom ; // Igual passa amb el segon cognom float pes ; // El pes es podria representar amb un decimal: 70,3 kg int al\u00e7ada ; // Si la al\u00e7ada \u00e9s en cent\u00edmetres amb un enter sobraria String posicio ; // Les posicions poden ser: base, ala, ala-pivot, escolta o pivot per tant un String int puntsAnuals ; // Els punts s\u00f3n un valor enter int assist\u00e8ncies ; // Idem que amb els punts float efectivitat ; // La efectivitat \u00e9s un percentatge per tant he d'usar un float Literals En programaci\u00f3 no nom\u00e9s es pot tractar la informaci\u00f3 mitjan\u00e7ant l'\u00fas de variables , tamb\u00e9 es poden emmagatzemar dades fent \u00fas dels literals . I qu\u00e8 s\u00f3n els literals? Un literal \u00e9s, segons el termCAT, una expressi\u00f3 o part d'una instrucci\u00f3 que representa expl\u00edcitament un valor. En altres paraules, mentre que les variables s\u00f3n cadenes alfanum\u00e8riques que representen un valor canviant, un literal \u00e9s una cadena alfanum\u00e8rica que representa exactament el que posa. Des del punt de vista m\u00e9s espec\u00edfic de la inform\u00e0tica, un literal \u00e9s un valor alfanum\u00e8ric que s'utilitza com una constant , \u00e9s a dir, que el seu valor no varia durant l'execuci\u00f3 del programa. Per\u00f2 com podem distingir el tipus dels literals o si s\u00f3n correctes o no? Mirem primer quins tipus de terminals ens podem trobar en Java. Literals enters: existeixen tres formes de el valor d'un n\u00famero enter. Si s'escriu solament el n\u00famero, aquest representa una xifra en base decimal . Si t\u00e9 un 0 davant estem escrivint n\u00fameros en sistema octal i si t\u00e9 el prefix \"0x\" aleshores est\u00e0 representat en base hexadecimal . Finalment si el que volem \u00e9s representar un literal de tipus long ho farem afegint un caracter 'L' al final de la cadena num\u00e8rica. Literals decimals: Per representar literals en coma flotant podem utilitzar el '.' per exemple: 10.3, o la notaci\u00f3 cient\u00edfica com 10.3e+5 que seria l'equivalent a 10.3 per 10 elevat a 5. Literals caracters i cadenes: Un literal de tipus caracter emmagatzema un caracter Unicode . Aquest sistema de codificaci\u00f3 amplia les opcions que t\u00e9 la codificaci\u00f3 ASCCII per incloure altres alfabets. Podem escriure en grec, hebreu o vietnamita sense que el compilador proteste. Un literal de tipus char s'expressa envoltant el caracter entre cometes simples. Una altra manera de representar un caracter \u00e9s indicant el codi Unicode en hexadecimal, posant com a prefix la cadena \\u, tot entre cometes simples. D'aquesta forma el s\u00edmbol '@' s'escriuria: '\\u0040. Literal Un literal \u00e9s un valor que poden assignar a les variables o que es pot usar com a terme constant. Depenent del tipus de variable, podrem assignar uns valors o uns altres. Els literals poden ser: enters, decimals, caracter o cadena. Literals enters: 12, 2, -3, 12L (long), 0b101010 (bin\u00e0ria), 0x1a (hexadecimal), 0754 (octal) Literals decimals: 12.2, 12.2F, 12.2D (double). Literals car\u00e0cter: 'a', 'b', '$'. Literals cadena: \"Bela\", \"Ciao\". Activitat 305. Literals num\u00e8rics Indica quins literals s\u00f3n v\u00e0lids. Per cadascun dels literals m\u2019has d\u2019indicar si es v\u00e0lid o no aix\u00ed com tamb\u00e9 el tipus de dades t\u00e9 associat. Problema Soluci\u00f3 Literal Tipus V\u00e0lid Sistema Literal Tipus V\u00e0lid Sistema 0.5 .5 9.3e12 9.3e-12 12345678 12345_L 0.8E+0.8 0.8E 8 05_15 018CDF 0XBC5DA 0x87e3a 234567L 0_B11 010101 0_557 .00.8E2 .3e3f 0b111 12_234L 0Xabcd 0xabcEL _234 1010B 0x1010B 1_234.2E-2 1234.2EF 1234.2E3F 1_1.2e_2 0bABCDL 0X1A 0X12AL abcd 0125 .01011 3e12 3_e12 -3E-1_2 0.8E 0B1212 1_2_3 0xedad 0XBE2 101e2 B1101 1.34.5 12.3E4F 0X12AG Literal Tipus V\u00e0lid Sistema /Error Literal Tipus V\u00e0lid Sistema / Error 0.5 double S\u00ed sistema decimal .5 double S\u00ed sistema decimal 9.3e12 double S\u00ed sistema decimal 9.3e-12 double S\u00ed sistema decimal 12345678 int S\u00ed sistema decimal 12345_L - No posici\u00f3 no v\u00e0lida per al caracter '_' 0.8E+0.8 - No exponent no v\u00e0lid. No pot ser decimal 0.8E 8 - No hi ha un espai entre E i 8 05_15 int S\u00ed sistema octal 018CDF - No Comen\u00e7a per 0 (octal) per\u00f2 t\u00e9 CDF? 0XBC5DA int S\u00ed sistema hexadecimal 0x87e3a int S\u00ed sistema hexadecimal 234567L long S\u00ed sistema decimal 0_B11 - No '_' caracter no v\u00e0lid 010101 int S\u00ed sistema octal 0_557 int S\u00ed sistema octal .00.8E2 - No nom\u00e9s poden tenir un sol punt (.) .3e3f float S\u00ed sistema decimal 0b111 int S\u00ed sistema binari 12_234L long S\u00ed sistema decimal 0Xabcd int S\u00ed sistema hexadecimal 0xabcEL long S\u00ed sistema hexadecimal _234 - No el caracter '_' no \u00e9s correcte 1010B - No si fora binari deuria comen\u00e7ar per 0b 0x1010B int S\u00ed sistema hexadecimal 1_234.2E-2 double S\u00ed sistema decimal 1234.2EF - No falta el valor exponent entre E i F 1234.2E3F float S\u00ed sistema decimal 1_1.2e_2 - No el caracter '_' despr\u00e9s d'exponent 0bABCDL - No Si fora hexadecimal deuria comen\u00e7ar per 0x 0X1A int S\u00ed sistema hexadecimal 0X12AL long S\u00ed sistema hexadecimal abcd - No si fora hexadecimal comen\u00e7aria per 0x 0125 int S\u00ed sistema octal .01011 double S\u00ed sistema decimal 3e12 double S\u00ed sistema decimal 3_e12 - No caracter '_' incorrecte. -3E-1_2 double S\u00ed sistema decimal 0.8E - No falta el valor de l'exponent 0B1212 - No els numeros binaris nom\u00e9s poden contindre 1 i 0 1_2_3 int S\u00ed sistema decimal 0xedad int S\u00ed sistema hexadecimal 0XBE2 int S\u00ed sistema hexadecimal 101e2 double S\u00ed sistema decimal B1101 - No si fos binari comen\u00e7aria per 0B 1.34.5 - No els literals nom\u00e9s poden tenir un punt (.) 12.3E4F float S\u00ed sistema decimal 0X12AG - No 'G' no \u00e9s un caracter v\u00e0lid Activitat 306. Literals caracter Indica quins dels seg\u00fcents literals de tipus caracter s\u00f3n v\u00e0lids. Problema Soluci\u00f3 Literal V\u00e0lid Motiu Literal V\u00e0lid Motiu 'a' '$' '\\n' '/n' '\\' '\\\u00f1' \"T\" '\u00f1' 'xyz' '\\u0066' \"XYZ\" '4' '\\t' '\\b' k + '+' '?' '\u00e0' ':' Literal V\u00e0lid Motiu Literal V\u00e0lid Motiu 'a' S\u00ed '$' S\u00ed '\\n' S\u00ed Seq\u00fc\u00e8ncia d'escapament '/n' No Per ser seq. escapament la barra \u00e9s invertida '\\' S\u00ed Seq\u00fc\u00e8ncia d'escapament '\\\u00f1' No Seq\u00fc\u00e8ncia d'escapament no v\u00e0lida \"T\" No S'usen comentes simples '\u00f1' S\u00ed 'xyz' No Hi ha m\u00e8s d'un caracter '\\u0066' S\u00ed Representa un valor UNICODE \"XYZ\" No Hi ha m\u00e9s d'un caracter '4' S\u00ed '\\t' S\u00ed Seq\u00fc\u00e8ncia escapament '\\b' S\u00ed Seq\u00fcencia d'escapament k No Falten les comentes simp + No Falten cometes simples '+' s\u00ed '?' S\u00ed '\u00e0' S\u00ed ':' S\u00ed Activitat 307. Literals String Indica quins dels seg\u00fcents literals s\u00f3n literals de tipus string v\u00e0lid. Problema Soluci\u00f3 Literal V\u00e0lid Motiu Literal V\u00e0lid Motiu '8:15 PM' \"FP' \"Roig i blau\" \" programaci\u00f3 \" \"Nom: \"programaci\u00f3 \"Java\"\" \"Capitol\\'3\\'\" programaci\u00f3 \"1.e3-1-2\" 'W' \"\" \"\\n\" \" \" \"\\b\" \"A\" \"4 + 5 * 2\" Literal V\u00e0lid Motiu Literal V\u00e0lid Motiu '8:15 PM' No String va entre cometes dobles \"FP' No La cometa simple del final \"Roig i blau\" S\u00ed \" programaci\u00f3 \" S\u00ed \"Nom: No Falten les cometes al final \"programaci\u00f3 \"Java\"\" No Les cometes dins de les cometes \"Capitol\\'3\\'\" S\u00ed Un literal pot tindre escapa. programaci\u00f3 No On estan les cometes dobles? \"1.e3-1-2\" S\u00ed 'W' No Cometes dobles \"\" S\u00ed Cadena buida \"\\n\" S\u00ed \" \" S\u00ed String amb un sol espai blanc \"\\b\" S\u00ed Backspace \"A\" S\u00ed \"4 + 5 * 2\" S\u00ed Declaraci\u00f3, inicialitzaci\u00f3 de variables Cal diferenciar entre la declaraci\u00f3 d'una variable , quan li donen nom i el tipus base com hem fet a l'activitat 304, i la inicialitzaci\u00f3 d'aquesta mateixa, quan li donem valor. Si recordeu l'exemple al qual necessitavem dues variables per representar la posici\u00f3 d'un element en un escenari 2D, haviem declarat les variables de tipus enter posX i posY per\u00f2 no els hauriem donat cap valor inicial. Si per declarar una variable \u00e9s necessari l'\u00fas d'un identificador que ens servir\u00e0 d'etiqueta per poder accedir a dita variable, per tal d'assignar-li un valor hem de fer \u00fas d'un literal . Per defecte Java inicialitzaria aquestes dues variables a zero, \u00e9s a dir, dins la caixa (contenidor) de cada variable, tindriem el valor zero si no s'indica el contrari. Activitat 308. Inicialitzaci\u00f3 de variables Problema Soluci\u00f3 Basant-nos en l'activitat del jugador de basquet, declara i inicialitza les variables que hages triat amb el tipus de dades que li corresponga i tamb\u00e9 les haur\u00e0s d'inicialitzar. Guarda aquesta activitat amb el nom de: CognomNomAct308.pde per poder lliurar-lo a aules. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // Declaraci\u00f3 de variables per a un jugador de b\u00e0squet String nomJugador ; // El nom d'un jugador \u00e9s una cadena de caracters. String primerCognom ; // El primer cognom tamb\u00e9 \u00e9s una cadena String segonCognom ; // Igual passa amb el segon cognom float pes ; // El pes es podria representar amb un decimal: 70,3 kg int al\u00e7ada ; // Si la al\u00e7ada \u00e9s en cent\u00edmetres amb un enter sobraria String posicio ; // Les posicions poden ser: base, ala, ala-pivot, escolta o pivot per tant un String int puntsAnuals ; // Els punts s\u00f3n un valor enter int assist\u00e8ncies ; // Idem que amb els punts float efectivitat ; // La efectivitat \u00e9s un percentatge per tant he d'usar un float /** * M\u00e8tode setup: m\u00e8tode de configuraci\u00f3 o inicialitzaci\u00f3 de l'aplicaci\u00f3. * Aprofitarem aquest m\u00e8tode per tal de donar valor inicial a les variables * abans declarades utilitzant els literals corresponents. */ void setup () { nomJugador = \"Manolo\" ; primerCognom = \"Studamaier\" ; segonCognom = \"Junior\" ; pes = 95.7f ; al\u00e7ada = 210 ; posicio = \"Ala-pivot\" ; puntsAnuals = 500 ; assist\u00e8ncies = 120 ; efectivitat = 0.9f ; } Constants Les constants en Java (les no literals) s\u00f3n semblants a les variables, \u00e9s a dir, s\u00f3n contenidors d'informaci\u00f3, tenen un identificador i un tipus b\u00e0sic associat per\u00f2 el seu valor no canvia durant l'execuci\u00f3 del programa. L'\u00fas de les constants sol ser per a definir valors immutables dins d'un programa com per exemple en un tauler d'escacs el n\u00famero de files i columnes \u00e9s 8 sempre. Declaraci\u00f3 i inicialitzaci\u00f3 de constats Una de les peculiaritats de les constants, a banda que el seu valor no varia mentre s'executa el programa, \u00e9s que el seu valor s'ha de fer a la mateixa l\u00ednia que la declaraci\u00f3. Les constants en java es defineixen de la seg\u00fcent forma: 1 2 // Constant en java static final int totalFiles = 8 ; // totalFiles valdr\u00e0 8 durant tot el programa. Comentaris Els comentaris a qualsevol llenguatge de programaci\u00f3, s'utilitzen per fer que el codi siga m\u00e9s f\u00e0cil de llegir millorant aix\u00ed el manteniment. Els comentaris s\u00f3n totalment ignorats pel compilador. D'altre banda, els comentaris s\u00f3n part de la documentaci\u00f3 de tot programa. \u00c9s molt important escriure comentaris breus per\u00f2 significatius. Massa text als comentaris produir\u00e0 l'efecte contrari i deixar\u00e0 encara m\u00e9s illegible el codi. Principi en programaci\u00f3 \"Un programa s'escriu una vegada per\u00f2 es llig moltes vegades\" En java tenim tres tipus de comentaris: Comentaris en l\u00ednia: S'utilitzen per comentar parts concretes del codi Comentaris de v\u00e0ries l\u00ednies: Si un programador vol descriure m\u00e9s detalladament un codi m\u00e9s complex i no es pot utilitzar el comentari d'una l\u00ednia perqu\u00e8 requereix m\u00e9s text Comentaris de documentaci\u00f3: Aquest tipus de comentaris ajuda a l'hora de generar documentaci\u00f3 de forma automatitzada per alguns dels IDEs que s'utilitzen a l'actualitat o les eines que porten amb ells. Un exemple d'eina de generar documentaci\u00f3 de refer\u00e8ncia \u00e9s javadoc 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // Comentari d'una sola l\u00ednia en Java /* Comentari de m\u00e9s d'una l\u00ednia linia 1 linia 2 ... linia final */ /** * Troba la mitjana de tres n\u00fameros! * El programa FindAvg implementa una aplicacio que * simplement calcula la mitjana de tres enters i els mostra * a la eixida per pantalla. * * @author Aleix Caminou * @version 1.0 * @since 2020-2-2 */ Activitat 309. Comentaris al codi Problema Soluci\u00f3 Visita el seg\u00fcent lloc web sobre comentaris de java i despr\u00e9s amb el codi de l'\u00faltima activitat, posa els seg\u00fcents comentaris: Un comentari de documentaci\u00f3 a nivell de fitxer explicant que fa l'aplicaci\u00f3. Un comentari de documentaci\u00f3 per m\u00e8tode explicant que fa cada m\u00e8tode. Comentaris de l\u00ednia (tant simple com m\u00faltiple) als llocs que consideres que siga necessari. Recorda que has de guardar aquest fitxer com a CognomNomAct309.pde per lliurar-lo. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 /** * Activitat 309. Comentaris de codi * ----------------------------------------------- * En aquesta activitat es demana que s'escriga un comentari de documentaci\u00f3 explicant el que fa l'aplicaci\u00f3. * B\u00e0sicament en aquesta aplicaci\u00f3 es declaren una s\u00e8rie de variables globals on s'emmagatzemar\u00e0 informaci\u00f3 * relativa a un jugador de b\u00e0squet com: nom, edat, pes etc... */ // Declaraci\u00f3 de variables per a un jugador de b\u00e0squet String nomJugador ; // El nom d'un jugador \u00e9s una cadena de caracters. String primerCognom ; // El primer cognom tamb\u00e9 \u00e9s una cadena String segonCognom ; // Igual passa amb el segon cognom float pes ; // El pes es podria representar amb un decimal: 70,3 kg int al\u00e7ada ; // Si la al\u00e7ada \u00e9s en cent\u00edmetres amb un enter sobraria String posicio ; // Les posicions poden ser: base, ala, ala-pivot, escolta o pivot per tant un String int puntsAnuals ; // Els punts s\u00f3n un valor enter int assist\u00e8ncies ; // Idem que amb els punts float efectivitat ; // La efectivitat \u00e9s un percentatge per tant he d'usar un float /** * M\u00e8tode setup. * Aquest \u00e9s el m\u00e8tode de configuraci\u00f3 de la nostra aplicaci\u00f3. * S'executa nom\u00e9s una vegada quan comen\u00e7a l'aplicaci\u00f3. * \u00c9s en aquesta funci\u00f3 on hem de posar totes les inicialitzacions per exemple * @return void */ void setup () { nomJugador = \"Manolo\" ; primerCognom = \"Studamaier\" ; segonCognom = \"Junior\" ; pes = 95.7f ; al\u00e7ada = 210 ; posicio = \"Ala-pivot\" ; puntsAnuals = 500 ; assist\u00e8ncies = 120 ; efectivitat = 0.9f ; } /** * M\u00e8tode draw * Tamb\u00e9 anomenat bucle del joc. Aquest m\u00e8tode s'executa amb una freq\u00fc\u00e8ncia de 60 vegades per segon (60Hz) * Aquest \u00e9s el m\u00e8tode principal de les aplicacions amb Processing IDE i \u00e9s el que ens permet poder fer animacions. * @return void */ void draw () { } Utilitza l'estructura anterior Pots utilitzar el codi de l'activitat anterior com a base de les pr\u00f2ximes activitats o programes que fages en Processing IDE. Tin en compte que els comentaris dels m\u00e8todes draw i setup sempre seran els mateixos o molt similar. B\u00e0sicament el que hauries de fer \u00e9s canviar el comentari de l'aplicaci\u00f3 que ser\u00e0 diferent abans de comen\u00e7ar a picar codi. Recorda que primer has d'esborrar tota la part de la declaraci\u00f3 i inicialitzaci\u00f3 de variables del jugador de b\u00e0squet. Fes-ho i guarda el fitxer resultant com a estructuraBasica.pde per poder-lo utilitzar quan ho necessites. Operadors i expressions Ha arribat el moment de revisar el que hem vist. Fins ara hem vist les dades com a unitat d'emmagatzemament d'informaci\u00f3 . Els diferents tipus de dades que ens proporciona Java, com les variables i les constants poden emmagatzemar dades que poden variar o no han de variar durant l'execuci\u00f3 del programa. I finalment tamb\u00e9 hem estudiat els literals i com construir identificadors per tal d'etiquetar distints elements dins del nostre programa. En definitiva em vist en detall com es pot representar tota classe d'informaci\u00f3 en un llenguatge de programaci\u00f3 com Java per\u00f2, com varem dir al primer tema, un programa inform\u00e0tic s'encarrega (entre d'altres) de processar l'informaci\u00f3 . B\u00e9 doncs, nosaltres de moment nom\u00e9s hem estudiat els diferents mecanismes que proporciona Java per gestionar eixa informaci\u00f3 per\u00f2 no hem vist encara com la podem processar. Per tal de poder processar la informaci\u00f3 haurem primer d'estudiar que s\u00f3n esl operadors i les expressions. Expressions Una expressi\u00f3 \u00e9s una equaci\u00f3 matem\u00e0tica que representa un c\u00e0lcul, per exemple: Exemple d'expressions 3 x + 7 z. 2 a b + a*a + 7 L'expressi\u00f3 anterior la formen els seg\u00fcents elements: dos literals enters: 3 i 7; dos identificadors de variables (no sabem el tipus) x i z; i els simbols * i +. Al final tota operaci\u00f3 t\u00e9 un valor , per exemple, si x val 3 i z val 2, el resultat (valor) de l'expressi\u00f3 seria 23. Que consistiria en multiplicar (*) el literal '3' per el contingut de la variable amb identificador x i despr\u00e9s sumar-li (+) el resultat de la multiplicaci\u00f3 del literal 7 per el contingut de la variable z. Els simbols + i * que hem vist a l'expressi\u00f3 anterior, s\u00f3n els operadors, concretament * \u00e9s l'operador aritm\u00e8tic de multiplicaci\u00f3 i el s\u00edmbol + representa l'operador de suma. Per\u00f2 abans de passar als operadors aritm\u00e8tics, vejam abans l'operador assignaci\u00f3. Operador assignaci\u00f3 L'operador assignaci\u00f3 (=) , com el seu nom indica, s'encarrega d'assignar-li a una variable el resultat d'una expressi\u00f3 matem\u00e0tica o el valor de una altra variable o un literal. S'ha de tenir en compte que el tipus de dades que representa b\u00e9 l'expressi\u00f3 matem\u00e0tica, el literal o l'altra variable han de coincidir als dos costats de l'operaci\u00f3 d'assignaci\u00f3. Com ja hem dit abans, l'operador assignaci\u00f3 en Java \u00e9s el s\u00edmbol '=' i s'utilitza de la seg\u00fcent forma: 1 2 3 4 // variable = expressi\u00f3 // Seguint l'exemple anterior int x = 3 , y , z = 2 ; y = 3 * x + 7 * z ; On l'operador '=' assignaria el valor de l'expressi\u00f3 '3x+2z' a la variable y, \u00e9s a dir, executada aquesta acci\u00f3 dins de la variable y haur\u00edem depositat el valor 23. Observa el codi escrit a continuaci\u00f3 on podr\u00e0s veure altres exemples d'\u00fas de l'operador assignaci\u00f3: 1 2 3 4 5 6 7 8 9 10 int a , b , c ; a = b = c = 10 ; // Tant a com b com c tindrien valor 10 int i = 3 ; i = i * 3 ; // i valdria 9 int j = 2 ; j *= 2 ; // Aquesta manera peculiar d'usar l'operador assignaci\u00f3 \u00e9s el mateix que j = j * 2; A la l\u00ednia 2 s'est\u00e0 assignant simult\u00e0niament el valor enter del literal 10 a les variables a, b i c. A la l\u00ednia 5 assignem el valor enter 3 a la variable amb identificador 'i' acabada de crear. A la l\u00ednia 6 assignem a la variable 'i' el seu propi valor multiplicat per 3. En altres paraules, tripliquem el valor inicial de 'i'. A la l\u00ednia 9 creem una variable de tipus enter amb identificador 'j' i li assignem el valor 2. A la l\u00ednia 10 dupliquem el valor inicial de 'j'. Exemples d'operacions aritm\u00e8tiques Escriu i executa el seg\u00fcent codi en Processing IDE i digues que \u00e9s el que mostra. // Codi per a Processing IDE void setup () { int a = 20 , b = 10 , c , d , e = 10 , f = 4 , g = 9 ; c = b ; System . out . println ( \"Valor de c = \" + c ); a = a + 1 ; b = b - 1 ; e = e * 2 ; f = f / 2 ; System . out . println ( \"a,b,e,f = \" + a + \",\" + b + \",\" + e + \",\" + f ); a = a - 1 ; b = b + 1 ; e = e / 2 ; f = f * 2 ; a += 1 ; b -= 1 ; e *= 2 ; f /= 2 ; System . out . println ( \"a,b,e,f (utilitzen operador curst)= \" + a + \",\" + b + \",\" + e + \",\" + f ); } Conversi\u00f3 de tipus Hem dit que en una expressi\u00f3 d'assignaci\u00f3 de valors, els tipus de dades han de ser el mateix als dos costats de l'operaci\u00f3, per\u00f2, qu\u00e8 passa si aquests no coincideixen? \u00c9s a dir, que passa si a una variable de tipus enter li assignem un nombre decimal? o un caracter? Amb Java \u00e9s possible transformar el tipus d'una variable o objecte en un altre diferent a l'original amb el que inicialment va ser declarat. Aquest procediment s'anomena \"Conversi\u00f3 de tipus\" , encara que tamb\u00e9 podreu trobar aquest terme com a tipat o modelat o casting i \u00e9s un mecanisme que hem de utilitzar amb cura ja que un mal \u00fas d'aquest \u00e9s una font d'errors. En Java ens podem trobar dos escenaris diferents: un en el que els tipus que es volen convertir s\u00f3n compatibles, en aquest cas Java fa una conversi\u00f3 autom\u00e0tica o l'escenari al qual els dos tipus de dades de l'assignaci\u00f3 no s\u00f3n compatibles per la qual cosa haurem de for\u00e7ar aquesta conversi\u00f3 amb un casting . Conversi\u00f3 autom\u00e0tica de tipus o ampliaci\u00f3 La conversi\u00f3 autom\u00e0tica de tipus ampliaci\u00f3 es produeix quan dos tipus de dades es converteixen autom\u00e0ticament. A\u00e7\u00f2 passa quan: Els dos tipus de dades s\u00f3n compatibles Quan assignem el valor de un tipus de dades m\u00e9s menut a un tipus de dades m\u00e9s gran. Tipus de dades ordenats per grand\u00e0ria: byte < short < int < long < float < double Per exemple, en Java, els tipus de dades num\u00e8rics s\u00f3n compatibles entre s\u00ed, per\u00f2 no s'admet la conversi\u00f3 autom\u00e0tica de tipus num\u00e8ric a char o boolean. A m\u00e9s a m\u00e9s, char i boolean no s\u00f3n compatibles entre ells. Mira el codi a continuaci\u00f3 on es produeix una conversi\u00f3 autom\u00e0tica en Java. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void draw () { int i = 100 ; // Conversi\u00f3 autom\u00e0tica de tipus long l = i ; // Conversi\u00f3 autom\u00e0tica de tipus float f = l ; println ( \"Valor Int \" + i ); println ( \"Valor Long \" + l ); println ( \"Valor Float \" + f ); } Conversi\u00f3 explicita de tipus o casting Si volem assignar un valor de tipus de dades m\u00e9s gran a un tipus de dades m\u00e9s xicotet, farem un casting o el que tamb\u00e9 es coneix com conversio de tipus explicit. Util per als tipus de dades incompatibles on la conversi\u00f3 autom\u00e0tica no es pot realitzar. char i int no s\u00f3n compatibles entre ells i donar\u00e0 un error de compilaci\u00f3. On necessitarem la conversi\u00f3 explicita: double > float > long > int > short > byte Mira el seg\u00fcent codi on hi ha un cas de tipus incompatibles. 1 2 3 4 5 6 void draw () { char ch = 'c' ; int num = 88 ; ch = num ; } L'exemple anterior donaria un error a la l\u00ednia 7 dient que no es pot convertir d'int a char. Per tant com podriem fer aquesta conversi\u00f3 explicita?. Una possible forma d'evitar aquests casos de tipus incompatibles \u00e9s la conversi\u00f3 explicita, on hem d'indicar al compilador especificament a quin tipus volem convertir. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void draw () { double d = 100.04 ; //casting de tipus long l = ( long ) d ; //casting de tipus int i = ( int ) l ; println ( \"Valor Double \" + d ); //part fraccion\u00e0ria perduda println ( \"Valor Long \" + l ); //part fraccion\u00e0ria perduda println ( \"Valor Int \" + i ); } La eixida de l'execuci\u00f3 d'aquest codi seria: Valor Double 100.04 Valor Long 100 Valor Int 100 Exemple de conversi\u00f3 de tipus Observa el seg\u00fcent codi i raona el que pot ser el seu resultat i anota'l. Despr\u00e9s c\u00f2pia el codi a un programa de Processing i executa'l. Compara el resultat del programa amb el que tu havies anotat. Qu\u00e8 est\u00e0 passant? Per qu\u00e8? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void draw () { byte b ; int i = 257 ; double d = 323.142 ; System . out . println ( \"Conversion de int a byte.\" ); //i%256 b = ( byte ) i ; System . out . println ( \"i = \" + i + \" b = \" + b ); System . out . println ( \"\\nConversion de double a byte.\" ); //d%256 b = ( byte ) d ; System . out . println ( \"d = \" + d + \" b= \" + b ); } Operadors aritm\u00e8tics Els operador aritm\u00e8tics en Java serveixen per realitzar operacions b\u00e0siques algebraiques com: la suma, resta, multiplicaci\u00f3 o divisi\u00f3. Els resultats de tota expressi\u00f3 aritm\u00e8tica \u00e9s de tipus de dades num\u00e8ric, per tant, podr\u00e0 ser assignat a una variable num\u00e8rica o podra ser utilitzant en qualsevol altra operaci\u00f3 num\u00e8rica. Suma: s\u00edmbol (+). Exemple: 4+5. Resultat 9. Resta: s\u00edmbol (-). Exemple: 5-2. Resultat 3. Multiplicaci\u00f3: s\u00edmbol ( ). Exemple: 3 7. Resultat 21. Divisi\u00f3 (Quocient): s\u00edmbol (/). Exemple: 8/4. Resultat 2. Divisi\u00f3 (Residu): s\u00edmbol (%). Exemple 10%2. Resultat 0. Activitat 310. Executa el seg\u00fcent codi d'operadors aritm\u00e8tics C\u00f2pia i compila el codi anterior i observa el que mostra pel terminal. Has de fer l'activitat amb Processing IDE 1 2 3 4 5 6 7 8 9 10 11 12 13 // OPERADORS ARITM\u00c8TICS void draw () { int a = 20 , b = 10 , c = 0 , d = 20 , e = 40 , f = 30 ; String x = \"Thank\" , y = \"You\" ; println ( \"a + b = \" + ( a + b )); println ( \"a - b = \" + ( a - b )); println ( \"x + y = \" + x + y ); println ( \"a * b = \" + ( a * b )); println ( \"a / b = \" + ( a / b )); println ( \"a % b = \" + ( a % b )); } A l'exemple anterior has pogut observar com s'escriuen en java algunes expressions aritm\u00e8tiques. A l'activitat seg\u00fcent haur\u00e0s d'escriure tu aquestes expressions o operacions aritm\u00e8tiques en un programa de Processing IDE. Activitat 311. Operacions i expressions aritm\u00e8tiques Problema Soluci\u00f3 A partir de les seg\u00fcents expressions matem\u00e0tiques, construeix les respectives expressions aritm\u00e8tiques escrites en java. A continuaci\u00f3 fes el proc\u00e9s contrari, \u00e9s a dir, a partir de l'expressi\u00f3 aritm\u00e8tica escrita en llenguatge java, escriu-la en format matem\u00e0tic correcte. Expressi\u00f3 Formula Expressi\u00f3 Formula b/2-4 a c 1/y+3*x/z+1 3 x y-5 x+12 x-17 1/(y+3)+x/y+1 (b+d)/(c+4) Si x, y i z s\u00f3n variables de tipus boole\u00e0 amb valors \u2018x\u2019 veritable, \u2018y\u2019 fals i \u2018z\u2019 veritable, determina el valors de les seg\u00fcents expressions l\u00f2giques: Expressi\u00f3 Resultat Expressi\u00f3 Resultat (X && Y) || (X && Z) (X || !Y)&& (!X || Z) !(X || Y) && Z X || Y || X && !Z && !Y !X || !Y || Z && X && !Y Si w, x, y i z s\u00f3n variables de tipus boole\u00e0 amb valors w falsa, x veritable, y veritable i z falsa, determina el valor de les seg\u00fcents expressions l\u00f2giques: Expressi\u00f3 Resultat Expressi\u00f3 Resultat W || Y && X && W || Z X && !Y && !X || !W && Y !(W || !Y) && X || Z X && Y && W || Z || X Y || !(Y || Z && W) !X && Y && (!Z || !X) A partir de les seg\u00fcents declaracions de variables: - int i = 8, j = 5; - float x = 0.005F, y = -0.01F; - char c = \u2018c\u2019, d = \u2018d\u2019; Determina el valor de les seg\u00fcents expressions. Expressi\u00f3 Resultat Expressi\u00f3 Resultat i <= j c > d x >= 0 x < y-- j != 6 c == 99 !(i <= j) !(c == 99) !(x > 0) \u2013j == i - 13 ++x > 0 y-- < 1 c > d || c > 0 5 * (i + j) > \u2018c\u2019 2 * x + y == 0 2 * x + (y == 0) x + y >= 0 x < ++y \u2013 (i + j) != -i + j i <= j && i >= c i > 0 && j < 5 i > 0 x > y && i > 0 || j < 5 (3 * i \u2013 2 * j) % (2 * d \u2013 c) > 3 * d 2 * ((i / 5) + (4 * (j \u2013 3)) % (i + j \u2013 2)) >= 10 (i \u2013 3 * j) % (c + 2 * d) / (x \u2013 y) >= 0 (x*y)/y+2 Quan hages acabat resol les seg\u00fcents expressions aritm\u00e8tiques suposant que a val 8, b val 3 i c val 5. Expressi\u00f3 Resultat Expressi\u00f3 Resultat a + b + c 2 * b + 3 * (a \u2013 c) a / b a % b a / c a % c a * b / c a * (b / c) (a * c) % b a * (c % b) (3 * a \u2013 2 * b) % (2 * a \u2013 c) 2 * ( a / 5 + (4 - b * 3)) % (a + c \u2013 2) (a - 3 * b) % (c + 2 * a) / (a \u2013 c) a - b - c * 2 Si x, y i z s\u00f3n variables de tipus double amb valors 88, 3.5 i -5.2 respectivament, determina els valor de les seg\u00fcents expressions aritm\u00e8tiques (m\u00e0xim 4 decimals) Expressi\u00f3 Resultat Expressi\u00f3 Resultat x + y + z 2 * y + 3 * (x \u2013 z) x / y x % y x / (y + z) (x / y) + z 2 * x / 3 * y 2 * x / (3 * y) x * y % z x * (y % z) 3 * x \u2013 z \u2013 2 * x 2 * x / 5 % y x - 100 % y % z x - y - z * 2 Si c1, c2 y c3 son variables de tipus char amb valors c1=\u2019E\u2019, c2=\u20195\u2019, c3=\u2019?\u2019, determina el valor num\u00e8ric de les seg\u00fcents expressions aritm\u00e8tiques. Per resoldre\u2019l necessites saber el valor num\u00e8ric corresponent a aquestos caracters en base a la taula ASCII: 'E' = 69, '5' = 53 i '?' = 63. Consulta a la taula ASCII els valors num\u00e8rics de la resta de caracters que apareixen a les operacions Expressi\u00f3 Resultat Expressi\u00f3 Resultat c1 + 1 c1 \u2013 c2 + c3 c2 \u2013 2 c2 \u2013 '2' c3 + '#' c1 % c3 '2' + '2' (c1 / c2) * c3 3 * c2 '3' * c2 Encara no disponible Operadors increment i decrement (unaris) En programaci\u00f3 i com her\u00e8ncia de C i C++ existeixen els operadors increment (++) i decrement (--) que el que fan \u00e9s incrementar o decrementar en una unitat la variable a la qual s'apliquen. Aquests operadors es diuen unaris perqu\u00e8 nom\u00e9s treballen sobre un sol operand. Encara que aquest operador s'aplique nom\u00e9s sobre un element, tamb\u00e9 es tractaria d'una expressi\u00f3 aritm\u00e8tica, per tant, tamb\u00e9 hauria de retornar un resultat num\u00e8ric per ser utilitzat com a tal. 1 2 3 4 int x = 10 ; // Postincrement o postdecrement x ++ ; // Aquest codi seria equivalent a x = x + 1; x -- ; // Aquest codi seria equivalent a x = x -1 ; Aquests operadors tamb\u00e9 es poden posar abans de la variable produint el mateix efecte 1 2 3 4 int x = 10 ; // Preincrement o predecrement ++ x ; // Aquest codi seria equivalent a x = x + 1; -- x ; // Aquest codi seria equivalent a x = x -1 ; La difer\u00e8ncia essencial entre el postincrement i el preincrement \u00e9s que el contingut de la variable, el que tenim dins la caixeta, s'avalua abans (postincrement) o despr\u00e9s (preincrement) de sumar-li un al seu valor. Activitat 312. Operadors postincrement i preincrement Prova el codi seg\u00fcent i digues-me el que passa. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void draw () { int a = 20 , b = 10 , c = 0 , d = 20 , e = 40 , f = 30 ; boolean condition = true ; c = ++ a ; println ( \"Valor de c (++a) = \" + c ); c = b ++ ; println ( \"Valor de c (b++) = \" + c ); c = -- d ; println ( \"Valor de c (--d) = \" + c ); c = e -- ; println ( \"Valor de c (e--) = \" + c ); println ( \"Valor de !condition = \" + ! condition ); } Operadors relacionals Com hem explicat en l'apartat sobre Tipus de dades , existeix en Java el tipus boolean que nom\u00e9s pot tenir valors true o false. Aquest tipus de dades est\u00e0 relacionat amb els operadors relacionals, ja que tota expressi\u00f3 relacional ha de donar com a resultat b\u00e9 true o false. Tant els operadors relacionals com els tipus de dades boolean, estan directament relacionats amb l'algebra de boole . A continuaci\u00f3 hi pots veure un resum de les operacions b\u00e0siques en l'algebra de boole: Negaci\u00f3. Operador unari A NOT 0 1 1 0 OR i AND. Operadors binaris A B OR AND 0 0 0 0 1 0 1 0 0 1 1 0 1 1 1 1 Els operadors relacionals a Java s\u00f3n: Igual que: == o igual a. Exemple d'\u00fas: a == b, compara si a i b s\u00f3n iguals o no. Distint de: != o distint de. Exemple d'\u00fas: a != b, comprova si a i b s\u00f3n distints. Major que: > o major que. Exemple d'\u00fas: 'a>b' comprova si a \u00e9s major que b. Menor que: < o menor que. Exemple d'\u00fas: 'a<b' comprova si a \u00e9s menor que b. Major o igual que: >= o major igual que. Exemple d'\u00fas: 'a>=b' comprova si a \u00e9s major o igual que b. Menor o igual que: <= o menor igual que. Exemple d'\u00fas: 'a<=b' comprova si a \u00e9s menor o igual que b. Aix\u00ed tenim que una expressi\u00f3 relacional , que com hem explicat ha de donar un resultat boole\u00e0, es podr\u00e0 utilitzar b\u00e9 en altres expressions relacionals o en avaluacions de condicions per a les estructures de control que veurem en pr\u00f2xims apartats. Activitat 313. Copia i executa en Processing IDE C\u00f2pia i executa el codi anterior en Processing i observa el que passa. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // Programa Java per mostrar operadors relacionals void draw () { int a = 20 , b = 10 ; String x = \"Thank\" , y = \"Thank\" ; int ar [] = { 1 , 2 , 3 }; int br [] = { 1 , 2 , 3 }; boolean condicion = true ; // Diversos operadors relacionals println ( \"a == b :\" + ( a == b )); println ( \"a < b :\" + ( a < b )); println ( \"a <= b :\" + ( a <= b )); println ( \"a > b :\" + ( a > b )); println ( \"a >= b :\" + ( a >= b )); println ( \"a != b :\" + ( a != b )); // Els arrays no es poden comparar cma operadors relacionals perqu\u00e8 els objectes emmagatzemen refer\u00e8ncies i no el valor println ( \"x == y : \" + ( ar == br )); println ( \"condicion==true :\" + ( condicion == true )); } Operadors l\u00f2gics Aquests operadors s'utilitzen per realitzar operacions l\u00f2giques AND i l\u00f2giques OR , \u00e9s a dir, la funci\u00f3 semblant a la port AND i la porta OR e l'electr\u00f2nica digital. Una cosa a tindre en compte \u00e9s que la segona condici\u00f3 no s'avalua si la primera \u00e9s falsa, \u00e9s a dir, t\u00e9 un efecte de curtcircuit. S'utilitza molt per provar varies condicions per prendre una decisi\u00f3. not (!) : negaci\u00f3 l\u00f2gica. and (&&) : and l\u00f2gic. or (||) : or l\u00f2gic. or exclusiu (^) : or exclusiu. Activitat 314. Operadors l\u00f2gics Prova i executa el codi anterior. Has de fer l'activitat en Processing IDE. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void setup () { println ( \"TAULA DE BOOLE\" ); println ( \"--------------\" ); println ( \" OPERADOR &&\" ); println ( \"--------------\" ); println ( \" V && V = \" + ( true && true )); println ( \" V && F = \" + ( true && false )); println ( \" F && V = \" + ( false && true )); println ( \" F && F = \" + ( false && false )); println ( \"--------------\" ); println ( \" OPERADOR ||\" ); println ( \"--------------\" ); println ( \" V || V = \" + ( true || true )); println ( \" V || F = \" + ( true || false )); println ( \" F || V = \" + ( false || true )); println ( \" F || F = \" + ( false || false )); println ( \"--------------\" ); println ( \" OPERADOR !\" ); println ( \"--------------\" ); println ( \" !V = \" + ! true ); println ( \" !F = \" + ! false ); println ( \"--------------\" ); } Operador condicional o ternari Java inclou un operador especial de tipus ternari que de vegades s'utilitza per substituir algunes estructures if then else. Aquest \u00e9s l'operador ? i la seua forma general \u00e9s: 1 expressio1 ? expressio2 : expressio 3 ; Expressi\u00f3 1: \u00e9s l'expressi\u00f3 que avalua un valor boole\u00e0, d'aquesta forma, si l'expressi\u00f3 1 s'avalua com a true , s'executaria l'expressi\u00f3 2 mentre que si l'expressi\u00f3 1 s'avalua a false , s'executaria l'expressi\u00f3 3. Mira l'exemple seg\u00fcent: 1 2 3 4 5 // B\u00e0sicament el que faria aquesta expressi\u00f3 seria engegar l'aire condicionat si la temperatura \u00e9s superior a 25 graus. double temperatura ; // Variable que ens indica la temperatura ambient boolean AC_ON = false ; // Variable booleana que ens indica si l'aire condicionat est\u00e0 en marxa temperatura > 25 ? AC_ON = true : AC_ON = false ; Activitat 315. Estudia i resol les seg\u00fcents expressions relacionals i l\u00f2giques Problema Soluci\u00f3 Si x, y i z s\u00f3n variables de tipus boole\u00e0 amb valors \u2018x\u2019 veritable, \u2018y\u2019 fals i \u2018z\u2019 veritable, determina el valors de les seg\u00fcents expressions l\u00f2giques: Expressi\u00f3 Resultat Expressi\u00f3 Resultat (X && Y) || (X && Z) (X || !Y)&& (!X || Z) !(X || Y) && Z X || Y || X && !Z && !Y !X || !Y || Z && X && !Y Si w, x, y i z s\u00f3n variables de tipus boole\u00e0 amb valors w falsa, x veritable, y veritable i z falsa, determina el valor de les seg\u00fcents expressions l\u00f2giques: Expressi\u00f3 Resultat Expressi\u00f3 Resultat W || Y && X && W || Z X && !Y && !X || !W && Y !(W || !Y) && X || Z X && Y && W || Z || X Y || !(Y || Z && W) !X && Y && (!Z || !X) A partir de les seg\u00fcents declaracions de variables: int i = 8, j = 5; float x = 0.005F, y = -0.01F; char c = \u2018c\u2019, d = \u2018d\u2019; Determina el valor de les seg\u00fcents expressions. Expressi\u00f3 Resultat Expressi\u00f3 Resultat i <= j c > d x >= 0 x < y-- j != 6 c == 99 !(i <= j) !(c == 99) !(x > 0) \u2013j == i - 13 ++x > 0 y-- < 1 c > d || c > 0 5 * (i + j) > \u2018c\u2019 2 * x + y == 0 2 * x + (y == 0) x + y >= 0 x < ++y \u2013 (i + j) != -i + j i <= j && i >= c i > 0 && j < 5 i > 0 x > y && i > 0 || j < 5 (3 * i \u2013 2 * j) % (2 * d \u2013 c) > 3 * d 2 * ((i / 5) + (4 * (j \u2013 3)) % (i + j \u2013 2)) >= 10 (i \u2013 3 * j) % (c + 2 * d) / (x \u2013 y) >= 0 No disponible encara Estructures Com hem vist al tema 2, el teorema de la programaci\u00f3 estructurada preveu una s\u00e8rie d'estructures b\u00e0siques amb les quals es podrien codificar tots els algorismes sense necessitat d'usar cap sent\u00e8ncia GOTO o similar. En els pr\u00f2xims punts veurem com es codifiquen totes aquestes estructures en llenguatge Java. Estructura Seq\u00fcencial Les ordres d'un programa s'executen per defecte en ordre seq\u00fcencial. El que significa que les instruccions s'executen, com hem comentat abans, una darrere de l'altra en el mateix ordre que apareixen escrites al programa. graph LR id1((Inici))-->Instrucci\u00f31; style id1 fill:#0F0 Instrucci\u00f31-->Instrucci\u00f32; Instrucci\u00f32-->Instrucci\u00f33; Instrucci\u00f33-->id2([Fi]); style id2 fill:#F00 L'estructura seq\u00fcencial \u00e9s l'ordre natura d'execuci\u00f3. Les instruccions que formen part d'aquesta estructura s'executen en ordre una a continuaci\u00f3 de l'altra. Al final de cada instrucci\u00f3 hi ha un punt i coma per indicar-li al compilador el final de la sent\u00e8ncia individual. Les instruccions dintre d'una estructura seq\u00fcencial es solen agrupar en blocs ( {...} ) i es codifica de la seg\u00fcent manera: 1 2 3 4 5 6 7 // Exemple de bloc - estructura seq\u00fcencial { Instrucci\u00f31 ; Instrucci\u00f32 ; ... Instrucci\u00f3N ; } Veiem a continuaci\u00f3 un exemple codificat en Java amb l'IDE de Processing. Activitat 316. Dibuixa amb Processing IDE Dibuixa amb processing IDE un punt, una l\u00ednia, un cercle i un quadrat copiant el codi que pots veure a continuaci\u00f3. Despr\u00e9s modifica alguns dels par\u00e0metres de les funcions point, line, ellipse i square i observa el que passa. 1 2 3 4 5 6 7 8 9 10 11 12 void setup () { size ( 320 , 320 ); // Estableix les dimensions de la nostra pantalla principal background ( 255 ); // Estableix el fons de la pantalla fill ( 0 ); // Color amb el que es dibuixaran les figures. } void draw () { point ( 10 , 10 ); // Dibuixa un punt line ( 20 , 20 , 40 , 40 ); // Dibuixa una l\u00ednia ellipse ( 100 , 100 , 80 , 80 ); // Dibuixa una el\u00b7lipse square ( 200 , 200 , 50 ); // Dibuixa un quadrat } Ara que ja has vist algunes de les funcions que ens ofereix l' API de Processing per tal de dibuixar, investiga quines altres funcions permet i aplica-les a la seg\u00fcent activitat. Activitat 317. Dibuix lliure amb Processing IDE. Problema Soluci\u00f3 Utilitzant altres primitives de dibuix que ens proporciona l'API de Processing IDE, dibuixa alguna cosa concreta. Has de tindre en compte que la majoria de primitives (funcions) s\u00f3n geom\u00e8triques, per tant, et podries inspirar en algun dibuix geom\u00e8tric. Pots buscar per Internet. Descarrega la soluci\u00f3 per al Dibuix lliure amb Processing Estructures de selecci\u00f3 \u00c9s una de les estructures que permeten modificar l'ordre d'execuci\u00f3 de les instruccions del programa. Una estructura condicional determina si s'executen unes accions o altres segons es compleixi o no una determinada condici\u00f3. La condici\u00f3 que es comprova per decidir si unes instruccions s'executen o no deu ser una expressi\u00f3 booleana, \u00e9s a dir, ha de donar com a resultat un valor boole\u00e0 true o false. Com varem explicar al tema anterior, ens podem trobar les seg\u00fcents variants d'estructura de selecci\u00f3: Selecci\u00f3 simple Selecci\u00f3 doble Selecci\u00f3 multiple Operador condicional ? Selecci\u00f3 Simple - if \u00c9s l'estructura condicional m\u00e9s simple en programaci\u00f3 estructurada. S'utilitza per determinar si una instrucci\u00f3 o bloc d'instruccions s'executa basat en una condici\u00f3. S'avalua la condici\u00f3 i si es true, s'executa la instrucci\u00f3 o bloc d'instruccions associat a la condici\u00f3. graph LR id1((Inici))-->Instrucci\u00f31; style id1 fill:#0F0 Instrucci\u00f31-->Instrucci\u00f32; Instrucci\u00f32-->Cond1{Condici\u00f3}; Cond1-->|SI|Instrucci\u00f33; Instrucci\u00f33-->Instrucci\u00f34; Instrucci\u00f34-->Instrucci\u00f35; Cond1-->|NO|Instrucci\u00f35; Instrucci\u00f35-->id2([Fi]); style id2 fill:#F00 El seu codi en Java seria: 1 2 3 4 5 6 7 8 Instrucci\u00f31 (); Instrucci\u00f32 (); if ( condicio ) { instrucci\u00f33 ; Instrucci\u00f34 ; } Instrucci\u00f35 ; Al codi anterior s'executarien sempre les instruccions 1 i 2 abans d'avaluar-se la condici\u00f3, en cas que la condici\u00f3 fora avaluada com a true , s'executaria l'estructura seq\u00fcencial que cont\u00e9 les instruccions 3 i 4 i finalment s'executaria la instrucci\u00f3 5 en tot cas. Pel contrari si la condici\u00f3 s'avalua a false no s'executarien les instruccions que cont\u00e9, \u00e9s a dir, 3 i 4 i passaria directament a l'instrucci\u00f3 5. Aplicaci\u00f3 que detecte n\u00fameros senars 1 2 3 4 5 6 int num = ( int ) random ( 100 ); if ( num % 2 == 0 ) println ( num + \" \u00e9s parell\" ); println ( \"S'ha acabat l'aplicaci\u00f3\" ); Selecci\u00f3 doble - if .. else Amb aquesta estructura condicional de la programaci\u00f3 estructurada es poden seguir camins distints depenent de si l'avaluaci\u00f3 de la condici\u00f3 \u00e9s true o false . En altres paraules, si la condici\u00f3 \u00e9s true, executaria una instrucci\u00f3 o bloc d'instruccions mentre que si s'avalua a false executaria una altra instrucci\u00f3 o bloc d'instruccions. Observa el diagrama de flux seg\u00fcent: graph LR id1((Inici))-->Instrucci\u00f31; style id1 fill:#0F0; Instrucci\u00f31-->Instrucci\u00f32 Instrucci\u00f32-->C1{Condici\u00f3} C1-->|SI|Instrucci\u00f33; Instrucci\u00f33-->Instrucci\u00f34; C1-->|NO|Instrucci\u00f35; Instrucci\u00f35-->Instrucci\u00f36; Instrucci\u00f34-->Instrucci\u00f37; Instrucci\u00f36-->Instrucci\u00f37; Instrucci\u00f37-->Instrucci\u00f38; Instrucci\u00f38-->id2((FI)); style id2 fill:#F00 El seu codi en Java seria 1 2 3 4 5 6 7 8 9 10 11 12 instruccio1 ; instruccio2 ; if ( condicio ) { instruccio3 ; instruccio4 ; } else { instruccio5 ; instruccio6 ; } instruccio7 ; instruccio8 ; Si ens fixem en el codi anterior, podem trobar dues seq\u00fc\u00e8ncies d'execucio d'instruccions depenent si la condici\u00f3 del 'if' s'avalua 'true' o 'false' . En el primer cas, amb la condici\u00f3 a 'true' , s'executarien: instrucci\u00f31, instrucci\u00f32, instrucci\u00f33, instrucci\u00f34, instrucci\u00f37 i instrucci\u00f38. Mentre que si la condici\u00f3 del 'if' s'avaluara a 'false' , les instruccions a executar serien: instrucci\u00f31, instrucci\u00f32, instrucci\u00f35, instrucci\u00f36, instrucci\u00f37 i instrucci\u00f38. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int hora ; void setup () { size ( 640 , 480 ); } void draw () { hora = ( int ) random ( 0 , 24 ); if ( hora >= 12 ) println ( \"Encara \u00e9s de mat\u00ed\" ); else println ( \"Ja \u00e9s de vesprada\" ); } Activitat 318. Nombres parells i senars amb la funci\u00f3 random() Problema Soluci\u00f3 Seguint l'exemple de l'aplicaci\u00f3 que detecta n\u00fameros senars, fes que tamb\u00e9 ens indique en cas contrari, si no \u00e9s parell, que es tracta d'un n\u00famero senar. 1 2 3 4 5 6 7 8 9 int num = ( int ) random ( 100 ); if ( num % 2 == 0 ) println ( num + \" \u00e9s un n\u00famero parell\" ); else println ( num + \" \u00e9s un n\u00famero senar\" ); println ( \"Ja s'ha acabat l'aplicaci\u00f3\" ); Selecci\u00f3 niada - if else if else Si volem avaluar m\u00e9s d'una condici\u00f3 al nostre codi, estariem parlant d'una estructura condicional m\u00faltiple que b\u00e0sicament consisteix en encadenar diversos if..else. A continuaci\u00f3 es pot veure com seria un exemple de condicional m\u00faltiple en diagrama de flux. graph LR id1((Inici))-->Instrucci\u00f31; style id1 fill:#0F0; Instrucci\u00f31-->|NO|C1{Condici\u00f3 1}; C1-->|NO|C2{Condici\u00f3 2}; C2-->|NO|C3{Condici\u00f3 3}; C1-->|SI|Instrucci\u00f32; Instrucci\u00f32-->Instrucci\u00f33; C2-->|SI|Instrucci\u00f34; C3-->|SI|Instrucci\u00f35; Instrucci\u00f35-->Instrucci\u00f36; Instrucci\u00f36-->Instrucci\u00f37; Instrucci\u00f33-->Instrucci\u00f310; Instrucci\u00f34-->Instrucci\u00f310; Instrucci\u00f37-->Instrucci\u00f310; Instrucci\u00f310-->Id2((FI)); style Id2 fill:#F00; El mateix exemple en Java que teniu a la imatge anterior seria: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 instruccio1 ; if ( condicio1 ) { instruccio2 ; instruccio3 ; } else if ( condicio2 ) { instruccio4 ; } else if ( condicio3 ) { instruccio5 ; instruccio6 ; instruccio7 ; } else { instruccio8 ; instruccio9 ; } instruccio10 ; Al codi anterior l'\u00fanic que s\u00ed sabem cert \u00e9s que s'executaran les instruccions 1 i 2 i depenent de quina condici\u00f3 s'avalua a true s'executar\u00e0 algun bloc d'instruccions que estan dins de l'estructura condicional. Seguint amb l'exemple de l'hora que hem utilitzat als apartats anteriors veiem com es podria usar una condici\u00f3 m\u00faltiple amb if else: Activitat 319. Copia i executa a Processing IDE 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void setup () { size ( 640 , 480 ); } void draw () { int hora = ( int ) random ( 0 , 24 ); if ( hora >= 7 && hora <= 9 ) println ( \"Eres matiner\" ); else if ( hora > 9 && hora <= 12 ) println ( \"Deuries haver esmorzat ja\" ); else if ( hora > 12 && hora <= 15 ) println ( \"Es hora de dinar si no has dinat\" ); else if ( hora > 15 && hora <= 18 ) println ( \"Si no has fet una migdiada oblidat\" ); else println ( \"Hora de la cervesa\" ); } Copia i executa el codi a Processing IDE. Al final de cada cicle de la funci\u00f3 draw posa un delay de 1 segon per tal que ens done temps a veure el resultat. Recorda tamb\u00e9 de fer un clear() al principi de cada cicle de draw. Modifica el codi per tal d'afegir-li m\u00e9s opcions. Per exemple podries afegir-li que passa entre les 18:00 i les 20:00 o tamb\u00e9 entre les 20:00 i les 22:00... Activitats sobre estructures de selecci\u00f3 Mira i fes les seg\u00fcents activitats per tal de refor\u00e7ar els conceptes vistos sobre les diferents estructures de selecci\u00f3 de la programaci\u00f3 estructurada. Activitat 320. Divisi\u00f3 Problema Soluci\u00f3 Escriu un programa en Processing IDE que genere aleat\u00f2riament dos nombres enters i que calcule la seua divisi\u00f3. El programa ens haur\u00e0 d'indicar si la divisi\u00f3 \u00e9s exacta qui \u00e9s el resultat i si no \u00e9s exacta quin \u00e9s el resultat i el residu. Fes que el resultat es mostre el m\u00e9s amigable possible. \u00c9s a dir, intenta no utilitzar el println i utilitza la funci\u00f3 text de l'API de Processing per mostrar el resultat per pantalla enlloc de pel terminal. Com a apartat d'ampliaci\u00f3, podries fer que el grandaria de la font fos un poc m\u00e9s gran. A banda si veus algun detall que no t'agrada com funciona, ho pots modificar. Descarrega la soluci\u00f3 al problema de la divisi\u00f3 Activitat 321. Divisi\u00f3 per zero i altres problemes Problema Soluci\u00f3 L'activitat anterior si t'has fixat, si el divisor \u00e9s menor que el dividend el resultat sempre \u00e9s zero. Seria interessant que es controlara que sempre es dividira el n\u00famero major pel menor. Tamb\u00e9 si s'ha dona el cas, haur\u00e0s pogut comprovar que si el divisor \u00e9s 0 el programa dona error. Millora el programa anterior controlant el que passa quan es vol dividir per zero, mostrant un missatge en el cas que el n\u00famero pel qual s'intenta dividir siga zero. I assegurat tamb\u00e9 que el divisor \u00e9s sempre el n\u00famero major. Compte perqu\u00e8 segurament haur\u00e0s d'usar estructures de selecci\u00f3 niades. Descarrega la soluci\u00f3 al problema de la divisi\u00f3 per zero Activitat 322. Major, menor o igual Problema Soluci\u00f3 Escriu un programa en Processing que genere aleat\u00f2riament dos n\u00fameros i que diga quin \u00e9s el major, quin \u00e9s el menor o si s\u00f3n iguals. \u00c9s a dir, l'aplicaci\u00f3 ha de generar dos n\u00fameros aleatoris, des del 0 fins al 100 per exemple i comprovar la seg\u00fcent casu\u00edstica: - S\u00f3n els dos n\u00fameros iguals? - \u00c9s el primer n\u00famero major que el segon? - \u00c9s el segon n\u00famero major que el segon? Descarrega la soluci\u00f3 al problema dels n\u00fameros majors iguals o menors Activitat 323. Difer\u00e8ncia d'anys Problema Soluci\u00f3 Escriu un programa en Processing que donat l'any actual(2023) i un any qualsevol que es genere de forma aleat\u00f2ria amb la funci\u00f3 random entre l'any 0 i l'any 2500 i escriga quants anys han passat des d'eixe any o quants anys falten per arribar a eixe any. Per exemple, imagina que l'any aleatori que genera la teua aplicaci\u00f3 \u00e9s l'any 2123, en aquest cas hauria de mostrar el seg\u00fcent missatge: \"Falten 100 anys per arribar a l'any 2123\", si per exemple l'any aleatori fos 2001, el missatge que hauria de mostrar \u00e9s: \"Han passat 22 anys des de l'any 2001\". Si finalment l'any aleatori \u00e9s igual a l'any actual, el missatge podria ser: \"L'any aleatori i l'actual s\u00f3n el mateix any\". Es podrien utilitzar constants en aquesta activitat. Quina? Descarrega la soluci\u00f3 al problema de la difer\u00e8ncia d'anys Activitat 324. Millora la difer\u00e8ncia d'anys Problema Soluci\u00f3 Igual en les proves que has fet no t'ha passat per\u00f2, t'has preguntat que passa si l'any aleatori \u00e9s exactament un any menys o un any m\u00e9s que l'actual? Si has fet b\u00e9 l'activitat anterior i si l'any aleatori fora per exemple 2022, el teu programa deuria mostrar: \"Han passat un anys des del 2022\", que \u00e9s incorrecte ja que deuria posar: \"Ha passat un any des del 2022\". Millora el programa anterior fent que quan la difer\u00e8ncia siga exactament un any, mostre una frase concreta: \"Nom\u00e9s queda un any per al 2023\" o \"Ha passat un any des del 2002\". En la resta de casos ha de funcionar igual que abans. Descarrega la soluci\u00f3 al problema de la millora de la difer\u00e8ncia d'anys Activitat 325. Nombres m\u00faltiples Problema Soluci\u00f3 Escriu un programa que genere dos n\u00fameros aleatoris entre el 0 i el 100 i escriga si el n\u00famero major \u00e9s multiple del menor. Per exemple, imagina que el nostre genera els n\u00fameros 6 i 60. Com que 60 \u00e9s major que 6, hem de comprovar si hi ha algun n\u00famero que al multiplicar-lo per 6 done 60. Dit d'una altra manera, si dividim 60 entre 6 el residu \u00e9s zero? En tal cas, si existeix un n\u00famero natural que al multiplicar-lo per 6 dona 60, aleshores podem dir que 60 \u00e9s m\u00faltiple de 6. Descarrega la soluci\u00f3 al problema dels nombres m\u00faltiples Activitat 326. Nombre m\u00faltiples amb negatius i zeros Problema Soluci\u00f3 A l'activitat anterior, quan generem els nombres de forma aleat\u00f2ria, els resultats podien estar entre 0 i 100, per\u00f2 que passaria si quan generem nombres de forma aleat\u00f2ria el resultat pogu\u00e9s ser negatiu? Com funcionen els m\u00faltiples tenint en compte els n\u00fameros negatius? Veiem un exemple: numero1 (-30), num2 (-6). \u00c9s -30 m\u00faltiple de -6? Qu\u00e8 dona el residu de l'operaci\u00f3 de dividir -30 entre -6? -30 % -6 = 0. Per tant podem concloure que -6 i -30 s\u00f3n m\u00faltiples. Millora el programa anterior fent que el programa avise quan s'escriguen valors negatius encara que realitze el c\u00e0lcul de la mateixa forma que ho feia abans. Qu\u00e8 passa si algun dels n\u00fameros generats aleat\u00f2riament s\u00f3n zero? I si els dos n\u00fameros aleatoris s\u00f3n zero? Descarrega la soluci\u00f3 al problema dels nombres m\u00faltiples amb negatius i zeros Activitat 327. Comparador de tres n\u00fameros Problema Soluci\u00f3 Escriu un programa que donats 3 n\u00fameros (creats aleat\u00f2riament) ens diga si s\u00f3n els tres iguals, dos s\u00f3n iguals o cap \u00e9s igual. Analitzem amb m\u00e9s profunditat el problema. Quants s\u00f3n els escenaris que ens podem trobar amb tres n\u00fameros aleatoris? - Els tres n\u00fameros s\u00f3n iguals. - El primer n\u00famero i el segon s\u00f3n iguals. - El primer n\u00famero i el tercer s\u00f3n iguals. - El segon n\u00famero i el tercer s\u00f3n iguals. - Cap nombre \u00e9s igual. Descarrega la soluci\u00f3 al problema del comparador Activitat 328. Any bixest Problema Soluci\u00f3 Escriu un programa que genere un any aleatori de 0 a 2021 i ens diga si aquest \u00e9s bixest o no. Cal recordar que els anys bixests s\u00f3n m\u00faltiples de 4, per\u00f2 no s\u00f3n m\u00faltiples de 100 i s\u00ed s\u00f3n m\u00faltiples de 400. Per exemple: 2012 \u00e9s bixest, 2010 no ho \u00e9s, 2000 s\u00ed que ho es per\u00f2 1900 no ho \u00e9s. Pots basar-te en el seg\u00fcent codi. Descarrega la soluci\u00f3 al problema de l'any bixest Selecci\u00f3 m\u00faltiple - switch case La sent\u00e8ncia de control 'switch' \u00e9s una altra forma de codificar la condici\u00f3 m\u00faltiple que hem vist a l'apartat anterior per\u00f2 m\u00e9s senzilla de visualitzar a primer cop d'ull. Fixa't en la imatge seg\u00fcent: graph LR id1((Inici))-->Instrucci\u00f31; style id1 fill:#F00; Instrucci\u00f31-->C1{Condici\u00f3 1}; C1-->|A|Instrucci\u00f32; C1-->|B|Instrucci\u00f33; C1-->|C|Instrucci\u00f34; Instrucci\u00f32-->D(fa:fa-spinner); Instrucci\u00f33-->D; Instrucci\u00f34-->D; D-->Instrucci\u00f35; Instrucci\u00f35-->id3((FI)); style id3 fill:#0F0; I el codi en Java seria: 1 2 3 4 5 6 7 8 9 10 11 12 13 switch ( condicio ) { case 1 : // Instruccions break ; case 2 : // INstruccions 2 break ; default : // Instruccions per defecte break ; } Un altre exemple m\u00e9s clar que diu el nom del mes a partir d'un n\u00famero entre 1 i 12 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 //Programa que demana un numero i diu quin mes \u00e9s int mes ; void setup () { size ( 640 , 480 ); } mes = ( int ) random ( 1 , 13 ); switch ( mes ) { //inicio del switch case 1 : println ( \"GENER\" ); break ; case 2 : println ( \"FEBRER\" ); break ; case 3 : println ( \"MAR\u00c7\" ); break ; case 4 : println ( \"ABRIL\" ); break ; case 5 : println ( \"MAIG\" ); break ; case 6 : println ( \"JUNY\" ); break ; case 7 : println ( \"JULIOL\" ); break ; case 8 : println ( \"AGOST\" ); break ; case 9 : println ( \"SETEMBRE\" ); break ; case 10 : println ( \"OCTUBRE\" ); break ; case 11 : println ( \"NOVEMBRE\" ); break ; case 12 : println ( \"DESEMBRE\" ); break ; default : println ( \"No v\u00e0lid\" ); } Activitat 329. Copia i adapta el codi anterior Problema Soluci\u00f3 Escriu el programa anterior per a Processing i comprova que funciona. Afegeix el codi necessari per tal que a banda de dir-te quin mes \u00e9s, et diga tamb\u00e9 a quina estaci\u00f3 de l'any estem. En l'exemple anterior el que s'ha fet ha sigut generar aleat\u00f2riament un n\u00famero enter entre 1 i 12 i despr\u00e9s mostrar per pantalla: primer el n\u00famero del mes i despr\u00e9s el nom. Descarrega la soluci\u00f3 al problema dels mesos i les estacions Activitat 330. Dies de la setmana Problema Soluci\u00f3 Escriu un programa que donat un n\u00famero entre 1 i 7 generat de forma aleat\u00f2ria, et diga quin dia de la setmana \u00e9s. 1 Dilluns, 2 Dimarts etc.. Descarrega la soluci\u00f3 al problema dels dies de la setmana Activitat 331. Passar d'if a switch Problema Soluci\u00f3 Observa el codi a continuaci\u00f3 que explica com es passa de if - else a switch - case i passa l'activitat 323 de l'apartat if..else a switch..case 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // Exemple de switch convertit a if switch ( variable ) { case valor1 : // Accions 1 break ; case valor2 : // Accions 2 break ; case valor3 : // Accions 3 break ; default : // Accions default } // El codi anterior utilitzant if if ( variable == valor1 ) // Accions 1 else if ( variable == valor2 ) // Accions 2 else if ( variable == valor3 ) // Accions 3 else //Accions default Descarrega la soluci\u00f3 al problema de passar d'if a switch .. else Activitat 332. Quants dies t\u00e9 el mes Problema Soluci\u00f3 Escriu un programa que ens demane el mes i l'any i ens mostre per pantalla el total de dies que t\u00e9 eixe mes. El fet de voler saber l'any \u00e9s per tenir en compte tamb\u00e9 que els anys bixestos tenen un dia m\u00e9s a febrer. Descarrega la soluci\u00f3 al problema dels dies del mes Activitat 333. Figures geom\u00e8triques Problema Soluci\u00f3 Escriure un programa que demane primer de quina figura geom\u00e8trica es vol calcular el perimetre. Triangle (t), Quadrat (q), Cercle (c) o rectangle (r) i despr\u00e9s mostre el c\u00e0lcul corresponent. Totes aquelles dades necess\u00e0ries per poder realitzar els diferents c\u00e0lculs es generaran de forma aleat\u00f2ria quan s'haja escollit de quina figura es vol calcular el perimetre. Per exemple, imagina que l'usuari tria el triangle, per saber el perimetre del triangle necessitem saber quant mesura el seu costat i multiplicar-lo per 3, per tant, ser\u00e0 la mesura del costat el que es generar\u00e0 de forma aleat\u00f2ria. Descarrega la soluci\u00f3 al problema de les figures geom\u00e8triques Estructures de repetici\u00f3 Imaginem que tenim un vector d'enters de 100 elements i volem trobar un nombre concret. Usant les estructures condicionals ho podr\u00edem fer. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int [] arrayNumeros ; // Declarem un array d'enters arrayNumeros = new int [ 100 ] ; // Reservem espai en mem\u00f2ria per 100 elements inicialitzaNumeros ( arrayNumeros ); // Emplenem de forma aleat\u00f2ria l'array // Comencem la recerca del n\u00famero 10 per exemple if ( array [ 0 ] == 10 ) println ( \"N\u00famero trobat a la posici\u00f3 0\" ); else if ( array [ 1 ] == 10 ) println ( \"N\u00famero trobat a la posici\u00f3 1\" ); else if ( array [ 2 ] == 10 ) println ( \"N\u00famero trobat a la posici\u00f3 2\" ); else if ( array [ 3 ] == 10 ) println ( \"N\u00famero trobat a la posici\u00f3 3\" ); else if ( array [ 4 ] == 10 ) println ( \"N\u00famero trobat a la posici\u00f3 4\" ); else if ( array [ 5 ] == 10 ) println ( \"N\u00famero trobat a la posici\u00f3 5\" ); // I aix\u00ed fins 100 ... Com podeu observar, nom\u00e9s he necessitat escriure codi per als 5 primers elements del nostre array per adondar-me que aquest codi \u00e9s totalment ineficient i t\u00e9 un manteniment molt complicat. Imagineu un array amb 1000 elements i que ho haurem de codificar com hem fet abans. Les estructures repetitives permetrien rec\u00f3rrer l'array de principi a final sense necessitat d'escriure tant de codi. Veiem els seg\u00fcents exemples. while Mentre la condici\u00f3 (tamb\u00e9 anomenada condici\u00f3 d'eixida) siga avaluada com a true, s'executarien les instruccions que hi ha dins del bucle while. graph LR Id1((Inici))-->Instrucci\u00f31; style Id1 fill:#0F0; Instrucci\u00f31-->D(fa:fa-spinner); D-->C1{Condici\u00f3}; C1-->|V|Instrucci\u00f32; Instrucci\u00f32-->P2((Fi)); style P2 fill:#F00; C1-->|F|D; En aquest tipus de bucle, el bloc d'instruccions del bucle while, es poden executar zero o m\u00e9s vegades. Els passos que representen el diagrama anterior s\u00f3n: 1. S'executa la instrucci\u00f3 1 2. S'avalua la condici\u00f3 3. Si la condici\u00f3 \u00e9s true, s'executa el bloc d'instruccions del bucle i es torna a avaluar la condici\u00f3. 4. En cas que la condici\u00f3 s'avalue com a false, passar\u00edem a executar la instrucci\u00f3 2. Com far\u00edem el codi necessari per rec\u00f3rrer el nostre array de 100 elements fins trobar el n\u00famero que busquem?. Mira el codi seg\u00fcent: 1 2 3 4 5 6 int i = 0 ; // Inicialitzem una variable que ens servir\u00e0 de comptador. while ( i < 100 ) { if ( arrayNumeros [ i ] == 10 ) println ( \"N\u00famero trobat a la posici\u00f3 \" + i ); i ++ ; // Important incrementar el comptador o entrar\u00edem en un bucle infinit. } do .. while Molt semblant al bucle while per\u00f2 amb la difer\u00e8ncia que el bloc s'instruccions que cont\u00e9 l'estructura s'executaria almenys una vegada ja que la condici\u00f3 d'eixida s'avalua despr\u00e9s d'executar les instruccions. graph LR Id1((Inici))-->Instrucci\u00f31; style Id1 fill:#F00; Instrucci\u00f31-->P1(fa:fa-spinner); P1-->Instrucci\u00f32; Instrucci\u00f32-->C1{Condici\u00f3}; C1-->|V|Instrucci\u00f33; C1-->|F|P1; Instrucci\u00f33-->Id2((Fi)); style Id2 fill:#0F0; Els passos que representen el diagrama anterior s\u00f3n: S'executa la instrucci\u00f3 1 S'executen les instruccions que cont\u00e9 el bloc S'avalua la condici\u00f3 Si la condici\u00f3 \u00e9s true, s'executa el bloc d'instruccions del bucle i es torna a avaluar la condici\u00f3. En cas que la condici\u00f3 s'avalue com a false, passar\u00edem a executar la instrucci\u00f3 2. A l'exemple seg\u00fcent podem veure el codi necessari per buscar un n\u00famero dins d'un array d'enters (Ja veurem m\u00e9s endavant que \u00e9s un array). 1 2 3 4 5 6 7 int i = 0 ; // Inicialitzem una variable que ens servir\u00e0 de comptador. do { if ( arrayNumeros [ i ] == 10 ) println ( \"N\u00famero trobat a la posici\u00f3 \" + i ); i ++ ; // Important incrementar el comptador o entrar\u00edem en un bucle infinit. } while ( i < 100 ); bucle for La m\u00e9s complicada de comprendre per\u00f2 tamb\u00e9 possiblement la m\u00e9s utilitzada. Mirem un exemple. graph LR Id1((Inici))-->Instrucci\u00f31; style Id1 fill:#0F0; Instrucci\u00f31-->Inicialitzaci\u00f3; Inicialitzaci\u00f3-->D(fa:fa-spinner); D-->C1{Condici\u00f3} C1-->|NO|Instrucci\u00f32; C1-->|SI|Instruccions; Instruccions-->Actualitzaci\u00f3; Actualitzaci\u00f3-->D; Instrucci\u00f32-->Id3([Fi]) style Id3 fill:#F00; I els passos serien: Executem instrucci\u00f3 1 (aliena al bucle for) Inicialitzaci\u00f3 Avaluaci\u00f3 de la condici\u00f3 Si la condici\u00f3 \u00e9s true Executem les instruccions del bucle for Actualitzem \u00edndex Si la condici\u00f3 es false eixim del bucle i executem instrucci\u00f3 2 1 2 3 4 for ( int i = 0 ; i < 100 ; i ++ ) { if ( arrayNumeros [ i ] == 10 ) println ( \"N\u00famero trobat a la posici\u00f3 \" + i ); } Al codi anterior: Inicialitzaci\u00f3: int i = 0; Avaluaci\u00f3 de la condici\u00f3: \u00e9s i < 100 ? Actualitzaci\u00f3: i ++ Dibuixar amb bucles Observa el seg\u00fcent codi i raona'l 1 2 3 4 5 6 7 8 9 10 void setup () { size ( 320 , 240 ); } void draw () { for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) circle ( 10 + j * 20 , 10 + i * 20 , 20 ); } } El resultat d'aquest codi seria: Activitat 334. Dibuixa la pir\u00e0mide i la invertida Problema Solucio Fes un programa semblant al de l'activitat anterior per\u00f2 a la inversa, \u00e9s a dir, cinc cercles a la primera l\u00ednia, quatre a la segona, tres a la tercera, dos a la quarta i, finalment, un a la cinquena l\u00ednia. Descarrega la soluci\u00f3 al problema de dibuixar la pir\u00e0mide invertida Activitat 335. Dibuixa les dues diagonals Problema Soluci\u00f3 Fes un programa en Processing IDE que dibuixe les dues diagonals sobre una pantalla de 500 pixels per 500 pixels. Des del punt (0,0) fins al (500,500) i l'altra que va des del punt (500,0) fins al (0,500). Si a una diagonal li dibuixes quadrats, a l'altra dibuixa-li cercles. Descarrega la soluci\u00f3 al problema de les dues diagonals Activitat 336. Dues diagonals 640x480 Problema Soluci\u00f3 Millora l'activitat anterior i dibuixa les dues diagonals per\u00f2 a una pantalla de 640 pixels per 480 pixels. Descarrega la soluci\u00f3 al problema de les dues diagonals 640x480 Activitat 337. whiles i for Problema Soluci\u00f3 Fes l'activitat anterior canviant els bucles while per for i a l'inrev\u00e9s. Descarrega la soluci\u00f3 al problema del canvi de while per for Activitat 338. Optimitzaci\u00f3 del codi Problema Soluci\u00f3 Seria possible fer l'activitat 336 per\u00f2 nom\u00e9s utilitzant un bucle? Encara no disponible.","title":"3.- El llenguatge Java"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#tema-3-el-llenguatge-java","text":"","title":"Tema 3. El llenguatge Java"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#introduccio","text":"Una vegada estudiat el teorema del programa estructurat juntament amb els diagrames de flux i pseudocodi, passem a veure aquests conceptes te\u00f2rics en un llenguatge de programaci\u00f3 d'alt nivell concret com \u00e9s el llenguatge de programaci\u00f3 Java. El Java \u00e9s un llenguatge de programaci\u00f3 dissenyat el 1990 per James Gosling amb altres companys de Sun Microsystems a partir del llenguatge C . Des del seu naixement fou pensat com un llenguatge orientat a objectes. Entre el 13 de novembre de 2006 i el maig del 2007 Sun va alliberar parts de Java com a programari lliure de codi obert amb llic\u00e8ncia GPL . \u00c9s un dels llenguatges de programaci\u00f3 m\u00e9s utilitzats, i s'utilitza tant per aplicacions web com per aplicacions d'escriptori. El Java \u00e9s un llenguatge compilat amb una m\u00e0quina virtual d'intermediari i, per tant, pot semblar lent en comparaci\u00f3 amb altres llenguatges, per\u00f2 ofereix un \u00edndex de re-utilitzaci\u00f3 de codi molt elevat, sent possible trobar moltes llibreries lliures de Java . \u00c9s un llenguatge flexible i potent tot i la facilitat amb la qual es programa i dels resultats que ofereix. Un dels trets que el caracteritza i que el fa una eina molt valorada a l'hora de desenvolupar aplicacions distribu\u00efdes, \u00e9s el fet que \u00e9s un llenguatge multi-plataforma. Generalment els programes de Java es compilen en un bytecode (fitxer .class) que pot c\u00f3rrer en una M\u00e0quina Virtual Java. Sun Microsystems disposa de tres implementacions diferents de Java: J2SE per a aplicacions d'escriptori; J2EE per a aplicacions distribu\u00efdes i J2ME per a plataformes amb recursos m\u00e9s redu\u00efts com ara m\u00f2bils o PDAs. Per a cada una de les tres implementacions \u00e9s possible descarregar el JRE (entorn d'execuci\u00f3 Java) per a executar aplicacions o el SDK (Eines per al desenvolupament d'aplicacions) per a programar aplicacions en Java, aquest \u00faltim tamb\u00e9 inclou el JRE.","title":"Introducci\u00f3"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#dades-variables-identificadors","text":"Eventualment la inform\u00e0tica el que tracta de fer \u00e9s interpretar i processar informaci\u00f3 , per tant, el primer pas hauria de ser implementar el mecanisme que s'encarregue de representar la informaci\u00f3 tal i com la interpretem nosaltres al m\u00f3n real. La informaci\u00f3 en inform\u00e0tica \u00e9s el contingut d'una o m\u00e9s dades , fent abstracci\u00f3 de la representaci\u00f3 concreta que adopta. Dit d'una altra manera. Imagineu el caixer d'un supermercat. Al final del dia el treballador que est\u00e0 a c\u00e0rrec del caixer, traur\u00e0 tota la recaptaci\u00f3 del dia i la comptar\u00e0. En aquest cas la informaci\u00f3 seria la quantitat total de diners que s'han recaptat, i es representa en forma de dada num\u00e8rica utilitzant nombres i algun signe de puntuaci\u00f3, 1.200,45\u20ac seria la dada que representa la informaci\u00f3 que es vol saber al final del dia. Qu\u00e8 s\u00f3n les Dades Una dada \u00e9s \"la representaci\u00f3 convencional de la informaci\u00f3 en un format adequat perqu\u00e8 puga ser processada, comunicada o interpretada per mitjans manuals o autom\u00e0tics.\" Ara la q\u00fcesti\u00f3 \u00e9s com aquesta informaci\u00f3 que al m\u00f3n real es representa utilitzant n\u00fameros la podem representar en forma de dada per tal que una m\u00e0quina siga capa\u00e7 de processar. En qualsevol llenguatge de programaci\u00f3, la informaci\u00f3 es pot representar de forma constant, amb literals per exemple, o de forma variable utilitzant identificadors . Mirem a continuaci\u00f3 amb m\u00e9s detall aquests conceptes. Qu\u00e8 s\u00f3n les Variables Una variable en el camp de les matem\u00e0tiques \u00e9s una quantitat que pot cr\u00e9ixer o decr\u00e9ixer d'una manera cont\u00ednua o discont\u00ednua. Mentre que en inform\u00e0tica \u00e9s un s\u00edmbol emprat en programaci\u00f3 per a emmagatzemar en mem\u00f2ria valors canviants. En resum, la realitat cont\u00e9 una informaci\u00f3 en forma de dada que representarem en un programa inform\u00e0tic de diverses formes, b\u00e9 a trav\u00e9s de literals o de variables a les quals accedirem utilitzant identificadors . Per\u00f2 no ens avancem encara i estudiem b\u00e9 qu\u00e8 \u00e9s un identificador . En tot llenguatge de programaci\u00f3 existeixen una s\u00e8rie d'elements com variables, constants, funcions, llibreries. Aquests elements requereixen d'un nom per tal de distingir-lo de la resta. Aquests noms es diuen identificadors Qu\u00e8 s\u00f3n els identificadors Un identificador \u00e9s una cadena alfanum\u00e8rica que representa o dona un nom a un element dins del nostre programa. Els identificadors de les variables s\u00f3n noms que s'inventa el programador i s'hauria de tindre en consideraci\u00f3 al seg\u00fcent m\u00e0xima: han de ser significatius En altres paraules, un identificador \u00e9s una etiqueta que podem utilitzar per anomenar \"coses\" en un programa inform\u00e0tic. Pel que fa al concepte de significatiu , vol dir que el nom que escollim per a l'etiqueta hauria de ser suficientment esclaridor per saber qu\u00e8 \u00e9s el que representa. Per exemple, si volem posar una etiqueta (amb un adhesiu) a una botella d'aigua que tenim a la nevera, una bona elecci\u00f3 seria: AIGUA . Una \u00faltima cosa, com en tot llenguatge de programaci\u00f3, Java t\u00e9 una s\u00e8rie de normes que hem de seguir per construir identificadors v\u00e0lids. LLig i revisa les normes de construcci\u00f3 d'identificadors de Java, que d'altra banda, s\u00f3n molt semblants a la majoria de llenguatges de programaci\u00f3. Normes per construir identificadors en Java Quan triem el nom per identificar a una variable, ha de ser significatiu, \u00e9s a dir, que el mateix identificador ja done alguna pista de que \u00e9s el que representa. 1. Estan formats per caracters i/o digits. 2. No poden comen\u00e7ar per digit. 3. No poden usar els seg\u00fcents caracters especials: + - * / = % & # ! ? ^ \u201c \u2018 ~ \\ | < > ( ) [ ] { } : ; . , 4. No poden ser cap paraula reservada de Java. 5. Els identificadors de Java distingeixen entre maj\u00fascules i min\u00fascules (case sensitive). 6. No hi ha l\u00edmit a la llarg\u00e0ria de l'identificador, per\u00f2 \u00e9s aconsellable utilitzar una grand\u00e0ria \u00f2ptima entre 4 i 15 caracters. Vejam a continuaci\u00f3 alguns exemples d'identificadors inventats per un programador qualsevol:","title":"Dades, Variables, identificadors."},{"location":"Tema%2003.%20El%20llenguatge%20Java/#operadors-i-expressions","text":"Ha arribat el moment de revisar el que hem vist. Fins ara hem vist les dades com a unitat d'emmagatzemament d'informaci\u00f3 . Els diferents tipus de dades que ens proporciona Java, com les variables i les constants poden emmagatzemar dades que poden variar o no han de variar durant l'execuci\u00f3 del programa. I finalment tamb\u00e9 hem estudiat els literals i com construir identificadors per tal d'etiquetar distints elements dins del nostre programa. En definitiva em vist en detall com es pot representar tota classe d'informaci\u00f3 en un llenguatge de programaci\u00f3 com Java per\u00f2, com varem dir al primer tema, un programa inform\u00e0tic s'encarrega (entre d'altres) de processar l'informaci\u00f3 . B\u00e9 doncs, nosaltres de moment nom\u00e9s hem estudiat els diferents mecanismes que proporciona Java per gestionar eixa informaci\u00f3 per\u00f2 no hem vist encara com la podem processar. Per tal de poder processar la informaci\u00f3 haurem primer d'estudiar que s\u00f3n esl operadors i les expressions.","title":"Operadors i expressions"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#estructures","text":"Com hem vist al tema 2, el teorema de la programaci\u00f3 estructurada preveu una s\u00e8rie d'estructures b\u00e0siques amb les quals es podrien codificar tots els algorismes sense necessitat d'usar cap sent\u00e8ncia GOTO o similar. En els pr\u00f2xims punts veurem com es codifiquen totes aquestes estructures en llenguatge Java.","title":"Estructures"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/","text":"Tema 4. Programaci\u00f3 Modular Introducci\u00f3 Anem a entrar en un m\u00f3n que es basa en la m\u00e0xima: \"Divideix i vencer\u00e0s\" . Si fem una analogia amb l'estrat\u00e8gia b\u00e8l\u00b7lica, podriem dir que en aquells casos que l'enemic \u00e9s molt gran per a les nostres possibilitats, seria interessant poder, d'alguna forma, dividir-lo en trossos m\u00e9s xicotets de tal forma que el podem afrontar. Qu\u00e8 \u00e9s? La programaci\u00f3 modular \u00e9s un paradigma de programaci\u00f3 que consisteix a dividir un programa en m\u00f2duls o subprogrames per tal de fer-lo m\u00e9s llegible i manejable Tamb\u00e9 podriem dir que \u00e9s una evoluci\u00f3 de la programaci\u00f3 estructurada per solucionar problemes de programaci\u00f3 m\u00e9s grans i complexos del que aquesta pot resoldre. En l'aplicar la programaci\u00f3 modular, un problema complex ha de ser dividit en diversos subproblemes m\u00e9s simples , i aquests al seu torn en altres subproblemes m\u00e9s simples encara. Aix\u00f2 s'ha de fer fins a obtenir subproblemes prou simples com per poder ser resolts f\u00e0cilment amb algun llenguatge de programaci\u00f3. Aquesta t\u00e8cnica es diu refinament successiu, divideix i vencer\u00e0s o an\u00e0lisi descendent (Top-Down). Un m\u00f2dul \u00e9s cadascuna de les parts d'un programa que resol un dels subproblemes en qu\u00e8 es divideix el problema complex original. Cadascun d'aquests m\u00f2duls t\u00e9 una tasca ben definida i alguns necessiten d'altres per poder operar. En cas que un m\u00f2dul necessiti d'un altre, pot comunicar-se amb aquest mitjan\u00e7ant una interf\u00edcie de comunicaci\u00f3 que tamb\u00e9 ha d'estar ben definida. Si b\u00e9 un m\u00f2dul es pot entendre com una part d'un programa en qualsevol de les seves formes i variats contextos, en la pr\u00e0ctica se'ls sol prendre com a sin\u00f2nims de procediments i funcions . Per\u00f2 no necess\u00e0ria ni estrictament un m\u00f2dul \u00e9s una funci\u00f3 o un procediment, ja que el mateix pot contenir molts d'ells. No s'ha de confondre el terme \"m\u00f2dul\" (en el sentit de programaci\u00f3 modular) amb termes com \"funci\u00f3\" o \"procediment\", propis de l'llenguatge que ho suporte. White Stripes - Little Acorn (lletra) - Intro When problems overwhelm us And sadness smothers us Where do we find the will and the courage to continue? Well, the answer may come in the carrying voice of a friend A chance encounter with a book Or from a personal faith For janette help came from her faith But it also came from a squirrel Shortly after her divorce Janette lost her father Then she lost her job She had mounthing money problems But Janette not only survived She worked her way out of despondency and now she says \"Life is good again\" How could this happen? She told me that late one autumn day when she was at her lowest She watched a squirrel storing up nuts for the winter One at a time he would take them to the nest And she thought, \"If that squirrel can take care of himself with the harsh winter coming on So can I Once I broke my problems into small pieces I was able to carry them Just like those acorns One at a time Caracter\u00edstiques La modularitat en programaci\u00f3 es considera la capacitat que t\u00e9 un llenguatge concret en dividir-se en parts o subprogrames (m\u00f2duls). Cadascun dels m\u00f2duls o parts que formaran part d'aquest programa, tenen una funci\u00f3 particular, s\u00f3n semi-independents i incl\u00fas es poden trobar en fitxers f\u00edsics distints. No hem de pensar mai en un programa com un tot sino com un conjunt de m\u00f2duls relacionats entre si on cada m\u00f2dul desenvolupa una tasca molt concreta independentment de la resta i que tots junts formen el programa o aplicaci\u00f3. Avantatges El codi resultant \u00e9s m\u00e9s net i f\u00e0cil d'entendre. Permet la divisi\u00f3 del treball. Es pot provar de forma independent, millorant aix\u00ed la recerca i correcci\u00f3 d'errades. Facilita la definici\u00f3 de variables al crear diversos \u00e0mbits. Tipus de modularitat Depenent del nivell de detall amb el que es tracten els m\u00f2duls, podem distingir tres tipus: Llibreries: conjunt de funcions o de m\u00f2duls que comparteixen una finalitat. Classes: les classes s\u00f3n definicions de possibles objectes. Ja ho veurem amb m\u00e9s detall al tema de programaci\u00f3 orientada a objectes. Funcions o m\u00e8todes: codi que realitza un funci\u00f3 concreta. Una funci\u00f3 o m\u00e8tode pot estar associat tant a una llibreria com a un classe. Una funci\u00f3 \u00e9s un tros de codi que realitza una funci\u00f3 concreta i de vegades torna algun valor com a resultat. A banda, la t\u00e8cnica de programaci\u00f3 modular tamb\u00e9 aporta alguns dels fonaments de la programaci\u00f3 orientada a objectes com s\u00f3n: abstracci\u00f3, encapsulament i modularitat . Veiem amb m\u00e9s detall que \u00e9s cadascun: Abstracci\u00f3 L'abstracci\u00f3 \u00e9s la capacitat de, observada una realitat, quedar-se amb all\u00f2 important o essencial i obviar el detall. Aquest concepte ser\u00e0 un concepte b\u00e0sic en l'evoluci\u00f3 de la programaci\u00f3 estructurada i modular cap a la programaci\u00f3 orientada a objectes. Per exemple, per saber conduir un cotxe no necessite saber al detall el funcionament del seu motor sino on est\u00e0 l'accelerador, el fre i el volant. Encapsulament L'encapsulament \u00e9s el proc\u00e9s d'emmagatzemar en un mateix compartiment els elements d'una abstracci\u00f3 que constitueixen la seua estructura i comportament. En altres paraules, l\u2019ocultaci\u00f3 d\u2019informaci\u00f3, de forma que les dades internes d\u2019un m\u00e8tode, funci\u00f3 o procediment estan ocultes al m\u00f3n exterior, nom\u00e9s es coneix d\u2019ell la seua ess\u00e8ncia, \u00e9s a dir, qu\u00e8 podem fer amb ell. Per exemple, amb freq\u00fc\u00e8ncia es desenvolupa codi font o projectes en els que utilitzem la classe out, m\u00e9s concretament el m\u00e8tode println. Out es troba dins de l\u2019espai de noms (namespace) System i no \u00e9s m\u00e9s que una classe d\u2019aquest paquet. Dit en altres paraules. Out \u00e9s una classe i println() \u00e9s un m\u00e8tode de la classe Out. Modularitat Aquesta propietat fa refer\u00e8ncia a la forma en la que els elements en programaci\u00f3 orientada a objectes es troben organitzats en m\u00f2duls, facilitant aix\u00ed l\u2019encapsulament i abstracci\u00f3 de la informaci\u00f3. La modularitat permet dividir una aplicaci\u00f3 en parts. Aquestes parts han de ser tan independents com puguen de la resta de m\u00f2duls aix\u00ed com tamb\u00e9 de l\u2019aplicaci\u00f3 principal. El motiu pel qual els m\u00f2duls han de ser el m\u00e9s independents possibles de l\u2019aplicaci\u00f3 \u00e9s perqu\u00e8 aix\u00ed es podran reutilitzar en altres aplicacions m\u00e9s endavant. Funcions en Java Una vegada vistos els fonaments de la programaci\u00f3 modular, augmentem el nivell de detall. A Java la modularitat s'implementa mitjan\u00e7ant l'\u00fas de funcions. Una funci\u00f3 en Java \u00e9s la concreci\u00f3 de la t\u00e8cnica de programaci\u00f3 modular, \u00e9s a dir, un metode o procediment \u00e9s un fragment de codi que realitza una funci\u00f3 concreta dins del nostre programa. Per\u00f2 com s'escriu una funci\u00f3 en Java: 1 2 3 4 5 6 7 8 [ acces ] [ modificador ] tipus nomFuncio ( [ tipus nomArgument , [ tipus nomArgument ] ... ] ) { /* * Bloc d'instruccions */ return valor ; } Veiem i expliquem que significa cadascun dels elements que formen el codi anterior. Qu\u00e8 \u00e9s qu\u00e8 Tots aquells elements que estan entre claudators s\u00f3n opcionals. On: Acc\u00e9s: public, protected, private o package Modificador: static o final Tipus: int, boolean, float o qualsevol tipus predefinit per l'usuari. nomFuncio: cadena alfanum\u00e8rica significativa que indique el que fa la funci\u00f3. nomArgument: par\u00e0metres que se li passen a la funci\u00f3. Aquestos par\u00e0metres funcionaran com variables locals a la funci\u00f3. Per acabar veiem exemples concrets de com s'implementen les funcions o m\u00e8todes en Java. La primera funci\u00f3 el que fa \u00e9s saludar dient \"Hola m\u00f3n\" cada vegada que s'utilitza. Las segona diu \"Hola\" junt amb el nom que es passa com argument i finalment la tercera funci\u00f3 el que fa \u00e9s agafar la cadena de caracters que se li passa per par\u00e0metre i la inverteix. Si no entens el que s\u00f3n par\u00e0metres i arguments, no et preocupes, ho veurem al punt seg\u00fcent. Mira el seg\u00fcent exemple: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Funci\u00f3 simple void diguesHola () { println ( \"Hola Mon\" ); } // Funci\u00f3 amb par\u00e0metres void sayMyName ( String strNom ) { println ( \"Hola Mon: \" + strNom ); } // Funci\u00f3 que torna algun valor String canviaNom ( String strNom ) { return strNom . reverse (); } Activitat 401. Modularitza el seg\u00fcent codi Problema Soluci\u00f3 El seg\u00fcent codi per a Processing IDE dibuixa una taula de billar amb dues boles negres, dues banques i dues roges. Modularitza el codi de tal forma que al m\u00e8tode draw nom\u00e9s hi haur\u00e0 crides a m\u00e8todes definits per tu, concretament els seg\u00fcents m\u00e8todes: dibuixarTaula. dibuixarBolesRoges. dibuixarBolesNegres. dibuixarBolesBlanques. Al codi teniu tamb\u00e9 el prototip de la funci\u00f3 dibuixarTaula() com a exemple. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 void setup () { size ( 640 , 480 ); background ( 255 ); } void draw () { strokeWeight ( 20 ); stroke ( 170 , 120 , 20 ); fill ( 0 , 255 , 0 ); rect ( 30 , 30 , 500 , 330 ); fill ( 0 ); strokeWeight ( 1 ); stroke ( 200 ); circle ( 200 , 200 , 35 ); circle ( 400 , 60 , 35 ); stroke ( 0 ); fill ( 255 , 0 , 0 ); circle ( 100 , 100 , 35 ); circle ( 350 , 330 , 35 ); fill ( 255 , 255 , 255 ); circle ( 300 , 150 , 35 ); circle ( 150 , 300 , 35 ); } void dibuixarTaula () { // Posa ac\u00ed el codi que dibuixaria la taula de billar. } Descarrega la soluci\u00f3 al problema de la modularitzaci\u00f3 del codi Par\u00e0metres d'una funci\u00f3 Les funcions o m\u00e8todes en Java no nom\u00e9s serveixen per poder dividir i simplificar el codi sino que tamb\u00e9 es poden parametritzar , \u00e9s a dir, se li poden passar arguments que b\u00e9 utilitzen en la seua l\u00f2gica interna o b\u00e9 modifiquen el comportament del m\u00e8tode en q\u00fcesti\u00f3. Qu\u00e8 \u00e9s un par\u00e0metre ? Els par\u00e0metres s\u00f3n una forma d'intercanviar informaci\u00f3 amb el m\u00e8tode en q\u00fcesti\u00f3. Poden servir per introduir dades per executar el m\u00e8tode (entrada) o per obtenir o modificar dades despr\u00e9s de la seua execuci\u00f3 (eixida). Hi ha alguns detalls al respecte dels par\u00e0metres d'una funci\u00f3: Una funci\u00f3 pot tindre una quantitat qualsevol de par\u00e0metres, \u00e9s a dir, poden tindre des de zero fins a un, dos, deu o cent par\u00e0metres. Encara que poden ser m\u00e9s, normalment no sol passar de cinc m\u00e0xim . Si la funci\u00f3 t\u00e9 m\u00e9s d'un par\u00e0metre cadascun d'ells ha d'anar separat per una coma . Els arguments d'una funci\u00f3 tamb\u00e9 tenen un tipus i nom que els identifica . El tipus dels arguments pot ser qualsevol i no ha de tindre relaci\u00f3 amb el tipus del m\u00e8tode. Al rebre un argument res ens obliga a fer \u00fas d'aquest dins del m\u00e8tode. Els par\u00e0metres poden passar-se per refer\u00e8ncia (es mantenen les modificacions que es facen dins del m\u00e8tode) o per valor (no afectarien les modificacions a l'element original). Una funci\u00f3 amb par\u00e0metres en Java 1 2 3 4 5 6 void mostraBola ( int posX , int posY , int tam ) { fill ( 127 ); stroke ( 0 ); strokeWeight ( 3 ); ellipse ( x , y , tam , tam ); } La funci\u00f3 anterior \u00e9s un m\u00e8tode, que si fem cas al nom, s'encarrega de dibuixar una bola. Aquesta funci\u00f3 t\u00e9 tres par\u00e0metres: Un enter anomenat posX que representa la posici\u00f3 x on es dibuixar\u00e0 la boleta Un enter amb nom posY que indica la posici\u00f3 y en la que es dibuixar\u00e0 la boleta Un \u00faltim enter que es diu tam que li dir\u00e0 a la funci\u00f3 quin ser\u00e0 el grand\u00e0ria de la boleta. Com ja s'ha comentat anteriorment, \u00e9s possible passar un o m\u00e9s valors a una funci\u00f3 quan es crida. Recordeu que un valor passat a una funci\u00f3 es diu argument . Dins la funci\u00f3, la variable que rep l'argument es diu par\u00e0metre . Els par\u00e0metres es declaren dins dels par\u00e8ntesis que segueixen a el nom de m\u00e8tode. Un par\u00e0metre est\u00e0 dins de l'abast de la seua funci\u00f3, i a banda de la seva tasca especial de rebre un argument, actua com qualsevol altra variable local . Difer\u00e8ncia entre par\u00e0metre i argument Ac\u00ed hi ha un exemple simple de l'\u00fas de par\u00e0metres. Dins del programa seg\u00fcent podem observar com tenim una funci\u00f3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // Un exemple per diferenciar par\u00e0metre d'argument void setup () { size ( 640 , 480 ); } void draw () { int a = ( int ) random ( - 1000 , 1000 ); aboslut ( a ); } void absolut ( int num ) { int aux = num ; if ( aux < 0 ) aux = aux * ( - 1 ); println ( \"El valor absolut de \" + num + \" \u00e9s: \" + aux ); } Com ja s'ha comentat anteriorment un m\u00e8tode pot tenir m\u00e9s d'un par\u00e0metre. Simplement declare cada par\u00e0metre, separant un el seg\u00fcent amb una coma. Per exemple, la classe Divisor defineix un m\u00e8tode anomenat esDivisor () que determina si el primer par\u00e0metre \u00e9s divisor de el segon. Funcions amb m\u00e9s d'un par\u00e0metre 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void setup () { size ( 640 , 480 ); } void draw () { int a = ( int ) random ( 100 ); int b = ( int ) random ( 100 ); if esDivisor ( a , b ) println ( \"a \u00e9s divisor de b\" ); } boolean esDivisor ( int a , int b ) { if (( b % a ) == 0 ) return true ; else return false ; } Activitat 402. Executa en Processing IDE Problema Soluci\u00f3 Passa el codi anterior a Processing i executa'l. Observa el codi amb atenci\u00f3 i digues si hi ha alguna funci\u00f3 amb par\u00e0metres? Quins? La funci\u00f3 esDivisor t\u00e9 dos par\u00e0metres a i b que s\u00f3n de tipus enter. El que fa aquesta funci\u00f3 \u00e9s determinar si a \u00e9s divisor de b. Finalment dir que els arguments poden ser literals , que corresponguen amb el tipus del par\u00e0metre, o tamb\u00e9 poden ser variables , per\u00f2 que passa amb les variables que es passen com a argument si el par\u00e0metre al qual s'assignen \u00e9s modificat en temps d'execuci\u00f3? Es modifiquen tamb\u00e9? Mirem la difer\u00e8ncia entre valor i refer\u00e8ncia. Pas per valor i pas per refer\u00e8ncia Entrem en m\u00e9s detall sobre els par\u00e0metres, que passa amb ells quan s'acaba l'execuci\u00f3 de la funci\u00f3 o m\u00e8tode si s\u00f3n variables locals? En resum el pas per valor significa que al m\u00e8tode, en la variable de l'argument li arriba una c\u00f2pia del valor en el cas que es tracte d'un tipus de dades primitiu , \u00e9s a dir, char, int, float, double, etc.. Mentre que el pas per refer\u00e8ncia en canvi, l'argument cont\u00e9 un punter amb l'adre\u00e7a de mem\u00f2ria de la variable en q\u00fcesti\u00f3. Resum valor vs refer\u00e8ncia Pas per valor: Es crea una c\u00f2pia local de la variable dins de la funci\u00f3. Pas per refer\u00e8ncia: Es maneja directament la variable, els canvis realitzats dins de la funci\u00f3 li afectaran tamb\u00e9 fora. En resum, si es passa un argument per c\u00f2pia, tot all\u00f2 que es faja al par\u00e0metre dins del codi de la funci\u00f3 no afectar\u00e0 a l'original mentre que si, per contra, l'argument es passa per refer\u00e8ncia, totes aquelles accions que es realitzen sobre el par\u00e0metre li afectaran a l'argument original. Fixa't en el seg\u00fcent codi: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void setup () { size ( 640 , 480 ); } void draw () { int a = 1 ; int b = 2 ; print ( \"Valors de a i b abans de la modificaci\u00f3: \" ); println ( \" a = \" + a + \" ; b = \" + b ); modificaTipusPrimitius ( a , b ); print ( \"Valors de a i b despr\u00e9s de la modificaci\u00f3: \" ); println ( \" a = \" + a + \" ; b = \" + b ); } void modificaTipusPrimitius ( int x , int y ) { x = 5 ; y = 10 ; } Activitat 403. Pas per valor i pas per refer\u00e8ncia I Problema Soluci\u00f3 Copia el codi anterior en Processing IDE i respon a les seg\u00fcents q\u00fcestions: Quins s\u00f3n els par\u00e0metres i de quin tipus s\u00f3n els de la funci\u00f3 modificaTipusPrimitius? Quantes vegades es crida a la funci\u00f3 modificaTipusPrimitius? Quins argument es passen a cada crida? Qu\u00e8 passa i per qu\u00e8 a l'executar-se el codi anterior? Estan passant-se els arguments per valor o per refer\u00e8ncia? Els par\u00e0metres s\u00f3n x i y i el seu tipus \u00e9s int Es crida una sola vegada al draw A la crida es passen els arguments a i b que s\u00f3n variables locals al m\u00e8tode draw. Passa que els valors originals d'a i b no es modifiquen ja que s\u00f3n tipus b\u00e0sics. Per valor, si es passaren per refer\u00e8ncia es mantindrien els canvis. Ara mira el seg\u00fcent codi: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void setup () { size ( 640 , 480 ); } void draw () { Persona juan = new Persona (); modificarPersona ( juan ); println ( \"Nom: \" + persona . strNom ); println ( \"Cognom: \" + persona . strCognom ); println ( \"Edat: \" + persona . edat ); delay ( 1000 ); } void modificaPersona ( Persona p ) { p . strNom = \"Manolo\" ; p . strCognom = \"Unodos\" ; p . edat = 18 ; } public class Persona { public String strNom ; public String strCognom ; public int edat ; } Activitat 404. Pas per valor i pas per refer\u00e8ncia II Problema Soluci\u00f3 Copia el codi anterior i respon a les seg\u00fcents q\u00fcestions: Quins s\u00f3n els par\u00e0metres i de quin tipus s\u00f3n els de la funci\u00f3 modificaPersona? Quantes vegades es crida a la funci\u00f3 modificaPersona? Quins argument es passen a cada crida? Qu\u00e8 passa i per qu\u00e8 a l'executar-se el codi anterior? Estan passant-se els arguments per valor o per refer\u00e8ncia? Es passa un par\u00e0metre amb identificador p de tipus Persona. Una vegada al draw En la crida al m\u00e8tode es passa l'argument juan Al tractar-se d'un objecte el par\u00e0metre de la funci\u00f3, els canvis que es produeixen dins del m\u00e8tode es mantenen. Per refer\u00e8ncia ja que les modificacions dins del codi del m\u00e8tode es mantenen despr\u00e9s de l'execuci\u00f3 d'aquest. Sobre el return Com ja haur\u00e0s vist, hi ha algunes funcions que comencen per void i altres que tenen altres tipus... a\u00e7\u00f2 el que torna la funci\u00f3. B\u00e0sicament la difer\u00e8ncia entre una funci\u00f3 i un procediment des del punt de vista conceptual \u00e9s si el m\u00e8tode torna o no algun valor. Si torna \u00e9s un procediment sino \u00e9s una funci\u00f3, per\u00f2 aquesta \u00e9s nom\u00e9s un q\u00fcesti\u00f3 conceptual ja que des del punt de vista t\u00e8cnic (del codi) no hi practicament cap difer\u00e8ncia entre funci\u00f3 i procediment a banda del fet que retornen un valor en Java. Has de tenir en compte dues coses importants amb la sent\u00e8ncia return: Qualsevol instrucci\u00f3 que es trobe despr\u00e9s de l'execuci\u00f3 de return, NO ser\u00e0 executada. \u00c9s com\u00fa trobar funcions amb m\u00faltiples sent\u00e8ncies return al seu codi, com per exemple en sentencies condicionals, per\u00f2 una vegada el codi execute una sent\u00e8ncia return all\u00f2 que vinga despr\u00e9s no s'executar\u00e0. El tipus de valor que es torna en una funci\u00f3 ha de coincidir amb el tipus declarat a la funci\u00f3, \u00e9s a dir, si es declara int, el valor que ha de tornar ha de ser un nombre enter. En el cas de les funcions que no tornen res (void) , tamb\u00e9 conegues com a procediments, poden usar la sent\u00e8ncia return per\u00f2 sense cap valor i nom\u00e9s s'usaria per acabar amb l'execuci\u00f3 de la funci\u00f3. Funcions i procediments 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void setup () { size ( 640 , 480 ); } void draw () { dibuixaSol (); int abs = calculaAbsolut ( - 10 ); println ( \"Abs: \" + abs ); } void dibuixaSol () { fill ( 255 , 0 , 0 ); stroke ( 0 ); strokeWeight ( 1 ); circle ( 320 , 240 , 40 ); } int calculaAbsolut ( int a ) { if ( a < 0 ) a = a * - 1 ; return a ; } Activitat 405. Revisa conceptes Problema Soluci\u00f3 \u00c9s el moment de revisar tots els conceptes vistos fins ara que no s\u00f3n pocs. Revisa el codi anterior i respon a les seg\u00fcents q\u00fcestions: Quants m\u00e8todes hi han al codi? (draw i setup no compten) Quin identificador tenen? Escriu el prototip (interf\u00edcie) de cadascun dels m\u00e8todes que has trobat. Per a cada m\u00e8tode respon: quants par\u00e0metres tenen? Quin \u00e9s el nom dels par\u00e0metres i el tipus? Quins dels m\u00e8todes que has trobat s\u00f3n funcions i quins procediments? Raona la resposta. Dos. dibuixaSol i calculaAbsolut void dibuixaSol() i int calculaAbsolut(int a). M\u00e8tode dibuixaSol t\u00e9 zero par\u00e0metres mentre que calculaAbsolut t\u00e9 un par\u00e0metre amb identificador a de tipus int dibuixaSol \u00e9s un procediment (no retorna res) mentre que calculaAbsolut \u00e9s una funci\u00f3 que retorna un enter. Funcions: declaraci\u00f3 i crida Hem vist ja la gran part t\u00e8cnica de com funcionen els m\u00e8todes en Java pel que fa a la part de sintaxis i les diferents paraules claus que s'utilitzen. En altres paraules, ja sabem construir funcions i procediments tant des del punt de vista t\u00e8cnic (com \u00e9s construeixen), com des del punt de vista sem\u00e0ntic (qu\u00e8 signifiquen) per\u00f2, com fem \u00fas d'aquestes funcions o procediments? Primer cal que distingim entre la declaraci\u00f3 d'un m\u00e8tode i la crida a aquest. Declaraci\u00f3 d'un m\u00e8tode: definici\u00f3 del procediment o funci\u00f3 on s'inclou tant la cap\u00e7alera (interf\u00edcie o prototip) i el cos (codi de la funci\u00f3). Crida a un m\u00e8tode: \u00fas del m\u00e8tode per mitj\u00e0 d'una crida a aquest utilitzant el prototip i els par\u00e0metres en cas de tenir-los. Prototip, interf\u00edcie o signatura: la signatura d'un m\u00e8tode \u00e9s la combinaci\u00f3 de nom, tipus de par\u00e0metres, nom d'aquestos i ordre. Per tal d'utilitzar una funci\u00f3 o m\u00e8tode en Java hem de cridar a eixa funci\u00f3. Una funci\u00f3 en Java es crida utilitzant el nom del m\u00e8tode i entre parentesi s'han de passar els par\u00e0metres que s'indica a la declaraci\u00f3 de la funci\u00f3. Aquestos par\u00e0metres que es passen han de coincidir en n\u00famero, si la declaraci\u00f3 del funci\u00f3 t\u00e9 3 par\u00e0metres s'hauran de passar tres par\u00e0metres, i tamb\u00e9 han de coincidir en el t\u00edtol. Per\u00f2 millor vegem un exemple: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * M\u00e8tode holaMon * Mostra per pantalla hola + el nom que es passa com a argument * @param strNom cadena de caracters que representa el nom d'una persona * @return void */ void holaMon ( String strNom ) { System . out . println ( \"Hola: \" + strNom ); } /** * M\u00e8tode suma * Retorna el valor de la suma dels elements que es passen com a arguments. * @param a primer element de la suma de tipus enter. * @param b segon element de la suma de tipus enter. * @return el resultat de la suma en forma entera */ int suma ( int a , int b ) { int res = a + b ; return res ; } // Crides a la funci\u00f3 holaMon holaMon ( \"Batiste\" ); holaMon (); holaMon ( \"Batiste\" , \"Ceba\" ); // Crides a la funci\u00f3 suma int resultat = suma ( 10 , 5 ); suma ( 10 , 5 ); int resultat = suma (); suma (); int res = suma ( 10 , 3 , 10 ); Activitat 406. Copia i raona el codi anterior Problema Soluci\u00f3 C\u00f2pia el codi anterior, executa'l i raona el que est\u00e0 passant. Modifica el codi per tal que funcione correctament i mostre un resultat per pantalla. Descarrega la soluci\u00f3 al problema de la crida a funcions Activitat 407. Crida als m\u00e8todes de forma correcta Problema Soluci\u00f3 A continuaci\u00f3 vos he deixat un codi amb 4 funcions. Observeu-les i despr\u00e9s feu \u00fas de totes elles des de la funci\u00f3 draw. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 void setup () { size ( 640 , 480 ); } void draw () { // Escriu el codi de les funcions ac\u00ed. } void fesAlgo () { println ( \"Algo far\u00e9\" ); } void f2 ( int a ) { if ( a % 2 == 0 ) println ( \"El nombre \u00e9s parell\" ); else println ( \"El nombre no \u00e9s parell\" ); } void funcio3 ( int a , char c ) { println ( \"El caracter \u00e9s \" + c + \" mentre que el n\u00famero \u00e9s: \" + a ); } int funcio4 ( int c ) { int a = 0 ; for ( int i = 0 ; i < c ; i ++ ) a = a + 1 + 2 * a ; return a ; } String funcio5 ( String str ) { if ( str == \"\" ) return \"Buida\" ; return str . toUpperCase (); } Descarrega la soluci\u00f3 al problema de la crida a funcions part 2 Detalls per cridar funcions El nom ha de coincidir exactament al moment de cridar, \u00e9s l\u2019\u00fanica forma d\u2019identificar-lo. L\u2019ordre dels par\u00e0metres i el tipus ha de coincidir. Cal tindre cura en el moment d'enviar els par\u00e0metres, hem de fer-ho en el mateix ordre en que varen ser declarats i han de ser del mateix tipus . Cada par\u00e0metre enviat tamb\u00e9 va separat per comes. Si una funci\u00f3 no rep par\u00e0metres , simplement no posem res a l'interior de la par\u00e8ntesi, per\u00f2 sempre deguem posar la par\u00e8ntesi. Invocar una funci\u00f3 segueix sent una sent\u00e8ncia normal i corrent en Java, aix\u00ed que ha de finalitzar amb ';' com sempre. El valor retornat per un m\u00e8tode o funci\u00f3 pot ser assignat a una variable del mateix tipus . Si es tracta d'un procediment no es pot retornar valor alg\u00fa. Una funci\u00f3 pot cridar a una altra dins de s\u00ed mateixa o fins i tot pot ser enviada com a par\u00e0metre a una altra (mira el seg\u00fcent exemple). Activitat 408. Copia i raona el seg\u00fcent codi Problema Soluci\u00f3 Passa el seg\u00fcent codi a processing, executa'l i raona el que est\u00e0 passant. Quin altre nom alternatiu li podriem posar a la funci\u00f3 per tal que aquest siga m\u00e9s significatiu? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void setup () { size ( 640 , 480 ); int i = 10 ; int [] array = new int [ 10 ] ; for ( int a = 0 ; a < i ; a ++ ) array [ a ] = 0 ; println ( \"Abans de la crida a la funci\u00f3:\" ); println ( \"i=\" + i ); println ( \"array[5]=\" + array [ 5 ] ); funcio ( i , array ); println ( \"Despr\u00e9s de la crida a la funci\u00f3:\" ); println ( \"i=\" + i ); println ( \"array[5]=\" + array [ 5 ] ); } void draw () { delay ( 10000 ); } void funcio ( int i , int [] array ) { i = 5 ; array [ i ] = 15 ; } Descarrega la soluci\u00f3 al problema de la crida a funcions part 2 Activitat 409. Executa el codi en Processing IDE Escriu el seg\u00fcent codi en Processing i executa'l. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // Variables globals int x , y ; void setup () { size ( 320 , 240 ); x = 150 ; y = 120 ; } void draw () { background ( 255 ); stroke ( 0 ); // Dibuixem la cara cercle strokeWeight ( 2 ); fill ( 255 , 255 , 0 ); circle ( x , y , 100 ); // Dibuixem ulls strokeWeight ( 2 ); fill ( 255 ); circle ( 130 , 110 , 20 ); circle ( 165 , 110 , 20 ); strokeWeight ( 5 ); point ( 133 , 110 ); point ( 168 , 110 ); // Dibuixem la boca noFill (); strokeWeight ( 2 ); arc ( 150 , 135 , 40 , 30 , 0 , PI ); Aquest codi mostra el seg\u00fcent dibuix Activitat 410. Divideix-lo en funcions Problema Soluci\u00f3 Separa el codi en funcions, has d'afegir les funcions dibuixaCara, dibuixaUlls i dibuixaBoca seguint els prototips que et mostre a continuaci\u00f3. 1 2 3 4 // Prototips de funcions void dibuixaCara (); void dibuixaUlls (); void dibuixaBoca (); Descarrega la soluci\u00f3 al problema del smiley Activitat 411. Par\u00e0metres coordenades Problema Soluci\u00f3 Modifica el codi anterior per tal que tant el codi que dibuixa els ulls com el codi que dibuixa la boca, estiguen en dues funcions: dibuixaUlls i dibuixaBoca. A aquestes funcions se'ls passar\u00e0 com a par\u00e0metres les coordenades x i y i a partir d'aquestes ha de dibuixar els ulls i la boca on corresponga. 1 2 3 4 // Prototips de les funcions void dibuixaCara ( int x , int y ); void dibuixaUlls ( int x , int y ); void dibuixaBoca ( int x , int y ); [Descarrega la soluci\u00f3 al problema del smiley] parametritzat(assets/Tema4/act411.pde) Activitat 412. Dibuixar cares - Ampliaci\u00f3 Problema Soluci\u00f3 Amplia el codi anterior per tal que mostre el seg\u00fcent dibuix. Observa com ha de quedar el codi de la funci\u00f3 draw 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // Variables Globals int cercleX , cercleY , triangleX , triangleY , quadratX , quadratY ; void setup () { size ( 640 , 300 ); // Coordenades del cercle cercleX = 150 ; cercleY = 150 ; // Coordenades del primer punt del triangle triangleX = 320 ; triangleY = 150 ; // Coordenades del quadrat quadratX = 470 ; quadratY = 150 ; } void draw () { background ( 255 ); // Codi per dibuixar el cercle // Escriu el codi necessari per dibuixar el cercle a cercleX i cercleY ac\u00ed dibuixaUlls ( cercleX , cercleY ); dibuixaBoca ( cercleX , cercleY ); // Codi per dibuixar el triangle // Escriu el codi necessari per dibuixar el cercle a triangleX i triangleY ac\u00ed dibuixaUlls ( triangleX , triangleY ); dibuixaBoca ( triangleX , triangleY ); // Codi per dibuixar el quadrat // Escriu el codi necessari per dibuixar el cercle a quadratX i quadratY ac\u00ed dibuixaUlls ( quadratX , quadratY ); dibuixaBoca ( quadratX , quadratY ); } Descarrega la soluci\u00f3 al problema del tres smileys Activitat 413. Dibuixar pe\u00e7a domino Problema Soluci\u00f3 Emplena el codi de la funci\u00f3 dibuixaDomino(int,int) per tal que mostre la imatge seg\u00fcent. 1 2 3 4 5 6 7 8 9 10 void setup () { size ( 640 , 480 ); } void draw () { dibuixaDomino ( 5 , 4 ); } void dibuixaDomino ( int a , int b ) { // Codi per dibuixar la pe\u00e7a de domin\u00f3 amb la puntuaci\u00f3 que es passa per par\u00e0metre. } Descarrega la soluci\u00f3 al problema de la fitxa de domin\u00f3 Activitat 414. Dibuixar pe\u00e7a domin\u00f3 parametritzada Problema Soluci\u00f3 Qu\u00e8 passa si en lloc de 5 i 4 passarem 6 i 6 per par\u00e0metre? Dibuixa el que esperes que dibuixe? Fes les modificacions necess\u00e0ries al codi per tal que funcione com s'espera. Ampliaci\u00f3: fes que el teu algorisme mostre totes les peces del domin\u00f3 ordenades en files i columnes. Descarrega la soluci\u00f3 al problema del joc del domin\u00f3 Pas d'objectes a funcions Quan passem un tipus primitiu a una funci\u00f3, es passa per valor . Per\u00f2 quan vam passar un objecte a una funci\u00f3, la situaci\u00f3 canvia dr\u00e0sticament, perqu\u00e8 els objectes es passen per refer\u00e8ncia . Java fa aquesta cosa interessant que \u00e9s una classe d'h\u00edbrid entre passar per valor i passar per refer\u00e8ncia. A l'crear una variable d'un tipus de classe (un objecte) , nom\u00e9s varem crear una refer\u00e8ncia a un objecte. Per tant, quan passem aquesta refer\u00e8ncia a un m\u00e8tode, el par\u00e0metre que el rep es referir\u00e0 a el mateix objecte que el referit per l'argument. Aix\u00f2 vol dir efectivament que els objectes actuen com si es passessin als m\u00e8todes mitjan\u00e7ant l'\u00fas del pas per refer\u00e8ncia. IMPORTANT: Els canvis en l'objecte dins el m\u00e8tode es reflecteixen en l'objecte utilitzat com a argument. Per\u00f2 vejam un exemple per tal que quede m\u00e9s clar: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // Programa Java per demostrar el pas d'objectes a funcions void setup () { size ( 640 , 480 ); } void draw () { Demo ob1 = new Demo ( 100 , 22 ); Demo ob2 = new Demo ( 100 , 22 ); Demo ob3 = new Demo ( - 1 , - 1 ); println ( \"ob1==ob2: \" + ob1 . equalTo ( ob2 )); println ( \"ob1==ob3: \" + ob1 . equalTo ( ob3 )); delay ( 1000 ); } public class Demo { public int a ; public int b ; // Constructor de la classe Demo ( int i , int j ) { a = i ; b = j ; } // Torna true si els valors s\u00f3n els mateixos boolean equalTo ( Demo obj ) { return ( obj . a == this . a && obj . b == this . b ); } } Eixida 1 2 obj1 == obj2 : true obj1 == obj3 : false Explicaci\u00f3 en imatges: 1.Primer: S'instancien els tres objectes ob1, ob2 i ob3. 1 2 3 Demo ob1 = new Demo ( 100 , 22 ); Demo ob2 = new Demo ( 100 , 22 ); Demo ob3 = new Demo ( - 1 , - 1 ); 2. Segon: En la funci\u00f3 equalTo , es declara una refer\u00e8ncia de classe Demo amb un objecte obj i s'assigna inicialment null . 3. Tercer: En la primera crida al m\u00e8tode equalTo (ob1.equalTo(ob2)), al par\u00e0metre obj del prototip del m\u00e8tode, se li passa l'argument 'ob2' , \u00e9s a dir, 'obj' passa a ser una refer\u00e8ncia a 'ob2' quan la seg\u00fcent sent\u00e8ncia s'execute. 1 System . out . println ( \"ob1 == ob2: \" + ob1 . equalTo ( ob2 )); 4. Quart: Ara com podem observar, es crida al m\u00e8tode equalTo sobre 'ob1' i 'obj' fa refer\u00e8ncia a 'ob2'. Donat que els valors 'a' i 'b' s\u00f3n els mateixos per ambdues refer\u00e8ncies, aleshores si la condici\u00f3 \u00e9s veritat, tornar\u00e0 true . 1 if ( obj . a == a && obj . b == b ) 5. Cinqu\u00e8: De nou 'obj' es reassignar\u00e0 a 'ob3' quan s'executa la seg\u00fcent sent\u00e8ncia com s'ha fet al pas tercer. 1 System . out . println ( \"ob1 == ob3: \" + ob1 . equalTo ( ob3 )); 6. Sis\u00e8: Ara, com podem observar, el m\u00e8tode equalTo es crida en 'ob1', i 'obj' fa refer\u00e8ncia a 'ob3'. Com que els valors 'a' i 'b' no s\u00f3n els mateixos per a les dues refer\u00e8ncies, aleshores torna false. Activitat 415. Copia el codi Copia i executa el codi anterior en Processing IDE Recursivitat Definici\u00f3 En general, la recursivitat \u00e9s el proc\u00e9s de definir alguna cosa en termes de si mateix i \u00e9s una cosa semblant a una definici\u00f3 circular. El component clau d'un m\u00e8tode recursiu \u00e9s una declaraci\u00f3 que executa una crida a si mateix. La recursivitat \u00e9s un poder\u00f3s mecanisme de control. L'exemple cl\u00e0ssic de recursivitat \u00e9s el c\u00e0lcul del factorial d'un nombre. El factorial d'un nombre N \u00e9s el producte de tots els nombres enters que es troben entre 1 i N. Per exemple, el factorial de 3 \u00e9s 1 \u00d7 2 \u00d7 3, \u00e9s a dir, \u00e9s de 6. El seg\u00fcent programa mostra una forma recursiva de calcular el factorial d'un nombre. Per a prop\u00f2sits de comparaci\u00f3, tamb\u00e9 s'inclou un equivalent no recursiu (iteratiu). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 void setup () { size ( 640 , 480 ); } void draw () { println ( \"Factorial utilitzant un m\u00e8tode recursiu:\" ); println ( \"El factorial de 3 \u00e9s: \" + factorialRecursiu ( 3 )); println ( \"El factorial de 6 \u00e9s: \" + factorialRecursiu ( 6 )); println (); println ( \"Factorial utilitzant un m\u00e8tode iteratiu:\" ); println ( \"El factorial de 3 \u00e9s: \" + factorialIteratiu ( 3 )); println ( \"El factorial de 6 \u00e9s: \" + factorialIteratiu ( 6 )); println (); } int factorialRecursiu ( int n ) { int res ; if ( n == 1 ) return 1 ; res = factorial ( n - 1 ) * n ; return res ; } int factorialIteratiu ( int n ) { int t , res ; res = 1 ; for ( t = 1 ; t <= n ; t ++ ) res *= t ; return res ; } Eixida 1 2 3 4 5 6 7 Factorial utilitzant un m\u00e8tode recursiu : El factorial de 3 \u00e9s : 6 El factorial de 6 \u00e9s : 720 Factorial utilitzant un m\u00e8tode iteratiu : El factorial de 3 \u00e9s : 6 El factorial de 6 \u00e9s : 720 Stack Overflow Les versions recursives de moltes rutines poden executar-se una mica m\u00e9s lentament que els seus equivalents iteratius causa de la sobrec\u00e0rrega addicional de les trucades a m\u00e8todes addicionals. Massa crides recursives a un m\u00e8tode podrien causar un desbordament de la pila. Com l'emmagatzematge per als par\u00e0metres i les variables locals est\u00e0 a la pila i cada trucada nova crea una nova c\u00f2pia d'aquestes variables, \u00e9s possible que la pila s'acabe esgotant . Si aix\u00f2 passa, el sistema de temps d'execuci\u00f3 (run-time) de Java causar\u00e0 una excepci\u00f3 . No obstant aix\u00f2, probablement no haur\u00e0s de preocupar-te per aix\u00f2 a menys que una rutina recursiva es torne boja. El principal avantatge de la recursivitat \u00e9s que alguns tipus d'algoritmes es poden implementar de forma m\u00e9s clara i m\u00e9s recursiva del que poden ser iterativament. Per exemple, l'algorisme de classificaci\u00f3 Quicksort \u00e9s bastant dif\u00edcil d'implementar de manera iterativa. A m\u00e9s, alguns problemes, especialment els relacionats amb la IA, semblen prestar-se a solucions recursives. 1 2 3 4 5 6 7 8 int fact ( int n ) { // Condici\u00f3 de base equivocada (provoca Stack Overflow) if ( n == 100 ) return 1 ; else return n * fact ( n - 1 ); } En l'exemple anterior: Si es diu a fact (10), cridar\u00e0 a fact(9), fact(8), fact(7), etc., per\u00f2 el nombre mai arribar\u00e0 a 100. Per tant, no s'assoleix la condici\u00f3 base. Si la mem\u00f2ria s'esgota amb aquests m\u00e8todes en la pila, provocar\u00e0 un error de desbordament de pila . La API de Java L'API Java \u00e9s una interf\u00edcie de programaci\u00f3 d'aplicacions (API, per les seves sigles de l'angl\u00e8s: Application Programming Interface) prove\u00efda pels creadors de el llenguatge de programaci\u00f3 Java, que d\u00f3na als programadors els mitjans per desenvolupar aplicacions Java. Com el llenguatge Java \u00e9s un llenguatge orientat a objectes, l'API de Java proveeix d'un conjunt de classes utilit\u00e0ries per a efectuar tota mena de tasques necess\u00e0ries dins d'un programa. L'API Java est\u00e0 organitzada en paquets l\u00f2gics, on cada paquet cont\u00e9 un conjunt de classes relacionades sem\u00e0nticament.","title":"4.- Programaci\u00f3 Modular"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#tema-4-programacio-modular","text":"","title":"Tema 4. Programaci\u00f3 Modular"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#introduccio","text":"Anem a entrar en un m\u00f3n que es basa en la m\u00e0xima: \"Divideix i vencer\u00e0s\" . Si fem una analogia amb l'estrat\u00e8gia b\u00e8l\u00b7lica, podriem dir que en aquells casos que l'enemic \u00e9s molt gran per a les nostres possibilitats, seria interessant poder, d'alguna forma, dividir-lo en trossos m\u00e9s xicotets de tal forma que el podem afrontar. Qu\u00e8 \u00e9s? La programaci\u00f3 modular \u00e9s un paradigma de programaci\u00f3 que consisteix a dividir un programa en m\u00f2duls o subprogrames per tal de fer-lo m\u00e9s llegible i manejable Tamb\u00e9 podriem dir que \u00e9s una evoluci\u00f3 de la programaci\u00f3 estructurada per solucionar problemes de programaci\u00f3 m\u00e9s grans i complexos del que aquesta pot resoldre. En l'aplicar la programaci\u00f3 modular, un problema complex ha de ser dividit en diversos subproblemes m\u00e9s simples , i aquests al seu torn en altres subproblemes m\u00e9s simples encara. Aix\u00f2 s'ha de fer fins a obtenir subproblemes prou simples com per poder ser resolts f\u00e0cilment amb algun llenguatge de programaci\u00f3. Aquesta t\u00e8cnica es diu refinament successiu, divideix i vencer\u00e0s o an\u00e0lisi descendent (Top-Down). Un m\u00f2dul \u00e9s cadascuna de les parts d'un programa que resol un dels subproblemes en qu\u00e8 es divideix el problema complex original. Cadascun d'aquests m\u00f2duls t\u00e9 una tasca ben definida i alguns necessiten d'altres per poder operar. En cas que un m\u00f2dul necessiti d'un altre, pot comunicar-se amb aquest mitjan\u00e7ant una interf\u00edcie de comunicaci\u00f3 que tamb\u00e9 ha d'estar ben definida. Si b\u00e9 un m\u00f2dul es pot entendre com una part d'un programa en qualsevol de les seves formes i variats contextos, en la pr\u00e0ctica se'ls sol prendre com a sin\u00f2nims de procediments i funcions . Per\u00f2 no necess\u00e0ria ni estrictament un m\u00f2dul \u00e9s una funci\u00f3 o un procediment, ja que el mateix pot contenir molts d'ells. No s'ha de confondre el terme \"m\u00f2dul\" (en el sentit de programaci\u00f3 modular) amb termes com \"funci\u00f3\" o \"procediment\", propis de l'llenguatge que ho suporte. White Stripes - Little Acorn (lletra) - Intro When problems overwhelm us And sadness smothers us Where do we find the will and the courage to continue? Well, the answer may come in the carrying voice of a friend A chance encounter with a book Or from a personal faith For janette help came from her faith But it also came from a squirrel Shortly after her divorce Janette lost her father Then she lost her job She had mounthing money problems But Janette not only survived She worked her way out of despondency and now she says \"Life is good again\" How could this happen? She told me that late one autumn day when she was at her lowest She watched a squirrel storing up nuts for the winter One at a time he would take them to the nest And she thought, \"If that squirrel can take care of himself with the harsh winter coming on So can I Once I broke my problems into small pieces I was able to carry them Just like those acorns One at a time","title":"Introducci\u00f3"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#caracteristiques","text":"La modularitat en programaci\u00f3 es considera la capacitat que t\u00e9 un llenguatge concret en dividir-se en parts o subprogrames (m\u00f2duls). Cadascun dels m\u00f2duls o parts que formaran part d'aquest programa, tenen una funci\u00f3 particular, s\u00f3n semi-independents i incl\u00fas es poden trobar en fitxers f\u00edsics distints. No hem de pensar mai en un programa com un tot sino com un conjunt de m\u00f2duls relacionats entre si on cada m\u00f2dul desenvolupa una tasca molt concreta independentment de la resta i que tots junts formen el programa o aplicaci\u00f3.","title":"Caracter\u00edstiques"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#funcions-en-java","text":"Una vegada vistos els fonaments de la programaci\u00f3 modular, augmentem el nivell de detall. A Java la modularitat s'implementa mitjan\u00e7ant l'\u00fas de funcions. Una funci\u00f3 en Java \u00e9s la concreci\u00f3 de la t\u00e8cnica de programaci\u00f3 modular, \u00e9s a dir, un metode o procediment \u00e9s un fragment de codi que realitza una funci\u00f3 concreta dins del nostre programa. Per\u00f2 com s'escriu una funci\u00f3 en Java: 1 2 3 4 5 6 7 8 [ acces ] [ modificador ] tipus nomFuncio ( [ tipus nomArgument , [ tipus nomArgument ] ... ] ) { /* * Bloc d'instruccions */ return valor ; } Veiem i expliquem que significa cadascun dels elements que formen el codi anterior. Qu\u00e8 \u00e9s qu\u00e8 Tots aquells elements que estan entre claudators s\u00f3n opcionals. On: Acc\u00e9s: public, protected, private o package Modificador: static o final Tipus: int, boolean, float o qualsevol tipus predefinit per l'usuari. nomFuncio: cadena alfanum\u00e8rica significativa que indique el que fa la funci\u00f3. nomArgument: par\u00e0metres que se li passen a la funci\u00f3. Aquestos par\u00e0metres funcionaran com variables locals a la funci\u00f3. Per acabar veiem exemples concrets de com s'implementen les funcions o m\u00e8todes en Java. La primera funci\u00f3 el que fa \u00e9s saludar dient \"Hola m\u00f3n\" cada vegada que s'utilitza. Las segona diu \"Hola\" junt amb el nom que es passa com argument i finalment la tercera funci\u00f3 el que fa \u00e9s agafar la cadena de caracters que se li passa per par\u00e0metre i la inverteix. Si no entens el que s\u00f3n par\u00e0metres i arguments, no et preocupes, ho veurem al punt seg\u00fcent. Mira el seg\u00fcent exemple: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Funci\u00f3 simple void diguesHola () { println ( \"Hola Mon\" ); } // Funci\u00f3 amb par\u00e0metres void sayMyName ( String strNom ) { println ( \"Hola Mon: \" + strNom ); } // Funci\u00f3 que torna algun valor String canviaNom ( String strNom ) { return strNom . reverse (); } Activitat 401. Modularitza el seg\u00fcent codi Problema Soluci\u00f3 El seg\u00fcent codi per a Processing IDE dibuixa una taula de billar amb dues boles negres, dues banques i dues roges. Modularitza el codi de tal forma que al m\u00e8tode draw nom\u00e9s hi haur\u00e0 crides a m\u00e8todes definits per tu, concretament els seg\u00fcents m\u00e8todes: dibuixarTaula. dibuixarBolesRoges. dibuixarBolesNegres. dibuixarBolesBlanques. Al codi teniu tamb\u00e9 el prototip de la funci\u00f3 dibuixarTaula() com a exemple. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 void setup () { size ( 640 , 480 ); background ( 255 ); } void draw () { strokeWeight ( 20 ); stroke ( 170 , 120 , 20 ); fill ( 0 , 255 , 0 ); rect ( 30 , 30 , 500 , 330 ); fill ( 0 ); strokeWeight ( 1 ); stroke ( 200 ); circle ( 200 , 200 , 35 ); circle ( 400 , 60 , 35 ); stroke ( 0 ); fill ( 255 , 0 , 0 ); circle ( 100 , 100 , 35 ); circle ( 350 , 330 , 35 ); fill ( 255 , 255 , 255 ); circle ( 300 , 150 , 35 ); circle ( 150 , 300 , 35 ); } void dibuixarTaula () { // Posa ac\u00ed el codi que dibuixaria la taula de billar. } Descarrega la soluci\u00f3 al problema de la modularitzaci\u00f3 del codi","title":"Funcions en Java"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#pas-dobjectes-a-funcions","text":"Quan passem un tipus primitiu a una funci\u00f3, es passa per valor . Per\u00f2 quan vam passar un objecte a una funci\u00f3, la situaci\u00f3 canvia dr\u00e0sticament, perqu\u00e8 els objectes es passen per refer\u00e8ncia . Java fa aquesta cosa interessant que \u00e9s una classe d'h\u00edbrid entre passar per valor i passar per refer\u00e8ncia. A l'crear una variable d'un tipus de classe (un objecte) , nom\u00e9s varem crear una refer\u00e8ncia a un objecte. Per tant, quan passem aquesta refer\u00e8ncia a un m\u00e8tode, el par\u00e0metre que el rep es referir\u00e0 a el mateix objecte que el referit per l'argument. Aix\u00f2 vol dir efectivament que els objectes actuen com si es passessin als m\u00e8todes mitjan\u00e7ant l'\u00fas del pas per refer\u00e8ncia. IMPORTANT: Els canvis en l'objecte dins el m\u00e8tode es reflecteixen en l'objecte utilitzat com a argument. Per\u00f2 vejam un exemple per tal que quede m\u00e9s clar: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // Programa Java per demostrar el pas d'objectes a funcions void setup () { size ( 640 , 480 ); } void draw () { Demo ob1 = new Demo ( 100 , 22 ); Demo ob2 = new Demo ( 100 , 22 ); Demo ob3 = new Demo ( - 1 , - 1 ); println ( \"ob1==ob2: \" + ob1 . equalTo ( ob2 )); println ( \"ob1==ob3: \" + ob1 . equalTo ( ob3 )); delay ( 1000 ); } public class Demo { public int a ; public int b ; // Constructor de la classe Demo ( int i , int j ) { a = i ; b = j ; } // Torna true si els valors s\u00f3n els mateixos boolean equalTo ( Demo obj ) { return ( obj . a == this . a && obj . b == this . b ); } } Eixida 1 2 obj1 == obj2 : true obj1 == obj3 : false Explicaci\u00f3 en imatges: 1.Primer: S'instancien els tres objectes ob1, ob2 i ob3. 1 2 3 Demo ob1 = new Demo ( 100 , 22 ); Demo ob2 = new Demo ( 100 , 22 ); Demo ob3 = new Demo ( - 1 , - 1 ); 2. Segon: En la funci\u00f3 equalTo , es declara una refer\u00e8ncia de classe Demo amb un objecte obj i s'assigna inicialment null . 3. Tercer: En la primera crida al m\u00e8tode equalTo (ob1.equalTo(ob2)), al par\u00e0metre obj del prototip del m\u00e8tode, se li passa l'argument 'ob2' , \u00e9s a dir, 'obj' passa a ser una refer\u00e8ncia a 'ob2' quan la seg\u00fcent sent\u00e8ncia s'execute. 1 System . out . println ( \"ob1 == ob2: \" + ob1 . equalTo ( ob2 )); 4. Quart: Ara com podem observar, es crida al m\u00e8tode equalTo sobre 'ob1' i 'obj' fa refer\u00e8ncia a 'ob2'. Donat que els valors 'a' i 'b' s\u00f3n els mateixos per ambdues refer\u00e8ncies, aleshores si la condici\u00f3 \u00e9s veritat, tornar\u00e0 true . 1 if ( obj . a == a && obj . b == b ) 5. Cinqu\u00e8: De nou 'obj' es reassignar\u00e0 a 'ob3' quan s'executa la seg\u00fcent sent\u00e8ncia com s'ha fet al pas tercer. 1 System . out . println ( \"ob1 == ob3: \" + ob1 . equalTo ( ob3 )); 6. Sis\u00e8: Ara, com podem observar, el m\u00e8tode equalTo es crida en 'ob1', i 'obj' fa refer\u00e8ncia a 'ob3'. Com que els valors 'a' i 'b' no s\u00f3n els mateixos per a les dues refer\u00e8ncies, aleshores torna false. Activitat 415. Copia el codi Copia i executa el codi anterior en Processing IDE","title":"Pas d'objectes a funcions"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#recursivitat","text":"Definici\u00f3 En general, la recursivitat \u00e9s el proc\u00e9s de definir alguna cosa en termes de si mateix i \u00e9s una cosa semblant a una definici\u00f3 circular. El component clau d'un m\u00e8tode recursiu \u00e9s una declaraci\u00f3 que executa una crida a si mateix. La recursivitat \u00e9s un poder\u00f3s mecanisme de control. L'exemple cl\u00e0ssic de recursivitat \u00e9s el c\u00e0lcul del factorial d'un nombre. El factorial d'un nombre N \u00e9s el producte de tots els nombres enters que es troben entre 1 i N. Per exemple, el factorial de 3 \u00e9s 1 \u00d7 2 \u00d7 3, \u00e9s a dir, \u00e9s de 6. El seg\u00fcent programa mostra una forma recursiva de calcular el factorial d'un nombre. Per a prop\u00f2sits de comparaci\u00f3, tamb\u00e9 s'inclou un equivalent no recursiu (iteratiu). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 void setup () { size ( 640 , 480 ); } void draw () { println ( \"Factorial utilitzant un m\u00e8tode recursiu:\" ); println ( \"El factorial de 3 \u00e9s: \" + factorialRecursiu ( 3 )); println ( \"El factorial de 6 \u00e9s: \" + factorialRecursiu ( 6 )); println (); println ( \"Factorial utilitzant un m\u00e8tode iteratiu:\" ); println ( \"El factorial de 3 \u00e9s: \" + factorialIteratiu ( 3 )); println ( \"El factorial de 6 \u00e9s: \" + factorialIteratiu ( 6 )); println (); } int factorialRecursiu ( int n ) { int res ; if ( n == 1 ) return 1 ; res = factorial ( n - 1 ) * n ; return res ; } int factorialIteratiu ( int n ) { int t , res ; res = 1 ; for ( t = 1 ; t <= n ; t ++ ) res *= t ; return res ; } Eixida 1 2 3 4 5 6 7 Factorial utilitzant un m\u00e8tode recursiu : El factorial de 3 \u00e9s : 6 El factorial de 6 \u00e9s : 720 Factorial utilitzant un m\u00e8tode iteratiu : El factorial de 3 \u00e9s : 6 El factorial de 6 \u00e9s : 720 Stack Overflow Les versions recursives de moltes rutines poden executar-se una mica m\u00e9s lentament que els seus equivalents iteratius causa de la sobrec\u00e0rrega addicional de les trucades a m\u00e8todes addicionals. Massa crides recursives a un m\u00e8tode podrien causar un desbordament de la pila. Com l'emmagatzematge per als par\u00e0metres i les variables locals est\u00e0 a la pila i cada trucada nova crea una nova c\u00f2pia d'aquestes variables, \u00e9s possible que la pila s'acabe esgotant . Si aix\u00f2 passa, el sistema de temps d'execuci\u00f3 (run-time) de Java causar\u00e0 una excepci\u00f3 . No obstant aix\u00f2, probablement no haur\u00e0s de preocupar-te per aix\u00f2 a menys que una rutina recursiva es torne boja. El principal avantatge de la recursivitat \u00e9s que alguns tipus d'algoritmes es poden implementar de forma m\u00e9s clara i m\u00e9s recursiva del que poden ser iterativament. Per exemple, l'algorisme de classificaci\u00f3 Quicksort \u00e9s bastant dif\u00edcil d'implementar de manera iterativa. A m\u00e9s, alguns problemes, especialment els relacionats amb la IA, semblen prestar-se a solucions recursives. 1 2 3 4 5 6 7 8 int fact ( int n ) { // Condici\u00f3 de base equivocada (provoca Stack Overflow) if ( n == 100 ) return 1 ; else return n * fact ( n - 1 ); } En l'exemple anterior: Si es diu a fact (10), cridar\u00e0 a fact(9), fact(8), fact(7), etc., per\u00f2 el nombre mai arribar\u00e0 a 100. Per tant, no s'assoleix la condici\u00f3 base. Si la mem\u00f2ria s'esgota amb aquests m\u00e8todes en la pila, provocar\u00e0 un error de desbordament de pila .","title":"Recursivitat"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#la-api-de-java","text":"L'API Java \u00e9s una interf\u00edcie de programaci\u00f3 d'aplicacions (API, per les seves sigles de l'angl\u00e8s: Application Programming Interface) prove\u00efda pels creadors de el llenguatge de programaci\u00f3 Java, que d\u00f3na als programadors els mitjans per desenvolupar aplicacions Java. Com el llenguatge Java \u00e9s un llenguatge orientat a objectes, l'API de Java proveeix d'un conjunt de classes utilit\u00e0ries per a efectuar tota mena de tasques necess\u00e0ries dins d'un programa. L'API Java est\u00e0 organitzada en paquets l\u00f2gics, on cada paquet cont\u00e9 un conjunt de classes relacionades sem\u00e0nticament.","title":"La API de Java"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/","text":"Tema 5. Tipus Compostos de Dades Introducci\u00f3 Fins ara hav\u00edem treballat amb tipus de dades simples: int, char, double, float, bool... per\u00f2 que passa si necessitarem guardar un conjunt de dades o informaci\u00f3 relativa a una persona? Nom, cognoms, DNI, adre\u00e7a postal, data de naixement etc? Amb els tipus de dades simples ens seria impossible representar aquesta informaci\u00f3. Es per aix\u00f2 que s\u2019utilitzen els tipus de dades compostos que ens permetran agrupar de diverses maneres aquesta informaci\u00f3. Ens podem trobar diversos tipus de dades compostos i en aquest tema veurem: Cadenes de caracters: conjunt d'elements de tipus b\u00e0sic caracter. Arrays: tamb\u00e9 coneguts com vectors o arreglos , contenen elements d'un mateix tipus base o objectes de la mateixa classe. Estructures: conjunt d'elements heterogenis, no tenen per qu\u00e8 ser del mateix tipus base. Arrays Comencem per veure l'estructura m\u00e9s simple de totes, l'array. Un array \u00e9s un tipus de dades compost que permet emmagatzemar un nombre x d\u2019elements del mateix tipus . Amb una \u00fanica declaraci\u00f3 podem tenir acc\u00e9s a un conjunt de valors agrupats. Aquestes agrupacions o arrays poden b\u00e9 ser de tipus simples o tamb\u00e9 de tipus compostos. Per tal d\u2019accedir a cadascun dels elements del array s\u2019utilitza un \u00edndex o posici\u00f3. La primera posici\u00f3 de tot array \u00e9s la 0 mentre que la segona seria la que t\u00e9 \u00edndex 1. A\u00e7\u00f2 pot marejar un poc al principi. Array d\u2019enters: {8,2,14,55,3,7} Array de car\u00e0cters: {\u2018n\u2019,\u2019a\u2019,\u2019t\u2019,\u2019o\u2019} Array de cadenes: {\"hola\", \"ciao\", \"hi\", \"allo\"} \u00c9s molt important distingir entre valor i posici\u00f3. Mentre que el valor \u00e9s el contingut de l\u2019array en una posici\u00f3 determinada la posici\u00f3 \u00e9s l\u2019\u00edndex que ens permet recorres l\u2019array i tot el seu contingut. A l\u2019exemple anterior tenim un array de 8 enters, la part superior de color blau ens indica les posicions que van de la 0 a la 7, 8 posicions ens total. Mentre que a la fila inferior trobarem el valor que cont\u00e9 cadascuna de les posicions. Per exemple en la posici\u00f3 5 (la sisena) de l\u2019array tindr\u00edem emmagatzemat un valor de 8. Un altre concepte a tenir en compte \u00e9s la dimensi\u00f3 o grand\u00e0ria de l\u2019array que ens determina el total d\u2019elements que es poden guardar en aquest. En el nostre cas la mida seria de 8. Declaraci\u00f3 i creaci\u00f3 d'un array en Java Un array en Java \u00e9s una estructura de dades que ens permet emmagatzemar un conjunt de dades del mateix tipus. El grand\u00e0ria de l\u2019array es determina en la seua declaraci\u00f3 i no es permet la seua modificaci\u00f3 posterior 1 2 tipusBase nomArray [] ; nomArray = new tipusBase [ grand\u00e0ria ] ; Alguns exemples: 1 2 3 4 int mes [] ; // Declarem un array mes d'enters (sense espai) mes = new int [ 30 ] ; // Creem espai per a 30 elements a l'array mes char grups [] ; // Declarem un array de caracters (sense espai assignat) grups = new char [ 5 ] ; // Creem espai per a 5 elements Aquesta forma de declarar i inicialitzar arrays es pot fer en una sola l\u00ednia de la seg\u00fcent forma: 1 int agendaMensual = new int [ 30 ] ; // Declarem un array d'enters i reservem 30 posicions de mem\u00f2ria Inicialitzaci\u00f3 d'un array Per tal d\u2019accedir a les dades que cont\u00e9 un array necessitem l\u2019identificador d\u2019aquest aix\u00ed com tamb\u00e9 la posici\u00f3 concreta a la qual volem accedir. Per exemple, imaginem un array d\u2019enters que es diu n\u00fameros. 1 2 int n\u00fameros = new int [ 5 ] ; // Declarem un array d'enters de cinc posicions n\u00fameros . [] = { 2 , 4 , 6 , 8 , 10 }; // Inicialitzaci\u00f3 dels cinc valors D\u2019aquesta forma haur\u00edem creat un array de 5 enters que contindria els nombres parells fins al 10. Difer\u00e8ncia entre declaraci\u00f3 creaci\u00f3 i inicialitzaci\u00f3 \u00c9s molt important que coneixeu b\u00e9 aquestos conceptes: Declaraci\u00f3: assignaci\u00f3 de nom i tipus. Creaci\u00f3: reserva d'espai necessari. Inicialitzaci\u00f3: assignaci\u00f3 de valors. Fins ara tots aquestos conceptes anaven lligats quan nom\u00e9s utilitzavem tipus de dades b\u00e0sics, per exemple, quan creavem en un programa nostre una variable de tipus enter, en la mateixa l\u00ednia anava la declaraci\u00f3 (donem nom a la variable), la creaci\u00f3 (automaticament es reserva l'espai necessari per al tipus de dades que hem creat) i la inicialitzaci\u00f3 (ja que per defecte i segons el tipus b\u00e0sic s'assignava un valor inicial). Per\u00f2 ara amb els arrays la cosa \u00e9s un poc m\u00e9s complexa. Vegem algun exemple. 1 2 3 int a ; int [] array ; array = new int [ 10 ] ; Repassem el codi anterior. A la l\u00ednia 1 de codi i nom\u00e9s amb aquesta l\u00ednia hem aconseguit: Declaraci\u00f3: es declara una variable amb identificador 'a' i de tipus enter Creaci\u00f3: automaticament el compilador li reserva l'espai necessari per a representar un enter: 4 bytes. Inicialitzaci\u00f3: per defecte se li dona valor 0. Ara si mirem les l\u00ednies seg\u00fcents podrem observar que: A la l\u00ednia 2 del codi es produeix la declaraci\u00f3 de l'array . Hem creat l'array i li hem assignat identificador per\u00f2, quants elements pot emmagatzemar? A la l\u00ednia 3 del codi \u00e9s on es crea l'array , \u00e9s a dir, es reserva espai en mem\u00f2ria. Al nostre cas 10 enters, \u00e9s a dir, 40 bytes. En aquest cas com que el tipus base de l'array \u00e9s enter, la inicialitzaci\u00f3 d'aquest vindria implicita en la reserva de mem\u00f2ria assignant-se valor 0 a tots els elements. Per\u00f2 com poden inicialitzar cadascun dels elements del nostre array de forma manual? Acc\u00e9s als elements d'un array Una vegada ja tenim la declaraci\u00f3 de l\u2019array i la seua inicialitzaci\u00f3, si volem b\u00e9 accedir al seu contingut o modificar-ho, necessitar\u00edem l\u2019identificador de l\u2019array i l\u2019\u00edndex al qual volem accedir. \u00c9s molt important tenir en compte que el primer element d\u2019un array en Java est\u00e0 a la posici\u00f3 (\u00edndex) 0 i no a la posici\u00f3 1 com ens indicaria la l\u00f2gica. 1 2 int primerNumero = n\u00fameros . [ 0 ] ; // primerNumero valdria 2 n\u00fameros . [ 0 ] = 12 ; // Canviem el primer numero de l\u2019array Activitat 501. Declara, crea i inicialitza Problema Soluci\u00f3 Escriu un programa en Java utilitzant Processing IDE que permeta emmagatzemar en un array 30 enters. Aquest array s'inicialitzar\u00e0 element a element cridant a una funci\u00f3 que es dir\u00e0 'generaNumAleatori' i que tornara un enter random entre 0 i 100. La funci\u00f3 tindr\u00e0 el seg\u00fcent prototip: int generaNumAleatori(); Encara no disponible Arrays de caracters Un array que cont\u00e9 car\u00e0cters en lloc de n\u00fameros funciona d\u2019una forma molt semblant al que s\u2019ha explicat en els apartats anteriors. Es pot veure de forma senzilla a l\u2019exemple que vos mostrem a continuaci\u00f3. 1 2 3 4 5 6 7 8 // Declaraci\u00f3 de l\u2019array vocals que contindr\u00e0 un total de 5 posicions en mem\u00f2ria char vocals = new char [ 5 ] ; // Inicialitzaci\u00f3 de l'array amb les vocals de l'alfabet. vocals [] = { \u2018 a \u2019 , \u2019 e \u2019 , \u2019 i \u2019 , \u2019 o \u2019 , \u2019 u \u2019 } // Acc\u00e9s a l'element primer (0) de l'array per modificar el seu valor vocals [ 0 ] = \u2018 z \u2019 ; Activitat 502. Array de caracters Problema Soluci\u00f3 Millora el codi anterior. Afegeix un array que puga emmagatzemar 10 caracters i inicialitza-lo amb un altre m\u00e8tode que es dir\u00e0: 'generaCharAleatori()'. El prototip del m\u00e8tode hauria de ser: char generaCharAleatori(); Encara no disponible Arrays com a par\u00e0metres Com qualsevol altre tipus de dades, un array tamb\u00e9 es pot passar com a par\u00e0metre a un m\u00e8tode. Els arrays sempre es passen per refer\u00e8ncia , \u00e9s a dir, quan passem un array per par\u00e0metre a un m\u00e8tode, el que en realitat estem passant \u00e9s un adre\u00e7a de mem\u00f2ria que \u00e9s la que ens indicaria on est\u00e0 l\u2019inici del contingut d\u2019aquest. Passar per refer\u00e8ncia qualsevol par\u00e0metre significa que qualsevol modificaci\u00f3 que es faja dins del m\u00e8tode afectar\u00e0 tamb\u00e9 a l\u2019array fora d\u2019aquest. No passa el mateix si passem un element concret de l\u2019array, en aquest cas a l\u2019igual que amb els altres par\u00e0metres, aquestos es passen per valor, per tant les modificacions o canvis que es produeixen dins del m\u00e8tode no afectaran fora d\u2019aquest. Activitat 503. Mostra array amigablement Problema Soluci\u00f3 Seguint amb el codi anterior, fes dos m\u00e8todes per la nostra aplicaci\u00f3 que mostre, de forma amigable, l\u2019array de n\u00fameros i l\u2019array de car\u00e0cters. Els m\u00e8todes es podrien dir mostraEnters i mostraCaracters. Utilitza totes les funcions que conegues de Processing IDE per tal que mostre els arrays de la forma m\u00e9s est\u00e8tica possible. 1 2 3 4 5 6 7 void mostraEnters ( int [] array ) { // Codi per mostrar el vector d'enters } void mostraCaracters ( char [] array ) { // Codi per mostrar el vector de caracters } Encara no disponible Bucle for en Java A les activitats anteriors t'haur\u00e0s trobat amb el dilema de com rec\u00f3rrer tant l'array d'enters com el de caracters per tal d'inicialitzar-lo. Si vares entendre b\u00e9 el teorema d'estructura i les estructures iteratives , segurament haur\u00e0s utilitzat un bucle while, un do while o un for. Per\u00f2 aquestos bucles a l'hora de rec\u00f3rrer arrays tenen un inconvenient: el grand\u00e0ria de l'array . El programador ha de controlar quan s'arriba al final de l'array per tal que l'aplicaci\u00f3 no done una errada inesperada i aix\u00f2 de vegades no \u00e9s senzill. Mira el seg\u00fcent exemple: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 final int TAM = 30 ; int [] arrayEnters ; arrayEnters = new int [ TAM ] ; // Recorrem l'array amb un for for ( int i = 0 ; i < TAM ; i ++ ) arrayEnters [ i ] = i * 10 ; // Recorrem l'array amb un while int i = 0 ; while ( i < TAM ) arrayEnters [ i ] = i * 10 ; // Recorrem l'array amb un do while int i = 0 ; do { arrayEnters [ i ] = i * 10 ; i ++ ; } while ( i < TAM ); Activitat 504. Fes una tra\u00e7a Problema Soluci\u00f3 Fes una tra\u00e7a al codi anterior i digues-me que passa. Falla o podria fallar algun bucle? Per qu\u00e8? Es podria arreglar? Encara no disponible La millor forma de rec\u00f3rrer un array sense haver de controlar quan s\u2019arriba al final \u00e9s la sent\u00e8ncia for usada d\u2019una manera alternativa. Si per exemple tenim un array d\u2019enters que s\u2019anomena \u00abvector\u00bb i volem llistar tots els seus elements, podr\u00edem fer el seg\u00fcent: 1 2 3 for ( int i : vector ){ // Accions a realitzar } Activitat 505. Recorre i mostra l'array Problema Soluci\u00f3 Seguint amb les activitats 502 i 503, modifica els m\u00e8todes mostraEnters i mostraCaracters per tal que utilitzen aquest \u00faltim bucle que hem vist per recorrer arrays en Java. Podriem fer el mateix als m\u00e8todes d'inicialitzaci\u00f3 dels arrays? Per qu\u00e8? Encara no disponible Algorismes de recerca Implicitament amb l'aparici\u00f3 de les estructures de dades complexes en programaci\u00f3 que, en certa manera, es podrien entendre com a conjunts , apareix la necessitat de poder fer recerques elements dintre d'aquestos conjunts. Existeixen dos algorismes de recerca que veurem en aquest apartat: la recerca seq\u00fcencial i la recerca binaria . A l\u2019element que estem buscant li direm clau . Per\u00f2 abans d'anar per feina, canviarem temporalment l'entorn de programaci\u00f3 de Processing IDE a Eclipse IDE i veurem un poc m\u00e9s que s\u00f3n les classes i els objectes i com funcionen en Java abans de veure-ho amb m\u00e9s detall al tema seg\u00fcent. Realitza les activitats seg\u00fcents abans de continuar. Activitat 506. Crea el projecte base Problema Soluci\u00f3 Aquesta primera activitat en Processing IDE \u00e9s senzilla, nom\u00e9s haur\u00e0s de crear un nou projecte en Java i copiar el codi seg\u00fcent per\u00f2 primer, veiem amb m\u00e9s detall qu\u00e9 \u00e9s el que es preten aconseguir. Volem crear un projecte que tinga les seg\u00fcents caracter\u00edstiques: Ha de tindre m\u00ednim una constant que ens indicar\u00e0 el total d\u2019elements que tindran els arrays, tant el d\u2019enters com el de car\u00e0cters. Com a global ha de tindre almenys un array de car\u00e0cters i un d\u2019enters. Tamb\u00e9 ha de tenir un m\u00e8tode setup i un draw que inicialitzen i executen l'aplicaci\u00f3. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 /** * Projecte Tipus Compostos * Projecte escrit en Processing IDE en el que tractarem els tipus compostos de dades en Java. * A aquest projecte se li aniran afegint funcionalitats conforme avancem en els continguts del Tema 5 * @author Vicent Sanchis * @since 10/11/23 * @version 1.0 */ // CONSTANTS static final int TAM = 10 ; // Variables Globals int [] arrayEnters ; char [] arrayCaracters ; /** * M\u00e8tode setup: s'executa a l'inici nom\u00e9s una vegada * sol utilitzar-se per inicialitzar les aplicacions * @return void */ void setup () { } /** * M\u00e8tode draw: o bucle del joc s'executa unes 60 vegades per segon aproximadament. * @return void */ void draw () { } void mostraEnters () { } void mostraCaracters () { } int generaNumAleatori () { return 0 ; } char generaCharAleatori () { return 0 ; } Encara no disponible En aquesta primera activitat haureu de copiar aquest codi en un nou projecte java de Processing IDE i si et fixes, aquest projecte disposa dels m\u00e8todes: mostraEnters, mostraCaracters, generaNumAleatori i generaCharAleatori que ja havieu implementat a les activitats anteriors. Aprofita i reutilitza el codi que ja havies escrit en activitats anteriors. Activitat 507. Inicialitzaci\u00f3 d'arrays Problema Soluci\u00f3 En aquest punt aprofitarem per crear un m\u00e8tode inicialitzador al nostre projecte. Com que volem que s\u2019execute en el moment que s\u2019inicia l'aplicaci\u00f3, aquest m\u00e8tode es cridar\u00e0 des del m\u00e8tode setup i \u00e9s ac\u00ed on inicialitzar\u00e0 els nostres arrays: el d'enters i el de caracters. C\u00f2pia el seg\u00fcent codi i posa'l al teu projecte. 1 2 3 4 void inicialitzaVectors () { arrayEnters = new int [ TAM ] ; arrayCaracters = new char [ TAM ] ; } Encara no disponible Afegeix i implementa els m\u00e8todes emplenaArrayNumeros() i emplenaArrayCaracters() per tal que es criden des del setup i utilitzen els m\u00e8todes generaNumAleatori() i generaCharAleatori(). Finalment i per tal de comprovar que anem b\u00e9 de moment, implementa els m\u00e8todes mostraEnters() i mostraCaracters() i crida'ls al m\u00e8tode draw i executa l'aplicaci\u00f3. Depura el codi anterior i comprova que tot est\u00e0 funcionant com s'espera que funcione. Activitat 508. Ampliaci\u00f3 de funcions Problema Soluci\u00f3 En la seg\u00fcent activitat afegirem una funci\u00f3 a la nostra classe en la que ens mostre un men\u00fa de les accions que podem realitzar. Per tal de realitzar aquest men\u00fa afegirem un array d\u2019strings com a nou membre de la classe que inicialitzarem amb les seg\u00fcents opcions: Eixir Mostrar array enters Mostrar array caracters Reinicialitzar vectors Recerca seq\u00fcencial Recerca bin\u00e0ria Ordenar amb bombolla Ordenar amb Quicksort Ordenar amb Shell Encara no disponible Activitat 509. Mostrar men\u00fa Problema Soluci\u00f3 Fes una funci\u00f3 que mostre per pantalla el men\u00fa de forma amigable. El men\u00fa s'haur\u00e0 de mostrar a la pantalla de l'aplicaci\u00f3, amb text(), i no pel terminal. Al mateix temps haur\u00e0s d'implementar un m\u00e8tode que capture el teclat per tal que execute alguna de les opcions que es mostraran al men\u00fa. Tin en compte que l'aplicaci\u00f3 que estem dissenyant nom\u00e9s haur\u00e0 de fer alguna acci\u00f3 si es premen els n\u00fameros del 1 al 9. Encara no disponible Seq\u00fcencial Tamb\u00e9 anomenada recerca lineal , es recorren tots els elements de l\u2019array des del principi fins que es troba la clau (element que estem buscant) o fins que s\u2019arriba a l\u2019\u00faltim element de l\u2019array. 1 2 3 4 5 6 int sequencial ( int [] array , int clau ) { for ( int i = 0 ; i < array . length ; i ++ ) if ( array [ i ] == clau ) return i ; return - 1 ; } Bin\u00e0ria En aquest algoritme existeix la precondici\u00f3 que l\u2019array o vector sobre el qual vaja a fer-se la recerca, ha d\u2019estar ordenat. Aquest m\u00e8tode \u00e9s m\u00e9s \u00f2ptim. El funcionament d\u2019aquest algorisme \u00e9s el seg\u00fcent: en una primera iteraci\u00f3 es compara la clau (element que estem buscant) amb el valor al centre, que s\u2019anomena pivot, de l\u2019array. Poden passar tres coses: - Que hajam trobat el que busquem, per tant s\u2019acaba la recerca - Que el pivot siga major que la clau. En aquest cas continuar\u00edem buscant a la meitat esquerra del vector desestimant la meitat dreta (pivot incl\u00f2s) - Que el pivot siga menor que la clau. Amb la qual cosa haur\u00edem de buscar a la part esquerra del vector. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int recercaBinaria ( int array [] , int clau ) { int posCentre , posInici , posFinal , valorCentral ; posInici = 0 ; posFinal = array . length \u2013 1 ; while ( posInici <= posFinal ) { posCentre = ( posInici + posFinal ) / 2 ; valorCentral = array [ posCentre ] ; if ( clau == valorCentral ) { return posCentre ; } else if ( clau < valorCentral ) { posFinal = posCentro \u2013 1 ; } else { posInici = posCentro + 1 ; } } } Activitat 510. Afegeix m\u00e8todes seq\u00fcencial i binari Problema Soluci\u00f3 Afegeix el m\u00e8tode de recerca seq\u00fcencial i el de recerca binaria al projecte. Tamb\u00e9 has d\u2019implementar el codi necessari per tal que quan l\u2019usuari seleccione una de les dues opcions de la nostra aplicaci\u00f3, demane el n\u00famero a buscar i mostre el resultat per pantalla. En cas que es seleccione la recerca bin\u00e0ria, haur\u00edem de comprovar si el vector est\u00e0 ordenat. Encara no disponible Activitat 511. Compara efici\u00e8ncies Problema Soluci\u00f3 Comparem l\u2019efici\u00e8ncia dels dos algorismes de recerca vistos. Fes una funci\u00f3 al teu projecte en la que es compten el total de vegades que s\u2019accedeix l\u2019array de n\u00fameros per arribar a trobar la clau. Haur\u00e0s de posar una opci\u00f3 m\u00e9s al men\u00fa, per exemple: \u00abComparar efici\u00e8ncia dels algoritmes\u00bb. Aquesta nova opci\u00f3 haur\u00e0 d\u2019executar varies vegades els dos algorismes de recerca amb vectors de n\u00fameros diferents. Encara no disponible Algorismes d'ordenaci\u00f3 Els algorismes d\u2019ordenaci\u00f3 permeten ordenar un array en funci\u00f3 d\u2019un criteri establert al propi algorisme. Hi han diferents tipus d\u2019algorismes d\u2019ordenaci\u00f3: selecci\u00f3, inserci\u00f3, bombolla, Shell i Quicksort. Selecci\u00f3 El procediment d\u2019ordenaci\u00f3 per selecci\u00f3 \u00e9s el seg\u00fcent: 1. Busquem l\u2019element m\u00e9s menut de l\u2019array i el col\u00b7loquem a la posici\u00f3 0 intercanviant els dos elements 2. A partir de la posici\u00f3 1 busquem l\u2019element m\u00e9s menut seg\u00fcent i fem el mateix que al pas anterior per\u00f2 aquesta vegada a la posici\u00f3 1 de l\u2019array 3. Repetim el pas 2 fins arribar a l\u2019\u00faltima posici\u00f3 de l\u2019array. 1 2 3 4 5 6 7 8 9 10 11 for ( int i = 0 ; i < TAM - 1 ; i ++ ){ int posMinim = i ; for ( int j = i + 1 ; j < TAM ; j ++ ){ if ( array [ j ] < array [ posMinim ] ){ posMinim = j ; } } int aux = array [ i ] ; array [ i ] = array [ posMinim ] ; array [ posMinim ] = aux ; } Activitat 512. Algorisme d'ordenaci\u00f3 per selecci\u00f3 Problema Soluci\u00f3 Implementa l\u2019algorisme d\u2019ordenaci\u00f3 per selecci\u00f3 al projecte i vicula-la a l\u2019opci\u00f3 del men\u00fa corresponent. Encara no disponible Inserci\u00f3 Aquest algorisme consisteix en generar un nou array a partir del que ja es t\u00e9, tal que cada nou element inserit es posa a la seua posici\u00f3 correcta. Imaginem que tenim el seg\u00fcent array d\u2019enters per ordenar: {12, 5, 3, 13, 2, 9, 7} Generem un nou array amb el primer element de l\u2019array a ordenar { 12 } El seg\u00fcent valor de l\u2019array original \u00e9s 5. \u00c9s major o menor que el que ja est\u00e0 inserit? Com que la resposta \u00e9s menor, aquest s\u2019haur\u00e0 d\u2019inserir abans quedant de la seg\u00fcent forma: { 5 , 12} El nou array es genera ja ordenat. El seg\u00fcent valor de l\u2019array desordenat \u00e9s 3. On l\u2019haurem de col\u00b7locar? Just abans del 5 quedant aix\u00ed: { 3 , 5, 12} Repetim la mateixa operaci\u00f3 per cada element de l\u2019array original: {3, 5, 12, 13 } { 2 , 3, 5, 12, 13} {2, 3, 5, 9 , 12, 13} {2, 3, 5, 7 , 9, 12, 13} 1 2 3 4 5 6 7 8 9 10 11 12 void insercio ( int [] array ) { int i , j , aux ; for ( i = 1 ; i < array . legnth ; i ++ ) { j = i ; aux = array [ i ] ; while ( j > 0 && aux < array [ j - 1 ] ) { array [ j ] = array [ j - 1 ] ; j -- ; } array [ j ] = aux ; } } Activitat 513. Algorisme ordenaci\u00f3 per inserci\u00f3 Problema Soluci\u00f3 Implementa l\u2019algorisme d\u2019ordenaci\u00f3 per inserci\u00f3 al projecte i vincula-la a l\u2019opci\u00f3 del men\u00fa corresponent. Encara no disponible Bombolla L\u2019algorisme d\u2019ordenaci\u00f3 per bombolla \u00e9s el m\u00e9s conegut i tamb\u00e9 el menys eficient, ja que a cada passada per ordenar un element compara cadascun d\u2019ells amb el seu adjacent de forma que si les seues posicions s\u00f3n incorrectes, s\u2019intercanvien. Al finalitzar cada passada l\u2019element m\u00e9s gran es va posant al final de la llista Donat el seg\u00fcent array: {12, 5, 3, 13, 2, 9, 7} Pas 1. Comparem les posicions 0 i 1, \u00e9s a dir, 12 i 5 i com que estan desordenats (el primer \u00e9s major que el segon), s\u2019intercanvien. { 5 , 12 , 3, 13, 2, 9, 7} Pas 2. A continuaci\u00f3 comparem les posicions 1 i 2 de l\u2019array, que s\u00f3n 12 i 3. Com que tamb\u00e9 estan desordenades, les intercanviem {5, 3 , 12 , 13, 2, 9, 7} Pas 3. Ara anem a comparar les posicions 2 i 3 que contenen els valors 12 i 13 respectivament. Com que estan ben ordenades no es realitza cap acci\u00f3: Pas 4. Posicions 3 i 4 que s\u00f3n 13 i 2. Les intercanviem. {5, 3, 12 , 2, 13 , 9, 7} Pas 5. Posicions 4 i 5 que tamb\u00e9 estan desordenades per tant executem l\u2019intercanviem {5, 3, 12, 2, 9 , 13 , 7} Pas 6. Comparem posicions 5 i 6 que tenen els valors 13 i 7 i s\u2019han d\u2019intercanviar {5, 3, 13, 2, 9, 7 , 13 } Una vegada finalitzada la primera passada hem aconseguit que l\u2019element major de l\u2019array estiga posicionat a l\u2019\u00faltima posici\u00f3. A la seg\u00fcent passada recorrerem l\u2019array fins la posici\u00f3 anterior a on es troba ara el n\u00famero 13, \u00e9s a dir la posici\u00f3 5 i aquest procediment es repeteix fins arribar a la posici\u00f3 0 Finalment el codi quedaria aix\u00ed: 1 2 3 4 5 6 7 8 9 10 11 void bombolla ( int [] arrayNumeros ) { for ( int i = 0 ; i < arrayNumeros . length - 1 ; i ++ ) { for ( int j = i + 1 ; j < arrayNumeros . length ; j ++ ) { if ( arrayNumeros [ i ] > arrayNumeros [ j ] ) { int canvi = arrayNumeros [ i ] ; arrayNumeros [ i ] = arrayNumeros [ j ] ; arrayNumeros [ j ] = canvi ; } } } } Activitat 515. Ordenaci\u00f3 per bombolla Problema Soluci\u00f3 Implementa l\u2019algorisme d\u2019ordenaci\u00f3 per bombolla al projecte i vincula-la a l\u2019opci\u00f3 del men\u00fa corresponent. Encara no disponible Shell L\u2019algorisme Shell \u00e9s una millora de l\u2019algorisme d\u2019inserci\u00f3 directa. Compara elements separats per un espai de v\u00e0ries posicions el que permet que un element faja passos m\u00e9s grans fins trobar la seua posici\u00f3 esperada. Els passos m\u00faltiples sobre els elements de l\u2019array es fan amb espais de posicions cada vegada m\u00e9s menuts. L\u2019\u00faltim pas de l\u2019algorisme Shell \u00e9s una simple ordenaci\u00f3 per inserci\u00f3 per\u00f2 arribats a aquest punt es pot garantir que l\u2019array esta ja quasi ordenat, el que fa que l\u2019ordenaci\u00f3 per inserci\u00f3 siga molt eficient. Vegem com actuaria aquest algorisme aplicat sobre l\u2019array que estem utilitzant com exemple: {12, 5, 3, 13, 2, 9, 7}. Aquest array t\u00e9 un total de 7 elements (n=7). Creem n/2 grups, separats n/2 n\u00fameros entre ells. n/2=7/2=3, \u00e9s a dir, el nostre interval per crear grups val 3 Marquem en negreta els valors de la primera subllista. {12, 5, 3, 13, 2, 9, 7} Donats els elements 12, 13 i 7 els hem d\u2019ordenar correctament {7, 5, 3, 12, 2, 9, 13} Continuem formant grups de 3 a partir del segon valor de l\u2019array {7, 5, 3, 12, 2, 9, 13} Ordenem els n\u00fameros en cas de no estar-ho, quedant l\u2019array aix\u00ed: {7, 2, 3, 12, 5, 9, 13} Passem a l\u2019element 3 de l\u2019array i apliquem el mateix procediment. {7, 2, 3, 12, 5, 9, 13} Els valors ja estan ordenats en aquest cas, per tant no hem de fer res. {7, 2, 3, 12, 5, 9, 13} No podem m\u00e9s grups ja que hem arribat al final del vector. Ara el que hem de fer \u00e9s tornar a dividir el nostre interval entre 2. El nou interval \u00e9s 3/2 = 1. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void shellSort ( int [] array ) { int interval , i , j , k , temp ; interval = array . length / 2 ; while ( interval > 0 ) { for ( i = interval ; i < n ; i ++ ) { j = i - interval ; while ( j >= 0 ) { k = j + interval ; if ( array [ j ] <= array [ k ] j = - 1 ; else { temp = array [ j ] ; array [ j ] = array [ k ] ; array [ k ] = temp ; j -= interval ; } } } interval = interval / 2 ; } } Activitat 516. Ordenaci\u00f3 per Shell Problema Soluci\u00f3 Implementa l\u2019algorisme d\u2019ordenaci\u00f3 shell al projecte i vincula-la a l\u2019opci\u00f3 del men\u00fa corresponent. Encara no disponible Quicksort Aquest \u00e9s un dels algorismes d\u2019ordenaci\u00f3 m\u00e9s r\u00e0pids i eficients. Utilitza la t\u00e8cnica \u00abdivideix i vencer\u00e0s\u00bb de tal forma que divideix l\u2019array a ordenar en parts que ordenar\u00e0 al mateix temps. B\u00e0sicament es tria l\u2019element de l\u2019array com a pivot tal que es forme dos subArrays, en un d\u2019ells s\u2019emmagatzemen els elements menors que l\u2019element que hem triat com a pivot i a l\u2019altre array es guarden els element majors que el pivot. Una vegada fet, s\u2019aplica el mateix procediment als subarrays obtinguts. Seguint amb el mateix array dels exemples anteriors, aplicarem l\u2019algorisme d\u2019ordenaci\u00f3 quicksort. {12, 5, 3, 13, 2, 9, 7} Triem un valor que fara el paper de pivot, per exemple el primer element de l\u2019array, el 12 i a partir d\u2019aquest creem dos arrays, un amb els n\u00fameros menors que el pivot i l\u2019altre amb els n\u00fameros majors que el pivot: pivot: {12}; menors: {5, 3, 2, 9, 7}; majors {13} El subarray de majors ja est\u00e0 ordenada ja que nom\u00e9s t\u00e9 un n\u00famero. Ara ordenem el subarray de menors: {5, 3, 2, 9, 7} per la qual cosa escollim com a pivot el primer element de l\u2019array, \u00e9s a dir, el 5. pivot: {5}; menors {3, 2}; majors: {9, 7}. Seguim dividint en subarrays, Una vegada els subarrays estan ordenats sempre sempre s\u2019assemblaran col\u00b7locant subarrays de menors, seguides de pivot i subarrays de majors {2, 3, 5, 7, 9, 12, 13} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void Quicksort ( int [] array , int primer , int ultim ) { int i , j , central , pivot , tmp ; central = ( primer + ultim ) / 2 ; pivot = array [ central ] ; i = primer ; j = ultim ; do { while ( array [ i ] < pivot ) i ++ ; while ( array [ j ] > pivot ) j -- ; if ( i <= j ) { tmp = array [ i ] ; array [ i ] = array [ j ] ; array [ j ] = tmp ; i ++ ; j \u2013 - ; } } while ( i <= j ); if ( primer < j ) Quicksort ( array , primer , j ); if ( i < ultim ) Quicksort ( array , i , ultim ); } Activitat 517. Algorisme Quicksort Problema Soluci\u00f3 Implementa l\u2019algorisme d\u2019ordenaci\u00f3 quicksort al projecte i vincula-la a l\u2019opci\u00f3 del men\u00fa corresponent. Encara no disponible Activitat 518. Mostrar tra\u00e7a algorismes ordenaci\u00f3 Problema Soluci\u00f3 Fes que en cada algorisme d\u2019ordenaci\u00f3 es mostre una tra\u00e7a on a cada passada de l\u2019algoritme, \u00e9s a dir, cada vegada que mou un element a l\u2019array, mostre aquest per pantalla. Encara no disponible Activitat 519. Entrega del projecte Problema Soluci\u00f3 Entrega mitjan\u00e7ant la plataforma aules el projecte final que inclou de les activitats 506 a 518 amb totes les funcions tant de recerca com d\u2019ordenaci\u00f3 sobre arrays unidimensionals. Encara no disponible Arrays multidimensionals Fins ara hem estan utilitzant arrays d\u2019una sola dimensi\u00f3, coneguts tamb\u00e9 com vectors, taules o llistes. Aquests arrays es recorren amb ajuda d\u2019un sol \u00edndex (tenen una sola dimensi\u00f3). En aquest apartat estudiarem arrays de m\u00e9s d\u2019una dimensi\u00f3 per als que necessitarem m\u00e9s d\u2019un \u00edndex a l\u2019hora de ser recorreguts. Els arrays multidimensionals m\u00e9s comuns s\u00f3n els de dues dimensions o bidimensionals, tamb\u00e9 coneguts com matrius. \u00c9s com\u00fa representar aquest tipus de dades com una taula composta per una s\u00e8rie de files i columnes: 0,0 0,1 0,2 0,3 ... 0,N 1,0 1,1 1,2 1,3 ... 1,N 2,0 2,1 2,2 2,3 ... 2,N ... ... ... ... ... ... N,0 N,1 N,2 N,3 ... N,N Al contrari del que passava amb els arrays d\u2019una sola dimensi\u00f3 on nom\u00e9s necessitavem un \u00edndex per accedir al valor, en els arrays de dues dimensions com el de l\u2019exemple anterior, necessitarem dos \u00edndex per accedir al valor de l\u2019array. Les matrius, com es coneixen els arrays bidimensionals es forme per files i columnes. Declaraci\u00f3 i creaci\u00f3 Per tal de declarar una matriu en java, \u00e9s a dir, un array de dues dimensions, ho farem de la seg\u00fcent forma:\u00c7 1 tipusBase matriu [][] ; Si es fixeu, mentre quan declaravem un array d\u2019una sola dimensi\u00f3 utilitzavem nom\u00e9s un parell de claud\u00e0tors: 1 tipusBase array [] ; Ara que volem crear una matriu (array de dues dimensions) utilitzarem dos parells de claud\u00e0tors. \u00c9s f\u00e0cil deduir que si volguerem declarar un array de tres dimensions, hauriem d\u2019utilitzar tres parells de claud\u00e0tors. Amb aquesta instrucci\u00f3 el que estem fent es declarar la matriu per\u00f2 no li hem dit quina grand\u00e0ria tindr\u00e0. Eixa \u00e9s la difer\u00e8ncia entre declaraci\u00f3 i creaci\u00f3. Per tal de crear, \u00e9s a dir, reservar espai per a la nostra matriu, hem de fer el seg\u00fcent: 1 matriu = new tipusBase [ n ][ m ] ; On n i m s\u00f3n valors enters que ens indiquen la grand\u00e0ria de cada dimensi\u00f3. Per exemple, per declarar i crear una matriu d\u2019enters de 5 files i 10 columnes fariem el seg\u00fcent: 1 2 3 4 int matriuEnters [][] ; matriuEnters = new int [ 5 ][ 10 ] ; // Tamb\u00e9 ho podriem fer en una sola instrucci\u00f3 int matriuEnters [][] = new int [ 5 ][ 10 ] ; Inicialitzaci\u00f3 i acc\u00e9s El proc\u00e9s d\u2019inicialitzaci\u00f3 d\u2019un vector, dona igual les dimensions que tinga, consisteix en donar-li valor a les cel\u00b7les que inicialment estan buides. Aquesta inicialitzaci\u00f3 es pot fer de tres formes diferents: De forma individual. En el moment de la declaraci\u00f3. Mitjan\u00e7ant l\u2019\u00fas d\u2019una sent\u00e8ncia de control repetitiva. Inicialitzaci\u00f3 i acc\u00e9s a cada element de l'array Per accedir a una dada en un array multidimensional hem de coneixer els \u00edndex de posici\u00f3 d\u2019aquest. En un array de dues dimensions, per accedir a una dada s\u2019ha d\u2019indicar la fila i la columna d\u2019on es troba aquesta informaci\u00f3. Per exemple, imaginem que tenim la seg\u00fcent taula (array de dos dimensions) 12 13 5 9 22 14 21 11 8 56 23 7 6 10 32 36 24 99 78 55 57 79 18 14 Per tal d\u2019inicialitzar-la element a element hauriem d\u2019executar les seg\u00fcents sent\u00e8ncies: 1 2 3 4 5 for ( int i = 0 ; i < FILES ; i ) { for ( int j = 0 ; j < COLUMNES ; j ++ ) { array [ i ][ j ] = 0 ; } } Per tal d\u2019entendre el concepte de matriu o array bidimensional, realitzarem un exercici on treballarem amb les t\u00edpiques matrius matem\u00e0tiques, realitzant les operacions pr\u00f2pies d\u2019aquestes. Activitat 520. Matrius Problema Soluci\u00f3 Es tracta de desenvolupar una aplicaci\u00f3 que realitze operacions utilitzant matrius de 3x3. El men\u00fa ha de mostrar el seg\u00fcent: Emplena la primera matriu Emplena la segona matriu Visualitza les matrius4 Suma les matrius Multiplica per un escalar Producte de matrius Transposta Eixir Per a cadascuna de les operacions anteriors s\u2019ha d\u2019implementar un m\u00e8tode Mireu el seg\u00fcent exemple: Encara no disponible Arrays irregulars Una matriu irregular o escalonada no \u00e9s m\u00e9s que un array de taules, on cadascuna de les taules que formen l\u2019array no necess\u00e0riament han de tenir la mateixa grand\u00e0ria. La declaraci\u00f3 d\u2019un array irregular en java seria de la seg\u00fcent manera: 1 2 3 4 5 6 7 8 9 10 // Declaraci\u00f3 d\u2019una matriu (files) int [][] mat ; // Primer creem la quantitat de files deixant les columnes buit mat = new int [ 3 ][] ; // Despr\u00e9s creem cada fila indicant la quantitat d\u2019elements mat [ 0 ]= new int [ 5 ] ; mat [ 1 ]= new int [ 3 ] ; mat [ 2 ]= new int [ 2 ] ; Activitat 521. Alumnes i assignatures Problema Soluci\u00f3 Imagina que has de mantindre les notes dels alumnes de tres assignatures. A cada assignatura tens 15 alumnes, tal que s\u2019ha de mantenir la informaci\u00f3 mitjan\u00e7ant una variable que gr\u00e0ficament presenta la seg\u00fcent estructura Assignatura 1 5 6 7,3 2,3 4,5 Assignatura 2 7,8 8,7 7,7 3,3 4,8 Assignatura 3 7 9 10 8,2 2,8 Crea una aplicaci\u00f3 en la que pugues: Inserir notes de l\u2019assignatura sel\u00b7leccionada. Inserir totes les notes Calcular la nota mitjana de l\u2019assignatura sel\u00b7leccionada. Ordenar les assignatures de forma ascendent. Estad\u00edstica Eixir de l\u2019aplicaci\u00f3. L\u2019opci\u00f3 estad\u00edstica mostra la quantitat de notes entre 0 i 3, entre 3,1 i 5, entre 5,1 i 7, entre 7.1 i 9 i entre 9,1 i 10. Encara no disponible Un sudoku simple Llig l'enunciat de la seg\u00fcent activitat i fes un sudoku simple. Activitat 522. Un sudoku simple Problema Soluci\u00f3 El seg\u00fcent codi \u00e9s un m\u00e8tode que s'encarrega d'emplenar una matriu de 9x9 seguint la l\u00f2gica del sudoku 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 void inicialitzaArraySudoku ( int [][] arraySudoku ) { // Primera fase: inicialitzem la matriu for ( int fil = 0 ; fil < 9 ; fil ++ ) { for ( int col = 0 ; col < 9 ; col ++ ) { if ( fil == 0 || fil == 3 || fil == 6 ) arraySudoku [ fil ][ col ] = ( col + fil / 3 ) % 9 + 1 ; else if (( fil > 0 && fil < 3 ) || ( fil > 3 && fil < 6 ) || ( fil > 6 && fil < 9 )) arraySudoku [ fil ][ col ] = ( arraySudoku [ ( fil / 3 ) * 3 ][ col ]+ 3 * fil - 1 ) % 9 + 1 ; } } // Segona fase: barallem files for ( int fil = 0 ; fil < 9 ; fil += 3 ) { int f1 , f2 ; do { f1 = ( int ) random ( fil , fil + 3 ); f2 = ( int ) random ( fil , fil + 3 ); } while ( f1 == f2 ); for ( int col = 0 ; col < 9 ; col ++ ) { int aux = arraySudoku [ f1 ][ col ] ; arraySudoku [ f1 ][ col ] = arraySudoku [ f2 ][ col ] ; arraySudoku [ f2 ][ col ] = aux ; } } // Tercera fase: barallem les columnes for ( int col = 0 ; col < 9 ; col += 3 ) { int c1 , c2 ; do { c1 = ( int ) random ( col , col + 3 ); c2 = ( int ) random ( col , col + 3 ); } while ( c1 == c2 ); for ( int fil = 0 ; fil < 9 ; fil ++ ) { int aux = arraySudoku [ fil ][ c1 ] ; arraySudoku [ fil ][ c1 ] = arraySudoku [ fil ][ c2 ] ; arraySudoku [ fil ][ c2 ] = aux ; } } // Quarta fase: interncanviem dues files de submatrius int sm1 , sm2 ; do { sm1 = ( int ) random ( 0 , 3 ); sm2 = ( int ) random ( 0 , 3 ); } while ( sm1 == sm2 ); for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 9 ; j ++ ) { int val1 = 3 * sm1 + i ; int val2 = 3 * sm2 + i ; int aux = arraySudoku [ val1 ][ j ] ; arraySudoku [ val1 ][ j ] = arraySudoku [ val2 ][ j ] ; arraySudoku [ val2 ][ j ] = aux ; } } } Escriu un programa utilitzant Processing IDE que et mostre un Sudoku per pantalla, que permeta al jugador emplenar les cel\u00b7les buides i que comprove si el n\u00famero escollit es v\u00e0lid o no. Encara no disponible string: Cadenes de caracters En Java hem vist que quan volem emmagatzemar un valor enter, definim una variable de tipus int, si pel contrari, el que volem \u00e9s emmagatzemar un valor amb decimals, definim una variable de tipus double o float. Ara b\u00e9, si el que volem \u00e9s emmagatzemar una cadena de caracters, per exemple el nom d\u2019una persona, hem de definir un objecte de tipus String 1 2 // Crear un objecte string String strNom = \u00ab Manolo el del bombo \u00bb ; Aquest codi el que fa \u00e9s crear un objectes string strNom que cont\u00e9 el nom: \u00abManolo el del bombo\u00bb. Tamb\u00e9 podriem crear un string de la seg\u00fcent manera: 1 String strNome = new String ( \u00ab Manolo el del bombo \u00bb ); Al tractar-se d\u2019una classe, la forma natural de treballar amb ella ser\u00e0 mitjan\u00e7ant l\u2019\u00fas dels m\u00e8todes que disposa la classe. Aquests m\u00e8todes s\u00f3n: int length(): retorna la llarg\u00e0ria de la cadena en un enter. char charAt (int i): ens diu quin caracter est\u00e0 a la posici\u00f3 \u2018i\u2019 String substring(int i): ens retorna la subcadena que hi ha a partir de la posici\u00f3 \u2018i\u2019 fins el final de la cadena String substring(int i, int j): ens retorna la subcadena que es troba des de l\u2019\u00edndex i fins el j String concat(String str): concatena la cadena \u2018str\u2019 que es passa com a par\u00e0metre al final de la cadena. Per exemple: 1 2 3 String s1 = \u00ab Java \u00bb ; String s2 = \u00ab Pego \u00bb ; String s3 = s1 . concat ( s2 ); // El resultat seria \u00abJavaPego\u00bb int indexOf(String s): Ens retorna l\u2019index dins de la cadena de la primera aparici\u00f3 de la subcadena s. Per exemple: 1 2 String s1 = \u00ab Java a Pego \u00bb ; int pos = s1 . indexOf ( \u00ab Pego \u00bb ); // Retorna 7 int indexOf(String s, int i): retorna l\u2019\u00edndex dins de la cadena de la primera aparici\u00f3 de la subcadena s a partir de l\u2019\u00edndex i int lastIndexOf(int ch): torna l\u2019\u00edndex de l\u2019\u00faltima vegada que apareix el caracter \u2018ch\u2019 dins de la cadena. boolean equals(String str): Compara l\u2019string amb l\u2019objecte que es passa per par\u00e0metre. boolean equalsIgnoreCase (String otroString): Compara dues cadenes sense tenir en compte maj\u00fascules i min\u00fascules. int compareTo (String otroString): compara dues cadenes lexicogr\u00e0ficament. En altres paraules, diu quina \u00e9s major que l\u2019altra. int compareToIgnoreCase (String otroString): com el m\u00e8tode anterior per\u00f2 sense tenir en compte maj\u00fascules ni min\u00fascules. String toLowerCase(): converteix la cadena a min\u00fascules. String toUpperCase(): converteix la cadena a maj\u00fascules. String trim(): suprimeix els espais en blanc que puguen haver als extrems de la cadena String replace (char oldChar, char newChar): substitueix totes les ocurr\u00e8ncies de oldChar que hi ha a la cadena per newChar Enumeracions Una enumeraci\u00f3 \u00e9s un tipus especial de \u2018classe\u2019 que representa un grup de constants. Cada element d\u2019aquesta estructura est\u00e0 associada a un valor de un tipus de dades concret (normalment enter) on el primer element de l\u2019enumeraci\u00f3 sol agafar el valor 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Exemple 1. Dies de la setmana enum Dies { Dilluns , Dimarts , Dimecres , Dijous , Divendres , Dissabte , Diumenge } // Exemple 2. Talles de roba enum Talles { XXL , XL , L , M , S , XS } Com usar una enumeraci\u00f3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 enum Colors { RED , BLUE , YELLOW , GREEN } Colors myColor = Colors . YELLOW ; switch ( myColor ) { case RED : System . out . println ( \"The color is red\" ); break ; case BLUE : System . out . println ( \"The color is blue\" ); break ; case YELLOW : System . out . println ( \"The color is yellow\" ); break ; case GREEN : System . out . println ( \"The color is green\" ); break ; } Col\u00b7leccions Les col\u00b7leccions en Java s\u00f3n un marc que proporciona una arquitectura per emmagatzemar i manipular el grup d'objectes Poden realitzar totes les operacions que realitzeu sobre les dades, com ara la cerca, l'ordenaci\u00f3, la inserci\u00f3, la manipulaci\u00f3 i la supressi\u00f3. Java ofereix interf\u00edcies (Set, List, Queue, Deque) i classes (ArrayList, Vector, LinkedList, PriorityQueue, HashSet, LinkedHashSet, TreeSet). Jerarquia de classes A continuaci\u00f3 pots observar la jerarquia de classes que ens ofereix l'API de Java respecte de les col\u00b7leccions. classDiagram Iterable < |-- Collection Collection < |-- List Collection < |-- Queue Collection < |-- Set List < |.. ArrayList List < |.. LinkedList List < |.. Vector List < |.. Stack Queue < |--Deque Queue < |..PriorityQueue Set < |-- SortedSet Set < |.. HashSet Set < |.. LinkedHashSet SortedSet < |.. TreeSet Deque < |.. ArrayDeque ArrayList La classe ArrayList implementa la interf\u00edcie List. Utilitza una matriu din\u00e0mica per emmagatzemar l'element duplicat de diferents tipus de dades. La classe ArrayList mant\u00e9 l'ordre d'inserci\u00f3 i no est\u00e0 sincronitzada. Es pot accedir aleat\u00f2riament als elements emmagatzemats a la classe ArrayList. Considereu l'exemple seg\u00fcent. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Primer creem l'arrayList ArrayList < String > list = new ArrayList < String > (); // Despr\u00e9s afegim elements a la llista list . add ( \"Ravi\" ); list . add ( \"Vijay\" ); list . add ( \"Ravi\" ); list . add ( \"Ajay\" ); // Recorrem la llista i mostrem per pantalla Iterator itr = list . iterator (); while ( itr . hasNext ()) { println ( itr . next ()); }","title":"5.- Tipus Compostos Dades"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#tema-5-tipus-compostos-de-dades","text":"","title":"Tema 5. Tipus Compostos de Dades"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#introduccio","text":"Fins ara hav\u00edem treballat amb tipus de dades simples: int, char, double, float, bool... per\u00f2 que passa si necessitarem guardar un conjunt de dades o informaci\u00f3 relativa a una persona? Nom, cognoms, DNI, adre\u00e7a postal, data de naixement etc? Amb els tipus de dades simples ens seria impossible representar aquesta informaci\u00f3. Es per aix\u00f2 que s\u2019utilitzen els tipus de dades compostos que ens permetran agrupar de diverses maneres aquesta informaci\u00f3. Ens podem trobar diversos tipus de dades compostos i en aquest tema veurem: Cadenes de caracters: conjunt d'elements de tipus b\u00e0sic caracter. Arrays: tamb\u00e9 coneguts com vectors o arreglos , contenen elements d'un mateix tipus base o objectes de la mateixa classe. Estructures: conjunt d'elements heterogenis, no tenen per qu\u00e8 ser del mateix tipus base.","title":"Introducci\u00f3"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#arrays","text":"Comencem per veure l'estructura m\u00e9s simple de totes, l'array. Un array \u00e9s un tipus de dades compost que permet emmagatzemar un nombre x d\u2019elements del mateix tipus . Amb una \u00fanica declaraci\u00f3 podem tenir acc\u00e9s a un conjunt de valors agrupats. Aquestes agrupacions o arrays poden b\u00e9 ser de tipus simples o tamb\u00e9 de tipus compostos. Per tal d\u2019accedir a cadascun dels elements del array s\u2019utilitza un \u00edndex o posici\u00f3. La primera posici\u00f3 de tot array \u00e9s la 0 mentre que la segona seria la que t\u00e9 \u00edndex 1. A\u00e7\u00f2 pot marejar un poc al principi. Array d\u2019enters: {8,2,14,55,3,7} Array de car\u00e0cters: {\u2018n\u2019,\u2019a\u2019,\u2019t\u2019,\u2019o\u2019} Array de cadenes: {\"hola\", \"ciao\", \"hi\", \"allo\"} \u00c9s molt important distingir entre valor i posici\u00f3. Mentre que el valor \u00e9s el contingut de l\u2019array en una posici\u00f3 determinada la posici\u00f3 \u00e9s l\u2019\u00edndex que ens permet recorres l\u2019array i tot el seu contingut. A l\u2019exemple anterior tenim un array de 8 enters, la part superior de color blau ens indica les posicions que van de la 0 a la 7, 8 posicions ens total. Mentre que a la fila inferior trobarem el valor que cont\u00e9 cadascuna de les posicions. Per exemple en la posici\u00f3 5 (la sisena) de l\u2019array tindr\u00edem emmagatzemat un valor de 8. Un altre concepte a tenir en compte \u00e9s la dimensi\u00f3 o grand\u00e0ria de l\u2019array que ens determina el total d\u2019elements que es poden guardar en aquest. En el nostre cas la mida seria de 8.","title":"Arrays"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#algorismes-de-recerca","text":"Implicitament amb l'aparici\u00f3 de les estructures de dades complexes en programaci\u00f3 que, en certa manera, es podrien entendre com a conjunts , apareix la necessitat de poder fer recerques elements dintre d'aquestos conjunts. Existeixen dos algorismes de recerca que veurem en aquest apartat: la recerca seq\u00fcencial i la recerca binaria . A l\u2019element que estem buscant li direm clau . Per\u00f2 abans d'anar per feina, canviarem temporalment l'entorn de programaci\u00f3 de Processing IDE a Eclipse IDE i veurem un poc m\u00e9s que s\u00f3n les classes i els objectes i com funcionen en Java abans de veure-ho amb m\u00e9s detall al tema seg\u00fcent. Realitza les activitats seg\u00fcents abans de continuar. Activitat 506. Crea el projecte base Problema Soluci\u00f3 Aquesta primera activitat en Processing IDE \u00e9s senzilla, nom\u00e9s haur\u00e0s de crear un nou projecte en Java i copiar el codi seg\u00fcent per\u00f2 primer, veiem amb m\u00e9s detall qu\u00e9 \u00e9s el que es preten aconseguir. Volem crear un projecte que tinga les seg\u00fcents caracter\u00edstiques: Ha de tindre m\u00ednim una constant que ens indicar\u00e0 el total d\u2019elements que tindran els arrays, tant el d\u2019enters com el de car\u00e0cters. Com a global ha de tindre almenys un array de car\u00e0cters i un d\u2019enters. Tamb\u00e9 ha de tenir un m\u00e8tode setup i un draw que inicialitzen i executen l'aplicaci\u00f3. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 /** * Projecte Tipus Compostos * Projecte escrit en Processing IDE en el que tractarem els tipus compostos de dades en Java. * A aquest projecte se li aniran afegint funcionalitats conforme avancem en els continguts del Tema 5 * @author Vicent Sanchis * @since 10/11/23 * @version 1.0 */ // CONSTANTS static final int TAM = 10 ; // Variables Globals int [] arrayEnters ; char [] arrayCaracters ; /** * M\u00e8tode setup: s'executa a l'inici nom\u00e9s una vegada * sol utilitzar-se per inicialitzar les aplicacions * @return void */ void setup () { } /** * M\u00e8tode draw: o bucle del joc s'executa unes 60 vegades per segon aproximadament. * @return void */ void draw () { } void mostraEnters () { } void mostraCaracters () { } int generaNumAleatori () { return 0 ; } char generaCharAleatori () { return 0 ; } Encara no disponible En aquesta primera activitat haureu de copiar aquest codi en un nou projecte java de Processing IDE i si et fixes, aquest projecte disposa dels m\u00e8todes: mostraEnters, mostraCaracters, generaNumAleatori i generaCharAleatori que ja havieu implementat a les activitats anteriors. Aprofita i reutilitza el codi que ja havies escrit en activitats anteriors. Activitat 507. Inicialitzaci\u00f3 d'arrays Problema Soluci\u00f3 En aquest punt aprofitarem per crear un m\u00e8tode inicialitzador al nostre projecte. Com que volem que s\u2019execute en el moment que s\u2019inicia l'aplicaci\u00f3, aquest m\u00e8tode es cridar\u00e0 des del m\u00e8tode setup i \u00e9s ac\u00ed on inicialitzar\u00e0 els nostres arrays: el d'enters i el de caracters. C\u00f2pia el seg\u00fcent codi i posa'l al teu projecte. 1 2 3 4 void inicialitzaVectors () { arrayEnters = new int [ TAM ] ; arrayCaracters = new char [ TAM ] ; } Encara no disponible Afegeix i implementa els m\u00e8todes emplenaArrayNumeros() i emplenaArrayCaracters() per tal que es criden des del setup i utilitzen els m\u00e8todes generaNumAleatori() i generaCharAleatori(). Finalment i per tal de comprovar que anem b\u00e9 de moment, implementa els m\u00e8todes mostraEnters() i mostraCaracters() i crida'ls al m\u00e8tode draw i executa l'aplicaci\u00f3. Depura el codi anterior i comprova que tot est\u00e0 funcionant com s'espera que funcione. Activitat 508. Ampliaci\u00f3 de funcions Problema Soluci\u00f3 En la seg\u00fcent activitat afegirem una funci\u00f3 a la nostra classe en la que ens mostre un men\u00fa de les accions que podem realitzar. Per tal de realitzar aquest men\u00fa afegirem un array d\u2019strings com a nou membre de la classe que inicialitzarem amb les seg\u00fcents opcions: Eixir Mostrar array enters Mostrar array caracters Reinicialitzar vectors Recerca seq\u00fcencial Recerca bin\u00e0ria Ordenar amb bombolla Ordenar amb Quicksort Ordenar amb Shell Encara no disponible Activitat 509. Mostrar men\u00fa Problema Soluci\u00f3 Fes una funci\u00f3 que mostre per pantalla el men\u00fa de forma amigable. El men\u00fa s'haur\u00e0 de mostrar a la pantalla de l'aplicaci\u00f3, amb text(), i no pel terminal. Al mateix temps haur\u00e0s d'implementar un m\u00e8tode que capture el teclat per tal que execute alguna de les opcions que es mostraran al men\u00fa. Tin en compte que l'aplicaci\u00f3 que estem dissenyant nom\u00e9s haur\u00e0 de fer alguna acci\u00f3 si es premen els n\u00fameros del 1 al 9. Encara no disponible","title":"Algorismes de recerca"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#algorismes-dordenacio","text":"Els algorismes d\u2019ordenaci\u00f3 permeten ordenar un array en funci\u00f3 d\u2019un criteri establert al propi algorisme. Hi han diferents tipus d\u2019algorismes d\u2019ordenaci\u00f3: selecci\u00f3, inserci\u00f3, bombolla, Shell i Quicksort.","title":"Algorismes d'ordenaci\u00f3"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#insercio","text":"Aquest algorisme consisteix en generar un nou array a partir del que ja es t\u00e9, tal que cada nou element inserit es posa a la seua posici\u00f3 correcta. Imaginem que tenim el seg\u00fcent array d\u2019enters per ordenar: {12, 5, 3, 13, 2, 9, 7} Generem un nou array amb el primer element de l\u2019array a ordenar { 12 } El seg\u00fcent valor de l\u2019array original \u00e9s 5. \u00c9s major o menor que el que ja est\u00e0 inserit? Com que la resposta \u00e9s menor, aquest s\u2019haur\u00e0 d\u2019inserir abans quedant de la seg\u00fcent forma: { 5 , 12} El nou array es genera ja ordenat. El seg\u00fcent valor de l\u2019array desordenat \u00e9s 3. On l\u2019haurem de col\u00b7locar? Just abans del 5 quedant aix\u00ed: { 3 , 5, 12} Repetim la mateixa operaci\u00f3 per cada element de l\u2019array original: {3, 5, 12, 13 } { 2 , 3, 5, 12, 13} {2, 3, 5, 9 , 12, 13} {2, 3, 5, 7 , 9, 12, 13} 1 2 3 4 5 6 7 8 9 10 11 12 void insercio ( int [] array ) { int i , j , aux ; for ( i = 1 ; i < array . legnth ; i ++ ) { j = i ; aux = array [ i ] ; while ( j > 0 && aux < array [ j - 1 ] ) { array [ j ] = array [ j - 1 ] ; j -- ; } array [ j ] = aux ; } } Activitat 513. Algorisme ordenaci\u00f3 per inserci\u00f3 Problema Soluci\u00f3 Implementa l\u2019algorisme d\u2019ordenaci\u00f3 per inserci\u00f3 al projecte i vincula-la a l\u2019opci\u00f3 del men\u00fa corresponent. Encara no disponible","title":"Inserci\u00f3"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#bombolla","text":"L\u2019algorisme d\u2019ordenaci\u00f3 per bombolla \u00e9s el m\u00e9s conegut i tamb\u00e9 el menys eficient, ja que a cada passada per ordenar un element compara cadascun d\u2019ells amb el seu adjacent de forma que si les seues posicions s\u00f3n incorrectes, s\u2019intercanvien. Al finalitzar cada passada l\u2019element m\u00e9s gran es va posant al final de la llista Donat el seg\u00fcent array: {12, 5, 3, 13, 2, 9, 7} Pas 1. Comparem les posicions 0 i 1, \u00e9s a dir, 12 i 5 i com que estan desordenats (el primer \u00e9s major que el segon), s\u2019intercanvien. { 5 , 12 , 3, 13, 2, 9, 7} Pas 2. A continuaci\u00f3 comparem les posicions 1 i 2 de l\u2019array, que s\u00f3n 12 i 3. Com que tamb\u00e9 estan desordenades, les intercanviem {5, 3 , 12 , 13, 2, 9, 7} Pas 3. Ara anem a comparar les posicions 2 i 3 que contenen els valors 12 i 13 respectivament. Com que estan ben ordenades no es realitza cap acci\u00f3: Pas 4. Posicions 3 i 4 que s\u00f3n 13 i 2. Les intercanviem. {5, 3, 12 , 2, 13 , 9, 7} Pas 5. Posicions 4 i 5 que tamb\u00e9 estan desordenades per tant executem l\u2019intercanviem {5, 3, 12, 2, 9 , 13 , 7} Pas 6. Comparem posicions 5 i 6 que tenen els valors 13 i 7 i s\u2019han d\u2019intercanviar {5, 3, 13, 2, 9, 7 , 13 } Una vegada finalitzada la primera passada hem aconseguit que l\u2019element major de l\u2019array estiga posicionat a l\u2019\u00faltima posici\u00f3. A la seg\u00fcent passada recorrerem l\u2019array fins la posici\u00f3 anterior a on es troba ara el n\u00famero 13, \u00e9s a dir la posici\u00f3 5 i aquest procediment es repeteix fins arribar a la posici\u00f3 0 Finalment el codi quedaria aix\u00ed: 1 2 3 4 5 6 7 8 9 10 11 void bombolla ( int [] arrayNumeros ) { for ( int i = 0 ; i < arrayNumeros . length - 1 ; i ++ ) { for ( int j = i + 1 ; j < arrayNumeros . length ; j ++ ) { if ( arrayNumeros [ i ] > arrayNumeros [ j ] ) { int canvi = arrayNumeros [ i ] ; arrayNumeros [ i ] = arrayNumeros [ j ] ; arrayNumeros [ j ] = canvi ; } } } } Activitat 515. Ordenaci\u00f3 per bombolla Problema Soluci\u00f3 Implementa l\u2019algorisme d\u2019ordenaci\u00f3 per bombolla al projecte i vincula-la a l\u2019opci\u00f3 del men\u00fa corresponent. Encara no disponible","title":"Bombolla"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#shell","text":"L\u2019algorisme Shell \u00e9s una millora de l\u2019algorisme d\u2019inserci\u00f3 directa. Compara elements separats per un espai de v\u00e0ries posicions el que permet que un element faja passos m\u00e9s grans fins trobar la seua posici\u00f3 esperada. Els passos m\u00faltiples sobre els elements de l\u2019array es fan amb espais de posicions cada vegada m\u00e9s menuts. L\u2019\u00faltim pas de l\u2019algorisme Shell \u00e9s una simple ordenaci\u00f3 per inserci\u00f3 per\u00f2 arribats a aquest punt es pot garantir que l\u2019array esta ja quasi ordenat, el que fa que l\u2019ordenaci\u00f3 per inserci\u00f3 siga molt eficient. Vegem com actuaria aquest algorisme aplicat sobre l\u2019array que estem utilitzant com exemple: {12, 5, 3, 13, 2, 9, 7}. Aquest array t\u00e9 un total de 7 elements (n=7). Creem n/2 grups, separats n/2 n\u00fameros entre ells. n/2=7/2=3, \u00e9s a dir, el nostre interval per crear grups val 3 Marquem en negreta els valors de la primera subllista. {12, 5, 3, 13, 2, 9, 7} Donats els elements 12, 13 i 7 els hem d\u2019ordenar correctament {7, 5, 3, 12, 2, 9, 13} Continuem formant grups de 3 a partir del segon valor de l\u2019array {7, 5, 3, 12, 2, 9, 13} Ordenem els n\u00fameros en cas de no estar-ho, quedant l\u2019array aix\u00ed: {7, 2, 3, 12, 5, 9, 13} Passem a l\u2019element 3 de l\u2019array i apliquem el mateix procediment. {7, 2, 3, 12, 5, 9, 13} Els valors ja estan ordenats en aquest cas, per tant no hem de fer res. {7, 2, 3, 12, 5, 9, 13} No podem m\u00e9s grups ja que hem arribat al final del vector. Ara el que hem de fer \u00e9s tornar a dividir el nostre interval entre 2. El nou interval \u00e9s 3/2 = 1. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void shellSort ( int [] array ) { int interval , i , j , k , temp ; interval = array . length / 2 ; while ( interval > 0 ) { for ( i = interval ; i < n ; i ++ ) { j = i - interval ; while ( j >= 0 ) { k = j + interval ; if ( array [ j ] <= array [ k ] j = - 1 ; else { temp = array [ j ] ; array [ j ] = array [ k ] ; array [ k ] = temp ; j -= interval ; } } } interval = interval / 2 ; } } Activitat 516. Ordenaci\u00f3 per Shell Problema Soluci\u00f3 Implementa l\u2019algorisme d\u2019ordenaci\u00f3 shell al projecte i vincula-la a l\u2019opci\u00f3 del men\u00fa corresponent. Encara no disponible","title":"Shell"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#quicksort","text":"Aquest \u00e9s un dels algorismes d\u2019ordenaci\u00f3 m\u00e9s r\u00e0pids i eficients. Utilitza la t\u00e8cnica \u00abdivideix i vencer\u00e0s\u00bb de tal forma que divideix l\u2019array a ordenar en parts que ordenar\u00e0 al mateix temps. B\u00e0sicament es tria l\u2019element de l\u2019array com a pivot tal que es forme dos subArrays, en un d\u2019ells s\u2019emmagatzemen els elements menors que l\u2019element que hem triat com a pivot i a l\u2019altre array es guarden els element majors que el pivot. Una vegada fet, s\u2019aplica el mateix procediment als subarrays obtinguts. Seguint amb el mateix array dels exemples anteriors, aplicarem l\u2019algorisme d\u2019ordenaci\u00f3 quicksort. {12, 5, 3, 13, 2, 9, 7} Triem un valor que fara el paper de pivot, per exemple el primer element de l\u2019array, el 12 i a partir d\u2019aquest creem dos arrays, un amb els n\u00fameros menors que el pivot i l\u2019altre amb els n\u00fameros majors que el pivot: pivot: {12}; menors: {5, 3, 2, 9, 7}; majors {13} El subarray de majors ja est\u00e0 ordenada ja que nom\u00e9s t\u00e9 un n\u00famero. Ara ordenem el subarray de menors: {5, 3, 2, 9, 7} per la qual cosa escollim com a pivot el primer element de l\u2019array, \u00e9s a dir, el 5. pivot: {5}; menors {3, 2}; majors: {9, 7}. Seguim dividint en subarrays, Una vegada els subarrays estan ordenats sempre sempre s\u2019assemblaran col\u00b7locant subarrays de menors, seguides de pivot i subarrays de majors {2, 3, 5, 7, 9, 12, 13} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void Quicksort ( int [] array , int primer , int ultim ) { int i , j , central , pivot , tmp ; central = ( primer + ultim ) / 2 ; pivot = array [ central ] ; i = primer ; j = ultim ; do { while ( array [ i ] < pivot ) i ++ ; while ( array [ j ] > pivot ) j -- ; if ( i <= j ) { tmp = array [ i ] ; array [ i ] = array [ j ] ; array [ j ] = tmp ; i ++ ; j \u2013 - ; } } while ( i <= j ); if ( primer < j ) Quicksort ( array , primer , j ); if ( i < ultim ) Quicksort ( array , i , ultim ); } Activitat 517. Algorisme Quicksort Problema Soluci\u00f3 Implementa l\u2019algorisme d\u2019ordenaci\u00f3 quicksort al projecte i vincula-la a l\u2019opci\u00f3 del men\u00fa corresponent. Encara no disponible Activitat 518. Mostrar tra\u00e7a algorismes ordenaci\u00f3 Problema Soluci\u00f3 Fes que en cada algorisme d\u2019ordenaci\u00f3 es mostre una tra\u00e7a on a cada passada de l\u2019algoritme, \u00e9s a dir, cada vegada que mou un element a l\u2019array, mostre aquest per pantalla. Encara no disponible Activitat 519. Entrega del projecte Problema Soluci\u00f3 Entrega mitjan\u00e7ant la plataforma aules el projecte final que inclou de les activitats 506 a 518 amb totes les funcions tant de recerca com d\u2019ordenaci\u00f3 sobre arrays unidimensionals. Encara no disponible","title":"Quicksort"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#arrays-multidimensionals","text":"Fins ara hem estan utilitzant arrays d\u2019una sola dimensi\u00f3, coneguts tamb\u00e9 com vectors, taules o llistes. Aquests arrays es recorren amb ajuda d\u2019un sol \u00edndex (tenen una sola dimensi\u00f3). En aquest apartat estudiarem arrays de m\u00e9s d\u2019una dimensi\u00f3 per als que necessitarem m\u00e9s d\u2019un \u00edndex a l\u2019hora de ser recorreguts. Els arrays multidimensionals m\u00e9s comuns s\u00f3n els de dues dimensions o bidimensionals, tamb\u00e9 coneguts com matrius. \u00c9s com\u00fa representar aquest tipus de dades com una taula composta per una s\u00e8rie de files i columnes: 0,0 0,1 0,2 0,3 ... 0,N 1,0 1,1 1,2 1,3 ... 1,N 2,0 2,1 2,2 2,3 ... 2,N ... ... ... ... ... ... N,0 N,1 N,2 N,3 ... N,N Al contrari del que passava amb els arrays d\u2019una sola dimensi\u00f3 on nom\u00e9s necessitavem un \u00edndex per accedir al valor, en els arrays de dues dimensions com el de l\u2019exemple anterior, necessitarem dos \u00edndex per accedir al valor de l\u2019array. Les matrius, com es coneixen els arrays bidimensionals es forme per files i columnes.","title":"Arrays multidimensionals"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#string-cadenes-de-caracters","text":"En Java hem vist que quan volem emmagatzemar un valor enter, definim una variable de tipus int, si pel contrari, el que volem \u00e9s emmagatzemar un valor amb decimals, definim una variable de tipus double o float. Ara b\u00e9, si el que volem \u00e9s emmagatzemar una cadena de caracters, per exemple el nom d\u2019una persona, hem de definir un objecte de tipus String 1 2 // Crear un objecte string String strNom = \u00ab Manolo el del bombo \u00bb ; Aquest codi el que fa \u00e9s crear un objectes string strNom que cont\u00e9 el nom: \u00abManolo el del bombo\u00bb. Tamb\u00e9 podriem crear un string de la seg\u00fcent manera: 1 String strNome = new String ( \u00ab Manolo el del bombo \u00bb ); Al tractar-se d\u2019una classe, la forma natural de treballar amb ella ser\u00e0 mitjan\u00e7ant l\u2019\u00fas dels m\u00e8todes que disposa la classe. Aquests m\u00e8todes s\u00f3n: int length(): retorna la llarg\u00e0ria de la cadena en un enter. char charAt (int i): ens diu quin caracter est\u00e0 a la posici\u00f3 \u2018i\u2019 String substring(int i): ens retorna la subcadena que hi ha a partir de la posici\u00f3 \u2018i\u2019 fins el final de la cadena String substring(int i, int j): ens retorna la subcadena que es troba des de l\u2019\u00edndex i fins el j String concat(String str): concatena la cadena \u2018str\u2019 que es passa com a par\u00e0metre al final de la cadena. Per exemple: 1 2 3 String s1 = \u00ab Java \u00bb ; String s2 = \u00ab Pego \u00bb ; String s3 = s1 . concat ( s2 ); // El resultat seria \u00abJavaPego\u00bb int indexOf(String s): Ens retorna l\u2019index dins de la cadena de la primera aparici\u00f3 de la subcadena s. Per exemple: 1 2 String s1 = \u00ab Java a Pego \u00bb ; int pos = s1 . indexOf ( \u00ab Pego \u00bb ); // Retorna 7 int indexOf(String s, int i): retorna l\u2019\u00edndex dins de la cadena de la primera aparici\u00f3 de la subcadena s a partir de l\u2019\u00edndex i int lastIndexOf(int ch): torna l\u2019\u00edndex de l\u2019\u00faltima vegada que apareix el caracter \u2018ch\u2019 dins de la cadena. boolean equals(String str): Compara l\u2019string amb l\u2019objecte que es passa per par\u00e0metre. boolean equalsIgnoreCase (String otroString): Compara dues cadenes sense tenir en compte maj\u00fascules i min\u00fascules. int compareTo (String otroString): compara dues cadenes lexicogr\u00e0ficament. En altres paraules, diu quina \u00e9s major que l\u2019altra. int compareToIgnoreCase (String otroString): com el m\u00e8tode anterior per\u00f2 sense tenir en compte maj\u00fascules ni min\u00fascules. String toLowerCase(): converteix la cadena a min\u00fascules. String toUpperCase(): converteix la cadena a maj\u00fascules. String trim(): suprimeix els espais en blanc que puguen haver als extrems de la cadena String replace (char oldChar, char newChar): substitueix totes les ocurr\u00e8ncies de oldChar que hi ha a la cadena per newChar","title":"string: Cadenes de caracters"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#enumeracions","text":"Una enumeraci\u00f3 \u00e9s un tipus especial de \u2018classe\u2019 que representa un grup de constants. Cada element d\u2019aquesta estructura est\u00e0 associada a un valor de un tipus de dades concret (normalment enter) on el primer element de l\u2019enumeraci\u00f3 sol agafar el valor 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Exemple 1. Dies de la setmana enum Dies { Dilluns , Dimarts , Dimecres , Dijous , Divendres , Dissabte , Diumenge } // Exemple 2. Talles de roba enum Talles { XXL , XL , L , M , S , XS } Com usar una enumeraci\u00f3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 enum Colors { RED , BLUE , YELLOW , GREEN } Colors myColor = Colors . YELLOW ; switch ( myColor ) { case RED : System . out . println ( \"The color is red\" ); break ; case BLUE : System . out . println ( \"The color is blue\" ); break ; case YELLOW : System . out . println ( \"The color is yellow\" ); break ; case GREEN : System . out . println ( \"The color is green\" ); break ; }","title":"Enumeracions"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#colleccions","text":"Les col\u00b7leccions en Java s\u00f3n un marc que proporciona una arquitectura per emmagatzemar i manipular el grup d'objectes Poden realitzar totes les operacions que realitzeu sobre les dades, com ara la cerca, l'ordenaci\u00f3, la inserci\u00f3, la manipulaci\u00f3 i la supressi\u00f3. Java ofereix interf\u00edcies (Set, List, Queue, Deque) i classes (ArrayList, Vector, LinkedList, PriorityQueue, HashSet, LinkedHashSet, TreeSet).","title":"Col\u00b7leccions"},{"location":"Tema%2006%20%28c%C3%B2pia%29.%20Programaci%C3%B3%20Orientada%20a%20Objectes/","text":"Tema 6. Programaci\u00f3 Orientada a Objectes. Introducci\u00f3 La programaci\u00f3 orientada a objectes tamb\u00e9 coneguda com POO \u00e9s el paradigma de programaci\u00f3 que m\u00e9s s\u2019utilitza hui en dia i que permet modelar de manera m\u00e9s eficient la realitat des del punt de vista del programari. La programaci\u00f3 orientada a objectes intenta proporcionar un model de programaci\u00f3 basat en objectes que contenen dades i procediments associats coneguts com a m\u00e8todes a difer\u00e8ncia del disseny procedimental que s'utilitzava en la programaci\u00f3 estructurada. Aquests objectes , que s\u00f3n inst\u00e0ncies de les classes , s\u00f3n tipus abstractes de dades que encapsulen (amaguen) tant les dades com les funcions per accedir-hi. Un dels objectius de la programaci\u00f3 orientada a objectes \u00e9s reflectir la realitat, de forma que els elements d\u2019un programa s\u2019ajusten a elements de la vida quotidiana. Per exemple, suposem que volem realitzar una aplicaci\u00f3 per una banda de rock a la que li direm RockCase . En un programa estructurat definir\u00edem funcions independentment de les dades, tal que per un costat creariem el codi de les funcions i posteriorment, al programa principal, s'establirien les dades en forma de variables sobre les que s'aplicarien els canvis. \u00c9s a dir, es farien els diagrames de flux corresponents utilitzant les estructures vistes al teorema de programaci\u00f3 estructurada a cadascun dels procediments que li suposem a la nostra aplicaci\u00f3 i els programariem en el llenguatge de programaci\u00f3 corresponent. Per exemple, una banda de rock pot tocar un tema (procediment) que al final no \u00e9s m\u00e9s que una successi\u00f3 (estructura seq\u00fcencial) de sons, instruments i parts de la can\u00e7\u00f3 que es toquen seguint una l\u00f2gica fins que acaba la can\u00e7\u00f3. En canvi en POO es dona prioritat a la modelaci\u00f3 de les dades i no als procediments. En un escenari de programaci\u00f3 orientada a objectes, a la fase d'an\u00e0lisi es determinen els diferents actors del programa (objectes) i a partir d'ahi se li assignen els diferents atributs i accions que pot realitzar. Per\u00f2 veiem-ho amb l'exemple del RockCase . Si ens parem a analitzar la nostra aplicaci\u00f3, arribarem a la conclusi\u00f3 que un dels objectes m\u00e9s importants seran els m\u00fasics. \u00c9s a dir, la nostra aplicaci\u00f3 b\u00e0sicament \u00e9s uh conjunt de m\u00fasics amb una s\u00e8rie de caracter\u00edstiques o atributs i que poden realitzar una s\u00e8rie d'accions (tocar, ferSolos, cantar, etc..). Doncs b\u00e9, a difer\u00e8ncia del paradigma de programaci\u00f3 estructurada, ac\u00ed programarem primer els objectes (definirem les classes) i despr\u00e9s els utilitzarem al programa principal. En aquesta aplicaci\u00f3 ens podriem trobar els seg\u00fcents objectes: bateria, baix, guitarra i cantant. La programaci\u00f3 orientada a objectes permet la creaci\u00f3 de programari cada vegada m\u00e9s complexe a partir d\u2019unitats o blocs de codi reutilitzables. Caracter\u00edstiques principals Les propietats principals o caracter\u00edstiques fonamentals del paradigma de programaci\u00f3 orientada a objectes s\u00f3n: Abstracci\u00f3 Abstraure's \u00e9s a\u00efllar mentalment , considerar separadament (un o diversos atributs o qualitats) d'una cosa. Per exemple abstraure els conceptes m\u00e9s importants d'un discurs, \u00e9s a dir, quedar-se amb el important. En programaci\u00f3 orientada a objectes abstraure\u2019s, l\u2019abstracci\u00f3, seria mostrar \u00fanicament les caracter\u00edstiques essencials, que fa l\u2019objecte i per a que es crea, deixant de banda elements com la implementaci\u00f3. L\u2019abstracci\u00f3 permet representar les caracter\u00edstiques essencials d\u2019un objecte, deixant enrere aquelles que no tenen tanta import\u00e0ncia. A m\u00e9s a m\u00e9s, es centra en l\u2019objecte tal i com el coneixem en la vida real, de forma que ens centrem en all\u00f2 que es capa\u00e7 de fer per\u00f2 no en com ho fa. B\u00e0sicament, definir\u00edem l\u2019abstracci\u00f3 com la forma de descriure una entitat del m\u00f3n real sense importar la complexitat que est\u00e0 present i el poder utilitzar aquesta en qualsevol aplicaci\u00f3. Un altre exemple d'abstracci\u00f3: Basant-nos en l'app RockCase de la que hem parlat a l'apartat anterior, necessitariem d'alguna manera representar cadascun dels components del nostre grup i cadascun dels membres reflectiria unes caracter\u00edstiques o unes altres. Deuriem poden emmagatzemar informaci\u00f3: nom, instrument que toca, llista de can\u00e7ons... Encapsulament L\u2019encapsulament \u00e9s, en altres paraules, l\u2019ocultaci\u00f3 d\u2019informaci\u00f3 , de forma que les dades internes d\u2019un objecte estan ocultes al m\u00f3n exterior, nom\u00e9s es coneix d\u2019ell la seua ess\u00e8ncia, \u00e9s a dir, qu\u00e8 podem fer amb ell. Per exemple, amb freq\u00fc\u00e8ncia es desenvolupa codi font o projectes en els que utilitzem la classe out, m\u00e9s concretament el m\u00e8tode println. Out es troba dins de l\u2019espai de noms (namespace) System i no \u00e9s m\u00e9s que una classe d\u2019aquest paquet. Dit en altres paraules. Out \u00e9s una classe i println() \u00e9s un m\u00e8tode de la classe Out. Respecte de la banda de rock que estem \"dissenyant\", tocar, tocarSolo, cantar... L'encapsulament en aquest cas es refereix a que nosaltres nom\u00e9s necessitem saber quines s\u00f3n les possibles accions que la nostra persona pot fer per\u00f2 no hem de saber com ho fa (el codi dels m\u00e8todes) Modularitat Aquesta propietat fa refer\u00e8ncia a la forma en la que els elements en programaci\u00f3 orientada a objectes es troben organitzats en m\u00f2duls , facilitant aix\u00ed l\u2019encapsulament i abstracci\u00f3 de la informaci\u00f3. La modularitat permet dividir una aplicaci\u00f3 en parts. Aquestes parts han de ser tan independents com puguen de la resta de m\u00f2duls aix\u00ed com tamb\u00e9 de l\u2019aplicaci\u00f3 principal. El motiu pel qual els m\u00f2duls han de ser el m\u00e9s independents possibles de l\u2019aplicaci\u00f3 \u00e9s perqu\u00e8 aix\u00ed es podran reutilitzar en altres aplicacions m\u00e9s endavant. Jerarquia i her\u00e8ncia La jerarquia \u00e9s la propietat de la programaci\u00f3 orientada a objectes respecte de la relaci\u00f3 o ordre existent entre les distintes classes i objectes. El mecanisme principal per tal d\u2019ordenar les classes als nostres projectes \u00e9s l\u2019her\u00e8ncia. Podem parlar d\u2019her\u00e8ncia entre classes quan elements d\u2019una classe (superclasse) son heretats per una altra o incl\u00f2s els seus m\u00e8todes poden ser sobrecarregats. Si et fixes en l'exemple de la RockCase haur\u00e0s observat que malgrat tenim quatre tipus de m\u00fasic diferents al nostre grup (bateria, veu, baix i guitarra) en realitat tots tenen una s\u00e8rie d'atributs comuns. Tots s\u00f3n persones. Per tant podriem dir que al final tant un bateria com un guitarra com un cantant com un baix (subClasses) s\u00f3n persones (superClasse). Mira el seg\u00fcent diagrama de classes: classDiagram Persona < |-- Bateria Persona < |-- Cantant Persona < |-- Baix Persona < |-- Guitarra Persona < |-- Cantant Persona: nom Persona: cognom Persona: nick Persona: foto Bateria: marcaBateria Bateria: repicar() Cantant: tipusMicro Cantant: cantar() Baix: tocarBaix() Guitarra: nomGuitarra Guitarra: tocarSolo Guitarra: tocarQuintes() Polimorfisme Polimorfisme \u00e9s una paraula grega que significa \u00abmoltes formes\u00bb . Aquesta paraula \u00e9s ideal per definir aquesta caracter\u00edstica de la programaci\u00f3 orientada a objectes ja que en POO podem tindre objectes amb el mateix nom que realitzen funcions distintes o implementen codi diferent. El polimorfisme \u00e9s un mecanisme que s\u2019utilitza molt en POO juntament amb l\u2019her\u00e8ncia tal que quan una classe deriva d\u2019una altra hereta les seues caracter\u00edstiques i operacions. A la classe que hereta es pot redefinir qualsevol m\u00e8tode heretat, de forma que en funci\u00f3 de la refer\u00e8ncia a objectes que usem a cada moment s\u2019estar\u00e0 executant un m\u00e8tode o un altre. Un mateix missatge enviat a objectes diferents donar\u00e0 com a resposta eixides diferents, \u00e9s a dir, si tenim diversos objectes amb m\u00e8todes similars, segons es referencie l\u2019un o l\u2019altre objecte el resultat final ser\u00e0 diferent. Per exemple, seguint amb l'esquema de les persones del RockCase suposem que la classe ( \"SuperClasse ) Persona t\u00e9 un m\u00e8tode que es diu \"tocar\", aquest m\u00e8tode l'hereten totes i cadascuna de les subClasses per\u00f2 \u00e9s evident que el resultat de tocar no ser\u00e0 el mateix si \u00e9s un baix que un guitarra que un bateria. Realitzaci\u00f3 de programes orientats a objectes A partir d\u2019ara, quan hajam de resoldre un problema hem de comen\u00e7ar a pensar d\u2019una forma diferent a la que est\u00e0vem fent fins ara. En programaci\u00f3 orientada a objectes seguirem usant els mecanismes de programaci\u00f3 estructurada com ara sent\u00e8ncies repetitives, alternatives, etc.. tanmateix hem de plantejar un sistema on les dades presenten una major import\u00e0ncia. L\u2019objectiu de l\u2019orientaci\u00f3 a objectes \u00e9s plasmar la realitat de manera que programem els elements el m\u00e9s pr\u00f2xim possible a com els veiem al seu entorn natural. Aix\u00ed, quan hajam d\u2019encarar un problema d\u2019aquest tipus: Ens preguntarem sobre aquells elements dels que realment es interessant emmagatzemar informaci\u00f3, \u00e9s a dir, localitzarem els possibles objectes del nostre programa. De cada element hem de con\u00e8ixer quines s\u00f3n les seues caracter\u00edstiques o quines s\u00f3n les caracter\u00edstiques que el representen. De cada element hem de con\u00e8ixer les operacions a realitzar , accions que hi poden fer, ja que cada conjunt de dades permetr\u00e0 la realitzaci\u00f3 d\u2019un conjunt d\u2019operacions. Finalment, desenvoluparem un entorn on utilitzarem els elements configurats. Per exemple, a l'hora de desenvolupar l'aplicaci\u00f3, podem resoldre les seg\u00fcents q\u00fcestions per determinar els elements que inclourem: 1. Quins elements de la nostra aplicaci\u00f3 han de ser desats o s'han de tenir en compte? - Les distintes tipus de m\u00fasics que formen la nostra banda 2. De cada element, quines dades ens interessen? - Persona: nom, cognoms, foto - Baix: - Guitarra: - Cantant: - Bateria: 3. A cada element, quines operacions associarem? - El cantant canta, el baix toca, el guitarra fa solos i acompanyaments i el bateria toca i fa solos de bateria. Pel que fa a l\u2019aplicaci\u00f3 principal que utilitze aquests objectes, podem plantejar un programa que emmagatzeme de forma din\u00e0mica les persones i estructurar la funcionalitat mitjan\u00e7ant un men\u00fa d\u2019opcions que permeta utilitzar les operacions anteriorment plantejades per a cada objecte. El diagrama de classes que deduir\u00edem de les especificacions anteriors podria ser el seg\u00fcent: classDiagram Persona < |-- Bateria Persona < |-- Cantant Persona < |-- Baix Persona < |-- Guitarra Persona < |-- Cantant Persona: nom Persona: cognom Persona: nick Persona: foto Bateria: marcaBateria Bateria: repicar() Bateria: ferSolo() Cantant: tipusMicro Cantant: cantar() Baix: amplificador Baix: tocarBaix() Baix: ferSlap() Guitarra: nomGuitarra Guitarra: amplificador Guitarra: tocarSolo() Guitarra: tocarQuintes() Guitarra: ferAcompanyament() ``` ??? question \"Activitat 601. Projecte Agenda\" === \"Problema\" En aquest tema i per tal de comen\u00e7ar a treballar amb classes i objectes, desenvoluparem una xicoteta aplicaci\u00f3 de gesti\u00f3 de contactes personals. El que es pret\u00e9n \u00e9s poder administrar un recull de contactes a mode d'agenda personal. De cada contacte es necessitaria saber la seg\u00fcent informaci\u00f3: - Nom - Cognoms - Tel\u00e8fon - Correu electr\u00f2nic A l'iniciar-se la nostra aplicaci\u00f3 es carregaran un m\u00ednim de cinc contactes que emmagatzemarem en un array. Mentre a la pantalla principal es mostrar\u00e0 un men\u00fa amb les accions que es poden realitzar en la nostra app: - Llistar contactes - Buscar contacte - Editar contacte - Afegir contacte - Esborrar contacte Fes una an\u00e0lisi semblant a la que hem fet al taller i especifica els requeriments de la teua aplicaci\u00f3 a m\u00e9s a m\u00e9s de localitzar les classes que penses que tindr\u00e0 l'aplicaci\u00f3. - Quants objectes diferents hi ha? - Quines s\u00f3n les seues caracter\u00edstiques principals? - Quines accions poden realitzar cada objecte? - Quines relacions hi ha entre els objectes? Dibuixa primer un diagrama de classes el m\u00e9s detallat possible. === \"Soluci\u00f3\" No disponible encara. ## Classes i Objectes Una **classe \u00e9s la definici\u00f3 d\u2019un objecte**, \u00e9s l\u2019element que descriu els components d\u2019un objecte de forma general. Diem que hem creat un objecte quan donem valors i utilitzem els components definits a la classe. Per exemple, si continuem utilitzant la nostra app de l'institut, una classe seria **Estudiant** en la que es descriu de forma general aquest element. S'establiria que l'estudiant es caracteritzaria per: - Tindre un NIA - Tindre un nom - Tindre uns cognoms - Tindre una foto - Ser d'ESO, Batxiller o Cicles. Ara b\u00e9, si al nostre programa mostrem informaci\u00f3 d'un estudiant concret, les caracter\u00edstiques abans esmentades adopten certs valors: - NIA: 120239202 - Nom: Braulio - Cognom: Estrella - Foto: - Curs: BAT Aix\u00ed per un costat tenim la classe Persona i per l'altre l'objecte \"Braulio\" Alhora de crear una classe definim el que denominem propietats o atributs i m\u00e8todes de classe. - **Atributs:** una caracter\u00edstica concreta d\u2019un objecte de la vida quotidiana. Quan s\u2019estableix un atribut a una classe, es defineix com quan cre\u00e0vem variables als nostres programes estructurats, indicant tipus de dades i nom amb el que el reconeixem. - **M\u00e8todes de la classe:** donen funcionalitat a la classe, \u00e9s a dir, reflecteixen les operacions que aquesta pot fer sobre els atributs. Els m\u00e8todes s\u00f3n similars a les funcions o procediments que cre\u00e0vem en programaci\u00f3 estructurada per\u00f2 orientats a modificar i actuar sobre les propietats d\u2019una classe. Un objecte dona valors concrets als atributs que defineix la classe i utilitza els seus m\u00e8todes. Quan un objecte utilitza un m\u00e8tode concret es diu que aquesta enviant un missatge. D\u2019alguna manera a\u00e7\u00f2 t\u00e9 l\u00f2gica ja que estem donant una ordre a un component que reflecteix la realitat. Si a la nostra aplicaci\u00f3 de les persones de l'institut volem mostrar la fitxa d'un estudiant li estem enviant un missatge a la persona per tal que mostre la fitxa per pantalla. A l'hora d'enviar un missatge a un objecte concret utilitzarem l'operador punt, per exemple: **braulio.mostraFitxa().** A sovint donem el nom d\u2019estat als valors que en un objecte t\u00e9 en un moment concret de la vida del programa on s\u2019est\u00e0 utilitzant. A m\u00e9s a m\u00e9s, quan creem un objecte, donem valors a les propietats de la classe, diem que estem instanciant aquesta classe. ## Definici\u00f3 de classes en Java Una vegada ja sabem que s\u00f3n les classes i els objectes veurem com es defineixen classes i instancien objectes en el llenguatge Java. Definir una classe implica donar-li nom a ella i als elements que emmagatzemen la seua informaci\u00f3, aix\u00ed com tamb\u00e9 descriure els m\u00e8todes que realitzaran les accions considerades als objectes. Les definicions o especificacions no constitueixen un codi de programa executable si no que s\u2019utilitzen per assignar mem\u00f2ria on emmagatzemar els valors dels atributs que utilitza el programa i recon\u00e8ixer els m\u00e8todes que aquesta utilitzar\u00e0; normalment es situen en arxius formant packages, utilitzant un arxiu per v\u00e0ries classes relacionades. ```java linenums=\"1\" class nomClasse { llista_de_membres } - nomClasse: definit per l\u2019usuari i identifica la classe; pot incloure lletres, n\u00fameros i subratllats com qualsevol identificador. - llista_de_membres: s\u00f3n els m\u00e8todes i atributs de la classe, etc.. M\u00e9s concretament, una classe es podria definir de la seg\u00fcent manera: 1 2 3 4 5 6 7 class nomClasse { llista_de_constants ; llista_de_atributs ; constructor_de_classe ; constructor_de_c\u00f2pia ; m\u00e8todes ; } En realitat si la definici\u00f3 de les parts de la classe es fera en un altre ordre, no afectaria a la compilaci\u00f3 i execuci\u00f3 d\u2019aquesta per\u00f2 s\u00ed a la lectura del codi i el faria m\u00e9s complicat d\u2019interpretar. Exemple de classe: per tal d\u2019il\u00b7lustrar com es defineix una classe amb un exemple, definirem la classe 'Persona'. 1 2 3 4 5 6 7 8 9 10 11 class Persona { String nom ; String cognom ; String NIF ; String dataNaixement ; String email ; void cobra () { } } Activitat 602. Defineix les classes del Projecte Agenda Problema Soluci\u00f3 Obre Processing IDE i declara les classes resultants de l'activitat 601. Recorda que totes les caracter\u00edstiques i accions que hages anotat a l'activitat anterior hauran de convertir-se en atributs i m\u00e8todes de les classes que dissenyes. Guarda el fitxer com a ProjecteAgenda.pde Encara no disponible. Visibilitat dels membres de la classe Un principi fonamental en la programaci\u00f3 orientada a objectes \u00e9s l\u2019ocultaci\u00f3 de la informaci\u00f3, a\u00e7\u00f2 significa que no es pot accedir per m\u00e8todes externs de la classe a determinada informaci\u00f3 interna. El mecanisme principal per aconseguir-ho \u00e9s posar-los dins d\u2019una classe i fer-los privats i aix\u00ed nom\u00e9s es podr\u00e0 accedir a aquests des de dins de la classe Existeixen tres diferents especificacions d\u2019acc\u00e9s o modificadors de visibilitat: public (+): un m\u00e8tode o atribut t\u00e9 una visibilitat p\u00fablica quan totes les dem\u00e8s classes poden accedir a ells, b\u00e9 siga una altra classe o una subclasse. Private (-): sols es pot accedir a ells des del propi codi de la classe. Protected (#): nom\u00e9s des del propi codi de la classe o de les seues subclasses es pot accedir. Package (~): nom\u00e9s accessible per membres del paquet. Atributs Els atributs s\u00f3n les caracter\u00edstiques individuals que diferencien un objecte d\u2019un altre i determinen la seua aparen\u00e7a, estat o altres qualitats. Els atributs es desen en variables anomenades variables d\u2019inst\u00e0ncia i cada objecte particular pot tindre valors distints per a aquestes variables. Per exemple, la classe persona que hem definit als exemples anteriors t\u00e9 els seg\u00fcents atributs: nom, cognom, NIF, dataNaixement, email. 1 2 3 4 5 6 7 public class Persona { private String nom ; private String cognom ; private String NIF ; private String dataNaixement ; private String email ; } Les variables d\u2019inst\u00e0ncia tamb\u00e9 anomenades membres s\u00f3n declarades a la classe per\u00f2 els seus valors son canviats i fixats a l\u2019objectes ja que una classe no \u00e9s m\u00e9s que un esquema que defineix com seran les persones al nostre programa. A m\u00e9s de les variables d\u2019inst\u00e0ncia hi ha variables de classe, les quals s\u2019apliquen a la classe i a totes les inst\u00e0ncies. Per exemple, el n\u00famero de rodes d\u2019un cotxe \u00e9s el mateix per a tots els objectes cotxe. M\u00e8todes Els m\u00e8tode s\u00f3n aquelles accions que pot realitzar la classe que estem definint. B\u00e0sicament el que fa un m\u00e8tode \u00e9s modificar l\u2019estat de l\u2019objecte mitjan\u00e7ant el canvi del valor dels seus atributs. Continuant amb la classe persona que hem definit al punt anterior, caldria que ens f\u00e9rem les seg\u00fcents q\u00fcestions: quines accions s\u00f3n les que pot realitzar la nostra persona? En que afecta eixes accions als atributs que hem escollit per definir-la? A la q\u00fcesti\u00f3 primera dir\u00edem que una persona pot: caminar, botar, c\u00f3rrer, menjar, cr\u00e9ixer, tintar-se els cabells, etc.. Pel que fa a la segon q\u00fcesti\u00f3, podr\u00edem dir que nom\u00e9s modifiquen atributs: menjar, augmentant de pes; cr\u00e9ixer, modificant l\u2019estatura i tintar-se els cabells, canviant el color del pel. Aix\u00ed la classe persona podria quedar de la seg\u00fcent forma: 1 2 3 4 5 6 7 8 9 10 11 public class Persona { private String nom ; private String cognom ; private String NIF ; private String dataNaixement ; private String email ; public void cobra () { } } Fixeu-se que mentre els atributs de la classe tenen un modificador de visibilitat private, els m\u00e8todes el solen tindre public. Encara que no necess\u00e0riament ha de ser aix\u00ed sempre per\u00f2 \u00e9s molt habitual. Els m\u00e8todes a Java sempre s\u00f3n membres d\u2019una classe, no hi ha m\u00e8todes o funcions fora d\u2019aquestes. La seua implementaci\u00f3 s\u2019inclou dins del cos de la classe. Exemple: A continuaci\u00f3 modelarem el nostre exemple de persones d'institut. Primer la classe Estudiant. 1 2 3 4 5 6 7 8 9 10 11 12 public class Estudiant { private String NIA ; private String curs ; public void ferExamen () { println ( \"No he estudiat\" ); } public void prenApunts () { println ( \"M'he deixat la llibreta\" ); } } A continuaci\u00f3 la classe Professor 1 2 3 4 5 6 7 8 9 10 11 12 public classe Professor { private String departament ; private float sou ; public void corregir () { println ( \"Tots suspesos\" ); } public void donarClasse () { } } Activitat 603. Visibilitat de classes Problema Soluci\u00f3 A partir de les classes que hages dissenyat a l'\u00faltima activitat, assigna-li la visibilitat corresponent a les classes i a cada membre de la classe, b\u00e9 siga un atribut o un m\u00e8tode. Encara no disponible Constructors i inst\u00e0ncies Un constructor \u00e9s un m\u00e8tode membre d\u2019una classe que s\u2019executa de forma autom\u00e0tica quan es crea un instancia d\u2019aquesta. El constructor d\u2019una classe es diferencia de la resta perqu\u00e8 s\u2019ha d\u2019anomenar igual que la classe (respectant maj\u00fascules i min\u00fascules) i mai s\u2019especifica a la seua definici\u00f3 un tipus de dades a retornar encara que siga void. El constructor admet par\u00e0metres, sent un m\u00e8tode que es pot sobrecarregar, \u00e9s a dir, podem tindre diversos constructors amb un nombre diferent de par\u00e0metres o diferents tipus de dades. Els constructors tenen com a finalitat principal la inicialitzaci\u00f3 de les variables o atributs de la classe. No \u00e9s obligatori definir un constructor a cada classe, encara que es sol fer. Aix\u00ed establim els valors que desitgem per quan un atribut de forma autom\u00e0tica a la creaci\u00f3 de l\u2019objecte, en lloc de fer-ho en un altre moment mitjan\u00e7ant altres m\u00e8todes. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class Persona { private String nom ; private String cognom ; private String DNI ; private String dataNaixement ; public Persona () { DNI = \"00000000Z\" ; } public Persona ( String NIF ) { DNI = NIF ; } public Persona ( String NIF , String nom , String C1 ) { DNI = NIF ; nom = nom ; cognom = C1 ; } } La declaraci\u00f3 d\u2019una classe no \u00e9s m\u00e9s que la definici\u00f3 d\u2019una realitat utilitzant un llenguatge de programaci\u00f3 orientada a objectes. El seg\u00fcent pas seria fer \u00fas d\u2019aquesta definici\u00f3 o classe, \u00e9s a dir, instanciar o crear un objecte a partir d\u2019aquesta classe. Per tal d\u2019instanciar una classe s\u2019utilitza la seg\u00fcent sent\u00e8ncia: 1 nom_classe nom_instancia = new nom_classe ( par\u00e0metres ); La paraula \u00abnew\u00bb s\u2019encarrega de reservar espai en mem\u00f2ria i torna una refer\u00e8ncia a l\u2019adre\u00e7a de mem\u00f2ria on s\u2019ha emmagatzemat l\u2019objecte. nom_classe: en el primer cas \u00e9s el nom de la classe que es vol instanciar. A la segon part es refereix al constructor de la classe que ha de ser igual que el nom d\u2019aquesta. El constructor \u00e9s un m\u00e8tode especial de la classe i com a m\u00e8tode que \u00e9s pot rebre par\u00e0metres. nom_instancia: identificador amb el que s\u2019identificar\u00e0 l\u2019objecte instanciat. L\u2019espai reservat a mem\u00f2ria per un objecte dependr\u00e0 de la quantitat d\u2019elements o membres que continga. Quan un objecte no est\u00e0 siguen referenciat es treu de mem\u00f2ria per tal d\u2019alliberar espai pel \u00abgarbage collector\u00bb Quan creem un objecte d\u2019una classe, cada atribut ser\u00e0 inicialitzat amb els valors per defecte del tipus de dades utilitzat o b\u00e9 pel valor establert al constructor. Activitat 604. Constructors i inst\u00e0ncies Problema Soluci\u00f3 Declara (nom\u00e9s la interf\u00edcie i amb el cos buit) dos constructors, un sense par\u00e0metres i un amb els par\u00e0metres necessaris, per a cada classe que tingues al teu Projecte Agenda. Encara no disponible. Acc\u00e9s als membres de la classe Podrem accedir als membres d\u2019una classe en funci\u00f3 de la seua visibilitat i el lloc on es desitge accedir. Els modificadors de visibilitat s\u00f3n: public, private, protected i internal. Per accedir a un membre de la classe utilitzem el \u00ab.\u00bb (punt): NomClasse.membre Basant-nos en la classe Persona dels punts anteriors farem un programa que instancie un objecte Persona i veurem com s\u2019accedeix als membres de la classes Suposem que persona t\u00e9 un constructor de la classe al qual li passem els seg\u00fcents par\u00e0metres: DNI, nom, cognom, estatura, pes i color del p\u00e8l. Main Persona 1 2 3 4 5 6 7 8 9 10 11 12 13 // Variables globals Persona manolo ; void setup () { manolo = new Persona ( \"11111111A\" , \"Manolo\" , \"Garibolo\" ); manolo . tintar ( \"blau\" ); manolo . menjar (); manolo . creixer (); } void draw () { } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Persona { // Atributs private String DNI ; private String nom ; private String cognoms ; private String dataNaixement ; private double estatura ; private double pes ; private String colorUlls ; private String colorCabells ; // M\u00e8todes public void creixer ( ) { estatura ++ ; } public void menjar ( ) { pes ++ ; } public void tintarse ( String colorNou ) { colorCabells = colorNou ; } } Tanmateix no podr\u00edem accedir als membres privats de la classe des de fora, per exemple, no podr\u00edem fer vicent.nom= \u00abAntonio\u00bb ja que nom \u00e9s un membre privat. Activitat 605. Dissenya el constructor parametritzat Problema Soluci\u00f3 Implementa amb codi el constructor parametritzat de l'activitat anterior. Despr\u00e9s al programa principal, instancia una agenda amb almenys un contacte que continga informaci\u00f3. Encara no disponible. La paraula reservada 'this' La paraula reservada \u00abthis\u00bb s\u2019utilitza per fer refer\u00e8ncia a l\u2019objecte actual. Si est\u00e0s dissenyant una classe, \u00abthis\u00bb fa refer\u00e8ncia a la pr\u00f2pia classe. Quan es crida a un m\u00e8tode, es passa autom\u00e0ticament un argument impl\u00edcit que \u00e9s una refer\u00e8ncia a l\u2019objecte invocat, \u00e9s a dir, l\u2019objecte sobre el que es crida al m\u00e8tode. Aquesta refer\u00e8ncia \u00e9s \u00abthis\u00bb. Amb els atributs de la classe tamb\u00e9 passa el mateix. Per comprendre-ho millor, mirem el seg\u00fcent exemple: 1 2 3 4 5 6 7 8 9 10 11 public class Persona { public String nom ; public String cognom ; public String DNI ; public Persona ( String nom , String cognom , String DNI ) { this . nom = nom ; this . cognom = cognom ; this . DNI = DNI ; } } Aquesta paraula clau sol utilitzar-se quan hi han b\u00e9 m\u00e8todes o atributs (membres) a dues classes diferents amb el mateix nom per exemple. M\u00e8todes, variables i blocs statics La paraula reservada \u00abstatic\u00bb en Java \u00e9s un modificador que en Java es pot aplicar a variables, m\u00e8todes, classes i blocs de codi Variables est\u00e0tiques Una variable est\u00e0tica (static) \u00e9s una variable que pertany a la classe en la que va ser declarada i s\u2019inicialitza nom\u00e9s una vegada a l\u2019inici de l\u2019execuci\u00f3 del programa, la caracter\u00edstica principal d\u2019aquest tipus de variables \u00e9s que es pot accedir directament amb el nom de la classe sense necessitat d\u2019instanciar un objecte. A banda tamb\u00e9: \u00c9s una variable que pertany a la classe (variable de classe) i no a l\u2019objecte. Les variables static s\u2019inicialitzen nom\u00e9s una vegada, a l\u2019inici de l\u2019execuci\u00f3. Aquestes variables s\u2019inicialitzaran primer abans de la inicialitzaci\u00f3 de qualsevol variable d\u2019inst\u00e0ncia. M\u00e8todes est\u00e0tics Un m\u00e8tode est\u00e0tic nom\u00e9s pot accedir a les variables o tipus de dades est\u00e0tiques i no pot accedir a les dades no est\u00e0tiques. Un m\u00e8tode est\u00e0tic nom\u00e9s pot accedir a dades est\u00e0tiques. No pot accedir a dades no est\u00e0tiques (variables d\u2019inst\u00e0ncia) Un m\u00e8tode est\u00e0tic pot cridar nom\u00e9s a m\u00e8todes est\u00e0tics i no pot invocar un m\u00e8tode no est\u00e0tic a partir d\u2019ell. Un m\u00e8tode est\u00e0tic es pot accedir directament pel nom de la classe i no es necessita crear un objecte per accedir al m\u00e8tode. Un m\u00e8tode est\u00e0tic no pot fer refer\u00e8ncia a \u00abthis\u00bb o \u00absuper\u00bb Blocs est\u00e0tics El bloc est\u00e0tic \u00e9s un bloc d\u2019instruccions dins de la classe (static { ... }) que s\u2019executa quan una classe es carrega per primera vegada en la m\u00e0quina virtual de Java (JVM). B\u00e0sicament un bloc est\u00e0tic inicialitza variables de tipus est\u00e0tic dins d\u2019una classe, de la mateixa forma que un constructor de classe ajuden a inicialitzar les variables d\u2019inst\u00e0ncia, un bloc est\u00e0tic inicialitza les variables tipus static de la classe. Activitat 606. Projecte Agenda Problema Soluci\u00f3 Finalitza el projecte de l'agenda amb totes les classes i m\u00e8todes implementats. Encara no disponible. Sobrec\u00e0rrega d'operadors En Java \u00e9s possible sobrecarregar m\u00e8todes, \u00e9s dir, definir dos o m\u00e9s dins de la mateixa classe, que comparteix nombre i que les declaracions dels seus par\u00e0metres s\u00f3n diferents; la sobrec\u00e0rrega \u00e9s una forma de polimorfisme. En les cridades als m\u00e8todes sobrecarregats, el compilador determina quin \u00e9s el m\u00e8tode invocat basant-se en el nombre i tipus d\u2019arguments passats; per tant, els m\u00e8todes sobrecarregats han de diferir en nombre i tipus de par\u00e0metres. Quan Java troba una trucada a un m\u00e8tode sobrecarregat, s\u2019executa la versi\u00f3 del que t\u00e9 par\u00e0metres (n\u00famero i tipus) que coincideixen amb els arguments utilitzats en la trucada. Sobrecarrega de constructors En Java es possible sobrecarregar m\u00e8todes, \u00e9s dir, definir dos o m\u00e9s dins de la mateixa classe, que comparteixen nombre i que les declaracions dels seus par\u00e0metres s\u00f3n diferents; la sobrec\u00e0rrega \u00e9s una forma de polimorfisme. La classe descriu un conjunt d'objectes amb les mateixes propietats i comportament; quan l\u2019objecte es crea, es inicialitza amb valors predeterminats o amb els que es transmeten en el moment de la inst\u00e0ncia; el m\u00e8tode que realitza la inicialitzaci\u00f3 de l\u2019objecte \u00e9s el constructor, aquest t\u00e9 el mateix nombre que la classe i no t\u00e9 tipus de retorn. A m\u00e9s de la sobrec\u00e0rrega de m\u00e8todes normals, es poden sobrecarregar els constructors; estos \u00faltims normalment es sobrecarregaran a la majoria de les classes creades, encara que no es regla; fins i tot una classe pot definir-se sense constructor i, per extensi\u00f3, sense arguments.","title":"Tema 6. Programaci\u00f3 Orientada a Objectes."},{"location":"Tema%2006%20%28c%C3%B2pia%29.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#tema-6-programacio-orientada-a-objectes","text":"","title":"Tema 6. Programaci\u00f3 Orientada a Objectes."},{"location":"Tema%2006%20%28c%C3%B2pia%29.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#introduccio","text":"La programaci\u00f3 orientada a objectes tamb\u00e9 coneguda com POO \u00e9s el paradigma de programaci\u00f3 que m\u00e9s s\u2019utilitza hui en dia i que permet modelar de manera m\u00e9s eficient la realitat des del punt de vista del programari. La programaci\u00f3 orientada a objectes intenta proporcionar un model de programaci\u00f3 basat en objectes que contenen dades i procediments associats coneguts com a m\u00e8todes a difer\u00e8ncia del disseny procedimental que s'utilitzava en la programaci\u00f3 estructurada. Aquests objectes , que s\u00f3n inst\u00e0ncies de les classes , s\u00f3n tipus abstractes de dades que encapsulen (amaguen) tant les dades com les funcions per accedir-hi. Un dels objectius de la programaci\u00f3 orientada a objectes \u00e9s reflectir la realitat, de forma que els elements d\u2019un programa s\u2019ajusten a elements de la vida quotidiana. Per exemple, suposem que volem realitzar una aplicaci\u00f3 per una banda de rock a la que li direm RockCase . En un programa estructurat definir\u00edem funcions independentment de les dades, tal que per un costat creariem el codi de les funcions i posteriorment, al programa principal, s'establirien les dades en forma de variables sobre les que s'aplicarien els canvis. \u00c9s a dir, es farien els diagrames de flux corresponents utilitzant les estructures vistes al teorema de programaci\u00f3 estructurada a cadascun dels procediments que li suposem a la nostra aplicaci\u00f3 i els programariem en el llenguatge de programaci\u00f3 corresponent. Per exemple, una banda de rock pot tocar un tema (procediment) que al final no \u00e9s m\u00e9s que una successi\u00f3 (estructura seq\u00fcencial) de sons, instruments i parts de la can\u00e7\u00f3 que es toquen seguint una l\u00f2gica fins que acaba la can\u00e7\u00f3. En canvi en POO es dona prioritat a la modelaci\u00f3 de les dades i no als procediments. En un escenari de programaci\u00f3 orientada a objectes, a la fase d'an\u00e0lisi es determinen els diferents actors del programa (objectes) i a partir d'ahi se li assignen els diferents atributs i accions que pot realitzar. Per\u00f2 veiem-ho amb l'exemple del RockCase . Si ens parem a analitzar la nostra aplicaci\u00f3, arribarem a la conclusi\u00f3 que un dels objectes m\u00e9s importants seran els m\u00fasics. \u00c9s a dir, la nostra aplicaci\u00f3 b\u00e0sicament \u00e9s uh conjunt de m\u00fasics amb una s\u00e8rie de caracter\u00edstiques o atributs i que poden realitzar una s\u00e8rie d'accions (tocar, ferSolos, cantar, etc..). Doncs b\u00e9, a difer\u00e8ncia del paradigma de programaci\u00f3 estructurada, ac\u00ed programarem primer els objectes (definirem les classes) i despr\u00e9s els utilitzarem al programa principal. En aquesta aplicaci\u00f3 ens podriem trobar els seg\u00fcents objectes: bateria, baix, guitarra i cantant. La programaci\u00f3 orientada a objectes permet la creaci\u00f3 de programari cada vegada m\u00e9s complexe a partir d\u2019unitats o blocs de codi reutilitzables.","title":"Introducci\u00f3"},{"location":"Tema%2006%20%28c%C3%B2pia%29.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#caracteristiques-principals","text":"Les propietats principals o caracter\u00edstiques fonamentals del paradigma de programaci\u00f3 orientada a objectes s\u00f3n:","title":"Caracter\u00edstiques principals"},{"location":"Tema%2006%20%28c%C3%B2pia%29.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#realitzacio-de-programes-orientats-a-objectes","text":"A partir d\u2019ara, quan hajam de resoldre un problema hem de comen\u00e7ar a pensar d\u2019una forma diferent a la que est\u00e0vem fent fins ara. En programaci\u00f3 orientada a objectes seguirem usant els mecanismes de programaci\u00f3 estructurada com ara sent\u00e8ncies repetitives, alternatives, etc.. tanmateix hem de plantejar un sistema on les dades presenten una major import\u00e0ncia. L\u2019objectiu de l\u2019orientaci\u00f3 a objectes \u00e9s plasmar la realitat de manera que programem els elements el m\u00e9s pr\u00f2xim possible a com els veiem al seu entorn natural. Aix\u00ed, quan hajam d\u2019encarar un problema d\u2019aquest tipus: Ens preguntarem sobre aquells elements dels que realment es interessant emmagatzemar informaci\u00f3, \u00e9s a dir, localitzarem els possibles objectes del nostre programa. De cada element hem de con\u00e8ixer quines s\u00f3n les seues caracter\u00edstiques o quines s\u00f3n les caracter\u00edstiques que el representen. De cada element hem de con\u00e8ixer les operacions a realitzar , accions que hi poden fer, ja que cada conjunt de dades permetr\u00e0 la realitzaci\u00f3 d\u2019un conjunt d\u2019operacions. Finalment, desenvoluparem un entorn on utilitzarem els elements configurats. Per exemple, a l'hora de desenvolupar l'aplicaci\u00f3, podem resoldre les seg\u00fcents q\u00fcestions per determinar els elements que inclourem: 1. Quins elements de la nostra aplicaci\u00f3 han de ser desats o s'han de tenir en compte? - Les distintes tipus de m\u00fasics que formen la nostra banda 2. De cada element, quines dades ens interessen? - Persona: nom, cognoms, foto - Baix: - Guitarra: - Cantant: - Bateria: 3. A cada element, quines operacions associarem? - El cantant canta, el baix toca, el guitarra fa solos i acompanyaments i el bateria toca i fa solos de bateria. Pel que fa a l\u2019aplicaci\u00f3 principal que utilitze aquests objectes, podem plantejar un programa que emmagatzeme de forma din\u00e0mica les persones i estructurar la funcionalitat mitjan\u00e7ant un men\u00fa d\u2019opcions que permeta utilitzar les operacions anteriorment plantejades per a cada objecte. El diagrama de classes que deduir\u00edem de les especificacions anteriors podria ser el seg\u00fcent: classDiagram Persona < |-- Bateria Persona < |-- Cantant Persona < |-- Baix Persona < |-- Guitarra Persona < |-- Cantant Persona: nom Persona: cognom Persona: nick Persona: foto Bateria: marcaBateria Bateria: repicar() Bateria: ferSolo() Cantant: tipusMicro Cantant: cantar() Baix: amplificador Baix: tocarBaix() Baix: ferSlap() Guitarra: nomGuitarra Guitarra: amplificador Guitarra: tocarSolo() Guitarra: tocarQuintes() Guitarra: ferAcompanyament() ``` ??? question \"Activitat 601. Projecte Agenda\" === \"Problema\" En aquest tema i per tal de comen\u00e7ar a treballar amb classes i objectes, desenvoluparem una xicoteta aplicaci\u00f3 de gesti\u00f3 de contactes personals. El que es pret\u00e9n \u00e9s poder administrar un recull de contactes a mode d'agenda personal. De cada contacte es necessitaria saber la seg\u00fcent informaci\u00f3: - Nom - Cognoms - Tel\u00e8fon - Correu electr\u00f2nic A l'iniciar-se la nostra aplicaci\u00f3 es carregaran un m\u00ednim de cinc contactes que emmagatzemarem en un array. Mentre a la pantalla principal es mostrar\u00e0 un men\u00fa amb les accions que es poden realitzar en la nostra app: - Llistar contactes - Buscar contacte - Editar contacte - Afegir contacte - Esborrar contacte Fes una an\u00e0lisi semblant a la que hem fet al taller i especifica els requeriments de la teua aplicaci\u00f3 a m\u00e9s a m\u00e9s de localitzar les classes que penses que tindr\u00e0 l'aplicaci\u00f3. - Quants objectes diferents hi ha? - Quines s\u00f3n les seues caracter\u00edstiques principals? - Quines accions poden realitzar cada objecte? - Quines relacions hi ha entre els objectes? Dibuixa primer un diagrama de classes el m\u00e9s detallat possible. === \"Soluci\u00f3\" No disponible encara. ## Classes i Objectes Una **classe \u00e9s la definici\u00f3 d\u2019un objecte**, \u00e9s l\u2019element que descriu els components d\u2019un objecte de forma general. Diem que hem creat un objecte quan donem valors i utilitzem els components definits a la classe. Per exemple, si continuem utilitzant la nostra app de l'institut, una classe seria **Estudiant** en la que es descriu de forma general aquest element. S'establiria que l'estudiant es caracteritzaria per: - Tindre un NIA - Tindre un nom - Tindre uns cognoms - Tindre una foto - Ser d'ESO, Batxiller o Cicles. Ara b\u00e9, si al nostre programa mostrem informaci\u00f3 d'un estudiant concret, les caracter\u00edstiques abans esmentades adopten certs valors: - NIA: 120239202 - Nom: Braulio - Cognom: Estrella - Foto: - Curs: BAT Aix\u00ed per un costat tenim la classe Persona i per l'altre l'objecte \"Braulio\" Alhora de crear una classe definim el que denominem propietats o atributs i m\u00e8todes de classe. - **Atributs:** una caracter\u00edstica concreta d\u2019un objecte de la vida quotidiana. Quan s\u2019estableix un atribut a una classe, es defineix com quan cre\u00e0vem variables als nostres programes estructurats, indicant tipus de dades i nom amb el que el reconeixem. - **M\u00e8todes de la classe:** donen funcionalitat a la classe, \u00e9s a dir, reflecteixen les operacions que aquesta pot fer sobre els atributs. Els m\u00e8todes s\u00f3n similars a les funcions o procediments que cre\u00e0vem en programaci\u00f3 estructurada per\u00f2 orientats a modificar i actuar sobre les propietats d\u2019una classe. Un objecte dona valors concrets als atributs que defineix la classe i utilitza els seus m\u00e8todes. Quan un objecte utilitza un m\u00e8tode concret es diu que aquesta enviant un missatge. D\u2019alguna manera a\u00e7\u00f2 t\u00e9 l\u00f2gica ja que estem donant una ordre a un component que reflecteix la realitat. Si a la nostra aplicaci\u00f3 de les persones de l'institut volem mostrar la fitxa d'un estudiant li estem enviant un missatge a la persona per tal que mostre la fitxa per pantalla. A l'hora d'enviar un missatge a un objecte concret utilitzarem l'operador punt, per exemple: **braulio.mostraFitxa().** A sovint donem el nom d\u2019estat als valors que en un objecte t\u00e9 en un moment concret de la vida del programa on s\u2019est\u00e0 utilitzant. A m\u00e9s a m\u00e9s, quan creem un objecte, donem valors a les propietats de la classe, diem que estem instanciant aquesta classe. ## Definici\u00f3 de classes en Java Una vegada ja sabem que s\u00f3n les classes i els objectes veurem com es defineixen classes i instancien objectes en el llenguatge Java. Definir una classe implica donar-li nom a ella i als elements que emmagatzemen la seua informaci\u00f3, aix\u00ed com tamb\u00e9 descriure els m\u00e8todes que realitzaran les accions considerades als objectes. Les definicions o especificacions no constitueixen un codi de programa executable si no que s\u2019utilitzen per assignar mem\u00f2ria on emmagatzemar els valors dels atributs que utilitza el programa i recon\u00e8ixer els m\u00e8todes que aquesta utilitzar\u00e0; normalment es situen en arxius formant packages, utilitzant un arxiu per v\u00e0ries classes relacionades. ```java linenums=\"1\" class nomClasse { llista_de_membres } - nomClasse: definit per l\u2019usuari i identifica la classe; pot incloure lletres, n\u00fameros i subratllats com qualsevol identificador. - llista_de_membres: s\u00f3n els m\u00e8todes i atributs de la classe, etc.. M\u00e9s concretament, una classe es podria definir de la seg\u00fcent manera: 1 2 3 4 5 6 7 class nomClasse { llista_de_constants ; llista_de_atributs ; constructor_de_classe ; constructor_de_c\u00f2pia ; m\u00e8todes ; } En realitat si la definici\u00f3 de les parts de la classe es fera en un altre ordre, no afectaria a la compilaci\u00f3 i execuci\u00f3 d\u2019aquesta per\u00f2 s\u00ed a la lectura del codi i el faria m\u00e9s complicat d\u2019interpretar. Exemple de classe: per tal d\u2019il\u00b7lustrar com es defineix una classe amb un exemple, definirem la classe 'Persona'. 1 2 3 4 5 6 7 8 9 10 11 class Persona { String nom ; String cognom ; String NIF ; String dataNaixement ; String email ; void cobra () { } } Activitat 602. Defineix les classes del Projecte Agenda Problema Soluci\u00f3 Obre Processing IDE i declara les classes resultants de l'activitat 601. Recorda que totes les caracter\u00edstiques i accions que hages anotat a l'activitat anterior hauran de convertir-se en atributs i m\u00e8todes de les classes que dissenyes. Guarda el fitxer com a ProjecteAgenda.pde Encara no disponible.","title":"Realitzaci\u00f3 de programes orientats a objectes"},{"location":"Tema%2006%20%28c%C3%B2pia%29.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#la-paraula-reservada-this","text":"La paraula reservada \u00abthis\u00bb s\u2019utilitza per fer refer\u00e8ncia a l\u2019objecte actual. Si est\u00e0s dissenyant una classe, \u00abthis\u00bb fa refer\u00e8ncia a la pr\u00f2pia classe. Quan es crida a un m\u00e8tode, es passa autom\u00e0ticament un argument impl\u00edcit que \u00e9s una refer\u00e8ncia a l\u2019objecte invocat, \u00e9s a dir, l\u2019objecte sobre el que es crida al m\u00e8tode. Aquesta refer\u00e8ncia \u00e9s \u00abthis\u00bb. Amb els atributs de la classe tamb\u00e9 passa el mateix. Per comprendre-ho millor, mirem el seg\u00fcent exemple: 1 2 3 4 5 6 7 8 9 10 11 public class Persona { public String nom ; public String cognom ; public String DNI ; public Persona ( String nom , String cognom , String DNI ) { this . nom = nom ; this . cognom = cognom ; this . DNI = DNI ; } } Aquesta paraula clau sol utilitzar-se quan hi han b\u00e9 m\u00e8todes o atributs (membres) a dues classes diferents amb el mateix nom per exemple.","title":"La paraula reservada 'this'"},{"location":"Tema%2006%20%28c%C3%B2pia%29.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#metodes-variables-i-blocs-statics","text":"La paraula reservada \u00abstatic\u00bb en Java \u00e9s un modificador que en Java es pot aplicar a variables, m\u00e8todes, classes i blocs de codi","title":"M\u00e8todes, variables i blocs statics"},{"location":"Tema%2006%20%28c%C3%B2pia%29.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#sobrecarrega-doperadors","text":"En Java \u00e9s possible sobrecarregar m\u00e8todes, \u00e9s dir, definir dos o m\u00e9s dins de la mateixa classe, que comparteix nombre i que les declaracions dels seus par\u00e0metres s\u00f3n diferents; la sobrec\u00e0rrega \u00e9s una forma de polimorfisme. En les cridades als m\u00e8todes sobrecarregats, el compilador determina quin \u00e9s el m\u00e8tode invocat basant-se en el nombre i tipus d\u2019arguments passats; per tant, els m\u00e8todes sobrecarregats han de diferir en nombre i tipus de par\u00e0metres. Quan Java troba una trucada a un m\u00e8tode sobrecarregat, s\u2019executa la versi\u00f3 del que t\u00e9 par\u00e0metres (n\u00famero i tipus) que coincideixen amb els arguments utilitzats en la trucada.","title":"Sobrec\u00e0rrega d'operadors"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/","text":"Tema 6. Programaci\u00f3 Orientada a Objectes. Introducci\u00f3 La programaci\u00f3 orientada a objectes tamb\u00e9 coneguda com POO \u00e9s el paradigma de programaci\u00f3 que m\u00e9s s\u2019utilitza hui en dia i que permet modelar de manera m\u00e9s eficient la realitat des del punt de vista del programari. La programaci\u00f3 orientada a objectes intenta proporcionar un model de programaci\u00f3 basat en objectes que contenen dades i procediments associats coneguts com a m\u00e8todes a difer\u00e8ncia del disseny procedimental que s'utilitzava en la programaci\u00f3 estructurada. Aquests objectes , que s\u00f3n inst\u00e0ncies de les classes , s\u00f3n tipus abstractes de dades que encapsulen (amaguen) tant les dades com les funcions per accedir-hi. Un dels objectius de la programaci\u00f3 orientada a objectes \u00e9s reflectir la realitat, de forma que els elements d\u2019un programa s\u2019ajusten a elements de la vida quotidiana. Per exemple, suposem que volem realitzar una aplicaci\u00f3 per una banda de rock a la que li direm RockCase . En un programa estructurat definir\u00edem funcions independentment de les dades, tal que per un costat creariem el codi de les funcions i posteriorment, al programa principal, s'establirien les dades en forma de variables sobre les que s'aplicarien els canvis. \u00c9s a dir, es farien els diagrames de flux corresponents utilitzant les estructures vistes al teorema de programaci\u00f3 estructurada a cadascun dels procediments que li suposem a la nostra aplicaci\u00f3 i els programariem en el llenguatge de programaci\u00f3 corresponent. Per exemple, una banda de rock pot tocar un tema (procediment) que al final no \u00e9s m\u00e9s que una successi\u00f3 (estructura seq\u00fcencial) de sons, instruments i parts de la can\u00e7\u00f3 que es toquen seguint una l\u00f2gica fins que acaba la can\u00e7\u00f3. En canvi en POO es dona prioritat a la modelaci\u00f3 de les dades i no als procediments. En un escenari de programaci\u00f3 orientada a objectes, a la fase d'an\u00e0lisi es determinen els diferents actors del programa (objectes) i a partir d'ac\u00ed se li assignen els diferents atributs i accions que pot realitzar. Per\u00f2 veiem-ho amb l'exemple del RockCase . Si ens parem a analitzar la nostra aplicaci\u00f3, arribarem a la conclusi\u00f3 que un dels objectes m\u00e9s importants seran els m\u00fasics. \u00c9s a dir, la nostra aplicaci\u00f3 b\u00e0sicament \u00e9s uh conjunt de m\u00fasics amb una s\u00e8rie de caracter\u00edstiques o atributs i que poden realitzar una s\u00e8rie d'accions (tocar, ferSolos, cantar, etc..). Doncs b\u00e9, a difer\u00e8ncia del paradigma de programaci\u00f3 estructurada, ac\u00ed programarem primer els objectes (definirem les classes) i despr\u00e9s els utilitzarem al programa principal. En aquesta aplicaci\u00f3 ens podriem trobar els seg\u00fcents objectes: bateria, baix, guitarra i cantant. La programaci\u00f3 orientada a objectes permet la creaci\u00f3 de programari cada vegada m\u00e9s complexe a partir d\u2019unitats o blocs de codi reutilitzables. Caracter\u00edstiques principals Les propietats principals o caracter\u00edstiques fonamentals del paradigma de programaci\u00f3 orientada a objectes s\u00f3n: Abstracci\u00f3 Abstraure's \u00e9s a\u00efllar mentalment , considerar separadament (un o diversos atributs o qualitats) d'una cosa. Per exemple abstraure els conceptes m\u00e9s importants d'un discurs, \u00e9s a dir, quedar-se amb el important. En programaci\u00f3 orientada a objectes abstraure\u2019s, l\u2019abstracci\u00f3, seria mostrar \u00fanicament les caracter\u00edstiques essencials, que fa l\u2019objecte i per a que es crea, deixant de banda elements com la implementaci\u00f3. L\u2019abstracci\u00f3 permet representar les caracter\u00edstiques essencials d\u2019un objecte, deixant enrere aquelles que no tenen tanta import\u00e0ncia. A m\u00e9s a m\u00e9s, es centra en l\u2019objecte tal i com el coneixem en la vida real, de forma que ens centrem en all\u00f2 que es capa\u00e7 de fer per\u00f2 no en com ho fa. B\u00e0sicament, definir\u00edem l\u2019abstracci\u00f3 com la forma de descriure una entitat del m\u00f3n real sense importar la complexitat que est\u00e0 present i el poder utilitzar aquesta en qualsevol aplicaci\u00f3. Un altre exemple d'abstracci\u00f3: Basant-nos en l'app RockCase de la que hem parlat a l'apartat anterior, necessitariem d'alguna manera representar cadascun dels components del nostre grup i cadascun dels membres reflectiria unes caracter\u00edstiques o unes altres. Deuriem poden emmagatzemar informaci\u00f3: nom, instrument que toca, llista de can\u00e7ons... Encapsulament L\u2019encapsulament \u00e9s, en altres paraules, l\u2019ocultaci\u00f3 d\u2019informaci\u00f3 , de forma que les dades internes d\u2019un objecte estan ocultes al m\u00f3n exterior, nom\u00e9s es coneix d\u2019ell la seua ess\u00e8ncia, \u00e9s a dir, qu\u00e8 podem fer amb ell. Per exemple, amb freq\u00fc\u00e8ncia es desenvolupa codi font o projectes en els que utilitzem la classe out, m\u00e9s concretament el m\u00e8tode println. Out es troba dins de l\u2019espai de noms (namespace) System i no \u00e9s m\u00e9s que una classe d\u2019aquest paquet. Dit en altres paraules. Out \u00e9s una classe i println() \u00e9s un m\u00e8tode de la classe Out. Respecte de la banda de rock que estem \"dissenyant\", tocar, tocarSolo, cantar... L'encapsulament en aquest cas es refereix a que nosaltres nom\u00e9s necessitem saber quines s\u00f3n les possibles accions que la nostra persona pot fer per\u00f2 no hem de saber com ho fa (el codi dels m\u00e8todes) Modularitat Aquesta propietat fa refer\u00e8ncia a la forma en la que els elements en programaci\u00f3 orientada a objectes es troben organitzats en m\u00f2duls , facilitant aix\u00ed l\u2019encapsulament i abstracci\u00f3 de la informaci\u00f3. La modularitat permet dividir una aplicaci\u00f3 en parts. Aquestes parts han de ser tan independents com puguen de la resta de m\u00f2duls aix\u00ed com tamb\u00e9 de l\u2019aplicaci\u00f3 principal. El motiu pel qual els m\u00f2duls han de ser el m\u00e9s independents possibles de l\u2019aplicaci\u00f3 \u00e9s perqu\u00e8 aix\u00ed es podran reutilitzar en altres aplicacions m\u00e9s endavant. Jerarquia i her\u00e8ncia La jerarquia \u00e9s la propietat de la programaci\u00f3 orientada a objectes respecte de la relaci\u00f3 o ordre existent entre les distintes classes i objectes. El mecanisme principal per tal d\u2019ordenar les classes als nostres projectes \u00e9s l\u2019her\u00e8ncia. Podem parlar d\u2019her\u00e8ncia entre classes quan elements d\u2019una classe (superclasse) son heretats per una altra o incl\u00f2s els seus m\u00e8todes poden ser sobrecarregats. Si et fixes en l'exemple de la RockCase haur\u00e0s observat que malgrat tenim quatre tipus de m\u00fasic diferents al nostre grup (bateria, veu, baix i guitarra) en realitat tots tenen una s\u00e8rie d'atributs comuns. Tots s\u00f3n persones. Per tant podriem dir que al final tant un bateria com un guitarra com un cantant com un baix (subClasses) s\u00f3n persones (superClasse). Mira el seg\u00fcent diagrama de classes: classDiagram Persona < |-- Bateria Persona < |-- Cantant Persona < |-- Baix Persona < |-- Guitarra Persona: nom Persona: cognom Persona: nick Persona: foto Bateria: marcaBateria Bateria: repicar() Cantant: tipusMicro Cantant: cantar() Baix: tocarBaix() Guitarra: nomGuitarra Guitarra: tocarSolo Guitarra: tocarQuintes() Polimorfisme Polimorfisme \u00e9s una paraula grega que significa \u00abmoltes formes\u00bb . Aquesta paraula \u00e9s ideal per definir aquesta caracter\u00edstica de la programaci\u00f3 orientada a objectes ja que en POO podem tindre objectes amb el mateix nom que realitzen funcions distintes o implementen codi diferent. El polimorfisme \u00e9s un mecanisme que s\u2019utilitza molt en POO juntament amb l\u2019her\u00e8ncia tal que quan una classe deriva d\u2019una altra hereta les seues caracter\u00edstiques i operacions. A la classe que hereta es pot redefinir qualsevol m\u00e8tode heretat, de forma que en funci\u00f3 de la refer\u00e8ncia a objectes que usem a cada moment s\u2019estar\u00e0 executant un m\u00e8tode o un altre. Un mateix missatge enviat a objectes diferents donar\u00e0 com a resposta eixides diferents, \u00e9s a dir, si tenim diversos objectes amb m\u00e8todes similars, segons es referencie l\u2019un o l\u2019altre objecte el resultat final ser\u00e0 diferent. Per exemple, seguint amb l'esquema de les persones del RockCase suposem que la classe ( \"SuperClasse ) Persona t\u00e9 un m\u00e8tode que es diu \"tocar\", aquest m\u00e8tode l'hereten totes i cadascuna de les subClasses per\u00f2 \u00e9s evident que el resultat de tocar no ser\u00e0 el mateix si \u00e9s un baix que un guitarra que un bateria. Realitzaci\u00f3 de programes orientats a objectes A partir d\u2019ara, quan hajam de resoldre un problema hem de comen\u00e7ar a pensar d\u2019una forma diferent a la que est\u00e0vem fent fins ara. En programaci\u00f3 orientada a objectes seguirem usant els mecanismes de programaci\u00f3 estructurada com ara sent\u00e8ncies repetitives, alternatives, etc.. tanmateix hem de plantejar un sistema on les dades presenten una major import\u00e0ncia. L\u2019objectiu de l\u2019orientaci\u00f3 a objectes \u00e9s plasmar la realitat de manera que programem els elements el m\u00e9s pr\u00f2xim possible a com els veiem al seu entorn natural. Aix\u00ed, quan hajam d\u2019encarar un problema d\u2019aquest tipus: Ens preguntarem sobre aquells elements dels que realment es interessant emmagatzemar informaci\u00f3, \u00e9s a dir, localitzarem els possibles objectes del nostre programa. De cada element hem de con\u00e8ixer quines s\u00f3n les seues caracter\u00edstiques o quines s\u00f3n les caracter\u00edstiques que el representen. De cada element hem de con\u00e8ixer les operacions a realitzar , accions que hi poden fer, ja que cada conjunt de dades permetr\u00e0 la realitzaci\u00f3 d\u2019un conjunt d\u2019operacions. Finalment, desenvoluparem un entorn on utilitzarem els elements configurats. Per exemple, a l'hora de desenvolupar l'aplicaci\u00f3, podem resoldre les seg\u00fcents q\u00fcestions per determinar els elements que inclourem: 1. Quins elements de la nostra aplicaci\u00f3 han de ser desats o s'han de tenir en compte? - Les distintes tipus de m\u00fasics que formen la nostra banda 2. De cada element, quines dades ens interessen? - Persona: nom, cognoms, foto - Baix: - Guitarra: - Cantant: - Bateria: 3. A cada element, quines operacions associarem? - El cantant canta, el baix toca, el guitarra fa solos i acompanyaments i el bateria toca i fa solos de bateria. Pel que fa a l\u2019aplicaci\u00f3 principal que utilitze aquests objectes, podem plantejar un programa que emmagatzeme de forma din\u00e0mica les persones i estructurar la funcionalitat mitjan\u00e7ant un men\u00fa d\u2019opcions que permeta utilitzar les operacions anteriorment plantejades per a cada objecte. El diagrama de classes que deduir\u00edem de les especificacions anteriors podria ser el seg\u00fcent: classDiagram Persona < |-- Bateria Persona < |-- Cantant Persona < |-- Baix Persona < |-- Guitarra Persona: nom Persona: cognom Persona: nick Persona: foto Bateria: marcaBateria Bateria: repicar() Bateria: ferSolo() Cantant: tipusMicro Cantant: cantar() Baix: amplificador Baix: tocarBaix() Baix: ferSlap() Guitarra: nomGuitarra Guitarra: amplificador Guitarra: tocarSolo() Guitarra: tocarQuintes() Guitarra: ferAcompanyament() Activitat 601. Projecte Agenda Problema Soluci\u00f3 En aquest tema i per tal de comen\u00e7ar a treballar amb classes i objectes, desenvoluparem una xicoteta aplicaci\u00f3 de gesti\u00f3 de contactes personals. El que es pret\u00e9n \u00e9s poder administrar un recull de contactes a mode d'agenda personal. De cada contacte es necessitaria saber la seg\u00fcent informaci\u00f3: Nom Cognoms Tel\u00e8fon Correu electr\u00f2nic A l'iniciar-se la nostra aplicaci\u00f3 es carregaran un m\u00ednim de cinc contactes que emmagatzemarem en un array. Mentre a la pantalla principal es mostrar\u00e0 un men\u00fa amb les accions que es poden realitzar en la nostra app: Llistar contactes Buscar contacte Editar contacte Afegir contacte Esborrar contacte Fes una an\u00e0lisi semblant a la que hem fet al taller i especifica els requeriments de la teua aplicaci\u00f3 a m\u00e9s a m\u00e9s de localitzar les classes que penses que tindr\u00e0 l'aplicaci\u00f3. Quants objectes diferents hi ha? Quines s\u00f3n les seues caracter\u00edstiques principals? Quines accions poden realitzar cada objecte? Quines relacions hi ha entre els objectes? Dibuixa primer un diagrama de classes el m\u00e9s detallat possible. No disponible encara. Classes i Objectes Una classe \u00e9s la definici\u00f3 d\u2019un objecte , \u00e9s l\u2019element que descriu els components d\u2019un objecte de forma general. Diem que hem creat un objecte quan donem valors i utilitzem els components definits a la classe. Per exemple, si continuem utilitzant la nostra app RockCase , una classe seria Persona en la que es descriu de forma general aquest element. S'establiria que la persona es caracteritzaria per: Tindre un nom Tindre un cognom Tindre uns nick Tindre una foto Ara b\u00e9, si al nostre programa mostrem informaci\u00f3 d'una persona concreta, les caracter\u00edstiques abans esmentades adopten certs valors: Nom: Braulio Cognom: Estrella nick: GraveRaiser Foto: image Aix\u00ed per un costat tenim la classe Persona i per l'altre l'objecte \"Braulio\" Alhora de crear una classe definim el que denominem propietats o atributs i m\u00e8todes de classe. Atributs: una caracter\u00edstica concreta d\u2019un objecte de la vida quotidiana. Quan s\u2019estableix un atribut a una classe, es defineix com quan cre\u00e0vem variables als nostres programes estructurats, indicant tipus de dades i nom amb el que el reconeixem. M\u00e8todes de la classe: donen funcionalitat a la classe, \u00e9s a dir, reflecteixen les operacions que aquesta pot fer sobre els atributs. Els m\u00e8todes s\u00f3n similars a les funcions o procediments que cre\u00e0vem en programaci\u00f3 estructurada per\u00f2 orientats a modificar i actuar sobre les propietats d\u2019una classe. Un objecte dona valors concrets als atributs que defineix la classe i utilitza els seus m\u00e8todes. Quan un objecte utilitza un m\u00e8tode concret es diu que aquesta enviant un missatge. D\u2019alguna manera a\u00e7\u00f2 t\u00e9 l\u00f2gica ja que estem donant una ordre a un component que reflecteix la realitat. Si a la nostra aplicaci\u00f3 de les bandes de rock volem mostrar la informaci\u00f3 d'una persona li estem enviant un missatge a la persona per tal que mostre la info per pantalla. A l'hora d'enviar un missatge a un objecte concret utilitzarem l'operador punt, per exemple: braulio.mostraInfo(). A sovint donem el nom d\u2019estat als valors que en un objecte t\u00e9 en un moment concret de la vida del programa on s\u2019est\u00e0 utilitzant. A m\u00e9s a m\u00e9s, quan creem un objecte, donem valors a les propietats de la classe, diem que estem instanciant aquesta classe. Definici\u00f3 de classes en Java Una vegada ja sabem que s\u00f3n les classes i els objectes veurem com es defineixen classes i instancien objectes en el llenguatge Java. Per tal de fer m\u00e9s gr\u00e0fica aquesta part de la teoria, seguirem usant l'aplicaci\u00f3 RockCase encara que un poc adaptada. Oblidem-nos de l'her\u00e8ncia i la jerarquia de moment i ho deixem per al pr\u00f2xim tema. Suposem que tenim quatre classes diferents: Cantant, Guitarra, Baix i Bateria com mostra el seg\u00fcent diagrama de classes: classDiagram Cantant: nom Cantant: cognom Cantant: nick Cantant: micro Cantant: registre Cantant: canta() Cantant: ferFalset() Guitarra: nom Guitarra: cognom Guitarra: nick Guitarra: model Guitarra: ampli Guitarra: tocaSolo() Guitarra: tocaAcopanyament() Baix: nom Baix: cognom Baix: nick Baix: model Baix: ampli Baix: toca() Baix: fesSlap() Bateria: nom Bateria: cognom Bateria: nick Bateria: marca Bateria: toca() Bateria: tocaSolo() Definir una classe implica donar-li nom a ella i als elements que emmagatzemen la seua informaci\u00f3, aix\u00ed com tamb\u00e9 descriure els m\u00e8todes que realitzaran les accions considerades als objectes. Les definicions o especificacions no constitueixen un codi de programa executable si no que s\u2019utilitzen per assignar mem\u00f2ria on emmagatzemar els valors dels atributs que utilitza el programa i recon\u00e8ixer els m\u00e8todes que aquesta utilitzar\u00e0; normalment es situen en arxius formant packages, utilitzant un arxiu per v\u00e0ries classes relacionades. 1 2 3 class nomClasse { llista_de_membres } - nomClasse: definit per l\u2019usuari i identifica la classe; pot incloure lletres, n\u00fameros i subratllats com qualsevol identificador. - llista_de_membres: s\u00f3n els m\u00e8todes i atributs de la classe, etc.. M\u00e9s concretament, una classe es podria definir de la seg\u00fcent manera: 1 2 3 4 5 6 7 class nomClasse { llista_de_constants ; llista_de_atributs ; constructor_de_classe ; constructor_de_c\u00f2pia ; m\u00e8todes ; } En realitat si la definici\u00f3 de les parts de la classe es fera en un altre ordre, no afectaria a la compilaci\u00f3 i execuci\u00f3 d\u2019aquesta per\u00f2 s\u00ed a la lectura del codi i el faria m\u00e9s complicat d\u2019interpretar. Exemple RockCase Cantant Guitarra 1 2 3 4 5 6 7 8 class Cantant { String nom ; String cognom ; String nick ; String dataNaixement ; String micro ; String registre ; } 1 2 3 4 5 6 7 8 9 10 class Guitarra { String nom ; String cognom ; String nick ; String dataNaixement ; String model ; String ampli ; } // Fes tu les altres dues classes Activitat 602. Defineix les classes del Projecte Agenda Problema Soluci\u00f3 Obre Processing IDE i declara les classes resultants de l'activitat 601. Recorda que totes les caracter\u00edstiques i accions que hages anotat a l'activitat anterior hauran de convertir-se en atributs i m\u00e8todes de les classes que dissenyes. Guarda el fitxer com a ProjecteAgenda.pde Encara no disponible. Visibilitat dels membres de la classe Un principi fonamental en la programaci\u00f3 orientada a objectes \u00e9s l\u2019ocultaci\u00f3 de la informaci\u00f3, a\u00e7\u00f2 significa que no es pot accedir per m\u00e8todes externs de la classe a determinada informaci\u00f3 interna. El mecanisme principal per aconseguir-ho \u00e9s posar-los dins d\u2019una classe i fer-los privats i aix\u00ed nom\u00e9s es podr\u00e0 accedir a aquests des de dins de la classe Existeixen tres diferents especificacions d\u2019acc\u00e9s o modificadors de visibilitat: public (+): un m\u00e8tode o atribut t\u00e9 una visibilitat p\u00fablica quan totes les dem\u00e8s classes poden accedir a ells, b\u00e9 siga una altra classe o una subclasse. Private (-): sols es pot accedir a ells des del propi codi de la classe. Protected (#): nom\u00e9s des del propi codi de la classe o de les seues subclasses es pot accedir. Package (~): nom\u00e9s accessible per membres del paquet. Atributs Els atributs s\u00f3n les caracter\u00edstiques individuals que diferencien un objecte d\u2019un altre i determinen la seua aparen\u00e7a, estat o altres qualitats. Els atributs es desen en variables anomenades variables d\u2019inst\u00e0ncia i cada objecte particular pot tindre valors distints per a aquestes variables. Cantant Guitarra 1 2 3 4 5 6 7 8 public class Cantant { private String nom ; private String cognom ; private String nick ; private String dataNaixement ; private String micro ; private String registre ; } 1 2 3 4 5 6 7 8 9 10 public class Guitarra { private String nom ; private String cognom ; private String nick ; private String dataNaixement ; private String model ; private String ampli ; } // Fes tu les altres dues classes Les variables d\u2019inst\u00e0ncia tamb\u00e9 anomenades membres s\u00f3n declarades a la classe per\u00f2 els seus valors son canviats i fixats a l\u2019objectes ja que una classe no \u00e9s m\u00e9s que un esquema que defineix com seran les persones al nostre programa. A m\u00e9s de les variables d\u2019inst\u00e0ncia hi ha variables de classe, les quals s\u2019apliquen a la classe i a totes les inst\u00e0ncies. M\u00e8todes Els m\u00e8tode s\u00f3n aquelles accions que pot realitzar la classe que estem definint. B\u00e0sicament el que fa un m\u00e8tode \u00e9s modificar l\u2019estat de l\u2019objecte mitjan\u00e7ant el canvi del valor dels seus atributs. Continuant amb les classes anteriors, caldria que ens f\u00e9rem les seg\u00fcents q\u00fcestions: quines accions s\u00f3n les que pot realitzar la nostra cantant? i el guitarra? En que afecta eixes accions als atributs que hem escollit per definir-la? A la q\u00fcesti\u00f3 primera dir\u00edem que una cantant pot: cantar, fer falset, calfar i afinar. Per tal d'il\u00b7lustrar el canvi d'estat en l'objecte s'ha afegit un nou atribut octava que ens indica en quina octava est\u00e0 cantant. Aix\u00ed la classe podria quedar aix\u00ed: Cantant Guitarra 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Cantant { private int octava ; // 0: greu, 1: normal, 2:aguda, 3: falset private String nom ; private String cognom ; private String nick ; private String dataNaixement ; private String micro ; private String registre ; public void cantar () { octava = 0 ; } public void ferFalset () { octava = 3 ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Guitarra { private String nom ; private String cognom ; private String nick ; private String dataNaixement ; private String model ; private String ampli ; public void ferSolo () { } public void ferAcompanyament () { } } // Fes tu les altres dues classes Fixeu-se que mentre els atributs de la classe tenen un modificador de visibilitat private, els m\u00e8todes el solen tindre public. Encara que no necess\u00e0riament ha de ser aix\u00ed sempre per\u00f2 \u00e9s molt habitual. En cas de les superclasses que tenen derivades, els atributs solen ser protected. Els m\u00e8todes a Java sempre s\u00f3n membres d\u2019una classe, no hi ha m\u00e8todes o funcions fora d\u2019aquestes. La seua implementaci\u00f3 s\u2019inclou dins del cos de la classe. Exemple: A continuaci\u00f3 modelarem el nostre exemple de banda de rock. Cantant Guitarra 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Cantant { private int octava ; private String nom ; private String cognom ; private String nick ; private String dataNaixement ; private String micro ; private String registre ; public void cantar () { octava = 0 ; } public void ferFalset () { octava = 3 ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Guitarra { private String nom ; private String cognom ; private String nick ; private String dataNaixement ; private String model ; private String ampli ; public void ferSolo () { } public void ferAcompanyament () { } } // Fes tu les altres dues classes Activitat 603. Visibilitat de classes Problema Soluci\u00f3 A partir de les classes que hages dissenyat a l'\u00faltima activitat, assigna-li la visibilitat corresponent a les classes i a cada membre de la classe, b\u00e9 siga un atribut o un m\u00e8tode. Encara no disponible Constructors i inst\u00e0ncies Un constructor \u00e9s un m\u00e8tode membre d\u2019una classe que s\u2019executa de forma autom\u00e0tica quan es crea un instancia d\u2019aquesta. El constructor d\u2019una classe es diferencia de la resta perqu\u00e8 s\u2019ha d\u2019anomenar igual que la classe (respectant maj\u00fascules i min\u00fascules) i mai s\u2019especifica a la seua definici\u00f3 un tipus de dades a retornar encara que siga void. El constructor admet par\u00e0metres, sent un m\u00e8tode que es pot sobrecarregar, \u00e9s a dir, podem tindre diversos constructors amb un nombre diferent de par\u00e0metres o diferents tipus de dades. Els constructors tenen com a finalitat principal la inicialitzaci\u00f3 de les variables o atributs de la classe. No \u00e9s obligatori definir un constructor a cada classe, encara que es sol fer. Aix\u00ed establim els valors que desitgem per quan un atribut de forma autom\u00e0tica a la creaci\u00f3 de l\u2019objecte, en lloc de fer-ho en un altre moment mitjan\u00e7ant altres m\u00e8todes. Cantant Guitarra 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Cantant { private int octava ; private String nom ; private String cognom ; private String nick ; private String dataNaixement ; private String micro ; private String registre ; // Exemple de constructor per defecte sense codi public Cantant () { } public void cantar () { octava = 0 ; } public void ferFalset () { octava = 3 ; } } ```java linenums=\"1\" public class Guitarra { private String nom; private String cognom; private String nick; private String dataNaixement; private String model; private String ampli; public Guitarra () { } // Exemple de constructor parametritzat public Guitarra (String guitarra) { model = guitarra; } public void ferSolo() { } public void ferAcompanyament() { } } // Fes tu les altres dues classes ``` La declaraci\u00f3 d\u2019una classe no \u00e9s m\u00e9s que la definici\u00f3 d\u2019una realitat utilitzant un llenguatge de programaci\u00f3 orientada a objectes. El seg\u00fcent pas seria fer \u00fas d\u2019aquesta definici\u00f3 o classe, \u00e9s a dir, instanciar o crear un objecte a partir d\u2019aquesta classe. Per tal d\u2019instanciar una classe s\u2019utilitza la seg\u00fcent sent\u00e8ncia: 1 nom_classe nom_instancia = new nom_classe ( par\u00e0metres ); La paraula \u00abnew\u00bb s\u2019encarrega de reservar espai en mem\u00f2ria i torna una refer\u00e8ncia a l\u2019adre\u00e7a de mem\u00f2ria on s\u2019ha emmagatzemat l\u2019objecte. nom_classe: en el primer cas \u00e9s el nom de la classe que es vol instanciar. A la segon part es refereix al constructor de la classe que ha de ser igual que el nom d\u2019aquesta. El constructor \u00e9s un m\u00e8tode especial de la classe i com a m\u00e8tode que \u00e9s pot rebre par\u00e0metres. nom_instancia: identificador amb el que s\u2019identificar\u00e0 l\u2019objecte instanciat. L\u2019espai reservat a mem\u00f2ria per un objecte dependr\u00e0 de la quantitat d\u2019elements o membres que continga. Quan un objecte no est\u00e0 siguen referenciat es treu de mem\u00f2ria per tal d\u2019alliberar espai pel \u00abgarbage collector\u00bb Quan creem un objecte d\u2019una classe, cada atribut ser\u00e0 inicialitzat amb els valors per defecte del tipus de dades utilitzat o b\u00e9 pel valor establert al constructor. En el nostre cas treballant amb Processing les instancies dels distints objectes que formen part de la nostra aplicaci\u00f3 les farem des del programa principal. Main Cantant Guitarra 1 2 3 4 5 6 7 8 // Declaraci\u00f3 dels objectes rozalen de classe cantant i slash de classe guitarra Cantant rozalen ; Guitarra slash ; void setup () { rozalen = new Cantant (); // Instanciem la cantant rozalen slash = new Guitarra ( \"Gibson LesPaul\" ); // instanciem el guitarrista slash } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Cantant { private int octava ; private String nom ; private String cognom ; private String nick ; private String dataNaixement ; private String micro ; private String registre ; // Exemple de constructor per defecte sense codi public Cantant () { } public void cantar () { octava = 0 ; } public void ferFalset () { octava = 3 ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Guitarra { private String nom ; private String cognom ; private String nick ; private String dataNaixement ; private String model ; private String ampli ; public Guitarra () { } // Exemple de constructor parametritzat public Guitarra ( String guitarra ) { model = guitarra ; } public void ferSolo () { } public void ferAcompanyament () { } } Activitat 604. Constructors i inst\u00e0ncies Problema Soluci\u00f3 Declara (nom\u00e9s la interf\u00edcie i amb el cos buit) dos constructors, un sense par\u00e0metres i un amb els par\u00e0metres necessaris, per a cada classe que tingues al teu Projecte Agenda. Encara no disponible. Acc\u00e9s als membres de la classe Podrem accedir als membres d\u2019una classe en funci\u00f3 de la seua visibilitat i el lloc on es desitge accedir. Els modificadors de visibilitat s\u00f3n: public, private, protected i internal. Per accedir a un membre de la classe utilitzem el \u00ab.\u00bb (punt): NomClasse.membre Basant-nos en la classe Persona dels punts anteriors farem un programa que instancie un objecte Persona i veurem com s\u2019accedeix als membres de la classes Suposem que persona t\u00e9 un constructor de la classe al qual li passem els seg\u00fcents par\u00e0metres: DNI, nom, cognom, estatura, pes i color del p\u00e8l. Main Cantant Guitarra 1 2 3 4 5 6 7 8 9 10 11 12 13 // Declaraci\u00f3 dels objectes rozalen de classe cantant i slash de classe guitarra Cantant rozalen ; Guitarra slash ; void setup () { rozalen = new Cantant (); slash = new Guitarra ( \"Gibson LesPaul\" ); } void draw () { rozalen . canta (); slash . ferAcompanyament (); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Cantant { private int octava ; private String nom ; private String cognom ; private String nick ; private String dataNaixement ; private String micro ; private String registre ; // Exemple de constructor per defecte sense codi public Cantant () { } public void cantar () { octava = 0 ; } public void ferFalset () { octava = 3 ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Guitarra { private String nom ; private String cognom ; private String nick ; private String dataNaixement ; private String model ; private String ampli ; public Guitarra () { } // Exemple de constructor parametritzat public Guitarra ( String guitarra ) { model = guitarra ; } public void ferSolo () { } public void ferAcompanyament () { } } Tanmateix no podr\u00edem accedir als membres privats de la classe des de fora, per exemple, no podr\u00edem fer vicent.nom= \u00abAntonio\u00bb ja que nom \u00e9s un membre privat. Activitat 605. Dissenya el constructor parametritzat Problema Soluci\u00f3 Implementa amb codi el constructor parametritzat de l'activitat anterior. Despr\u00e9s al programa principal, instancia una agenda amb almenys un contacte que continga informaci\u00f3. Encara no disponible. La paraula reservada 'this' La paraula reservada \u00abthis\u00bb s\u2019utilitza per fer refer\u00e8ncia a l\u2019objecte actual. Si est\u00e0s dissenyant una classe, \u00abthis\u00bb fa refer\u00e8ncia a la pr\u00f2pia classe. Quan es crida a un m\u00e8tode, es passa autom\u00e0ticament un argument impl\u00edcit que \u00e9s una refer\u00e8ncia a l\u2019objecte invocat, \u00e9s a dir, l\u2019objecte sobre el que es crida al m\u00e8tode. Aquesta refer\u00e8ncia \u00e9s \u00abthis\u00bb. Amb els atributs de la classe tamb\u00e9 passa el mateix. Per comprendre-ho millor, mirem el seg\u00fcent exemple: 1 2 3 4 5 6 7 8 9 10 11 public class Cantant { public String nom ; public String cognom ; public String nick ; public Cantant ( String nom , String cognom , String nick ) { this . nom = nom ; this . cognom = cognom ; this . nick = nick ; } } Aquesta paraula clau sol utilitzar-se quan hi han b\u00e9 m\u00e8todes o atributs (membres) a dues classes diferents amb el mateix nom per exemple. M\u00e8todes, variables i blocs statics La paraula reservada \u00abstatic\u00bb en Java \u00e9s un modificador que en Java es pot aplicar a variables, m\u00e8todes, classes i blocs de codi Variables est\u00e0tiques Una variable est\u00e0tica (static) \u00e9s una variable que pertany a la classe en la que va ser declarada i s\u2019inicialitza nom\u00e9s una vegada a l\u2019inici de l\u2019execuci\u00f3 del programa, la caracter\u00edstica principal d\u2019aquest tipus de variables \u00e9s que es pot accedir directament amb el nom de la classe sense necessitat d\u2019instanciar un objecte. A banda tamb\u00e9: \u00c9s una variable que pertany a la classe (variable de classe) i no a l\u2019objecte. Les variables static s\u2019inicialitzen nom\u00e9s una vegada, a l\u2019inici de l\u2019execuci\u00f3. Aquestes variables s\u2019inicialitzaran primer abans de la inicialitzaci\u00f3 de qualsevol variable d\u2019inst\u00e0ncia. M\u00e8todes est\u00e0tics Un m\u00e8tode est\u00e0tic nom\u00e9s pot accedir a les variables o tipus de dades est\u00e0tiques i no pot accedir a les dades no est\u00e0tiques. Un m\u00e8tode est\u00e0tic nom\u00e9s pot accedir a dades est\u00e0tiques. No pot accedir a dades no est\u00e0tiques (variables d\u2019inst\u00e0ncia) Un m\u00e8tode est\u00e0tic pot cridar nom\u00e9s a m\u00e8todes est\u00e0tics i no pot invocar un m\u00e8tode no est\u00e0tic a partir d\u2019ell. Un m\u00e8tode est\u00e0tic es pot accedir directament pel nom de la classe i no es necessita crear un objecte per accedir al m\u00e8tode. Un m\u00e8tode est\u00e0tic no pot fer refer\u00e8ncia a \u00abthis\u00bb o \u00absuper\u00bb Blocs est\u00e0tics El bloc est\u00e0tic \u00e9s un bloc d\u2019instruccions dins de la classe (static { ... }) que s\u2019executa quan una classe es carrega per primera vegada en la m\u00e0quina virtual de Java (JVM). B\u00e0sicament un bloc est\u00e0tic inicialitza variables de tipus est\u00e0tic dins d\u2019una classe, de la mateixa forma que un constructor de classe ajuden a inicialitzar les variables d\u2019inst\u00e0ncia, un bloc est\u00e0tic inicialitza les variables tipus static de la classe. Activitat 606. Projecte Agenda Problema Soluci\u00f3 Finalitza el projecte de l'agenda amb totes les classes i m\u00e8todes implementats. Encara no disponible. Sobrec\u00e0rrega d'operadors En Java \u00e9s possible sobrecarregar m\u00e8todes, \u00e9s dir, definir dos o m\u00e9s dins de la mateixa classe, que comparteix nombre i que les declaracions dels seus par\u00e0metres s\u00f3n diferents; la sobrec\u00e0rrega \u00e9s una forma de polimorfisme. En les cridades als m\u00e8todes sobrecarregats, el compilador determina quin \u00e9s el m\u00e8tode invocat basant-se en el nombre i tipus d\u2019arguments passats; per tant, els m\u00e8todes sobrecarregats han de diferir en nombre i tipus de par\u00e0metres. Quan Java troba una trucada a un m\u00e8tode sobrecarregat, s\u2019executa la versi\u00f3 del que t\u00e9 par\u00e0metres (n\u00famero i tipus) que coincideixen amb els arguments utilitzats en la trucada. Sobrecarrega de constructors En Java es possible sobrecarregar m\u00e8todes, \u00e9s dir, definir dos o m\u00e9s dins de la mateixa classe, que comparteixen nombre i que les declaracions dels seus par\u00e0metres s\u00f3n diferents; la sobrec\u00e0rrega \u00e9s una forma de polimorfisme. La classe descriu un conjunt d'objectes amb les mateixes propietats i comportament; quan l\u2019objecte es crea, es inicialitza amb valors predeterminats o amb els que es transmeten en el moment de la inst\u00e0ncia; el m\u00e8tode que realitza la inicialitzaci\u00f3 de l\u2019objecte \u00e9s el constructor, aquest t\u00e9 el mateix nombre que la classe i no t\u00e9 tipus de retorn. A m\u00e9s de la sobrec\u00e0rrega de m\u00e8todes normals, es poden sobrecarregar els constructors; estos \u00faltims normalment es sobrecarregaran a la majoria de les classes creades, encara que no es regla; fins i tot una classe pot definir-se sense constructor i, per extensi\u00f3, sense arguments.","title":"6.- Prog Orientada Objectes"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#tema-6-programacio-orientada-a-objectes","text":"","title":"Tema 6. Programaci\u00f3 Orientada a Objectes."},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#introduccio","text":"La programaci\u00f3 orientada a objectes tamb\u00e9 coneguda com POO \u00e9s el paradigma de programaci\u00f3 que m\u00e9s s\u2019utilitza hui en dia i que permet modelar de manera m\u00e9s eficient la realitat des del punt de vista del programari. La programaci\u00f3 orientada a objectes intenta proporcionar un model de programaci\u00f3 basat en objectes que contenen dades i procediments associats coneguts com a m\u00e8todes a difer\u00e8ncia del disseny procedimental que s'utilitzava en la programaci\u00f3 estructurada. Aquests objectes , que s\u00f3n inst\u00e0ncies de les classes , s\u00f3n tipus abstractes de dades que encapsulen (amaguen) tant les dades com les funcions per accedir-hi. Un dels objectius de la programaci\u00f3 orientada a objectes \u00e9s reflectir la realitat, de forma que els elements d\u2019un programa s\u2019ajusten a elements de la vida quotidiana. Per exemple, suposem que volem realitzar una aplicaci\u00f3 per una banda de rock a la que li direm RockCase . En un programa estructurat definir\u00edem funcions independentment de les dades, tal que per un costat creariem el codi de les funcions i posteriorment, al programa principal, s'establirien les dades en forma de variables sobre les que s'aplicarien els canvis. \u00c9s a dir, es farien els diagrames de flux corresponents utilitzant les estructures vistes al teorema de programaci\u00f3 estructurada a cadascun dels procediments que li suposem a la nostra aplicaci\u00f3 i els programariem en el llenguatge de programaci\u00f3 corresponent. Per exemple, una banda de rock pot tocar un tema (procediment) que al final no \u00e9s m\u00e9s que una successi\u00f3 (estructura seq\u00fcencial) de sons, instruments i parts de la can\u00e7\u00f3 que es toquen seguint una l\u00f2gica fins que acaba la can\u00e7\u00f3. En canvi en POO es dona prioritat a la modelaci\u00f3 de les dades i no als procediments. En un escenari de programaci\u00f3 orientada a objectes, a la fase d'an\u00e0lisi es determinen els diferents actors del programa (objectes) i a partir d'ac\u00ed se li assignen els diferents atributs i accions que pot realitzar. Per\u00f2 veiem-ho amb l'exemple del RockCase . Si ens parem a analitzar la nostra aplicaci\u00f3, arribarem a la conclusi\u00f3 que un dels objectes m\u00e9s importants seran els m\u00fasics. \u00c9s a dir, la nostra aplicaci\u00f3 b\u00e0sicament \u00e9s uh conjunt de m\u00fasics amb una s\u00e8rie de caracter\u00edstiques o atributs i que poden realitzar una s\u00e8rie d'accions (tocar, ferSolos, cantar, etc..). Doncs b\u00e9, a difer\u00e8ncia del paradigma de programaci\u00f3 estructurada, ac\u00ed programarem primer els objectes (definirem les classes) i despr\u00e9s els utilitzarem al programa principal. En aquesta aplicaci\u00f3 ens podriem trobar els seg\u00fcents objectes: bateria, baix, guitarra i cantant. La programaci\u00f3 orientada a objectes permet la creaci\u00f3 de programari cada vegada m\u00e9s complexe a partir d\u2019unitats o blocs de codi reutilitzables.","title":"Introducci\u00f3"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#caracteristiques-principals","text":"Les propietats principals o caracter\u00edstiques fonamentals del paradigma de programaci\u00f3 orientada a objectes s\u00f3n:","title":"Caracter\u00edstiques principals"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#realitzacio-de-programes-orientats-a-objectes","text":"A partir d\u2019ara, quan hajam de resoldre un problema hem de comen\u00e7ar a pensar d\u2019una forma diferent a la que est\u00e0vem fent fins ara. En programaci\u00f3 orientada a objectes seguirem usant els mecanismes de programaci\u00f3 estructurada com ara sent\u00e8ncies repetitives, alternatives, etc.. tanmateix hem de plantejar un sistema on les dades presenten una major import\u00e0ncia. L\u2019objectiu de l\u2019orientaci\u00f3 a objectes \u00e9s plasmar la realitat de manera que programem els elements el m\u00e9s pr\u00f2xim possible a com els veiem al seu entorn natural. Aix\u00ed, quan hajam d\u2019encarar un problema d\u2019aquest tipus: Ens preguntarem sobre aquells elements dels que realment es interessant emmagatzemar informaci\u00f3, \u00e9s a dir, localitzarem els possibles objectes del nostre programa. De cada element hem de con\u00e8ixer quines s\u00f3n les seues caracter\u00edstiques o quines s\u00f3n les caracter\u00edstiques que el representen. De cada element hem de con\u00e8ixer les operacions a realitzar , accions que hi poden fer, ja que cada conjunt de dades permetr\u00e0 la realitzaci\u00f3 d\u2019un conjunt d\u2019operacions. Finalment, desenvoluparem un entorn on utilitzarem els elements configurats. Per exemple, a l'hora de desenvolupar l'aplicaci\u00f3, podem resoldre les seg\u00fcents q\u00fcestions per determinar els elements que inclourem: 1. Quins elements de la nostra aplicaci\u00f3 han de ser desats o s'han de tenir en compte? - Les distintes tipus de m\u00fasics que formen la nostra banda 2. De cada element, quines dades ens interessen? - Persona: nom, cognoms, foto - Baix: - Guitarra: - Cantant: - Bateria: 3. A cada element, quines operacions associarem? - El cantant canta, el baix toca, el guitarra fa solos i acompanyaments i el bateria toca i fa solos de bateria. Pel que fa a l\u2019aplicaci\u00f3 principal que utilitze aquests objectes, podem plantejar un programa que emmagatzeme de forma din\u00e0mica les persones i estructurar la funcionalitat mitjan\u00e7ant un men\u00fa d\u2019opcions que permeta utilitzar les operacions anteriorment plantejades per a cada objecte. El diagrama de classes que deduir\u00edem de les especificacions anteriors podria ser el seg\u00fcent: classDiagram Persona < |-- Bateria Persona < |-- Cantant Persona < |-- Baix Persona < |-- Guitarra Persona: nom Persona: cognom Persona: nick Persona: foto Bateria: marcaBateria Bateria: repicar() Bateria: ferSolo() Cantant: tipusMicro Cantant: cantar() Baix: amplificador Baix: tocarBaix() Baix: ferSlap() Guitarra: nomGuitarra Guitarra: amplificador Guitarra: tocarSolo() Guitarra: tocarQuintes() Guitarra: ferAcompanyament() Activitat 601. Projecte Agenda Problema Soluci\u00f3 En aquest tema i per tal de comen\u00e7ar a treballar amb classes i objectes, desenvoluparem una xicoteta aplicaci\u00f3 de gesti\u00f3 de contactes personals. El que es pret\u00e9n \u00e9s poder administrar un recull de contactes a mode d'agenda personal. De cada contacte es necessitaria saber la seg\u00fcent informaci\u00f3: Nom Cognoms Tel\u00e8fon Correu electr\u00f2nic A l'iniciar-se la nostra aplicaci\u00f3 es carregaran un m\u00ednim de cinc contactes que emmagatzemarem en un array. Mentre a la pantalla principal es mostrar\u00e0 un men\u00fa amb les accions que es poden realitzar en la nostra app: Llistar contactes Buscar contacte Editar contacte Afegir contacte Esborrar contacte Fes una an\u00e0lisi semblant a la que hem fet al taller i especifica els requeriments de la teua aplicaci\u00f3 a m\u00e9s a m\u00e9s de localitzar les classes que penses que tindr\u00e0 l'aplicaci\u00f3. Quants objectes diferents hi ha? Quines s\u00f3n les seues caracter\u00edstiques principals? Quines accions poden realitzar cada objecte? Quines relacions hi ha entre els objectes? Dibuixa primer un diagrama de classes el m\u00e9s detallat possible. No disponible encara.","title":"Realitzaci\u00f3 de programes orientats a objectes"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#classes-i-objectes","text":"Una classe \u00e9s la definici\u00f3 d\u2019un objecte , \u00e9s l\u2019element que descriu els components d\u2019un objecte de forma general. Diem que hem creat un objecte quan donem valors i utilitzem els components definits a la classe. Per exemple, si continuem utilitzant la nostra app RockCase , una classe seria Persona en la que es descriu de forma general aquest element. S'establiria que la persona es caracteritzaria per: Tindre un nom Tindre un cognom Tindre uns nick Tindre una foto Ara b\u00e9, si al nostre programa mostrem informaci\u00f3 d'una persona concreta, les caracter\u00edstiques abans esmentades adopten certs valors: Nom: Braulio Cognom: Estrella nick: GraveRaiser Foto: image Aix\u00ed per un costat tenim la classe Persona i per l'altre l'objecte \"Braulio\" Alhora de crear una classe definim el que denominem propietats o atributs i m\u00e8todes de classe. Atributs: una caracter\u00edstica concreta d\u2019un objecte de la vida quotidiana. Quan s\u2019estableix un atribut a una classe, es defineix com quan cre\u00e0vem variables als nostres programes estructurats, indicant tipus de dades i nom amb el que el reconeixem. M\u00e8todes de la classe: donen funcionalitat a la classe, \u00e9s a dir, reflecteixen les operacions que aquesta pot fer sobre els atributs. Els m\u00e8todes s\u00f3n similars a les funcions o procediments que cre\u00e0vem en programaci\u00f3 estructurada per\u00f2 orientats a modificar i actuar sobre les propietats d\u2019una classe. Un objecte dona valors concrets als atributs que defineix la classe i utilitza els seus m\u00e8todes. Quan un objecte utilitza un m\u00e8tode concret es diu que aquesta enviant un missatge. D\u2019alguna manera a\u00e7\u00f2 t\u00e9 l\u00f2gica ja que estem donant una ordre a un component que reflecteix la realitat. Si a la nostra aplicaci\u00f3 de les bandes de rock volem mostrar la informaci\u00f3 d'una persona li estem enviant un missatge a la persona per tal que mostre la info per pantalla. A l'hora d'enviar un missatge a un objecte concret utilitzarem l'operador punt, per exemple: braulio.mostraInfo(). A sovint donem el nom d\u2019estat als valors que en un objecte t\u00e9 en un moment concret de la vida del programa on s\u2019est\u00e0 utilitzant. A m\u00e9s a m\u00e9s, quan creem un objecte, donem valors a les propietats de la classe, diem que estem instanciant aquesta classe.","title":"Classes i Objectes"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#definicio-de-classes-en-java","text":"Una vegada ja sabem que s\u00f3n les classes i els objectes veurem com es defineixen classes i instancien objectes en el llenguatge Java. Per tal de fer m\u00e9s gr\u00e0fica aquesta part de la teoria, seguirem usant l'aplicaci\u00f3 RockCase encara que un poc adaptada. Oblidem-nos de l'her\u00e8ncia i la jerarquia de moment i ho deixem per al pr\u00f2xim tema. Suposem que tenim quatre classes diferents: Cantant, Guitarra, Baix i Bateria com mostra el seg\u00fcent diagrama de classes: classDiagram Cantant: nom Cantant: cognom Cantant: nick Cantant: micro Cantant: registre Cantant: canta() Cantant: ferFalset() Guitarra: nom Guitarra: cognom Guitarra: nick Guitarra: model Guitarra: ampli Guitarra: tocaSolo() Guitarra: tocaAcopanyament() Baix: nom Baix: cognom Baix: nick Baix: model Baix: ampli Baix: toca() Baix: fesSlap() Bateria: nom Bateria: cognom Bateria: nick Bateria: marca Bateria: toca() Bateria: tocaSolo() Definir una classe implica donar-li nom a ella i als elements que emmagatzemen la seua informaci\u00f3, aix\u00ed com tamb\u00e9 descriure els m\u00e8todes que realitzaran les accions considerades als objectes. Les definicions o especificacions no constitueixen un codi de programa executable si no que s\u2019utilitzen per assignar mem\u00f2ria on emmagatzemar els valors dels atributs que utilitza el programa i recon\u00e8ixer els m\u00e8todes que aquesta utilitzar\u00e0; normalment es situen en arxius formant packages, utilitzant un arxiu per v\u00e0ries classes relacionades. 1 2 3 class nomClasse { llista_de_membres } - nomClasse: definit per l\u2019usuari i identifica la classe; pot incloure lletres, n\u00fameros i subratllats com qualsevol identificador. - llista_de_membres: s\u00f3n els m\u00e8todes i atributs de la classe, etc.. M\u00e9s concretament, una classe es podria definir de la seg\u00fcent manera: 1 2 3 4 5 6 7 class nomClasse { llista_de_constants ; llista_de_atributs ; constructor_de_classe ; constructor_de_c\u00f2pia ; m\u00e8todes ; } En realitat si la definici\u00f3 de les parts de la classe es fera en un altre ordre, no afectaria a la compilaci\u00f3 i execuci\u00f3 d\u2019aquesta per\u00f2 s\u00ed a la lectura del codi i el faria m\u00e9s complicat d\u2019interpretar. Exemple RockCase Cantant Guitarra 1 2 3 4 5 6 7 8 class Cantant { String nom ; String cognom ; String nick ; String dataNaixement ; String micro ; String registre ; } 1 2 3 4 5 6 7 8 9 10 class Guitarra { String nom ; String cognom ; String nick ; String dataNaixement ; String model ; String ampli ; } // Fes tu les altres dues classes Activitat 602. Defineix les classes del Projecte Agenda Problema Soluci\u00f3 Obre Processing IDE i declara les classes resultants de l'activitat 601. Recorda que totes les caracter\u00edstiques i accions que hages anotat a l'activitat anterior hauran de convertir-se en atributs i m\u00e8todes de les classes que dissenyes. Guarda el fitxer com a ProjecteAgenda.pde Encara no disponible.","title":"Definici\u00f3 de classes en Java"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#la-paraula-reservada-this","text":"La paraula reservada \u00abthis\u00bb s\u2019utilitza per fer refer\u00e8ncia a l\u2019objecte actual. Si est\u00e0s dissenyant una classe, \u00abthis\u00bb fa refer\u00e8ncia a la pr\u00f2pia classe. Quan es crida a un m\u00e8tode, es passa autom\u00e0ticament un argument impl\u00edcit que \u00e9s una refer\u00e8ncia a l\u2019objecte invocat, \u00e9s a dir, l\u2019objecte sobre el que es crida al m\u00e8tode. Aquesta refer\u00e8ncia \u00e9s \u00abthis\u00bb. Amb els atributs de la classe tamb\u00e9 passa el mateix. Per comprendre-ho millor, mirem el seg\u00fcent exemple: 1 2 3 4 5 6 7 8 9 10 11 public class Cantant { public String nom ; public String cognom ; public String nick ; public Cantant ( String nom , String cognom , String nick ) { this . nom = nom ; this . cognom = cognom ; this . nick = nick ; } } Aquesta paraula clau sol utilitzar-se quan hi han b\u00e9 m\u00e8todes o atributs (membres) a dues classes diferents amb el mateix nom per exemple.","title":"La paraula reservada 'this'"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#metodes-variables-i-blocs-statics","text":"La paraula reservada \u00abstatic\u00bb en Java \u00e9s un modificador que en Java es pot aplicar a variables, m\u00e8todes, classes i blocs de codi","title":"M\u00e8todes, variables i blocs statics"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#sobrecarrega-doperadors","text":"En Java \u00e9s possible sobrecarregar m\u00e8todes, \u00e9s dir, definir dos o m\u00e9s dins de la mateixa classe, que comparteix nombre i que les declaracions dels seus par\u00e0metres s\u00f3n diferents; la sobrec\u00e0rrega \u00e9s una forma de polimorfisme. En les cridades als m\u00e8todes sobrecarregats, el compilador determina quin \u00e9s el m\u00e8tode invocat basant-se en el nombre i tipus d\u2019arguments passats; per tant, els m\u00e8todes sobrecarregats han de diferir en nombre i tipus de par\u00e0metres. Quan Java troba una trucada a un m\u00e8tode sobrecarregat, s\u2019executa la versi\u00f3 del que t\u00e9 par\u00e0metres (n\u00famero i tipus) que coincideixen amb els arguments utilitzats en la trucada.","title":"Sobrec\u00e0rrega d'operadors"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/","text":"Tema 7. Her\u00e8ncia, polimorfisme i interf\u00edcies Introducci\u00f3 Un dels mecanismes m\u00e9s potents que incorpora el paradigma de programaci\u00f3 orientada a objectes s\u00f3n l\u2019her\u00e8ncia i el polimorfisme. El primer ens permet crear una jerarquia de classes relacionades entre s\u00ed de tal forma que la quantitat de codi, especialment el codi redundant, es redueix significativament. El segon permet redefinir m\u00e8todes de tal forma que realitzen funcions diferents depenent del context en el qual es troben. En altres paraules, el polimorfisme \u00e9s el mecanisme de la programaci\u00f3 orientada a objectes que permet que una funci\u00f3 amb el mateix nom realitze tasques diferents depenent de l\u2019objecte des del qual es fa refer\u00e8ncia. Finalment tamb\u00e9 veurem com a les interf\u00edcies podrem especificar les operacions que haurien de definir-se a les classes que la implementen. Una interf\u00edcie \u00e9s un mitj\u00e0 per a que els objectes no relacionats es comuniquen entres s\u00ed. Aquestes s\u00f3n les definicions de m\u00e8todes i valors sobre els quals els objectes estan d\u2019acord per cooperar. Her\u00e8ncia En programaci\u00f3 orientada a objectes l\u2019her\u00e8ncia \u00e9s un mecanisme que permet potenciar la reutilitzaci\u00f3 i l\u2019extensibilitat en el desenvolupament de programari a banda de reduir la quantitat de codi redundant. Aquest mecanisme permet crear noves classes a partir d\u2019una classe o jerarquia de classes preexistent (ja comprovades i verificades) evitant d\u2019aquesta forma el redisseny, la modificaci\u00f3 i verificaci\u00f3 de la part ja implementada. L\u2019her\u00e8ncia facilita la creaci\u00f3 d\u2019objectes a partir d\u2019altres ja existents i implica que una subclasse obt\u00e9 tot el comportament (m\u00e8todes) i finalment els atributs (variables) de la seua superclasse. En aquest tema veurem com Java implementa el mecanisme de l\u2019her\u00e8ncia i quines s\u00f3n les opcions que ens dona. Suposem el cas en el que disposem de dues classes (amb menys classes resultaria impossible l\u2019her\u00e8ncia), una s\u2019anomenar\u00e0: classe base, superclasse o classe pare; mentre que l\u2019altra ser\u00e0 la classe derivada, subclasse o classe filla. En el nostre cas la classe pare, superclasse o classe base ser\u00e0 \u00abInstrument\u00bb i la classe derivada, filla o subclasse ser\u00e0 \u00abGuitarra\u00bb que en llenguatge natural es podria traduir com que una guitarra \u00e9s un tipus d\u2019instrument. La classe base en una jerarquia d\u2019her\u00e8ncia \u00e9s la classe que cont\u00e9 els atributs i m\u00e8todes comuns a totes les classes derivades i \u00e9s per aix\u00f2 que s\u2019evita la redund\u00e0ncia del codi que es produiria si hagu\u00e9rem de repetir codi com\u00fa a cadascuna de les subclasses, per tant, es podria deduir que una classe derivada \u00e9s de facto una ampliaci\u00f3 de les funcionalitats de la classe base ja que contindr\u00e0 tant els membres de la classe base com els que s'afegeixen de m\u00e9s a la classe derivada. Declaraci\u00f3 d'una classe derivada Per tal de declarar que una classe hereta d\u2019una altra, Java utilitza la paraula reservada \u2018extends\u2019. Mira l\u2019exemple seg\u00fcent: 1 2 3 public class Guitarra extends Instrument { } Afegim al nostre exemple dos instruments m\u00e9s; un baix i un teclat. El diagrama de classes quedaria aix\u00ed: El codi en Java resultant seria el seg\u00fcent: 1 2 3 4 5 6 7 8 9 10 11 public class Instrument { } public class Guitarra extends Instrument { } public class Baix extends Instrument { } Respecte de la visibilitat dels membre de la superclasse, les subclasses tindran acc\u00e9s als membres, siguen atributs o m\u00e8todes, public o protected mentre que no heretaran els membres privats de la classe pare. Disseny de subclasses Dissenyar \u00e9s adaptar la realitat que es vol representar a un model concret, en el nostre cas els diagrames de classes d\u2019UML. \u00c9s en aquest pas en el que s\u2019han de prendre les decisions que poden condicionar el resultat final de la nostra aplicaci\u00f3 i no sempre \u00e9s f\u00e0cil determinar quines s\u00f3n les relacions que s\u2019han d\u2019establir. \u00c9s per aix\u00f2 que cal tenir en ment sempre la seg\u00fcent m\u00e0xima: \u00abLa jerarquia de classes m\u00e9s eficient i efectiva \u00e9s aquella que minimitza el codi al redundant al m\u00e0xim i simplifica el codi\u00bb Al utilitzar el mecanisme de l\u2019her\u00e8ncia en programaci\u00f3 orientada a objectes hem d\u2019intentar sempre tindre un m\u00e0xim de membres a la superclasse i despr\u00e9s a les diferents subclasses nom\u00e9s aquells membres o atributs que fan de discriminador, \u00e9s a dir, que diferencien la classe especialitzada (o subclasse) de la classe superior. Ampliem el nostre exemple de banda de rock anterior i afegim atributs i membres a totes les classes. Per exemple cada instrument tindr\u00e0 amo, any, tipus, marca, model i clau d\u2019afinaci\u00f3. A m\u00e9s a m\u00e9s, podr\u00e0 afinar i tocar. Ja m\u00e9s espec\u00edficament d\u2019una bateria hem de saber el total de Toms que t\u00e9, el total de pedals (hi ha bateries amb doble pedal) i el total de plats a banda de poder tocar un redoble. D\u2019una guitarra hem d\u2019especificar quin ampli utilitza i quantes cordes t\u00e9 (pot tenir-ne fins 12). Finalment pel que fa al teclat, sabrem el nombre de tecles que t\u00e9 i podr\u00e0 tocar melodies. El codi resultant d\u2019aquest disseny seria el seg\u00fcent: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 public class Instrument { public Instrument () { } private String amo ; protected int any ; protected String marca ; protected String model ; protected String clauAfinacio ; public void afinar ( ) { } public void tocar ( ) { } } public class Guitarra extends Instrument { public Guitarra ( ) { } private int numCordes ; private String ampli ; public void ferSolo () { } } public class Teclat extends Instrument { public Teclat () { } private int totalTecles ; public void tocarMelodia () { } } public class Bateria extends Instrument { public Bateria () { } private int totalToms ; private int pedals ; private int totalPlats ; public void ferRedoble () { } } Del codi anterior es pot extreure la seg\u00fcent informaci\u00f3: Amo \u00e9s un atribut que no hereta cap subclasse al ser privat. Totes les subclasses tindran acc\u00e9s, encara que al codi no estiga, a any, marca, model i clauAfinaci\u00f3. Totes les subclasses quan criden als m\u00e8todes afinar i tocar, executaran el codi que hi ha a la superclasse sempre que no es s\u2019indique el contrari (sobrec\u00e0rrega) Guitarra i Bateria no tenen acc\u00e9s a l\u2019atribut totalTecles. Teclat i Bateria no tenen poden fer solos. Sobrec\u00e0rrega de m\u00e8todes a la classe derivada La sobrec\u00e0rrega de m\u00e8todes \u00e9s la creaci\u00f3 de diversos m\u00e8todes amb el mateix nom per\u00f2 amb diferent llista de tipus de par\u00e0metres. Java diferencia entre els m\u00e8todes sobrecarregats en base al n\u00famero i tipus de par\u00e0metres o arguments que t\u00e9 el m\u00e8tode i no pel tipus que retorna. classe derivada pot redefinir un m\u00e8tode de la classe base amb el mateix nom per\u00f2 una llista diferent d\u2019arguments Si pel contrari tenim un mateix m\u00e8tode amb el mateix nom i la mateixa signatura (els mateixos par\u00e0metres) el que estem fent es sobreescriure (overridint) i no sobrecarregar (overloading) Seguint amb l\u2019exemple de la nostra banda de rock mireu el seg\u00fcent codi: Com es pot observar a la imatge anterior hi ha una sobrecarrega del m\u00e8tode afinar a cada classe derivada perqu\u00e8 seria el mateix que el de la classe pare per\u00f2 amb diferents par\u00e0metres mentre que el m\u00e8tode tocar est\u00e0 sobreescrit ja que la interf\u00edcie \u00e9s id\u00e8ntica. En codi podria quedar de la seg\u00fcent forma: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 public class Instrument { public Instrument () { } private String amo ; protected int any ; protected String marca ; protected String model ; protected String clauAfinacio ; public void afinar ( ) { System . out . println ( \"Afinar la superclasse\" ); } public void tocar ( ) { System . out . println ( \"Tocar instrument\" ); } } public class Guitarra extends Instrument { public Guitarra ( ) { } private int numCordes ; private String ampli ; public void ferSolo () { } public void tocar ( ) { System . out . println ( \"Tocar Guitarra\" ); } public void afinar ( char clau ) { System . out . println ( \"Afinar guitarra en clau \" + clau ); } } public class Teclat extends Instrument { public Teclat () { } private int totalTecles ; public void tocarMelodia () { } public void tocar ( ) { System . out . println ( \"Tocar Teclat\" ); } public void afinar ( char clau ) { System . out . println ( \"Afinar teclat en clau \" + clau ); } } public class Bateria extends Instrument { public Bateria () { } private int totalToms ; private int pedals ; private int totalPlats ; public void ferRedoble () { } public void tocar ( ) { System . out . println ( \"Tocar Bateria\" ); } public void afinar ( char clau ) { System . out . println ( \"Afinar bateria en clau \" + clau ); } } Her\u00e8ncia p\u00fablica En Java tenim la possibilitat de fer protected (#) private (-) public (+) i package (~) ens determina la visibilitat dels membres d\u2019una classe. Java considera que l\u2019her\u00e8ncia \u00e9s sempre p\u00fablica i que la classe derivada tindr\u00e0 per tant acc\u00e9s als membres protected i public de la classe pare per\u00f2 no als membres privats. El fet de poder tindre elements privats a la nostra classe base seria per poder ocultar informaci\u00f3 a les classes derivades. Constructors en her\u00e8ncia De la mateixa manera que s\u2019hereten m\u00e8todes i atributs tamb\u00e9 s\u2019hereten els constructors de la classe. D\u2019aquesta forma si declarem un objecte d\u2019una classe derivada, primer s\u2019executa el constructor de la classe base i a continuaci\u00f3 s\u2019executa la part de codi de la classe derivada. Continuant amb la nostra banda de rock farem algunes modificacions. Afegim un constructor parametritzat a la classe instrument que s\u2019encarregar\u00e0 d\u2019inicialitzar els atributs amo, any, marca i model. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class Instrument { private String amo ; protected int any ; protected String marca ; protected String model ; protected String clauAfinacio ; public Instrument () { } public Instrument ( String strAmo , int iAny , String strMarca , String strModel ) { this . amo = strAmo ; this . any = iAny ; this . marca = strMarca ; this . model = strModel ; } public void afinar ( ) { System . out . println ( \"Afinar la superclasse\" ); } public void tocar ( ) { System . out . println ( \"Tocar instrument\" ); } } Per l\u2019altre costat a la classe Guitarra hi afegim tamb\u00e9 un nou constructor (sobrecarregat) amb els par\u00e0metres: amo, any, marca, model, n\u00famero de cordes i l\u2019amplificador que utilitza. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class Guitarra extends Instrument { private int numCordes ; private String ampli ; public Guitarra ( ) { } public Guitarra ( String strAmo , int iAny , String strMarca , String strModel , int iCordes , String strAmpli ) { super ( strAmo , iAny , strMarca , strModel ); this . numCordes = iCordes ; this . ampli = strAmpli ; } public void ferSolo () { } public void tocar ( ) { System . out . println ( \"Tocar Guitarra\" ); } public void afinar ( char clau ) { System . out . println ( \"Afinar guitarra en clau \" + clau ); } } Amb aquest disseny de classes podr\u00edem per exemple executar el seg\u00fcent codi 1 2 3 4 5 6 7 public class Test { public static void main ( String [] args ) { Guitarra lesPaul = new Guitarra ( \"Vicent\" , 2007 , \"Gibson\" , \"LesPaul\" , 6 , \"Marshall\" ); lesPaul . afinar ( 'R' ); lesPaul . tocar (); } } Qu\u00e8 \u00e9s el que estaria passant si ferem un tra\u00e7a? Al crear un objecte \u2018gibsonLesPaul\u2019 de la classe guitarra passant-li par\u00e0metres, es cridaria al constructor de la classe guitarra. Aquest el primer que faria seria cridar al constructor de la classe pare utlitzant \u2018super\u2019 per indicar-li que ha d\u2019executar el constructor de la superclasse assignant-li d\u2019aquesta forma: l\u2019amo, any, marca i model per immediatament despr\u00e9s assignar el nombre de cordes i l\u2019amplificador de la classe derivada. El m\u00e8tode super(), es crida nom\u00e9s quan s\u2019utilitzen constructors sobrecarregats per tal que execute tamb\u00e9 el constructor de la superclasse amb par\u00e0metres i no el constructor per defecte que \u00e9s el que faria si no li diguem el contrari. Exemple Que executaria el seg\u00fcent codi? A m\u00e9s a m\u00e9s, super() tamb\u00e9 ens permet cridar a m\u00e8todes de la classe pare de la seg\u00fcent forma: 1 super . metode ( argumnets ); Conversi\u00f3 entre subclasse i superclasse De vegades en programaci\u00f3 hem de poder convertir entre tipus de dades, aquest mecanisme s\u2019anomena tamb\u00e9 \u00abcast\u00bb. Per exemple si tenim un double amb valor 6,8 i volem convertir-lo en un moment determinat de la nostra aplicaci\u00f3 a un int, ho fariem de la seg\u00fcent forma: 1 2 double d = 6 , 8 ; int i = ( int ) d ; Entre objectes tamb\u00e9 existeix la possibilitat de aplicar aquest mecanisme. Al nostre model de banda de rock, ens podr\u00edem trobar amb la seg\u00fcent situaci\u00f3: 1 2 3 4 5 Instrument inst = new Instrument (); Guitarra git = new Guitarra (); Teclat tcl = new Teclat (); inst = git ; // Conversi\u00f3 autom\u00e0tica inst = tcl ; // Conversi\u00f3 autom\u00e0tica Classes no derivables: atribut final Si volem que alguna classe en concret no siga ja m\u00e9s derivable, \u00e9s a dir, que no volem que es creen m\u00e9s subclasses a partir d\u2019una classe concreta, ho indiquem utilitzant la paraula reservada \u00abfinal\u00bb 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public final class Bateria extends Instrument { public Bateria () { } private int totalToms ; private int pedals ; private int totalPlats ; public void Tocar ( ) { System . out . println ( \"Tocar la bateria\" ); } public void afinar ( char clau ) { System . out . println ( \"Afinar la bateria en \" + clau ); } } Amb aquest codi aconseguim que no es puguen crear subclasses de la classe Bateria. Polimorfisme El polimorfisme (del Grec \u03c0\u03bf\u03bb\u03cd\u03c2, polys, \"molt, molts\" i \u03bc\u03bf\u03c1\u03c6\u03ae, morph\u0113, \"forma, figura\") \u00e9s una caracter\u00edstica d'alguns llenguatges de programaci\u00f3 que tenen la propietat d'enviar missatges sint\u00e0cticament iguals als objectes de diferents tipus. L'\u00fanic requisit que han de complir els objectes que s'utilitzen de manera polim\u00f2rfica \u00e9s saber respondre al missatge que se'ls hi envia. El polimorfisme permet fer refer\u00e8ncia a altres objectes de classes mitjan\u00e7ant el mateix element de programa i realitzar la mateixa operaci\u00f3 de diferents maneres d\u2019acord amb l\u2019objectes al qual es fa refer\u00e8ncia en cada moment. Si mirem la nostra banda de rock, l\u2019exemple m\u00e9s clar \u00e9s el del m\u00e8tode tocar, tots el nostres instruments poden tocar per\u00f2 cadascun ho fa d\u2019una forma diferent. Lligadura El terme lligadura es correspon a l\u2019enlla\u00e7 que es produeix entre un objecte o inst\u00e0ncia d\u2019una classe i les seues propietats. Si aquestes propietats s\u00f3n atributs, la lligadura \u00e9s refereix a la connexi\u00f3 entre l\u2019atribut i la refer\u00e8ncia a mem\u00f2ria on es trobaria el valor de l\u2019atribut en q\u00fcesti\u00f3 mentre que si estem parlant de m\u00e8todes, la lligadura \u00e9s refereix a la connexi\u00f3 entre el nom del m\u00e8tode que es pret\u00e9n executar i el codi que executaria. Per un altre costat, el temps de lligadura \u00e9s el moment en el que l\u2019atribut s\u2019associa amb el seu valor o que un m\u00e8tode s\u2019agrupa amb el seu codi corresponent. Aquest temps de lligadura pot ser \u2018est\u00e0tic\u2019 o \u2018din\u00e0mic\u2019. El primer es produeix durant la compilaci\u00f3 del programa mentre que la segona es produeix en temps d\u2019execuci\u00f3. La majoria de llenguatges de programaci\u00f3 com C utilitzen la lligadura est\u00e0tica en temps de compilaci\u00f3 mitjan\u00e7ant l\u2019enlla\u00e7ador, pel contrari els llenguatges de programaci\u00f3 que utilitzen lligadura din\u00e0mica, no determinen quin \u00e9s el codi que s\u2019executar\u00e0 en la crida al m\u00e8tode fins que arriba el moment en temps d\u2019execuci\u00f3 i \u00e9s nom\u00e9s en eixe cas en el que es determinar\u00e0 de totes les possibilitats de codi a executar (polimorfisme) quin \u00e9s el que s\u2019enlla\u00e7ar\u00e0 o lligar\u00e0 (lligadura efectiva). Java \u00e9s un llenguatge orientat a objectes que utilitza la lligadura din\u00e0mica en temps d\u2019execuci\u00f3 amb l\u2019excepci\u00f3 dels m\u00e8todes static o final que utilitzen lligadura est\u00e0tica. Classes i m\u00e8todes abstractes Les classes i m\u00e8todes abstractes s\u00f3n un \u00abfenomen\u00bb que es dona en algunes de les generalitzacions que ens apareixen quan analitzem una realitat des del punt de vista de la programaci\u00f3 orientada a objectes. \u00c9s a dir, l\u2019abstracci\u00f3 com a t\u00e8cnica en POO nom\u00e9s es pot donar en l\u2019her\u00e8ncia entre classes, concretament a les classes m\u00e9s altes de la jerarquia. Una classe abstracta \u00e9s aquella de la qual mai s\u2019instanciar\u00e0 cap objecte. Per exemple Instrument a la nostra banda de rock on o s\u2019instancia una guitarra, un baix o una bateria per\u00f2 mai un instrument com a tal. A nivell de codi l\u2019\u00fanic canvi que es produeix \u00e9s que a la classe general \u00abInstrument\u00bb se li afegeix la paraula reservada abstract com a modificador de comportament de la classe. 1 2 3 public abstract class Instrument { } Normalment els m\u00e8todes d\u2019una classe abstracta tamb\u00e9 seran abstractes. Al convertir la classe Instrument a abstracta ja no la podr\u00edem instanciar \u00e9s a dir, no podrem crear cap objecte de la classe Instrument, \u00e9s a dir, no podrem en cap moment fer Instrument ins = new Instrument(); ja que ens donaria error de compilaci\u00f3 per\u00f2 en canvi, si podr\u00edem fer Instrument ins = new Guitarra(); ja que la classe Guitarra no \u00e9s abstracta i una Guitarra \u00e9s, segons el nostre model, un instrument. M\u00e8todes Abstractes Un m\u00e8tode abstracte \u00e9s un m\u00e8tode que defineix un comportament o funcionalitat concreta per\u00f2 no especifica la seua implementaci\u00f3 i ha de ser la classe filla la que implemente el m\u00e8tode. En altres paraules, a la classe para o superclasse podem tindre m\u00e8tode tocar, public void abstract tocar(), que no tindra cap codi a la seua implementaci\u00f3 si no que ser\u00e0 la classe filla o subclasse, guitarra per exemple, la que incorpore el codi dins del seu m\u00e8tode public void tocar(). Fixeu-se que aquest \u00faltim ja no porta la paraula reservada \u00ababstract\u00bb La implementaci\u00f3 de m\u00e8todes abstractes per part de les classes filles en una jerarquia utilitzen la lligadura din\u00e0mica ja que no es possible determinar el codi que s\u2019ha d\u2019executar en temps de compilaci\u00f3. \u00das del polimorfisme Arribats a aquest punt podem treure les seg\u00fcents conclusions: que el polimorfisme ens permet que diferents objectes responguen de manera diferent al mateix missatge (m\u00e8tode amb el mateix nom) i que aquesta diferenciaci\u00f3 de quin codi executar ho fa el compilador amb lligadura din\u00e0mica (en temps d\u2019execuci\u00f3 i no de compilaci\u00f3) Per usar el polimorfisme a Java hem de seguir les seg\u00fcents regles: Crear una jerarquia de classes amb les operacions importants definies per els m\u00e8todes membre declarades com abstractes a la base. Les implementacions espec\u00edfiques dels m\u00e8todes abstractes s\u2019han de fer a les classes derivades. Les inst\u00e0ncies d\u2019aquestes classes s\u2019usen mitjan\u00e7ant una refer\u00e8ncia a la base amb lligadura din\u00e0mica la qual \u00e9s l\u2019ess\u00e8ncia del polimorfisme a Java Finalment,en realitat no \u00e9s necessari declarar abstractes els m\u00e8todes a la classe base si despr\u00e9s es redefineixen amb la mateixa signatura (nom m\u00e9s par\u00e0metres) a la classe derivada. Avantatges del polimorfisme El polimorfisme fa el seu sistema m\u00e9s flexible, sense perdre cap dels avantatges de la compilaci\u00f3 est\u00e0tica de tipus que tenen lloc en temps de compilaci\u00f3; tal \u00e9s el cas de Java. Les aplicacions m\u00e9s freq\u00fcents del polimorfisme s\u00f3n: - Especialitzaci\u00f3 de classes derivades. \u00c9s a dir, especialitzar classes que han estat definits des; per exemple: Quadrat \u00e9s una especialitzaci\u00f3 de la classe Rectangle perqu\u00e8 qualsevol quadrat \u00e9s un tipus de rectangle; aquesta classe de polimorfisme augmenta la efici\u00e8ncia de la subclasse, mentre conserva un alt grau de flexibilitat i permet un mitj\u00e0 uniforme de manejar rectangles i quadrats. - Estructures de dades heterogenis. De vegades \u00e9s \u00fatil poder manipular conjunts similars dors d'objectes; amb el polimorfisme es poden crear i gestionar f\u00e0cilment estructures de dades heterogenis que s\u00f3n f\u00e0cils de dissenyar i dibuixar, sense perdre la comprovaci\u00f3 de tipus dels elements utilitzats. - Gesti\u00f3 d'una jerarquia de classes. S\u00f3n col\u00b7leccions de classes altament estructurades amb relacions d'her\u00e8ncia que es poden estendre f\u00e0cilment. M\u00e8todes no derivables: atribut final Al context de l\u2019her\u00e8ncia, la paraula reservada final, s\u2019utilitza per protegir la redefinici\u00f3 dels m\u00e8todes de la classe base; un m\u00e8tode que t\u00e9 l\u2019atribut final, no pot tornar a definir-se a la o les classes derivades Interf\u00edcies Una interf\u00edcie en Java, \u00e9s sint\u00e0cticament similar a una classe abstracta, en la qual pot especificar un o m\u00e9s m\u00e8todes que no tenen cos. Aquests m\u00e8todes han de ser implementats per una classe perqu\u00e8 es defineixen les seues accions. Per tant, una interf\u00edcie especifica qu\u00e8 s'ha de fer, per\u00f2 no com fer-ho. Una vegada que es defineix una interf\u00edcie, qualsevol quantitat de classes pot implementar-la. A m\u00e9s, una classe pot implementar qualsevol quantitat d'interf\u00edcies. Per implementar una interf\u00edcie, una classe ha de proporcionar cossos (implementacions) per als m\u00e8todes descrits per la interf\u00edcie. Cada classe \u00e9s lliure de determinar els detalls de la seva pr\u00f2pia implementaci\u00f3. Dues classes poden implementar la mateixa interf\u00edcie de diferents maneres, per\u00f2 cada classe encara admet el mateix conjunt de m\u00e8todes. Per tant, el codi que t\u00e9. Her\u00e8ncia, polimorfisme i Interf\u00edcies coneixement de la interf\u00edcie pot usar objectes de qualsevol classe, ja que la interf\u00edcie amb aquests objectes \u00e9s la mateixa. Implementaci\u00f3 d'una interf\u00edcie La interf\u00edcie especifica el comportament com\u00fa que tenen un conjunt de dades el qual es realitza en cadascuna d\u2019elles i es coneix tamb\u00e9 com a implementaci\u00f3 d\u2019una interf\u00edcie. La sintaxis \u00e9s similar a la derivaci\u00f3 o extensi\u00f3 d\u2019una classe amb la paraula reservada implements en llo d\u2019extends. 1 2 3 4 5 Class nomClasse implements nomInterficie { // definici\u00f3 d\u2019atributs // implementaci\u00f3 dels m\u00e8todes de la classe // implementaci\u00f3 dels m\u00e8todes de la interf\u00edcies } La classe que implementa la interf\u00edcie ha d\u2019especificar el codi (la implementaci\u00f3) de cadascun dels m\u00e8todes, en cas de no fer-ho, la classe es. Her\u00e8ncia, polimorfisme i Interf\u00edcies converteix en abstracta i com a tal s\u2019ha de declarar. \u00c9s a dir, si una classe implementa una interf\u00edcie, est\u00e0 obligada a implementar tots els seus m\u00e8todes. Per tal d\u2019il\u00b7lustrar amb un exemple sobre una interf\u00edcie, utilitzarem un comandament a dist\u00e0ncia de qualsevol dispositiu electr\u00f2nic. Es suposa que des d\u2019un comandament a dist\u00e0ncia podrem: encendre i apagar el dispositiu, pujar i baixar el volum, silenciar etc.. La nostra interf\u00edcie creada amb Java podria ser com la seg\u00fcent: 1 2 3 4 5 6 7 public class Comandament { void engegar (); void apagar (); void pujarVolum ( int increment ); void baixarVolum ( int decrement ); void silenciar (); } Els m\u00e8todes declarats ac\u00ed a la interf\u00edcie Comandament deurien ser autoexplicatoris. Hem incl\u00f2s nom\u00e9s unes poques de les m\u00faltiples accions que es poden realitzar amb un comandament a dist\u00e0ncia d\u2019un dispositiu electr\u00f2nic i encara se li podrien afegir algunes m\u00e9s ben segur. No hi ha definici\u00f3 de cap dels m\u00e8todes ac\u00ed, Els m\u00e8todes declarats en una interf\u00edcie s\u00f3n sempre abstractes i sempre p\u00fablics per defecte. Ara qualsevol classe que necessite de l\u2019\u00fas de la funcionalitat prove\u00efda per Comandament nom\u00e9s ha de delcarar que implementa la interficie a m\u00e9s a m\u00e9s de definir cadascun dels m\u00e8todes que la formen. Posem per exemple una televisi\u00f3, el codi Java seria el seg\u00fcent: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class TV implements comandament { public void engegar () { // Codi necessari per engegar la televisi\u00f3 } public void apagar () { // Codi necessari per apagar la televisi\u00f3 } public void pujaVolum ( int increment ) { // Codi necessari per incrementar el volum en increment } public void baixaVolum ( int increment ) { // Codi necessari per disminuir el volum en increment } public void silenciar () { // Codi necessari per silenciar la televisi\u00f3 } } Jerarquia d'intef\u00edcies Les interf\u00edcies tamb\u00e9 es poden organitzar de forma jerarquica de manera que els m\u00e8todes siguen heredats 1 interficie extends interficie2 extends interficie3 ... Her\u00e8ncia de classes i implementaci\u00f3 d'interf\u00edcies es interf\u00edcies no s\u00f3n classes ja que especifiquen un comportament mitjan\u00e7ant m\u00e8todes per la classe que els implemente; per aix\u00f2, una classe pot heretar de la seua classe base i al mateix temps implementar una interf\u00edcie. Per exemple si tenim una classe base anomenada Electrodom\u00e8stic de la qual hereten una s\u00e8rie de classes com podrien ser: Televisi\u00f3, DVD, Microones, Forn, Nevera etc..i a m\u00e9s a m\u00e9s tamb\u00e9 disposem d\u2019una interf\u00edcie Comandament, podr\u00edem crear una aplicaci\u00f3 en la que la televisi\u00f3 herete de la classe general electrodom\u00e8stic i a banda implemente la interf\u00edcie comandament com hem vist abans. 1 public class Televisio extends Electrodomestic implements comandament { ... } Classes internes Una classe interna \u00e9s una classe que es declara dintre d\u2019una altra classe.","title":"7.- Her\u00e8ncia, polimorfisme.."},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#tema-7-herencia-polimorfisme-i-interficies","text":"","title":"Tema 7. Her\u00e8ncia, polimorfisme i interf\u00edcies"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#introduccio","text":"Un dels mecanismes m\u00e9s potents que incorpora el paradigma de programaci\u00f3 orientada a objectes s\u00f3n l\u2019her\u00e8ncia i el polimorfisme. El primer ens permet crear una jerarquia de classes relacionades entre s\u00ed de tal forma que la quantitat de codi, especialment el codi redundant, es redueix significativament. El segon permet redefinir m\u00e8todes de tal forma que realitzen funcions diferents depenent del context en el qual es troben. En altres paraules, el polimorfisme \u00e9s el mecanisme de la programaci\u00f3 orientada a objectes que permet que una funci\u00f3 amb el mateix nom realitze tasques diferents depenent de l\u2019objecte des del qual es fa refer\u00e8ncia. Finalment tamb\u00e9 veurem com a les interf\u00edcies podrem especificar les operacions que haurien de definir-se a les classes que la implementen. Una interf\u00edcie \u00e9s un mitj\u00e0 per a que els objectes no relacionats es comuniquen entres s\u00ed. Aquestes s\u00f3n les definicions de m\u00e8todes i valors sobre els quals els objectes estan d\u2019acord per cooperar.","title":"Introducci\u00f3"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#herencia","text":"En programaci\u00f3 orientada a objectes l\u2019her\u00e8ncia \u00e9s un mecanisme que permet potenciar la reutilitzaci\u00f3 i l\u2019extensibilitat en el desenvolupament de programari a banda de reduir la quantitat de codi redundant. Aquest mecanisme permet crear noves classes a partir d\u2019una classe o jerarquia de classes preexistent (ja comprovades i verificades) evitant d\u2019aquesta forma el redisseny, la modificaci\u00f3 i verificaci\u00f3 de la part ja implementada. L\u2019her\u00e8ncia facilita la creaci\u00f3 d\u2019objectes a partir d\u2019altres ja existents i implica que una subclasse obt\u00e9 tot el comportament (m\u00e8todes) i finalment els atributs (variables) de la seua superclasse. En aquest tema veurem com Java implementa el mecanisme de l\u2019her\u00e8ncia i quines s\u00f3n les opcions que ens dona. Suposem el cas en el que disposem de dues classes (amb menys classes resultaria impossible l\u2019her\u00e8ncia), una s\u2019anomenar\u00e0: classe base, superclasse o classe pare; mentre que l\u2019altra ser\u00e0 la classe derivada, subclasse o classe filla. En el nostre cas la classe pare, superclasse o classe base ser\u00e0 \u00abInstrument\u00bb i la classe derivada, filla o subclasse ser\u00e0 \u00abGuitarra\u00bb que en llenguatge natural es podria traduir com que una guitarra \u00e9s un tipus d\u2019instrument. La classe base en una jerarquia d\u2019her\u00e8ncia \u00e9s la classe que cont\u00e9 els atributs i m\u00e8todes comuns a totes les classes derivades i \u00e9s per aix\u00f2 que s\u2019evita la redund\u00e0ncia del codi que es produiria si hagu\u00e9rem de repetir codi com\u00fa a cadascuna de les subclasses, per tant, es podria deduir que una classe derivada \u00e9s de facto una ampliaci\u00f3 de les funcionalitats de la classe base ja que contindr\u00e0 tant els membres de la classe base com els que s'afegeixen de m\u00e9s a la classe derivada.","title":"Her\u00e8ncia"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#polimorfisme","text":"El polimorfisme (del Grec \u03c0\u03bf\u03bb\u03cd\u03c2, polys, \"molt, molts\" i \u03bc\u03bf\u03c1\u03c6\u03ae, morph\u0113, \"forma, figura\") \u00e9s una caracter\u00edstica d'alguns llenguatges de programaci\u00f3 que tenen la propietat d'enviar missatges sint\u00e0cticament iguals als objectes de diferents tipus. L'\u00fanic requisit que han de complir els objectes que s'utilitzen de manera polim\u00f2rfica \u00e9s saber respondre al missatge que se'ls hi envia. El polimorfisme permet fer refer\u00e8ncia a altres objectes de classes mitjan\u00e7ant el mateix element de programa i realitzar la mateixa operaci\u00f3 de diferents maneres d\u2019acord amb l\u2019objectes al qual es fa refer\u00e8ncia en cada moment. Si mirem la nostra banda de rock, l\u2019exemple m\u00e9s clar \u00e9s el del m\u00e8tode tocar, tots el nostres instruments poden tocar per\u00f2 cadascun ho fa d\u2019una forma diferent.","title":"Polimorfisme"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#interficies","text":"Una interf\u00edcie en Java, \u00e9s sint\u00e0cticament similar a una classe abstracta, en la qual pot especificar un o m\u00e9s m\u00e8todes que no tenen cos. Aquests m\u00e8todes han de ser implementats per una classe perqu\u00e8 es defineixen les seues accions. Per tant, una interf\u00edcie especifica qu\u00e8 s'ha de fer, per\u00f2 no com fer-ho. Una vegada que es defineix una interf\u00edcie, qualsevol quantitat de classes pot implementar-la. A m\u00e9s, una classe pot implementar qualsevol quantitat d'interf\u00edcies. Per implementar una interf\u00edcie, una classe ha de proporcionar cossos (implementacions) per als m\u00e8todes descrits per la interf\u00edcie. Cada classe \u00e9s lliure de determinar els detalls de la seva pr\u00f2pia implementaci\u00f3. Dues classes poden implementar la mateixa interf\u00edcie de diferents maneres, per\u00f2 cada classe encara admet el mateix conjunt de m\u00e8todes. Per tant, el codi que t\u00e9. Her\u00e8ncia, polimorfisme i Interf\u00edcies coneixement de la interf\u00edcie pot usar objectes de qualsevol classe, ja que la interf\u00edcie amb aquests objectes \u00e9s la mateixa.","title":"Interf\u00edcies"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/","text":"Tema 8. Entrada, eixida i excepcions Introducci\u00f3 Una part important de tot llenguatge de programaci\u00f3 \u00e9s com s\u2019establir\u00e0 el contacte amb l\u2019exterior, b\u00e9 siga mitjan\u00e7ant la consola o a trav\u00e9s del sistema de fitxers , per finalment poder actuar amb l\u2019usuari d\u2019una aplicaci\u00f3 en execuci\u00f3. Ambd\u00f3s, consola i sistema de fitxers, poden funcionar tant d\u2019entrada als nostres programes com d\u2019eixida. Java defineix una abstracci\u00f3, els streams o fluxos per tractar la comunicaci\u00f3 d\u2019informaci\u00f3 amb l\u2019exterior. Per entendre-ho millor, un stream o flux \u00e9s com un canal de comunicaci\u00f3 entre un origen i un dest\u00ed. Per exemple suposem el cas d\u2019un programa que quan arranque haja de llegir una llista de clients d\u2019un fitxer de text per crear una agenda. En aquest cas l\u2019origen seria el fitxer de text i el dest\u00ed el programa o aplicaci\u00f3 que s\u2019encarrega d\u2019emplenar l\u2019agenda amb el llistat de clients, doncs b\u00e9, l\u2019stream en aquest escenari seria el canal de comunicaci\u00f3 que s\u2019establiria entre el fitxer de text i el programa per tal que aquest puga llegir la informaci\u00f3. A la imatge anterior es poden observar dos tipus de fluxos de dades: El primer \u00e9s un flux d'entrada de dades, s'enten d'entrada perqu\u00e8 va del sistema de fitxers al programa, mentre que el segon representa un flux de dades d'eixida, ja que aquest va del programa al sistema de fitxers. En aquest tema explicarem com Java tracta mitjan\u00e7ant objectes l\u2019establiment d'aquests canals de comunicaci\u00f3 i quines s\u00f3n les operacions que hi podem fer i com s\u2019han d\u2019utilitzar aquestes abstraccions de Java. D\u2019altra banda Java tamb\u00e9 ofereix el mecanisme d\u2019excepcions per controlar els errors sobrevinguts. Una excepci\u00f3 \u00e9s un problema que es produeix en temps d\u2019execuci\u00f3. Java permet controlar aquests problemes i programar amb els try...catch la soluci\u00f3 als errors en temps d\u2019execuci\u00f3. Entrada i eixida b\u00e0siques Com hem dit abans, Java organitza la entrada i eixida mitjan\u00e7ant l\u2019\u00fas d\u2019streams, que s\u00f3n abstraccions en realitat , i aquests streams el que fan es transportar la informaci\u00f3 del programa o aplicaci\u00f3 a dispositius externs. Aquests dispositius externs poden ser b\u00e9 fitxers o incl\u00fas la consola, que es tractada com un fitxer per Java. Flux i jerarquia de classes Com que les possibilitats que tenim en programaci\u00f3 respecte de l\u2019\u00fas de fitxers \u00e9s ampla, podem: llegir de fitxers, escriure en fitxers, llegir per una entrada com un teclat System.in o escriure en una eixida com un monitor System.out , Java en primera inst\u00e0ncia distingeix entre dos tipus de fluxos: flux de bytes i flux de caracters E/S Bytes Caracters Flux entrada InputStream Reader Flux eixida OutputStream Writer Java declara quatre classes abstractes , \u00e9s a dir, que no podem instanciar cap objectes d'aquestes classes, que deriven directament de la superclasse \u00abObject\u00bb que s\u00f3n: InputStream , OutputStream , Reader i Writer . InputStream \u00e9s la base per a totes les classes definides per al flux d\u2019entrada de dades a nivell de bytes. A la imatge seg\u00fcent es mostren totes les classes que deriven d'InputStream. De totes les classes derivades de la classe abstracta InputStream, veurem amb m\u00e9s detal les seg\u00fcents: FileInputStream, DataInputStream i ObjectInputStream. OutputStream \u00e9s la classe base per a les classes que gestionen el flux d\u2019eixida a nivell de bytes. A la imatge seg\u00fcent es poden observar totes les seues classes derivades. Pel que fa a aquesta classe abstracta, veurem amb m\u00e9s detall: FileOutputStream, DataOutputStream, PrintStream i ObjectOutputStream. Reader \u00e9s la classe per llegir streams a nivell de caracter. Observa les classes derivades a la imatge seg\u00fcent. D'aquesta classe abstracta veurem amb m\u00e9s detall: BufferedReader, InputStreamReader, FileReader Writer \u00e9s la classe per escriure a streams a nivell de caracter i les classes que deriven d'ell s\u00f3n les que es poden veure a la seg\u00fcent imatge. De totes les derivades ens centrarem en: OutputStreamWriter, FileWriter, BufferedWriter i PrintWriter. Consola Una de les possibilitats de realitzar l'entrada eixida a un programa \u00e9s mitjan\u00e7ant la consola, on d'una banda es pot escriure i mostrar missatges i d'altra banda l'usuari pot introduir informaci\u00f3. Utilitzant BufferedReader BufferedReader \u00e9s una classe derivada de la classe abstracta Reader que es troba dins del paquet java.io . A l'exemple seg\u00fcent es mostra com podem utilitzar aquesta classe. 1 2 3 4 5 6 7 8 9 10 11 12 13 import java.io.BufferedReader ; import java.io.IOException ; import java.io.InputStreamRader ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in )); try { String strName = reader . readLine (); System . out . println ( \"Hola: \" + strName + \"!\" ); } catch ( IOException e ) { System . out . println ( \"S'ha produit un error: \" + e . getMessage ()); } finally () { reader . close (); // \u00c9s molt important tancar els streams } Consideracions de l'exemple anterior: S'han d'importar les llibreries necess\u00e0ries per poder utilitzar les classes necess\u00e0ries. Per instanciar un objecte de la classe BufferedReader, el constructor necessita que se li passe un objecte de tipus InputStreamReader que apunte al flux d'entrada predefinit System.in (el teclat) Tota instrucci\u00f3 relacionada amb els streams, s'han de posar dins d'un bloc try..catch. Utilitzant Scanner L'altra alternativa, m\u00e9s comoda al meu entendre, \u00e9s l'\u00fas de la classe Scanner . Aquesta classe es troba dins del paquet java.util i \u00e9s una derivada de la classe arrel Object . Observa l'exemple seg\u00fcent d'\u00fas de la classe Scanner : 1 2 3 4 5 6 7 import java.util.Scanner ; System . out . println ( \"Per favor escriu el teu nom i prem Intro\" ); Scanner scanner = new Scanner ( System . in ); String strName = scanner . nextLine (); System . out . println ( \"Hola: \" + strName + \"!\" ); Algunes consideracions: S'han d'importar les llibreries necess\u00e0ries per poder utilitzar les classes necess\u00e0ries. Per instanciar un objecte de la classe Scanner, el constructor necessita que se li passe un flux d'entrada com pot ser: System.in (el teclat) A difer\u00e8ncia del BufferedReader no \u00e9s necessari posar el codi dins del bloc try..catch Activitat 1. Entrada i eixida per consola. Seguint els exemples anteriors, crear un nou projecte en Eclipse que et demane el nom per consola i despr\u00e9s mostre el missatge: \"Hola *nom*\". Has de fer el mateix dues vegades: una utilitzant el **BUfferedReader** i l'altre amb la classe **Scanner**. Flux d'arxius Un arxiu o fitxer \u00e9s un conjunt de bytes que s\u00f3n emmagatzemats en un dispositiu. Un arxiu o fitxer es identificat per un nom i la descripci\u00f3 de la carpeta o directori (la ruta) que el cont\u00e9. Una de les principals finalitats dels arxius \u00e9s tindre desats en mem\u00f2ria secund\u00e0ria , quan les aplicacions ja han acabat d\u2019executar-se, i que siguen recuperables despr\u00e9s. Un fitxer s\u2019ha de poder llegir, actualitzar, esborrar registres i tornar a guardar-se de nou amb tots els canvis realitzats. Segons el dispositiu f\u00edsic que els emmagatzeme, els arxius poden ser directes o seq\u00fcencials , el primer implica que per poder accedir a qualsevol registre, hem de passar pr\u00e8viament pels anteriors, per exemple una cinta magn\u00e8tica, mentre que el segon tipus d\u2019arxiu permet l\u2019acc\u00e9s directe al registre en q\u00fcesti\u00f3 sense haver de passar pels anteriors. En Java un arxiu \u00e9s una seq\u00fcencia de bytes que contenen la informaci\u00f3 emmagatzemada. Per poder treballar amb aquestes seq\u00fcencies de bytes, Java disposa de classes com s\u00f3n els tipus b\u00e0sics (int, double, string..). D\u2019una altra banda, com ja hem explicat abans, un flux \u00e9s una abstracci\u00f3 que es refereix a una corrent (stream) de dades entre un origen (tamb\u00e9 conegut com a font o productor) i una destinaci\u00f3 o embornal (consumidor) i la connexi\u00f3 que existeix entre els dos tamb\u00e9 es coneix com a pipe o tub per on circules les dades. Quan comen\u00e7a qualsevol execuci\u00f3 d\u2019un programa Java, es creen tres objectes flux, canals pels que pot fluir informaci\u00f3 d\u2019entrada o eixida; aquests objectes estan definits a la classe System i s\u00f3n: Sytem.in: entrada est\u00e0ndard, permet l\u2019entrada de dades des del teclat.Una excepci\u00f3 \u00e9s un fallo que es produeix en temps d\u2019execuci\u00f3. Classe InputStream System.out: eixida est\u00e0ndard, permet la programa imprimir per pantalla. Classe PrintStream System.err: eixida d\u2019errors, permet al programa imprimir errors per pantalla Per defecte sol ser la mateixa eixida que System.out. Classe PrintStream Class File Per poder identificar d\u2019un fitxer al sistema de fitxers de qualsevol sistema operatiu, necessitem: nom i ruta. Per exemple \u2018/user/data/file.txt\u2019. El fitxer es diu file.txt i la ruta en la qual es troba \u00e9s \u2018/user/data/\u2019. Aquest identificador de fitxer \u00e9s el que es passa al constructor de la classe per tal d\u2019obrir un flux. 1 2 File fitxer = new File ( strPath + \"prova.txt\" ); // Fes el que vullgues fer amb el fitxer En l\u2019exemple anterior hem utilitzat la classe File per tal d\u2019instanciar un stream al fitxer que li hem passat per par\u00e0metre \u00abprova.txt\u00bb. Compte que s\u2019ha de passar la ruta absoluta d\u2019on es troba el fitxer. Hi ha alternatives al constructor de la classe File que hem mostrat a l\u2019exemple anterior, es pot construir tamb\u00e9 amb dos par\u00e0metres: ruta i nom del fitxer o incl\u00fas indicar-li la ruta mitjan\u00e7ant un altre objecte File. Els m\u00e8todes de la classe File s\u00f3n: M\u00e8tode Explicaci\u00f3 public bolean exists() Torna true si el fitxer existeix public boolean canWrite() Torna true si es pot escriure al fitxer public boolean canRead() Torna true si es nom\u00e9s de lectura public boolean isFile() Torna true si \u00e9s un fitxer public boolean isDirectory() Torna true si \u00e9s un directori public boolean isAbsolute() Torna true si el directori t\u00e9 ruta completa public long lenght() Torna la mida en bytes del fitxer public long lastModified() Torna el timestamp de l\u2019\u00faltima modificaci\u00f3 public String getName() Torna una string amb el nom del fitxer public String getPath() Torna una string amb el path del fitxer public String getAbsolutePath() Torna la ruta absoluta del fitxer public boolean setReadOnly() Converteix el fitxer en nom\u00e9s lectura public boolean delete() Elimina el fitxer o directori (si est\u00e0 buit) public boolean renameTo(File nou) Canvia el nom pel del fitxer nou public boolean mkdir() Crea el directori del fitxer public String[] list() Torna un array d\u2019strings dels elements Activitat 2. Class File Crea un projecte en Eclipse que obriga un fitxer de prova qualsevol, per exemple: prova.txt. Llegeixca l\u00ednia a l\u00ednia el contingut del fitxer i el mostre per pantalla. Fins ara hem vist com llegir i escriure per consola, la forma m\u00e9s senzilla \u00e9s utilitzant la classe Scanner i tamb\u00e9 com obrir i treballar amb fitxers utilitzant la classe File . A continuaci\u00f3 estudiarem amb m\u00e9s detall les diferents classes que disposa Java pel tractament de l'entrada i eixida d'informaci\u00f3. Per tal entendre-ho millor, dividirem aquesta secci\u00f3 en dos blocs: Tractament a nivell de byte amb les classes abstractes InputStream i OutputStream i les seues classes derivades i tractament a nivell de caracter amb les classes abstraces Writer i Reader i les seues subclasses. Flux de dades a nivell de byte Com ja hem explicat abans, el tractament de l'entrada eixida en java a nivell de bytes es fa amb les classes abstractes InputStream i OutputStream de les quals deriven les classes: FileInputStream i FileOutputStream PipedInputStream i PipedOutputStream FilterInputStream i FilterOutputStream ByteArrayInputStream i ByteArrayOutputStream ObjectInputStream i ObjectOutputStream, etc.. FileInputStream i FileOutputStream Tot arxiu es pot considerar en s\u00ed mateix una seq\u00fc\u00e8ncia de bytes de baix nivell i despr\u00e9s sobre aquesta informaci\u00f3 es pot construir informaci\u00f3 de mes alt nivell per tal de processar dades m\u00e9s complexes des de tipus b\u00e0sic fins objectes. En altres paraules, si volem obrir un flux de dades a un fitxer o arxiu i volem llegir byte a byte per despr\u00e9s decidir nosaltres a nivell de programaci\u00f3 que volem fer amb aquests bytes, haur\u00edem d\u2019utilitzar aquestes classes. 1 2 3 FileInputStream fen = new FileInputStream ( strPath + \"provat.txt\" ); // Fem el que hem de fer amb le fitxer i despr\u00e9s s'ha de tancar fen . close (); La classe FileInputStream s\u2019utilitza per llegir bytes o grups de bytes del fitxer associat. Tots els m\u00e8todes tenen visibilitat p\u00fablica i s\u2019ha de tenir en compte quina \u00e9s l\u2019excepci\u00f3 que llencen per controlar els possibles errors en temps d\u2019execuci\u00f3. M\u00e8tode Explicaci\u00f3 FileOutputStream(String nombre) throws IOException; Crea un objecte inicialitzat amb el nom d\u2019arxiu que es passa com argument FileOutputStream(String nombre, boolean sw) throws IOException; Crea un objecte inicialitzat amb el nom d\u2019arxiu que es passa per par\u00e0metre. Si sw \u00e9s true els nous bytes s\u2019afegeixen al final FileOutputStream(File nombre) throws IOException; Crea un objecte inicialitzat amb l\u2019objecte file que es passa per par\u00e0metre void write(byte a) throws IOException; Escriu el byte \u2018a\u2019 al flux associat void write(byte[] s) throws IOException; Escriu l\u2019array de bytes \u2018s\u2019 al flux void write(byte[] s, int org, int len) throws IOException; Llig una seq\u00fc\u00e8ncia de bytes del flux i la desa a \u2018s\u2019 comen\u00e7ant per \u2018org\u2019 i una mida de \u2018len\u2019. Torna -1 si arriba al final del fitxer void close()throws IOException; Tanca el flux i el fitxer queda lliure per al seu \u00fas posterior Exemple A continuaci\u00f3 obrirem el fitxer \u00abprova.txt\u00bb amb un FileInputStream per llegir-lo i desarem el seu contingut a un fitxer d\u2019eixida \u00abresultat.txt\u00bb que obirem amb un FileOutputStream. Al fitxer d\u2019eixida, bolcarem el contingut de \u00abprova.txt\u00bb 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 try { FileInputStream fen = new FileInputStream ( strPath + \"prova.txt\" ); FileOutputStream fout = new FileOutputStream ( strPath + \"resultat.txt\" ); int byteLlegit = fen . read (); while ( byteLlegit != - 1 ) { fout . write ( byteLlegit ); byteLlegit = fen . read (); } fen . close (); fout . close (); } catch ( FileNotFoundException f ) { System . out . println ( \"Fitxer no trobat\" ); } catch ( IOException e ) { System . out . println ( \"Error d'entrada eixida\" ); } Activitat 3. Copiar invertit Basat en el codi anterior i fes que al fitxer resultat, el d\u2019eixida, es copie el que apareix a \u00abprova.txt\u00bb, el d\u2019entrada per\u00f2 a l\u2019inrev\u00e9s. Per exemple: Un possible resultat de l'activitat anterior podria ser el que es pot observar a la imatge seg\u00fcent: DataInputStream i DataOutputStream La veritat \u00e9s que treballar amb bytes quan estem parlant de fitxers o arxius que contenen informaci\u00f3 o dades de m\u00e9s nivell pot resultar incomode, ja que entre altres haur\u00edem de saber quants bytes t\u00e9 un car\u00e0cter, un enter o un doble. En Java tenim les classes DataInputStream i DataOutputStream que s\u00f3n subclasses de les classes FilterInputStream i FilterOutputStream . Abans d'entrar en el detall d'aquetes classes, veurem amb m\u00e9s profunditat que s\u00f3n les classes FilterInputStream i FilterOutputStream. Aquestes dues classes deriven de les classes abstractes InputStream i OutputStream. B\u00e0sicament el que fan es sobreescriure tots els m\u00e8todes de les seues super classes i permeten agrupar bytes (Input) i desagrupar-lo(Output) de tal forma que classes derivades seues podran treballar amb informaci\u00f3 de m\u00e9s alt nivell. Per tal d'instanciar un objecte de la classe DataInputStream d'on es podria llegir, ho fariem de la seg\u00fcent manera: 1 2 3 4 5 FileInputStream gs = new FileInputStream ( strPath + \"prova.txt\" ); DataInputStream ent = new DataInputStream ( gs ); // Treballem amb ells i com passava amb els streams anteriors tamb\u00e9 els hem de tancar gs . close (); ent . close (); Observa el codi anterior: Primer s'instancia un objecte de la classe FileInputStream (derivada de InputStream) en la que se li indica la ruta del fitxer amb el que volem treballar. Despr\u00e9s aquest objecte FileInputStream s'utilitza per poder instanciar un objecte de la classe DataInputStream que utilitzarem per llegir tipus de dades primitius del fitxer. B\u00e0sicament aquestes classes el que fan \u00e9s organitzar els bytes en tipus primitius de tal forma que ja podem treballar llegint i escrivint als fluxos: enters, car\u00e0cters, reals, cadenes etc.. M\u00e8tode Explicaci\u00f3 public DataInputStream(InputStream entrada) throws IOException Crea un objecte associat a l\u2019stream que es passa per par\u00e0metre public final boolean readBoolean() throws IOException Torna el valor de tipus boole\u00e0 llegit public final byte readByte() throws IOException Torna el valor de tipus byte llegit public final short readShort() throws IOException Torna el valor de tipus short llegit public final char readChar() throws IOException Torna el valor de tipus char llegit public final int readInt() throws IOException Torna el valor de tipus int llegit public final long readLong() throws IOException Torna el valor de tipus long llegit public final float readFloat() throws IOException Torna el valor de tipus float llegit public final double readDouble() throws IOException Torna el valor de tipus double llegit public final String readUTF() throws IOException Torna una cadena que es va escriure en UTF D\u2019aquesta forma ja no ens hem de preocupar de saber quants bytes de mem\u00f2ria s\u2019han de reservar per un car\u00e0cter o un enter. Per exemple si associem un DataOutputStream a un fitxer i despr\u00e9s cridem al m\u00e8tode writeInt , realment el que s\u2019est\u00e0 fent \u00e9s escriure 4 bytes d\u2019informaci\u00f3 al fitxer de la qual cosa s\u2019estaria encarregant de manera transparent a l\u2019usuari. Per tal d'instanciar un objecte de la classe DataOutputStream , on es podria escriure, ho fariem de la seg\u00fcent forma: 1 2 3 4 5 FileOutputStream fn = new FileOutputStream ( strPath + \"result.txt\" ); DataOutputStream snb = new DataOutputStream ( fn ); // Treballem amb ells i tanquem. fn . close (); snb . close (); Al contrari que passava amb el DataInputStream, al codi anterior estem instanciant un objecte de la classe DataOutputStream que utlitzarem per escriure la informaci\u00f3 desitjada. M\u00e8tode Explicaci\u00f3 public DataOutputStream(OutputStream destino) throws IOException Crea un objecte associat a l\u2019out11putstream que es passa per par\u00e0metre public final void writeBoolean(boolean v) throws IOException Escriu un boolean public final void writeByte(int v) throws IOException Escriu un byte public final void writeShort(int v) throws IOException Escriu un short public final void writeChar(int v) throws IOException Escriu un char public final void writeChars(String v) throws IOException Escriu tots els chars que cont\u00e9 la String v public final void writeInt(int v) throws IOException Escriu un int public final void writeLong(long v) throws IOException Escriu un long public final void writeFloat(float v) throws IOException Escriu un float public final void writeDouble(double v) throws IOException Escriu un double public final void writeUTF(String cad) throws IOException Escriu la cadena cad en format UTF public final int close()throws IOException Tanca el flux Un altre exemple d'\u00fas del DataInputStream: 1 2 3 4 5 6 7 8 9 InputStream input = new FileInputStream ( \"datastreamdemo.txt\" ); DataInputStream inst = new DataInputStream ( input ); int count = input . available (); byte [] arr = new byte [ count ] ; inst . read ( arr ); for ( byte byt : arr ) { char ki = ( char ) byt ; System . out . print ( ki + \"-\" ); } A continuaci\u00f3 podem veure un exemple en el que fem \u00fas del DataOutputStream i DataInputStream . El que fa aquest exemple \u00e9s escriure a un fitxer d\u2019eixida \u00abpluges.dat\u00bb dos valors double aleatoris per despr\u00e9s llegir-los amb un DataInputStream i mostrar-los per pantalla. El codi podria ser el seg\u00fcent: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 try { FileOutputStream fos = new FileOutputStream ( strPath + \"pluges.dat\" ); DataOutputStream dos = new DataOutputStream ( fos ); double info Math . random () * 100 ; dos . writeDouble ( info ); FileInputStream fis = new FileInputStream ( strPath + \"pluges.dat\" ); DataInputStream dis = new DataInputStream ( fis ); double info2 = dis . readDouble (); System . out . println ( \"Primer valor: \" + info2 ); info2 = dis . readDouble (); System . out . println ( \"Segon valor: \" + info2 ); fos . close (); dos . close (); fis . close (); dis . close (); } catch ( FileNotFoundException e ) { System . out . println ( \"El fitxer no existeix\" ); } catch ( IOException e ) { System . out . println ( \"Error IO inesperat\" ); } Activitat 4. Data Iput i Data Output Crea un projecte en Eclipsei copia el codi anterior i una vegada acabada l'execuci\u00f3 del programa, obre el fitxer \"pluges.dat\" i compara el que s'ha mostrat a consola amb el que s'ha gravat al fitxer. Posa el mateix? Per qu\u00e8? PrintStream La classe PrintStream deriva de FilterOutputStream i el valor afegit d\u2019aquesta classe derivada \u00e9s que permet afegir el car\u00e0cter final de l\u00ednia als fitxers. Aquests tipus de fluxos s\u00f3n sempre d\u2019eixida i s\u2019associen a un altre flux de bytes de m\u00e9s baix nivell. System.out \u00e9s un objecte de tipus PrintStream. System.out \u00e9s un clar exemple de PrintStream 1 2 3 PrintStream ps = new PrintStream ( new FileOutputStream ( \"Complex.dat\" )); // Treballem i tanquem ps . close (); M\u00e8tode Explicaci\u00f3 public PrintStream(OutputStream destino) Crea un objecte associat a qualsevol objecte d\u2019eixida per par\u00e0metre public PrintStream(OutputStream destino, boolean flag) Crea un objecte associat a qualsevol objecte d\u2019eixida per par\u00e0metre. Si flag \u00e9s true, es produeix un bolcat autom\u00e0tic al escriure final de l\u00ednia. public void flush() Bolca el flux actual ublic void print(Object obj) Escriu la representaci\u00f3 de l\u2019objecte obj al flux public void print(String cad) Escriu la cadena al flux public void print(char c) Escriu un car\u00e0cter al flux public void println(Object obj) Escriu la representaci\u00f3 de l\u2019objecte al flux i final de l\u00ednia public void println(String cad) Escriu la cadena al flux i final de l\u00ednia Observa el codi seg\u00fcent. Utilitzant la classe PrintStream s'obre un fitxer 'output.txt' dintre del qual s'escriur\u00e0 una sola cadena de caracters 'data' i despr\u00e9s es tancar\u00e0 l'stream una vegada finalitzat l'execuci\u00f3 del codi. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import java.io.PrintStream ; class Main { public static void main ( String [] args ) { String data = \"Text que volem escriure dintre del fitxer\" ; try { PrintStream output = new PrintStream ( \"output.txt\" ); output . print ( data ); output . close (); } catch ( Exception e ) { e . getStackTrace (); } } } Activitat 5 Utilitzant la classe Scanner que hem vist abans, has de fer una aplicaci\u00f3 en Eclipse IDE que tot all\u00f2 que llegeixca per teclat o guarde en un fitxer de text juntament amb l'hora a la qual s'ha escrit. Per exemple, si l'usuari escriu per pantalla el seu nom, \"Manolo\" i prem Intro, al fitxer d'eixida s'hauria de gravar: [09:05:25] - Manolo Has d'utilitzar la classe PrintStream per fer aquesta activitat. Flux de dades a nivell de caracter Una altra forma de poder treballar amb fitxers en lloc de a nivell de byte com estavem fent als apartats anteriors, \u00e9s fer-ho a nivell de caracter. Al cap i a la fi els arxius, en una gran majoria, solen ser seq\u00fc\u00e8ncies de caracters i des del punt de vista l\u00f2gic ens resulta m\u00e9s natural treballar amb ells a aquest nivell. Reader i writer Els arxius de text s\u00f3n arxius de car\u00e0cters, es poden crear fluxos de bytes o de car\u00e0cters derivats de les classes abstractes Reader i Writer. Els fluxos Reader i Writer s\u00f3n fluxos de Java orientats a car\u00e0cters. Amb aquests fluxos podem llegir i escriure car\u00e0cters o cadenes de car\u00e0cters al dispositius connectats mitjan\u00e7ant aquests fluxos. Per llegir arxius de car\u00e0cters s\u2019utilitzen fluxos derivats de la classe Reader on es declaren o sobreescriuen m\u00e8todes per la lectura de car\u00e0cters. Els m\u00e8todes m\u00e9s importants s\u00f3n: M\u00e9tode Explicaci\u00f3 public int read() Llig un car\u00e0cter en forma d\u2019enter. Si arriba al final del fitxer torna -1 public int read(char [] b) Llig una seq\u00fcencia de car\u00e0cters fins completar l\u2019array b o llegir el final del fitxer. Torna el nombre de car\u00e0cters llegits o -1 si arriba al final de l\u2019arxiu InputStreamReader i OutputStreamWriter Els fluxos de la classe IntpuStreamReader envolten (wrap) a un flux de bytes; converteixen la seq\u00fc\u00e8ncia de bytes en seq\u00fc\u00e8ncia de car\u00e0cters i aix\u00ed ja no ho hem de fer nosaltres; la classe deriva directament de Reader, pel que t\u00e9 disponibles els m\u00e8todes read() de la seua classe pare per la lectura de car\u00e0cters 1 2 3 InputStreamReader ent = new InputStreamReader ( Sytem . in ); // En acabar tanquem l'stream ent . close (); La classe OutputStreamWriter que deriva de writer , permet escriure car\u00e0cters en un flux de bytes al qual s\u2019associa la creaci\u00f3 de l\u2019objecte o flux. 1 2 3 OutputStreamWriter ot = new OutputStreamWriter ( new FileOutputStream ( arxiu )); // Despr\u00e9s hem de recordar de tancar l'stream ot . close (); Els m\u00e8todes de la classe InputStreamReader s\u00f3n: M\u00e9tode Explicaci\u00f3 void close() Tanca el flux i allibera tots els recursos del sistema associats String getEconding() Retorna el nom de la codificaci\u00f3 de car\u00e0cters que utilitza aquest flux int read() Llegeix un sol car\u00e0cter int read(char[] buf, int offset, int length) Llegeix car\u00e0cters en una part d'una matriu boolean ready() Indica si aquest flux est\u00e0 llest per ser llegit Els m\u00e8todes de la classe OutputStreamWriter s\u00f3n: M\u00e9tode Explicaci\u00f3 void close() Tanca el corrent, rentant-lo primer void flush() Redueix el corrent String getEconding() Retorna el nom de la codificaci\u00f3 de car\u00e0cters que utilitza aquest flux void write(char [] buf, int off, int len) Escriu una part d'una matriu de car\u00e0cters void write(int c) Escriu un sol car\u00e0cter void write(String str, int off, int len) Escriu una part d'una cadena Activitat 6 Repeteix l'activitat anterior, la 5, per\u00f2 utilitzant InputStreamReader i OutputStreamReader Per\u00f2 all\u00f2 normal \u00e9s que no s'utilitzen directament aquestes classes sino que es faja \u00fas de FileReader i FileWriter . FileReader i FileWriter Per llegir arxius de text o de car\u00e0cters es pot crear un flux del tipus FileReader , aquesta classe deriva d\u2019InputStreamReader, hereta els m\u00e8todes read() per a llegir car\u00e0cters, el constructor t\u00e9 com entrada una cadena amb el nom de l\u2019arxiu Per exemple 1 2 FileReader fr = new FileReader ( \"cartes.dat\" ); fr . close (); Els constructors de la classe FileReader s\u00f3n: Constructor Explicaci\u00f3 FileReader(File file) Crea un nou FileReader , amb el nom del fitxer des del qual cal llegir FileReader(FileDescriptor fd) Crea un nou FileReader , donat el FileDescriptor per llegir FileReader(String fileName) Crea un nou FileReader , amb el nom del fitxer des del qual cal llegir Els m\u00e8todes dels que disposa FileReader s\u00f3n: Heretats de java.io.InputStreamReader: close, getEncoding, read, ready Heretats de java.io.Reader: mark, markSupported, read, reset, skip Heretats de java.lang.Object: clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait No es freq\u00fcent utilitzar directament fluxos OutputStreamWriter , encara que resulta interessant perqu\u00e8 la classe FileWriter \u00e9s una extensi\u00f3 d\u2019ella. Dissenyada per escriure en un arxiu de car\u00e0cters, els fluxos d\u2019aquest tipus escriuen car\u00e0cters amb el m\u00e8tode write() a l\u2019arxiu al que s\u2019associa el flux quan es crea l\u2019objecte. 1 2 3 FileWriter nr = new FileWriter ( \"cartes.dat\" ); nr . write ( \"Frase qualsevol a escriure\" ); nr . close (); Els constructors de la classe FileWriter s\u00f3n: Constructor Explicaci\u00f3 FileWriter(File file) Construeix un objecte FileWriter donat un objecte File FileWriter(File file, boolean append) Construeix un objecte FileWriter donat un objecte File FileWriter(FileDescriptor fd) Construeix un objecte FileWriter associat a un descriptor de fitxer FileWriter(String fileName) Construeix un objecte FileWriter amb un nom de fitxer FileWriter(String fileName, boolean append) Construeix un objecte FileWriter amb un nom de fitxer amb un boole\u00e0 que indica si s'han d'afegir o no les dades escrites En general no resulta eficient llegir directament d\u2019un flux d\u2019aquest tipus, s\u2019utilitzar\u00e0 un flux BufferedReader Activitat 7 Utilitzant les classes anteriors, obre un fitxer que continga text, llig tot el seu coningut i enregistra'l a un fitxer d'eixida amb la condici\u00f3 que has de canviar maj\u00fascules per min\u00fascules i a l'inrev\u00e9s des del fitxer d'origen. BufferedReader i BufferedWriter La lectura d\u2019arxius de text es realitza amb un flux que emmagatzema els car\u00e0cters en un buffer intermedi, aquests no es lligen directament de l\u2019arxiu si no del buffer. D\u2019aquesta manera augmentem l\u2019efici\u00e8ncia a les operacions d\u2019entrada, la classe BufferedReader permet crear fluxos de car\u00e0cters amb buffer que no \u00e9s m\u00e9s que una forma d\u2019organitzar el flux b\u00e0sic de car\u00e0cters del que ve el text perqu\u00e8 al crear un flux BufferReader, aquest s\u2019inicialitza com un flux de car\u00e0cters InputStreamReader o qualsevol altre. El constructor de la classe t\u00e9 un argument de tipus Reader, FileReader o InputStreamReader, el flux creat disposa d\u2019un buffer de grand\u00e0ria suficient, el qual es pot especificar en el constructor amb un segon argument encara que no fa falta. Exemples de fluxos amb buffer. Els m\u00e8todes de la classe BufferedReader s\u00f3n: M\u00e8tode Explicaci\u00f3 void close() Tanca el flux i allibera tots els recursos del sistema associats void mark(int readAheadLimit) Marca la posici\u00f3 actual al flux boolean markSupported() Indica si aquest flux admet l'operaci\u00f3 mark(), que fa read() Llegeix un sol car\u00e0cter int read(char[] cbuf, int off, int len) Llegeix car\u00e0cters en una part d'una matriu String readLine() Llegeix una l\u00ednia de text boolean ready() ndica si aquest flux est\u00e0 llest per ser llegit void reset() Restableix el flux a la marca m\u00e9s recent long skip(long n) Omet personatges Exemple 1 2 3 4 5 6 7 8 9 10 11 12 13 File someFile = new File (...); int aCount = 0 ; FileReader fr = new FileReader ( someFile ); BufferedReader br = new BufferedReader ( fr ); // Count the number of 'a' characters. int ch ; while (( ch = br . read ()) != - 1 ) { if ( ch == 'a' ) { aCount ++ ; } } System . out . println ( \"There are \" + aCount + \" 'a' characters in \" + someFile ); BufferedWriter , per un altre costat, escriu text en un flux de sortida de car\u00e0cters, guarda els car\u00e0cters en mem\u00f2ria interm\u00e8dia (buffer) per tal de proporcionar una escriptura eficient de car\u00e0cters, matrius i cadenes individuals. Es pot especificar la mida de la mem\u00f2ria interm\u00e8dia o es pot acceptar la mida predeterminada. El valor predeterminat \u00e9s prou gran per a la majoria de prop\u00f2sits. Es proporciona un m\u00e8tode newLine(), que utilitza la pr\u00f2pia noci\u00f3 de separador de l\u00ednies de la plataforma tal com es defineix per la propietat del sistema line.separator . No totes les plataformes utilitzen el car\u00e0cter de nova l\u00ednia ('\\n') per acabar les l\u00ednies. Per tant, es prefereix cridar aquest m\u00e8tode per acabar cada l\u00ednia de sortida que escriure directament un car\u00e0cter de nova l\u00ednia. Els m\u00e8todes de la classe s\u00f3n: M\u00e8tode Explicaci\u00f3 void close() Tanca el corrent, rentant-lo primer void flush() Redueix el corrent void newLine() Escriu un separador de l\u00ednies void write(char[] cbuf, int off, int len) Escriu una part d'una matriu de car\u00e0cters void write(int c) Escriu un sol car\u00e0cter void write(String s, int off, int len) Escriu una part d'una cadena Exemple 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import java.io.FileWriter ; import java.io.BufferedWriter ; public class Main { public static void main ( String args [] ) { String data = \"This is the data in the output file\" ; try { // Creates a FileWriter FileWriter file = new FileWriter ( \"output.txt\" ); // Creates a BufferedWriter BufferedWriter output = new BufferedWriter ( file ); // Writes the string to the file output . write ( data ); // Closes the writer output . close (); } catch ( Exception e ) { e . getStackTrace (); } } } PrintWriter Els fluxos m\u00e9s utilitzats en l\u2019eixida de car\u00e0cters s\u00f3n de tipus PrintWriter, aquesta classe declara constructors per associar un flux PrintWriter amb qualsevol altre de tipus Writer o b\u00e9 OutputStream. M\u00e8tode Explicaci\u00f3 public PrintWriter(OutputStream dest\u00ed) Crea un flux associat amb un altre d\u2019eixida a nivell de byte. public PrintWriter(Writer destino) Crea un flux associat amb un altre d\u2019eixida de car\u00e0cters de tipus Writer. La import\u00e0ncia d\u2019aquesta classe radica en que defineix m\u00e8todes print() i println() per cadascun dels tipus de dades simples, per String i per Object; la difer\u00e8ncia entre els m\u00e8todes print() i println() est\u00e0 en que el segon afegeix els car\u00e0cters de final de l\u00ednia a continuaci\u00f3 dels escrits per l\u2019argument. M\u00e8tode Explicaci\u00f3 public void print(Object obj) Escriu la representaci\u00f3 de l\u2019objecte obj al flux public void print(String cad) Escriu la cadena al flux public void print(char c) Escriu el car\u00e0cter c al flux. public void println(Object obj) Escriu la representaci\u00f3 de l\u2019objecte obj al flux i final de l\u00ednia public void println(String cad) Escriu la cadena al flux i el final de l\u00ednia public void println(char c) Escriu el car\u00e0cter c al flux i final de l\u00ednia. Exemple 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import java.io.PrintWriter ; class Main { public static void main ( String [] args ) { String data = \"This is a text inside the file.\" ; try { PrintWriter output = new PrintWriter ( \"output.txt\" ); output . print ( data ); output . close (); } catch ( Exception e ) { e . getStackTrace (); } } } Fixa't en l'exemple anterior i fes la seg\u00fcent activitat. Activitat 8 Repeteix l'activitat 7 per\u00f2 utilitzant les classes PrintWriter i BufferedReader. Arxius d'objectes Fins ara hem tractat el tema d'entrada - eixida d'informaci\u00f3 utilitzant els tipus primitius o b\u00e0sics que ens proporciona el llenguatge de programaci\u00f3: int, char, float, String... per\u00f2 que passa si el que volem desar o llegir des d'un dispositiu extern \u00e9s un o diversos objectes? Com es guarden i com es recuperen aquestos objectes? Java proporciona una mecanisme que s'anomena serialitzaci\u00f3 que consisteix en convertir un objecte en una seq\u00fc\u00e8ncia de bytes de tal forma que, ara s\u00ed, es podr\u00e0 desar a un fitxer o un dispositiu extern. El proc\u00e9s de lectura d'un objecte serialitzat a un fitxer, per contra, s'anomena desserialitzaci\u00f3 . Per tal que un objecte continue existint, \u00e9s a dir, que siga persistent, una vegada ja hem finalitzat l\u2019execuci\u00f3 d\u2019un programa o aplicaci\u00f3 l\u2019hem de desar a un arxiu d\u2019objectes. Per poder aconseguir a\u00e7\u00f2, utilitzarem les classes ObjectInputStream i ObjectOutputStream Classe d'objecte persistent Serialitzaci\u00f3: \u00e9s el proc\u00e9s de convertir un objecte (incloses les refer\u00e8ncies a altres objectes) a una seq\u00fc\u00e8ncia de bytes, aix\u00ed com tamb\u00e9 l'acci\u00f3 de reconstruir eixos bytes en un objecte viu en un futur. La serialitzaci\u00f3 s'utilitza quan vols persistir un objecte, \u00e9s a dir, que dure m\u00e9s que el que dura l'execuci\u00f3 d'un programa o apliaci\u00f3. La declaraci\u00f3 de la classe els objectes de la qual van a ser persistents, han de implementar la interf\u00edcie \u00abserializable\u00bb del paquet java.io, la qual \u00e9s buida, no declara m\u00e8todes, simplement indica a la m\u00e0quina virtual de Java que les inst\u00e0ncies d\u2019aquestes classes podran gravar-se en un fitxer. Exemples 1 class racional implements serializable { ... } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import java.io.Serializable ; public class SerialClass implements Serializable { private static final long serialVersionUID = 1L ; private Date currentTime ; public SerialClass () { currentTime = Calendar . getInstance (). getTime (); } public Date getCurrentTime () { return currentTime ; } } ObjectOutputStream Els fluxos de la classe ObjectOutputStream s\u2019utilitzen per gravar objectes persistents. El m\u00e8tode writeObject() escriu qualsevol objecte d\u2019una classe serializable en el flux de bytes associat. Pot llen\u00e7ar excepcions del tipus IOException que \u00e9s necessari processar. 1 public void writeObject ( Object obj ) throws IOException ; El constructor de la classe espera un argument de tipus OutputStream, que \u00e9s la base dels fluxos d\u2019eixida a nivell de bytes, per tant, per crear aquest tipus de fluxos primer es crea un d\u2019eixida a nivell de bytes associat a un arxiu extern i a continuaci\u00f3, es passa com argument al constructor de ObjectOutputStream, per exemple: 1 2 3 4 FileOutputStream bn = new FileOutputStream ( \"dadesRac.dat\" ); ObjectOutputStream fobj = new ObjectOuputStream ( bn ); bn . close (); fobj . close (); A continuaci\u00f3 es pot escriure qualsevol objecte al flux: 1 2 3 4 5 Persona juan = new Persona ( \"Juan\" , \"Martin\" , \"123432123X\" ); fobj . writeObject ( juan ); String str = new String ( \"Cadena de favors\" ); fobj . write ( str ); fobj . close (); ObjectInputStream El objectes guardats en arxius amb fluxos de la classe ObjectOutputStream es recuperen i lligen amb fluxos d\u2019entrada del tipus ObjectInputStream, aquesta classe \u00e9s una extensi\u00f3 d\u2019InputStream, a m\u00e9s a m\u00e9s, implementa la interf\u00edcie DataInput, per aix\u00f2 disposa de diversos m\u00e8todes d\u2019entrada (read) per cadascun dels tipus de dades com readInt() o altres. El m\u00e8tode m\u00e9s important definit per la classe ObjectInputStream \u00e9s readObject(), el qual llig un objecte del flux d\u2019entrada, \u00e9s a dir, de l\u2019arxiu associat al flux de baix nivell; l\u2019objecte llegit es va escriure en el seu moment amb el m\u00e8tode writeObject() 1 public Object readObject () throws IOException ; El constructor de fluxos ObjectInputStreeam t\u00e9 com entrada un altre flux de baix nivell de qualsevol tipus derivat d\u2019InputStream, per exemple: FileInputStream associat amb l\u2019arxiu d\u2019objectes. A continuaci\u00f3 es crea un flux d\u2019entrada per llegir els objectes de l\u2019arxiu \u00abarchivoObjects.dat\u00bb 1 2 ObjectInputStream obj = new ObjectInputStream ( new FileInputStream ( \"arxiuObjects.dat\" )); obj . close (); El constructor llen\u00e7a una excepci\u00f3 si, per exemple, l\u2019arxiu no existeix, aquella \u00e9s del tipus \u00abClassNotFoundException\u00bb o \u00abIOException\u00bb, \u00e9s necessari poder capturar aquestes excepcions Exemple 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 import java.io.FileInputStream ; import java.io.FileOutputStream ; import java.io.ObjectInputStream ; import java.io.ObjectOutputStream ; import java.io.Serializable ; class Dog implements Serializable { String name ; String breed ; public Dog ( String name , String breed ) { this . name = name ; this . breed = breed ; } } class Main { public static void main ( String [] args ) { // Creates an object of Dog class Dog dog = new Dog ( \"Tyson\" , \"Labrador\" ); try { FileOutputStream file = new FileOutputStream ( \"file.txt\" ); // Creates an ObjectOutputStream ObjectOutputStream output = new ObjectOutputStream ( file ); // Writes objects to the output stream output . writeObject ( dog ); FileInputStream fileStream = new FileInputStream ( \"file.txt\" ); // Creates an ObjectInputStream ObjectInputStream input = new ObjectInputStream ( fileStream ); // Reads the objects Dog newDog = ( Dog ) input . readObject (); System . out . println ( \"Dog Name: \" + newDog . name ); System . out . println ( \"Dog Breed: \" + newDog . breed ); output . close (); input . close (); } catch ( Exception e ) { e . getStackTrace (); } } } Actitivat 9 Dissenya una aplicaci\u00f3 amb Eclipse IDE on es podr\u00e0 per un costat introduir informaci\u00f3 d'alumnes que es guardaran en un fitxer que s'anomene: 'alumnes.dat'. Al principi l'apliaci\u00f3 llegir\u00e0 de l'arxiu 'alumnes.dat' tots els alumnes inscrits al curs i els mostrar per pantalla, ordenats alfab\u00e8ticament pel congnom. Una vegada haja mostrat tots els alumnes, l'apliaci\u00f3 esperar\u00e0 que s'introduiexca algun alumne nou per consola, una vegada introduits totes les dades de l'alumne, aquesta es guardar\u00e0 en un objecte primer i despr\u00e9s al fitxer 'alumnes.dat' a continuaci\u00f3 dels que ja haiven estat enregistrats. Despr\u00e9s tornar\u00e0 a mostrar els alumnes ordenats alfab\u00e8ticament i torna a comen\u00e7ar. Excepcions Un problema important en el desenvolupament del programari \u00e9s la gesti\u00f3 de les errades o errors. No importa quan b\u00e9 estiga planificat aquest desenvolupament i quan eficient siga l\u2019equip desenvolupador. \u00c9s una m\u00e0xima en inform\u00e0tica el fet que sempre apareixeran problemes. Aquests problemes inesperats s\u00f3n problemes o errors que apareixen en temps d\u2019execuci\u00f3, per exemple: esgotament de mem\u00f2ria o recursos, errors en els intervals dels bucles, divisions per zero, arxius no existents, etc.. Les excepcions s\u00f3n el mecanisme previst per Java per tractar aquests problemes sobrevinguts. Amb les excepcions, Java dona la possibilitat al programador salvar aquest tipus de situacions de manera controlada sense que el programa o aplicaci\u00f3 es tanque, bloquege o deixe de respondre. Condicions d'errors en programes Programar, escriure codi, m\u00e8todes, classes, etc.. que siga eficient, efica\u00e7 i lliure d\u2019errades \u00e9s altament complicat. El control d\u2019errades \u00e9s una part tant important en el disseny d\u2019aplicacions que a totes les diferents metodologia de cicle de vida software, hi ha una fase que es dedica \u00fanica i exclusivament a detectar aquestes errades i solucionar-les i aix\u00ed i tot \u00e9s impossible produir programari totalment lliure d\u2019errades. Tractament dels codis d'error Java inclou un mecanisme de gesti\u00f3 d\u2019excepcions per poder intentat cobrir possibles errades en els programes en temps d\u2019execuci\u00f3. Aquest mecanisme consisteix en capturar (catch) els errors quan es produeixen en temps d\u2019execuci\u00f3. Quan es produeix un fallo en temps d\u2019execuci\u00f3 es podrien fer tres coses: parar l\u2019execuci\u00f3 de sobte, continuar executant esperant que no passe res o establir una senyal d\u2019error que el mateix codi amb altres sent\u00e8ncies s\u2019encarregue de gestionar. Aquestes senyals que envia (throw) el programa quan es produeix alguna errada en Java s\u2019anomenen excepcions i el bloc del codi on es posen les sent\u00e8ncies per tal d\u2019intentar solucionar-lo en temps d\u2019execuci\u00f3 \u00e9s el bloc catch. Excepcions en Java Una excepci\u00f3 \u00e9s un fallo que es produeix en temps d\u2019execuci\u00f3. Si hem escrit b\u00e9 el codi per tal de gestionar aquest fallo, el flux d\u2019execuci\u00f3 passa al codi destinat a gestionar les excepcions, en cas contrari el programa acaba la seua execuci\u00f3. Aquestes excepcions es poden produir per exemple si intenten accedir a un element d\u2019un array fora dels seus l\u00edmits, si intentem obrir un fitxer que no existeix o est\u00e0 bloquejat, si dividim per zero, etc.. El model de gesti\u00f3 d\u2019excepcions a Java afegeix cinc noves paraules reservades: try, throw, throws, catch i finally. try: bloc on es detectaran les excepcions catch: captura les excepcions que es produiexen al bloc try throw: expressi\u00f3 per llen\u00e7ar excepcions throws: indica les excepcions que pot llen\u00e7ar un m\u00e8tode. finally: bloc opcional situat despr\u00e9s del try catch Els pasos del model de control d\u2019excepcions en Java s\u00f3n: El bloc try cont\u00e9 les instruccions o part del codi susceptible de provocar algun error. Si en temps d\u2019execuci\u00f3 es produeix algun error dins de les sent\u00e8ncies que es troben dins del bloc try, es llen\u00e7a una excepci\u00f3. S\u2019executa el codi que es troba dins del bloc catch associat a la excepci\u00f3 que s\u2019ha llen\u00e7at al punt anterior. S\u2019executa el bloc finally (opcional) Exemple. Suposem una classe persona que incorporarem a la nostra aplicaci\u00f3. Aquesta classe t\u00e9 un constructor al qual se li passa el DNI, imaginem ara que de la nostra aplicaci\u00f3 instanciem un objecte de la classe persona a la qual l direm Joan per\u00f2 quan cridem al constructor de la classe no li passem un DNI, aquest \u00abmal \u00fas\u00bb de la classe Persona, llen\u00e7aria una excepci\u00f3 que hauria de capturar la nostra aplicaci\u00f3 al bloc catch i \u00e9s ac\u00ed, en aquest bloc d\u2019instruccions, en el que s\u2019hauria de corregir la situaci\u00f3 o avisar a l\u2019usuari de l\u2019aplicaci\u00f3 del que ha passat. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public void escolta () throws Exception { // Codi del metode escolta // ... throw new Exception (); } public static void main ( String [] args ) { try { escolta (); } catch ( Exception e ) { // Codi a executar quan es produeix una excepci\u00f3. } } Al codi anterior hem crear un m\u00e8tode escolta que l\u2019\u00fanic que fa \u00e9s lle\u00e7ar una excepci\u00f3. Quan al m\u00e8tode main cridem a la funci\u00f3 escolta, si volem fer \u00fas del sistema d\u2019excepcions de Java, l\u2019haurem de posar dins del bloc try. Just despr\u00e8s d\u2019acabar el conjunt d\u2019instruccions del bloc try posem un catch indicant-li quina \u00e9s la classe d\u2019excepci\u00f3 que hauriem de capturar, al nostre cas Exception, i dins del bloc catch posariem el codi que s\u2019hauria d\u2019executar en cas de produir-se eixe error. Normalment es solen posar missatges d\u2019error que alerten l\u2019usuari de l\u2019aplicaci\u00f3. A continuaci\u00f3 explicarem amb m\u00e9s detall qu\u00e8 \u00e9s el que fan cadascun dels blocs del mecanisme d\u2019excepcions que ha dissenyat Java. Bloc try Dins del bloc try s\u2019han de posar aquelles sent\u00e8ncies que poden llen\u00e7ar alguna excepci\u00f3 entre claud\u00e0tors, despr\u00e9s del claud\u00e0tor de tancament s\u2019ha de posar el bloc catch o controlador d\u2019excepcions almenys un bloc catch. Si l\u2019excepci\u00f3 que es produeix coincideix amb algun dels par\u00e0metres dels blocs catch que hi han, s\u2019executen les sent\u00e8ncies que es troben a dintre. Els blocs try, de la mateixa forma que amb totes les sent\u00e8ncies de programaci\u00f3 estructurada, es poden niar. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public static void main ( String [] args ) { try { escolta (); try { tornaAEscoltar (); } catch ( Exception e ) { // Codi excepci\u00f3 interna } } catch ( Exception e ) { // Codi excepci\u00f3 externa } } A l\u2019exemple anterior \u00e9s pot observar un codi amb dos blocs try niats on el primer bloc try t\u00e9 dos blocs catch per controlar varies excepcions Bloc throw La sent\u00e8ncia throw llen\u00e7a (raise) una excepci\u00f3. Les excepcions en Java s\u00f3n objectes, per tant, una excepci\u00f3 \u00e9s una inst\u00e0ncia d\u2019una classe que deriva de la classe Exception A l\u2019exemple anterior com es pot observar es capturen dos tipus d\u2019excepcions diferents, una generica Exception i una altra FileNotFoundException. Aquesta \u00faltima es produiex normalment quan volem obrir un fitxer, amb la classe File per exemple, i aquest no existeix. Bloc catch El bloc catch o de captura d\u2019excepcions. Quan una excepci\u00f3 es llen\u00e7a des d\u2019un bloc try, si el tipus d\u2019excepci\u00f3 que s\u2019ha llen\u00e7at coincideix amb el tipus d\u2019excepci\u00f3 que s\u2019ha passat per par\u00e0metre al catch, s\u2019executarien les sent\u00e8ncies que hi han dins del bloc catch. Normalment es sol posar el codi necessari per poder eixir de la situaci\u00f3 en la que ens trobem quan s\u2019al\u00e7a una excepci\u00f3. Cl\u00e0usula finally El bloc finally en un try..catch, \u00e9s el bloc d\u2019instruccions que s\u2019executar\u00e0 sempre, hi haja excepcions o no, al final de tot el nostre codi. Normalment es solen posar sent\u00e8ncies per tal d\u2019alliberar tot all\u00f2 que pugam haver creat dins del bloc try, \u00e9s a dir, tancar fluxos, fitxers, connexions a bases de dades etc..amb la finalitat d\u2019alliberar mem\u00f2ria. Classes d'excepcions en Java Nove excepcions Java permet la creaci\u00f3 d\u2019excepcions noves que deriven de la classe base Exception","title":"8.- Entrada, eixida, excepcions"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#tema-8-entrada-eixida-i-excepcions","text":"","title":"Tema 8. Entrada, eixida i excepcions"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#introduccio","text":"Una part important de tot llenguatge de programaci\u00f3 \u00e9s com s\u2019establir\u00e0 el contacte amb l\u2019exterior, b\u00e9 siga mitjan\u00e7ant la consola o a trav\u00e9s del sistema de fitxers , per finalment poder actuar amb l\u2019usuari d\u2019una aplicaci\u00f3 en execuci\u00f3. Ambd\u00f3s, consola i sistema de fitxers, poden funcionar tant d\u2019entrada als nostres programes com d\u2019eixida. Java defineix una abstracci\u00f3, els streams o fluxos per tractar la comunicaci\u00f3 d\u2019informaci\u00f3 amb l\u2019exterior. Per entendre-ho millor, un stream o flux \u00e9s com un canal de comunicaci\u00f3 entre un origen i un dest\u00ed. Per exemple suposem el cas d\u2019un programa que quan arranque haja de llegir una llista de clients d\u2019un fitxer de text per crear una agenda. En aquest cas l\u2019origen seria el fitxer de text i el dest\u00ed el programa o aplicaci\u00f3 que s\u2019encarrega d\u2019emplenar l\u2019agenda amb el llistat de clients, doncs b\u00e9, l\u2019stream en aquest escenari seria el canal de comunicaci\u00f3 que s\u2019establiria entre el fitxer de text i el programa per tal que aquest puga llegir la informaci\u00f3. A la imatge anterior es poden observar dos tipus de fluxos de dades: El primer \u00e9s un flux d'entrada de dades, s'enten d'entrada perqu\u00e8 va del sistema de fitxers al programa, mentre que el segon representa un flux de dades d'eixida, ja que aquest va del programa al sistema de fitxers. En aquest tema explicarem com Java tracta mitjan\u00e7ant objectes l\u2019establiment d'aquests canals de comunicaci\u00f3 i quines s\u00f3n les operacions que hi podem fer i com s\u2019han d\u2019utilitzar aquestes abstraccions de Java. D\u2019altra banda Java tamb\u00e9 ofereix el mecanisme d\u2019excepcions per controlar els errors sobrevinguts. Una excepci\u00f3 \u00e9s un problema que es produeix en temps d\u2019execuci\u00f3. Java permet controlar aquests problemes i programar amb els try...catch la soluci\u00f3 als errors en temps d\u2019execuci\u00f3.","title":"Introducci\u00f3"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#entrada-i-eixida-basiques","text":"Com hem dit abans, Java organitza la entrada i eixida mitjan\u00e7ant l\u2019\u00fas d\u2019streams, que s\u00f3n abstraccions en realitat , i aquests streams el que fan es transportar la informaci\u00f3 del programa o aplicaci\u00f3 a dispositius externs. Aquests dispositius externs poden ser b\u00e9 fitxers o incl\u00fas la consola, que es tractada com un fitxer per Java.","title":"Entrada i eixida b\u00e0siques"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#flux-de-dades-a-nivell-de-byte","text":"Com ja hem explicat abans, el tractament de l'entrada eixida en java a nivell de bytes es fa amb les classes abstractes InputStream i OutputStream de les quals deriven les classes: FileInputStream i FileOutputStream PipedInputStream i PipedOutputStream FilterInputStream i FilterOutputStream ByteArrayInputStream i ByteArrayOutputStream ObjectInputStream i ObjectOutputStream, etc..","title":"Flux de dades a nivell de byte"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#flux-de-dades-a-nivell-de-caracter","text":"Una altra forma de poder treballar amb fitxers en lloc de a nivell de byte com estavem fent als apartats anteriors, \u00e9s fer-ho a nivell de caracter. Al cap i a la fi els arxius, en una gran majoria, solen ser seq\u00fc\u00e8ncies de caracters i des del punt de vista l\u00f2gic ens resulta m\u00e9s natural treballar amb ells a aquest nivell.","title":"Flux de dades a nivell de caracter"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#arxius-dobjectes","text":"Fins ara hem tractat el tema d'entrada - eixida d'informaci\u00f3 utilitzant els tipus primitius o b\u00e0sics que ens proporciona el llenguatge de programaci\u00f3: int, char, float, String... per\u00f2 que passa si el que volem desar o llegir des d'un dispositiu extern \u00e9s un o diversos objectes? Com es guarden i com es recuperen aquestos objectes? Java proporciona una mecanisme que s'anomena serialitzaci\u00f3 que consisteix en convertir un objecte en una seq\u00fc\u00e8ncia de bytes de tal forma que, ara s\u00ed, es podr\u00e0 desar a un fitxer o un dispositiu extern. El proc\u00e9s de lectura d'un objecte serialitzat a un fitxer, per contra, s'anomena desserialitzaci\u00f3 . Per tal que un objecte continue existint, \u00e9s a dir, que siga persistent, una vegada ja hem finalitzat l\u2019execuci\u00f3 d\u2019un programa o aplicaci\u00f3 l\u2019hem de desar a un arxiu d\u2019objectes. Per poder aconseguir a\u00e7\u00f2, utilitzarem les classes ObjectInputStream i ObjectOutputStream","title":"Arxius d'objectes"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#excepcions","text":"Un problema important en el desenvolupament del programari \u00e9s la gesti\u00f3 de les errades o errors. No importa quan b\u00e9 estiga planificat aquest desenvolupament i quan eficient siga l\u2019equip desenvolupador. \u00c9s una m\u00e0xima en inform\u00e0tica el fet que sempre apareixeran problemes. Aquests problemes inesperats s\u00f3n problemes o errors que apareixen en temps d\u2019execuci\u00f3, per exemple: esgotament de mem\u00f2ria o recursos, errors en els intervals dels bucles, divisions per zero, arxius no existents, etc.. Les excepcions s\u00f3n el mecanisme previst per Java per tractar aquests problemes sobrevinguts. Amb les excepcions, Java dona la possibilitat al programador salvar aquest tipus de situacions de manera controlada sense que el programa o aplicaci\u00f3 es tanque, bloquege o deixe de respondre.","title":"Excepcions"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/","text":"Tema 9. Gr\u00e0fics. Java Swing Introducci\u00f3 Fins ara hem estat utilitzant la consola i el teclat a les nostres aplicacions per tal de comunicar-nos amb l'usuari. En aquest tema utilitzarem l'API de Java per al desenvolupament de components gr\u00e0fics Swing. Swing \u00e9s un conjunt d'eines per a Java. \u00c9s una API que proporciona interf\u00edcie gr\u00e0fica d'usuari (GUI) per a programes de Java. Entre d'altres Swing cont\u00e9: frames, botons, textbox, men\u00fas a banda dels events associats als elements. Swing va ser desenvolupat per a proporcionar un conjunt m\u00e9s complex de components GUI que l'anterior Abstract Window Toolkit (AWT). Swing proporciona un aspecte i aparen\u00e7a natiu que emula diverses plataformes, tamb\u00e9 d\u00f3na suport a extensions d'aspecte i aparen\u00e7a que permeten a les aplicacions tindre un aspecte i apare\u00e7a que no guarda relaci\u00f3 amb la plataforma subjacent. Hu\u00ed en dia la majoria de desenvolupadors Java utilitzen Swing o JavaFX per construir interf\u00edcies d'usuari La llibreria Swing Com tot en Java, swing no anava a ser menys, est\u00e0 dissenyat com una llibreria de classes, interf\u00edcies, recursos, etc.. per la construcci\u00f3 d'insterf\u00edcies gr\u00e0fiques. Swing cont\u00e9 tres APIs una per a components 2D, una altra per al Drag & Drop i l'\u00faltima per facilitar l'acc\u00e9s. Swing est\u00e0 basada en AWT per\u00f2 \u00e9s independent de la plataforma, \u00e9s a dir, sempre mostra la mateixa aparen\u00e7a independentment del sistema en el que s'execute l'aplicaci\u00f3 a difer\u00e8ncia d'AWT. Amb Swing podem fer: - Marcs: Finestres amb de t\u00edtol, men\u00fa, botons maximitzar, minimitzar i tancar. - Contenidors: poden agrupar diversos controls. - Botons - Etiqutes: text - Camps i arees de text. - Desplegables Per tal de poder utilitzar les llibreries Swing de Java hauriem d'afegir al nostre codi el seg\u00fcent: 1 import javax.swing.* ; Components i contenidors En general, els components Swing es deriven de la classe JComponent. Les \u00faniques excepcions s\u00f3n els quatre contenidors de nivell superior. JComponent proporciona la funcionalitat que \u00e9s com\u00fa a tots els components. Per exemple, JComponent admet la look & feel conectables. JComponent hereta les classes AWT Container i Component. Per tant, un component Swing est\u00e0 integrat i es compatible amb un component AWT. Tots els components de Swing estan representats per classes definides dins del paquet javax.swing com hem explicat abans. La seg\u00fcent taula mostra els noms de classe per als components Swing inclosos els contenidors. Components Java Swing JApplet JButton JCheckBox JCheckBoxMenuItem JColorChooser JComboBox JComponent JDesktopPane JDialog JEditorPane JFileChooser JFormattedTextField JFrame JInternalFrame JLabel JLayer JLayeredPane JList JMenu JMenuBar JMenuItem JOptionPane JPanel JPasswordField JPopUpMenu JProgressBar JRadioButton JRadioButtonMenuItem JRootPane JScrollBar JScrollPane JSeparator JSlider JSpineer JSplitPane JTabbedPane JTable JTextArea JTextField JTextPane JTogglebutton JToolBar JToolTip JTree JViewport JWindows La majora de noms solen ser prou significatius i resulta intuitiu a primer cop d'ull saber quina \u00e9s la finalitat de cadascun dels components. Contenidors Java Swing Swing defineix dos tipus de contenidors. Els primers s\u00f3n contenidors de nivell superior: JFrame, JApplet, JWindow i JDialog. (JApplet, que admet applets basats en Swing, ha estat descartat per JDK 9.) Aquests contenidors no hereten JComponent. No obstant aix\u00f2, hereten les classes AWT Component i Container. A difer\u00e8ncia d'altres components de Swing, que s\u00f3n lightweight, els contenidors de nivell superior s\u00f3n heavyweight. Aix\u00f2 fa que els contenidors de nivell superior siguin un cas especial a la biblioteca de components Swing. Com el seu nom indica, un contenidor de nivell superior ha d'estar a la part superior d'una jerarquia de contenci\u00f3. Un contenidor de nivell superior no est\u00e0 contingut en cap altre contenidor. A m\u00e9s, cada jerarquia de contenci\u00f3 ha de comen\u00e7ar amb un contenidor de nivell superior. El m\u00e9s comunament utilitzat per les aplicacions \u00e9s JFrame. El segon tipus de contenidor compatible amb Swing \u00e9s el contenidor lightweight. Els contenidors lightweight hereten JComponent. Exemples de contenidors lightweight s\u00f3n JPanel, JScrollPane i JRootPane. Els contenidors lightweight sovint es fan servir per a organitzar i administrar col\u00b7lectivament grups de components relacionats perqu\u00e8 un contenidor lightweight es pot contenir dins d'un altre contenidor. Per tant, pot utilitzar contenidors lightweight per crear subgrups de controls relacionats que estan continguts dins d'un contenidor extern. Swing vs AWT \u00c9s possible utilitzar Swing i AWT a la mateixa interf\u00edcie, per\u00f2 podria donar problemes. \u00c9s recomanable utilitzar nom\u00e9s components Swing, ja que tot component AWT t\u00e9 el seu equivalent Swing. La majoria de classes Swing comencen per J, per exemple: JButton, JFrame... encara que tamb\u00e9 existeixen Frame i Button que pertanyen a la llibreria AWT. Cal tindre molta cura en no oblidar de posar la 'J' davant dels components ja que si no podria portar a inconsist\u00e8ncies a causa de mesclar components. A l'actualitat quasi tota la programaci\u00f3 gr\u00e0fica en Java es fa amb Swing que implemente una interf\u00edcie gr\u00e0fica normalment va a tenir quatre tipus d'elements: 1. Un contenidor de nivell superior: un marc (JFrame), un applet (JApplet) o b\u00e9 objectes JDialog. Aquests contenidors no estan dins d'una altra finestra, s\u00f3n les finestres principals. 2. Components de la interf\u00edcie gr\u00e0fica: botons, camps de text, etc\u00e8tera, que se situen a la finestra principal o en contenidors. 3. Contenidors dissenyats per altres elements de la interf\u00edcie; JPanel i JScrollPane s\u00f3n dos contenidors i, a el mateix temps, s\u00f3n components. 4. Elements per a la gesti\u00f3 d'esdeveniments. Els components sempre s'afegeixen a una l\u00e0mina o panell; pot ser la de el marc, o b\u00e9 un panell tipus JPanel. En general, sempre es creen classes derivades de les classes contenidors de nivell superior; tot marc ser\u00e0 una subclasse de JFrame, a l'igual que un applet \u00e9s una subclasse de JApplet. Creaci\u00f3 d'un JFrame La difer\u00e8ncia entre crear programes que es comuniquen amb l'usuari mitjan\u00e7ant el terminal i el teclat i fer programes amb Swing \u00e9s considerable. Al crear una aplicaci\u00f3 Swing s'han de tenir en compte conceptes nous com el threading . Per\u00f2 per entendre-ho tot millor, farem un programa Swing d'exemple. Per al programa d'exemple crearem un JFrame al qual li posarem una JLabel Exemple 1. Programa simple Swing 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // Un simple programa Swing import javax.swing.* ; public class SwingDemo { SwingDemo (){ JFrame jfrm = new JFrame ( \"Aplicaci\u00f3 Simple Swing\" ); // Crea un nou contenidor JFrame. jfrm . setSize ( 475 , 200 ); // Establim el tamany inicial jfrm . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); // Acabe el programa quan l'usuari tanque l'aplicaci\u00f3. JLabel jLabel = new JLabel ( \"Programaci\u00f3 GUI amb Swing.\" ); // Creem una etiqueta jLabel . setHorizontalAlignment ( SwingConstants . CENTER ); // Situem l'etiqueta al centre del frame jfrm . add ( jLabel ); // Afegim l'etiqueta al frame jfrm . setVisible ( true ); // Visualitzem el marc. } public static void main ( String [] args ) { SwingUtilities . invokeLater ( new Runnable () { public void run (){ new SwingDemo (); } }); } } El resultat del codi anterior seria el seg\u00fcent: JFrame \u00e9s un contenidor de nivell superior que s'utilitza de forma com\u00fa a les aplicacions Swing, mentre que JLabel \u00e9s una etiqueta que ens servir\u00e0 per posar text. Expliquem amb m\u00e9s detall el que fa la funci\u00f3 main: - SwingUtilities.invokeLater() - static void invokeLater(Runnable doRun): Executa un doRun.run() per tal que s'execute de forma asincrona al AWT event dispatching thread. A aquets m\u00e8tode se li ha de passar un objecte Runnable - new Runnable() { }: - Objecte Runnable que s'ha de passar al m\u00e8tode invokeLater - public void run() { }: M\u00e8tode run que s'executa de l'objecte runnable que se li passa a InvokeLater - new SwingDemo() - Codi del m\u00e8tode run de l'objecte runnable. Una aplicaci\u00f3 que implemente una interf\u00edcie gr\u00e0fica normalment va a tindre quatre tipus d'elements. 1. Un contenidor de nivell superior: un marc (JFrame), un applet (JApplet) o b\u00e9 di\u00e0legs (JDialog) que faran el paper de finestra principal. 2. Components de la interf\u00edcie gr\u00e0fica: botons, camps de text, etc, que s'afegiran al contenidor de nivell superior anterior. 3. Contenidors dissenyats per altres elements de la interf\u00edcie: JPanel i JScrollPane s\u00f3n dos contenidors i al mateix temps s\u00f3n components. 4. Elements per la gesti\u00f3 d'events. Els components sempre s'afegeixen a una l\u00e0mina o paper; pot ser la del marc o b\u00e9 un panel tipus JPanel. En general, sempre es creen classes derivades de les classes contenidores de nivell superior. Tot marc ser\u00e0 una subclasse de JFrame, de la mateixa forma que un applet \u00e9s una subclasse de JApplet JFrame La classe JFrame \u00e9s un tipus de contenidor que hereta de la classe java.awt.Frame. JFrame funciona com la finestra principal on components com etiquetes, botons, camps de text etc, s'afegeixen per crear una interf\u00edcie gr\u00e0fica. M\u00e8todes M\u00e8tode Descripci\u00f3 JFrame() Constructor de la classe. Crea un marca sense t\u00edtol JFrame (String titol) Crea un marc amb t\u00edtol. void setTitle (String titlo) Estableix el t\u00edtol del marc void setIconImage ( Image img ) Estableix la icona del marc void setDefaultCloseOperation (int op ) programa el comportament del marca quan es tanca. Possibles valors: EXIT_ON_CLOSE, DO_NOTHING_ON_CLOSE, DISPOSE_ON_CLOSE, HIDE_ON_CLOSE Container getContentPane () proporciona el layout de continguts del marc, \u00e9s a dir, les vores void setResizable ( boolean r ) si r val true, es pot redimensionar el marc void add (Component c) Afegeix el component c al marc void removeComponent (Component c) elimina el component c del marc Component add (Component c, int p) Coloca el component c a la posici\u00f3 p del marc void setLayout (LayoutManager mngr) estableix la forma de distribuir el components al marc, els quals normalment es distribueixen en posicions relatives, segons el layout que tinga associat el marc void setVisible (boolean b) fa visible el component si b \u00e9s true void setBounds (int x, int y, int ample, int alt) situa el component i canvia el seu tamany void setLocation (int x, int y) situa el component a les coordenades x i y void setLocation (Point p) situa el component al punt p void setSize (int ample, int alt) estableix les dimensions del component void setSize (Dimension dim) estableix la dimensi\u00f3 del component a dim Layout Manager - Gestor de posicionament A difer\u00e8ncia d'altres aplicacions que es dediquen al disseny d'interf\u00edcies gr\u00e0fiques, les posicions dels elements dintre del nostre contenidor no es fan en pixels ni valors absoluts, s'utilitzen els Layout Manager que ho podriem traduir com \"gestors de disposici\u00f3\" o \"gestor de plantilla\" o \"gestor de posicionament\". Aquestos gestors de posicionament s\u00f3n elements que implementen la interf\u00edcie \"LayoutManager\". Cada cotenidor t\u00e9 associat un Layout Manager que pot ser: BorderLayout, FlowLayout, GridLayout, BoxLayout, GridBagLayout, CardLayout, SpringLayout... Veiem un exemple: Exemple 2. Marc de prova 1 2 JFrame marc = new JFrame ( \"MarcProva\" ); marco . setLayout ( new GridLayout ( 3 , 4 )); El que hem fet al codi anterior \u00e9s crear i instanciar un nou marc de tipus JFrame amb el t\u00edtol \"MarcProva\" i despr\u00e9s hem establert el seu gestor de posicionament de tipus GridLayout. A continuaci\u00f3 detallarem els m\u00e9s utilitzats BorderLayout Gestor de posicionament per defecte dels marcs (JFrame) i di\u00e0legs (JDialog). Divideix al contenidor en cinc zones: nord, sud, est, oest i centre, que es corresponen a: BorderLayout.NORTH, BorderLayout.SOUTH, BorderLayout.EAST, BorderLayout.WEST i BorderLayout.CENTER Veiem un exemple: Exemple 3. Marc amb vora 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import javax.swing.* ; import java.awt.* ; public class MarcBorder extends JFrame { static int AMPLE = 350 ; static int ALT = 200 ; public MarcBorder () { super ( \"T\u00edtol Marc\" ); add ( new JLabel ( \"Nord\" , SwingConstants . CENTER ), BorderLayout . NORTH ); add ( new JLabel ( \"Sud\" , SwingConstants . CENTER ), BorderLayout . SOUTH ); add ( new JLabel ( \"Centre\" , SwingConstants . CENTER ), BorderLayout . CENTER ); add ( new JLabel ( \"Oest\" , SwingConstants . CENTER ), BorderLayout . WEST ); add ( new JLabel ( \"Est\" , SwingConstants . CENTER ), BorderLayout . EAST ); setSize ( AMPLE , ALT ); setVisible ( true ); } public static void main ( String args [] ) { MarcBorder marc = new MarcBorder (); marc . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); } } El resultat del codi anterior \u00e9s: FlowLayout Amb aquest gestor podem colocar els elements d'esquerra cap a dreta i de dalt cap avall. La classe FlowLayout disposa de diversos constructors, un d'ells ens permet establir l'alineaci\u00f3 dels components FlowLayout(int align) on align pot ser: FlowLayout.RIGHT, FlowLayout.CENTER, FlowLayout.LEFT. Exemple 4. Flowlayout 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import java.awt.* ; import javax.swing.* ; public class MarcFlow extends JFrame { static int AMPLE = 175 ; static int ALT = 100 ; public MarcFlow () { super ( \"El meu marc\" ); setLayout ( new FlowLayout ()); add ( new JLabel ( \"Primera\" )); add ( new JLabel ( \"Segona\" )); add ( new JLabel ( \"Tercera\" )); add ( new JLabel ( \"Quarta\" )); add ( new JLabel ( \"Cinquena\" )); add ( new JLabel ( \"Sisena\" )); setSize ( AMPLE , ALT ); setVisible ( true ); } public static void main ( String args [] ) { MarcFlow marc = new MarcFlow (); marc . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); } } I aquest \u00e9s el resultat: GridLayout Aquest gestor de posicionament distribueix els components del container associat en forma de graella de cel\u00b7les iguals en forma de quadricula de dalt cap avall i de esquerra a dreta, \u00e9s a dir, en files i columnes. Exemple 5. GridLayout 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import java.awt.* ; import javax.swing.* ; public class MarcGrid extends JFrame { static int AMPLE = 175 ; static int ALT = 100 ; public MarcGrid () { super ( \"El meu marc\" ); setLayout ( new GridLayout ( 3 , 2 , 15 , 15 )); add ( new JLabel ( \"Primera\" )); add ( new JLabel ( \"Segona\" )); add ( new JLabel ( \"Tercera\" )); add ( new JLabel ( \"Quarta\" )); add ( new JLabel ( \"Cinquena\" )); add ( new JLabel ( \"Sisena\" )); setSize ( AMPLE , ALT ); setVisible ( true ); } public static void main ( String args [] ) { MarcGrid marc = new MarcGrid (); marc . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); } } Resultat del codi anterior: BoxLayout Aquest gestor coloca els components en una \u00fanica fila o una \u00fanica columna, s'assembla a una caixa amb orientaci\u00f3 horitzontal o vertical; el constructor necessita un argument amb el contenidor que es va a utilitzar i l'orientaci\u00f3 que pot ser: BoxLayout.X_AXIS o BoxLayout.Y_AXIS. El format del constructor \u00e9s: BoxLayout (Container desti, int orientacio) Exemple 6. BoxLayout 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import javax.swing.* ; import java.awt.* ; public class MarcBox extends JFrame { static int AMPLE = 175 ; static int ALT = 150 ; public MarcBox () { super ( \"El meu marcBox\" ); JPanel panel = new JPanel () ; panel . setLayout ( new BoxLayout ( panel , BoxLayout . Y_AXIS )); panel . add ( new JLabel ( \"Primera\" )); panel . add ( new JLabel ( \"Segona\" )); panel . add ( new JLabel ( \"Tercera\" )); panel . add ( new JLabel ( \"Quarta\" )); panel . add ( new JLabel ( \"Cinquena\" )); panel . add ( new JLabel ( \"Sisena\" )); add ( panel ); setSize ( AMPLE , ALT ); setVisible ( true ); } public static void main ( String args [] ) { MarcBox miMarcBox = new MarcBox (); miMarcBox . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); } } BoxLayout - Box Box o caixa, \u00e9s un contenidor que t\u00e9 com gestor de posicionament (LayoutManager) predeterminat un BoxLayout; utilitzant aquest contenidor no cal crear un panel perqu\u00e8 directament es crea un objecte Box i a continuaci\u00f3 s'afegeixen els components. La classe Box disposa de dos m\u00e8todes static (m\u00e8todes factoria) que creen l'objecte, i s\u00f3n: 1 2 Box . createHorizontalBox (); Box . createVerticalBox (); Aleshores, per crear un Box no s'utilitza el constructor sino que es crida a un d'aquestos dos m\u00e8todes; per un objecte Box amb orientaci\u00f3 horitzontal, per exemple: 1 Box caixaHoriz = Box . createHorizontalBox (); Al contenidor se li afegeix el component caixaHoriz.add(element) i despr\u00e9s el contenidor al marc. Exemple 7. BoxLayout - Box 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 import javax.swing.* ; import java.awt.* ; public class Marc2Box extends JFrame { static int AMPLE = 275 ; static int ALT = 175 ; public Marc2Box () { super ( \"El meu marc\" ); JButton b1 = new JButton ( \"Boto1\" ); JButton b2 = new JButton ( \"Boto2\" ); JButton b3 = new JButton ( \"Boto3\" ); JButton b4 = new JButton ( \"Boto4\" ); JButton b5 = new JButton ( \"Boto5\" ); JButton b6 = new JButton ( \"Boto6\" ); Box caixaH = Box . createHorizontalBox (); // m\u00e9todo factor\u00eda caixaH . add ( b1 ); // separaci\u00f3n horizontal de 10 pixeles caixaH . add ( Box . createHorizontalStrut ( 10 )); caixaH . add ( b2 ); // zona r\u00edgida, separaci\u00f3n horizontal caixaH . add ( Box . createRigidArea ( new Dimension ( 5 , 5 ))); caixaH . add ( b3 ); add ( caixaH , BorderLayout . NORTH ); Box caixaV = Box . createVerticalBox (); caixaV . add ( Box . createHorizontalStrut ( 70 )); caixaV . add ( b4 ); // separaci\u00f3n horizontal 10 pixeles caixaV . add ( Box . createVerticalStrut ( 10 )); caixaV . add ( b5 ); caixaV . add ( Box . createRigidArea ( new Dimension ( 5 , 5 ))); caixaV . add ( b6 ); add ( caixaV , BorderLayout . CENTER ); setSize ( AMPLE , ALT ); setVisible ( true ); } public static void main ( String args [] ) { Marc2Box marcBox2 = new Marc2Box (); marcBox2 . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); } } Combinar Layouts JFrame, JDialog i JPanel nom\u00e9s poden tindre un gestor de posicionament per\u00f2 si agafem un contenidor de primer nivell com un marc, podr\u00edem combinar diversos layouts niats (nested). Al seg\u00fcent exemple podem veure una combinaci\u00f3 de tres gestors de posicionament en un mateix contenidor. Exemple 8. Combinaci\u00f3 de disposicions (layouts) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import javax.swing.* ; import java.awt.* ; public class MarcGestors extends JFrame { public MarcGestors () { JPanel pa1 = new JPanel ( new FlowLayout ()); JPanel pa2 = new JPanel ( new BorderLayout ()); JPanel pa3 = new JPanel (); pa3 . setLayout ( new BoxLayout ( pa3 , BoxLayout . Y_AXIS )); // componentes del panel 1 String [] opc = { \"Alta mar\" , \"Baixa mar\" , \" Muntanya\" }; pa1 . add ( new JLabel ( \"Tria..\" , JLabel . CENTER )); pa1 . add ( new JList ( opc )); pa1 . add ( new JButton ( \"Pr\u00e8mer\" )); // componentes del panel 2 JTextField j = new JTextField ( \"Raons \" ); j . setEditable ( false ); pa2 . add ( j , BorderLayout . WEST ); pa2 . add ( new JButton ( \"Bot\u00f3\" ), BorderLayout . EAST ); // componentes del panel 3 pa3 . add ( new JCheckBox ( \"Box \" , false )); pa3 . add ( new JLabel ( \"Calendari\" , JLabel . CENTER )); pa3 . add ( new JRadioButton ( \"Bot Radio\" , true )); // asigna layout al marco y se ponen los paneles setLayout ( new BorderLayout ( 10 , 15 )); add ( pa1 , BorderLayout . NORTH ); add ( pa2 , BorderLayout . CENTER ); add ( pa3 , BorderLayout . SOUTH ); } public static void main ( String [] args ) { MarcGestors m ; m = new MarcGestors (); m . setSize ( 200 , 300 ); m . setLocation ( 20 , 200 ); m . setResizable ( false ); m . setVisible ( true ); m . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); } } El resultat seria: Desactivar gestor de posicionament Per defecte un contenidor sempre t\u00e9 associat un gestor de posicionament (layout) per\u00f2 de vegades ens pot resultar interessant desactivar aquest gestor de posicionament. Utilitzarem el m\u00e8tode setLayout i li passarem per parametre null. Etiqutes Una etiqueta \u00e9s un component nom\u00e9s lectura al qual li podem modificar el text que cont\u00e9 i que normalment s'utilitza per posar algun missatge significatiu de la nostra interf\u00edcie a l'usuari final. En altres paraules, s\u00f3n components de text fixe que nom\u00e9s mostren text per\u00f2 que no reben cap event. Per gestionar les etiquetes a Java utilitzem la classe JLabel M\u00e8todes JLabel (): Crea una etiqueta sense text associat. JLabel (String msg): Crea una etiqueta amb el text msg. JLabel (String msg, Icon icona): Crea una etiqueta amb el text msg i la icona icon. JLabel (String msg, int align): crea una etiqueta amb el text msg alineat segons el segon argument que pot ser SwingConstants.CENTER, SwingConstants.LEFT o SwingConstants.RIGHT. public String getText (): torna el text de l'etiqueta public void setText (String msg): estableix el text de l'etiqueta. Botons A Swing es defineixe diversos tipus de botons, la classe base dels quals \u00e9s Abstract Button , \u00e9s una classe abstracta que encapsula propietats i m\u00e8todes comuns als diversos tipus de botons M\u00e8todes void setText (String text) : Estableix el text del bot\u00f3. String getText () : Obt\u00e9 el text del bot\u00f3. boolean isSelected() : true si s'ha seleccionat el bot\u00f3. void setSelectes (boolean b) : selecciona el bot\u00f3. void doClick (int temps) : tria el bot\u00f3 durant temps milisegons void setIcon (Icon icona) : estableix la icona del bot\u00f3. void setMnemonic (int mnemonic) : relaciona una tecla amb el bot\u00f3. void addActionListener(ActionListener al) : assigna un listener per controlar events. JButton La classe JButton representa el bot\u00f3 com\u00fa; es crea especificament una cadena, una icona, ambdos, o un element encara sense especificar; els constructors de la classe s\u00f3n: - JButton() : Constructor de la classe - JButton(String text) : Constructor amb text del bot\u00f3. - JButton(String text, Icon icona) : Constructor amb text i icona. La classe deriva d'AbstractButton per tant tots els seus m\u00e8todes estaran disponibles tamb\u00e9. 1 2 3 4 JButton b1 , b2 , b3 ; b1 = new JButton (); b2 = new JButton ( \"GROC\" ); b3 = new JButton ( new LibroIcon ()); Botons amb dos estats JToogleButton \u00e9s la classe base dels botons amb dos estats; JRadioButton que s'utilitza per definir un grup de botons d'opci\u00f3 \u00fanica; per agrupar botons d'opci\u00f3 \u00fanica s'utilitza la classe ButtonGroup, primer es crea un objecte ButtonGroup (constructor sense arguments); a continuaci\u00f3 s'afegeix JRadioButton amb el m\u00e8tode de ButtonGroup, add(AbstracButton b). Constructors de JRadioButton JRadioButton() : Constructor per defecte. JRadioButton(String msg) : Constructor amb text del bot\u00f3. JRadioButton(String msg, boolean sel) : Constructor amb el text i si sel \u00e9s true, el bot\u00f3 ja estaria seleccionat. Exemple 9. Diversons botons 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import javax.swing.* ; class PanelJRadio extends JPanel { ButtonGroup grb ; JRadioButton jr1 , jr2 , jr3 ; public PanelJRadio () { grb = new ButtonGroup (); setLayout ( new GridLayout ( 4 , 1 )); add ( new JLabel ( \"Selecci\u00f3 excloent\" )); // se crea bot\u00f3n de radio, se a\u00f1ade al panel y a la agrupaci\u00f3n jr1 = new JRadioButton ( \"Avi\u00f3\" , false ); add ( jr1 ); grb . add ( jr1 ); // se crea bot\u00f3n de radio, se a\u00f1ade al panel y a la agrupaci\u00f3n jr2 = new JRadioButton ( \"Tren\" , false ); add ( jr2 ); grb . add ( jr2 ); // se crea bot\u00f3n de radio, se a\u00f1ade al panel y a la agrupaci\u00f3n jr3 = new JRadioButton ( \"Cotxe\" , false ); add ( jr3 ); grb . add ( jr3 ); } } JCheckBox o tamb\u00e9 anomenat: casella de verificaci\u00f3, check o checkbox. Constructors de JCheckBox JCheckBox(): Constructor per defecte. JCheckBox(String text): : Constructor amb el text associat. JCheckBox(String text, boolean sel): Constructor amb text i si sel \u00e9s true, la casella vindria ja marcada. La classe JComboBox no est\u00e0 a la jerarquia de botons, no deriva d'AbstractButton; combina en un sol component un bot\u00f3 amb una llista d'elements. Una JComboBox s'utilitza per crear una llista desplegable a la que es poden afegir opcions, editarles o fer seleccions. Constructors de JComboBox JComboBox(): Constructor per defecte. JComboBox(Object llista[]): Constructor amb una llista d'objectes per par\u00e0metre. Alguns dels seus m\u00e8todes s\u00f3n: - public void addItem(Object q): afegeix un element a la llista (pel final). - public insertItemAt(Object q, int indice): insereix en \u00edndex l'element. - public void setEditable(boolean flag): si flag \u00e9s true l'element de llista seleccionat \u00e9s editable. - public void setMaximumRowCount(int n): posa el m\u00e0xim d'elements a mostrar en el combo, si hi ha m\u00e9s elements apareix la barra d'scroll. - public Object getSelectedItem(): torna l'element seleccionat. Els m\u00e8todes seg\u00fcents s\u00f3n per la gesti\u00f3 d'events al combobox: - public void actionPerformed(ActionEvent ev); - public void addActionListener(ActionListener ae); - public void addItemListener(ItemListener it); - public void addStateChanged(ItemEvent ev); Exemple 10. ComboBox 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import javax.swing.* ; import java.awt.* ; import java.awt.event.* ; class PanelJCombo extends JPanel { private JComboBox jcb ; public PanelJCombo () { jcb = new JComboBox (); setLayout ( new BorderLayout ()); jcb . addItem ( \"MAD - BCN\" ); jcb . addItem ( \"MAD - AGP\" ); jcb . addItem ( \"MAD - XRY\" ); jcb . addItem ( \"BRU - TFN\" ); jcb . addItem ( \"LEN - BCN\" ); jcb . addItem ( \"ROM - BCN\" ); jcb . setMaximumRowCount ( 4 ); add ( jcb , BorderLayout . NORTH ); } } Components de text Els components Swing que s'utilitzen per editar o mostrar text formen una jerarquia de classes la base de la qual \u00e9s JTextComponent; aquesta \u00faltima \u00e9s una classe abstracta que es troba al paquet java.swing.text JTextComponent Els components de text suporten una ampla varietat de caracters de c\u00f2dis alfab\u00e8tics; en ells es pot inserir, esborrar o seleccionar caracters; \u00e9s text modificable per l'usuari; la classe disposa del constructor JTextComponent() que crea una component de text editable. Els seus m\u00e8todes s\u00f3n: - String getText(): torna el text que t\u00e9 el component. - String getText(int dspl,int lon): torna el text del component a partir del despla\u00e7ament dspl i de la longitud lon. - void setText(String txt): : substituieix el text del component per txt; si txt \u00e9s null o \u00e9s una cadena buida, esborra el text del component. - void setEditable(boolean b): un component de text \u00e9s editable per omisi\u00f3; amb aquest m\u00e8tode s'especifica si \u00e9s o no. JTextField, JPasswordText La classe JTextField representa un camp de text modificable per l'usuar; amb aquest component s'edita una l\u00ednia de text amb l'ample, alineaci\u00f3 i tipus de lletra que es desitge. JPasswordField es deriva de JTextField; representa un camp de text amb la particularitat de que emmascara els caracters quan es visualitza; s'utilitza per editar una clau secreta, contrasenya o password; per omisi\u00f3, cada caracter de un JPasswordField es substitueix per un '*'. Els constructors de JTextField s\u00f3n: - JTextField(): camp de text buit de 0 columnes. - JTextField(int cols): camp de text buit de cols columnes. - JTextField(String msg): camp de text ajustat a la cadena msg. - JTextField(String msg,int col): camp de text amb la cadena msg i de cols columnes. Els constructors de JPasswordField tenen els mateixos arguments que JTextField; els seus m\u00e8todes s\u00f3n: - void setFont(Font tipo) - void setHorizontalAlignment(int alig): alineaci\u00f3 del text; els valors possibles d'alig son les constants de SwingConstants : RIGHT, LEFT, CENTER, TRAILING, LEADING (aquest \u00e9s el predeterminat) - void setColumns(int cols): posa el n\u00famero de columnes preferit per al camp. JPasswordField hereta els m\u00e8todes anteriors i a m\u00e9s a m\u00e9s disposa d'aquestos: - void setEchoChar(char c): coloca c per emmascarar els caracters del camp. - char getEchoChar(): torna el caracter que emmascara; per defecte ' '. - char[] getPassword(): * torna la cadena del camp en un array de caracters. Exemple 11. Passwords i Labels 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 import javax.swing.* ; import java.awt.* ; import java.awt.event.* ; public class MarcPassWord extends JFrame { private static final int AMPLE = 300 , ALT = 150 ; private JPasswordField clau = null ; private JLabel et1 = null ; private JLabel res = null ; public MarcPassWord ( String c ) { super ( c ); setSize ( ANCHO , ALTO ); creaComponentes (); pack (); } private void creaComponents () { clau = new JPasswordField ( 20 ); et1 = new JLabel (); // oyente para proceso de la acci\u00f3n del usuario clave . addActionListener ( new ActionListener () { public void actionPerformed ( ActionEvent evt ) { procesoAccionUser ( evt ); } }); // pone el campo de texto con la clave add ( clau , BorderLayout . CENTER ); // crea y pone la etiqueta en el marco et1 . setFont ( new java . awt . Font ( \"Times New Roman\" , 3 , 12 )); et1 . setHorizontalAlignment ( javax . swing . SwingConstants . CENTER ); et1 . setText ( \"PASSWORD \" ); et1 . setToolTipText ( \"Exemple\" ); add ( et1 , BorderLayout . NORTH ); // m\u00e9todo que se ejecuta al actuar el usuario sobre el campo private void procesoAccionUser ( ActionEvent evt ) { char pas [] ; pas = clau . getPassword (); res = new JLabel ( \" \" ); res . setFont ( new Font ( \"Book Antiqua\" , 3 , 14 )); if ( pas . length == 0 ) { System . out . println ( \"Teclejar Password \" ); et1 . setText ( \"PASSWORD(teclejar) \" ); } else { clau . setEditable ( false ); res . setText ( \"Es valida la clau\" ); } add ( res , BorderLayout . SOUTH ); validate (); pack (); } public static void main ( String args [] ) { MarcPassWord marc ; marc = new MarcPassWord ( \"Marc amb password\" ); marc . setVisible ( true ); marc . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); } } } Resultat JTextArea El component JTextArea s'utilitza amb la finalitat de mostrar moltes l\u00ednies de text; disposa de m\u00e8todes per fixar l'ample de cada l\u00ednia i l'acci\u00f3 a realitzar si la l\u00ednia que s'insereix \u00e9s major que l'ample prefixat; tamb\u00e9 permet decidir si es trenquen o no les paraules al canvi de l\u00ednia. Aquest component no disposa de barra d'scroll JScrollPane , cal crear l'scroll i associar-lo al component; per exemple: es crea el component areaText: 1 2 3 4 5 JTextArea areaText = new JTextArea (); // A continuaci\u00f3 es crea l'scroll i s'associa a **areaText**: JScrollPane barra = new JScrollPane ( areaText ); // Per \u00faltim, l'scroll es posa al marc areaText . add ( barra ); Els constructors s\u00f3n: - JTextArea(): crea el component amb cadena nula, zero files i columnes. - JTextArea(int filas,int cols): crea amb cadena nula i el n\u00famero de files i columnes especificat. - JTextArea(String t): crea el component amb cadena t i zero files i columnes. - JTextArea(String t,int filas, int col): crea el component amb cadena t i el n\u00famero de files i columnes especificat. Els seus m\u00e8todes s\u00f3n: - public void append(String t): afegeix la cadena t al final del document. - public void insert(String t,int p): insereix la cadena t a partir de la posici\u00f3 p. - void replaceRange(String t, int inici, int fi): substitueix el text del document al rang inici-fi per la cadena t. - public void setColumns(int cols): fixa l'ample de cada l\u00ednia. - public void setLineWrap(boolean f): si f \u00e9s true activa el canvi autom\u00e0tica de l\u00ednia. - public void setWrapStyleWord(boolean f): si f \u00e9s true no 'trenca' les paraules en el canvi de l\u00ednia. Esdeveniments En aquest punt tractarem l'\u00fas dels esdeveniments per tal que la nostra aplicaci\u00f3 interactue amb l'usuari. Esdeveniment: All\u00f2 que s'esdev\u00e9. Fet considerat extraordinari o molt important en la vida d'una persona o col\u00b7lectivitat. Esdeveniment (Inform\u00e0tica): Fet que s'esdev\u00e9 o canvi d'un conjunt particular de circumst\u00e0ncies. En altres paraules un esdeveniment en una aplicaci\u00f3 inform\u00e0tica \u00e9s all\u00f3 que passa sense que necessariament estiga controlat al codi. Exemples d'esdeveniments: - Fer clic a un bot\u00f3. - Fer clic dins d'un textbox. - Minimitzar una finestra. - Escriure al teclat - etc Arribats a aquest punt podriem tindre una interf\u00edcie totalment dissenyada per\u00f2 no completament funcional, \u00e9s a dir, imagineu que hem dissenyat la interf\u00edcie per a una calculadora amb tots els seus controls necessaris. Qu\u00e8 passa si fem clic en algun bot\u00f3 de la calculadora? No res ,veritat. Encara hem de programar el comportament d'aquesta calculadora i per tal d'aconseguir-ho hem de fer \u00fas de la programaci\u00f3 d'esdeveniments. Aquest procediment es diu Event Handling i es pot aplicar a aquells elements gr\u00e0fics que produeixen algun esdeveniment. Els esdeveniments s\u00f3n essencials per als usuaris interactuen amb els components de una aplicaci\u00f3 gr\u00e0fica; el model d'esdeveniments segueix el AWT de Java. Aquest cap\u00edtol estudia la forma general de captura d'esdeveniments, la jerarquia de classes del model i les interfaces desenvolupades per a la seva captura; inclou exemples senzills de captura d\u2019esdeveniments de los botons. Veiem un exemple 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import java.awt.* ; import java.awt.event.* ; import javax.swing.* ; public class EventDemo { JLabel lab ; public EventDemo () { JFrame jfrm = new JFrame ( \"Esdeveniments\" ); jfrm . setLayout ( new FlowLayout ()); jfrm . setSize ( 220 , 90 ); jfrm . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); JButton btnAlpha = new JButton ( \"Alpha\" ); JButton btnBeta = new JButton ( \"Beta\" ); btnAlpha . addActionListener ( new ActionListener () { public void actionPerformed ( ActionEvent ae ) { lab . setText ( \"Alpha Pressed\" ); } }); btnBeta . addActionListener ( new ActionListener () { public void actionPerformed ( ActionEvent ae ) { lab . setText ( \"Beta Pressed\" ); } }); jfrm . add ( btnAlpha ); jfrm . add ( btnBeta ); lab = new JLabel ( \"Apreta un bot\u00f3\" ); jfrm . add ( lab ); jfrm . setVisible ( true ); } public static void main ( String [] args ) { SwingUtilities . invokeLater ( new Runnable () { public void run () { new EventDemo (); } }); } } El resultat seria Jlist Selection Listener A continuaci\u00f3 escriurem un 'listener' per a un control JList. Suposem una llista que nom\u00e9s pot sel\u00b7leccionar un element de la llista","title":"9.- Gr\u00e0fics. Java Swing."},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#tema-9-grafics-java-swing","text":"","title":"Tema 9. Gr\u00e0fics. Java Swing"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#introduccio","text":"Fins ara hem estat utilitzant la consola i el teclat a les nostres aplicacions per tal de comunicar-nos amb l'usuari. En aquest tema utilitzarem l'API de Java per al desenvolupament de components gr\u00e0fics Swing. Swing \u00e9s un conjunt d'eines per a Java. \u00c9s una API que proporciona interf\u00edcie gr\u00e0fica d'usuari (GUI) per a programes de Java. Entre d'altres Swing cont\u00e9: frames, botons, textbox, men\u00fas a banda dels events associats als elements. Swing va ser desenvolupat per a proporcionar un conjunt m\u00e9s complex de components GUI que l'anterior Abstract Window Toolkit (AWT). Swing proporciona un aspecte i aparen\u00e7a natiu que emula diverses plataformes, tamb\u00e9 d\u00f3na suport a extensions d'aspecte i aparen\u00e7a que permeten a les aplicacions tindre un aspecte i apare\u00e7a que no guarda relaci\u00f3 amb la plataforma subjacent. Hu\u00ed en dia la majoria de desenvolupadors Java utilitzen Swing o JavaFX per construir interf\u00edcies d'usuari","title":"Introducci\u00f3"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#la-llibreria-swing","text":"Com tot en Java, swing no anava a ser menys, est\u00e0 dissenyat com una llibreria de classes, interf\u00edcies, recursos, etc.. per la construcci\u00f3 d'insterf\u00edcies gr\u00e0fiques. Swing cont\u00e9 tres APIs una per a components 2D, una altra per al Drag & Drop i l'\u00faltima per facilitar l'acc\u00e9s. Swing est\u00e0 basada en AWT per\u00f2 \u00e9s independent de la plataforma, \u00e9s a dir, sempre mostra la mateixa aparen\u00e7a independentment del sistema en el que s'execute l'aplicaci\u00f3 a difer\u00e8ncia d'AWT. Amb Swing podem fer: - Marcs: Finestres amb de t\u00edtol, men\u00fa, botons maximitzar, minimitzar i tancar. - Contenidors: poden agrupar diversos controls. - Botons - Etiqutes: text - Camps i arees de text. - Desplegables Per tal de poder utilitzar les llibreries Swing de Java hauriem d'afegir al nostre codi el seg\u00fcent: 1 import javax.swing.* ;","title":"La llibreria Swing"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#creacio-dun-jframe","text":"La difer\u00e8ncia entre crear programes que es comuniquen amb l'usuari mitjan\u00e7ant el terminal i el teclat i fer programes amb Swing \u00e9s considerable. Al crear una aplicaci\u00f3 Swing s'han de tenir en compte conceptes nous com el threading . Per\u00f2 per entendre-ho tot millor, farem un programa Swing d'exemple. Per al programa d'exemple crearem un JFrame al qual li posarem una JLabel","title":"Creaci\u00f3 d'un JFrame"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#jframe","text":"La classe JFrame \u00e9s un tipus de contenidor que hereta de la classe java.awt.Frame. JFrame funciona com la finestra principal on components com etiquetes, botons, camps de text etc, s'afegeixen per crear una interf\u00edcie gr\u00e0fica.","title":"JFrame"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#layout-manager-gestor-de-posicionament","text":"A difer\u00e8ncia d'altres aplicacions que es dediquen al disseny d'interf\u00edcies gr\u00e0fiques, les posicions dels elements dintre del nostre contenidor no es fan en pixels ni valors absoluts, s'utilitzen els Layout Manager que ho podriem traduir com \"gestors de disposici\u00f3\" o \"gestor de plantilla\" o \"gestor de posicionament\". Aquestos gestors de posicionament s\u00f3n elements que implementen la interf\u00edcie \"LayoutManager\". Cada cotenidor t\u00e9 associat un Layout Manager que pot ser: BorderLayout, FlowLayout, GridLayout, BoxLayout, GridBagLayout, CardLayout, SpringLayout... Veiem un exemple:","title":"Layout Manager - Gestor de posicionament"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#etiqutes","text":"Una etiqueta \u00e9s un component nom\u00e9s lectura al qual li podem modificar el text que cont\u00e9 i que normalment s'utilitza per posar algun missatge significatiu de la nostra interf\u00edcie a l'usuari final. En altres paraules, s\u00f3n components de text fixe que nom\u00e9s mostren text per\u00f2 que no reben cap event. Per gestionar les etiquetes a Java utilitzem la classe JLabel","title":"Etiqutes"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#botons","text":"A Swing es defineixe diversos tipus de botons, la classe base dels quals \u00e9s Abstract Button , \u00e9s una classe abstracta que encapsula propietats i m\u00e8todes comuns als diversos tipus de botons","title":"Botons"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#botons-amb-dos-estats","text":"JToogleButton \u00e9s la classe base dels botons amb dos estats; JRadioButton que s'utilitza per definir un grup de botons d'opci\u00f3 \u00fanica; per agrupar botons d'opci\u00f3 \u00fanica s'utilitza la classe ButtonGroup, primer es crea un objecte ButtonGroup (constructor sense arguments); a continuaci\u00f3 s'afegeix JRadioButton amb el m\u00e8tode de ButtonGroup, add(AbstracButton b).","title":"Botons amb dos estats"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#components-de-text","text":"Els components Swing que s'utilitzen per editar o mostrar text formen una jerarquia de classes la base de la qual \u00e9s JTextComponent; aquesta \u00faltima \u00e9s una classe abstracta que es troba al paquet java.swing.text","title":"Components de text"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#esdeveniments","text":"En aquest punt tractarem l'\u00fas dels esdeveniments per tal que la nostra aplicaci\u00f3 interactue amb l'usuari. Esdeveniment: All\u00f2 que s'esdev\u00e9. Fet considerat extraordinari o molt important en la vida d'una persona o col\u00b7lectivitat. Esdeveniment (Inform\u00e0tica): Fet que s'esdev\u00e9 o canvi d'un conjunt particular de circumst\u00e0ncies. En altres paraules un esdeveniment en una aplicaci\u00f3 inform\u00e0tica \u00e9s all\u00f3 que passa sense que necessariament estiga controlat al codi. Exemples d'esdeveniments: - Fer clic a un bot\u00f3. - Fer clic dins d'un textbox. - Minimitzar una finestra. - Escriure al teclat - etc Arribats a aquest punt podriem tindre una interf\u00edcie totalment dissenyada per\u00f2 no completament funcional, \u00e9s a dir, imagineu que hem dissenyat la interf\u00edcie per a una calculadora amb tots els seus controls necessaris. Qu\u00e8 passa si fem clic en algun bot\u00f3 de la calculadora? No res ,veritat. Encara hem de programar el comportament d'aquesta calculadora i per tal d'aconseguir-ho hem de fer \u00fas de la programaci\u00f3 d'esdeveniments. Aquest procediment es diu Event Handling i es pot aplicar a aquells elements gr\u00e0fics que produeixen algun esdeveniment. Els esdeveniments s\u00f3n essencials per als usuaris interactuen amb els components de una aplicaci\u00f3 gr\u00e0fica; el model d'esdeveniments segueix el AWT de Java. Aquest cap\u00edtol estudia la forma general de captura d'esdeveniments, la jerarquia de classes del model i les interfaces desenvolupades per a la seva captura; inclou exemples senzills de captura d\u2019esdeveniments de los botons. Veiem un exemple 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import java.awt.* ; import java.awt.event.* ; import javax.swing.* ; public class EventDemo { JLabel lab ; public EventDemo () { JFrame jfrm = new JFrame ( \"Esdeveniments\" ); jfrm . setLayout ( new FlowLayout ()); jfrm . setSize ( 220 , 90 ); jfrm . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); JButton btnAlpha = new JButton ( \"Alpha\" ); JButton btnBeta = new JButton ( \"Beta\" ); btnAlpha . addActionListener ( new ActionListener () { public void actionPerformed ( ActionEvent ae ) { lab . setText ( \"Alpha Pressed\" ); } }); btnBeta . addActionListener ( new ActionListener () { public void actionPerformed ( ActionEvent ae ) { lab . setText ( \"Beta Pressed\" ); } }); jfrm . add ( btnAlpha ); jfrm . add ( btnBeta ); lab = new JLabel ( \"Apreta un bot\u00f3\" ); jfrm . add ( lab ); jfrm . setVisible ( true ); } public static void main ( String [] args ) { SwingUtilities . invokeLater ( new Runnable () { public void run () { new EventDemo (); } }); } } El resultat seria","title":"Esdeveniments"},{"location":"Tema%2010.%20Acc%C3%A9s%20a%20dades/","text":"Tema 10. Acc\u00e9s a dades Introducci\u00f3 Fins ara hem estat treballant amb aplicacions que si necessitaven desar informaci\u00f3 o carregar-la, ho feiem utilitzant arxius o la consola d'entrada. En aquest tema veurem com podem connectar una aplicaci\u00f3 Java a una base de dades MySql. JDBC Java proporciona l\u2019API Java Database Connectivity (connectivitat Java a bases dedades) com a mecanisme per poder generar i invocar sent\u00e8ncies SQL sobre una base de dades relacional mitjan\u00e7ant codi en programes Java. La seva particularitat \u00e9s que, en contrast amb altres sistemes existents, ofereix una interf\u00edcie comuna per a l\u2019acc\u00e9s a qualsevol tipus de BD, independentment del fabricant. Per al desenvolupador, la BD real que hi ha al darrere \u00e9s totalment transparent i obvia la necessitat d\u2019efectuar cap classe de configuraci\u00f3 en la m\u00e0quina on s\u2019executa l\u2019aplicaci\u00f3 que accedeix ales dades. Aquesta biblioteca es troba principalment en els paquets java.sql i javax.sql . Partint de la suposici\u00f3 que ja hi ha una BD correctament configurada i a la qualvolem accedir des del codi d\u2019un programa Java, el resum de passos que cal fer dins l\u2019aplicaci\u00f3 \u00e9s: Importar correctament els packages corresponents Carregar el controlador (driver) per a l\u2019acc\u00e9s a la BD. Aquest dep\u00e8n de la BD a accedir. Establir la connexi\u00f3 a la BD. A partir d\u2019aqu\u00ed, ja es poden executar sent\u00e8ncies SQL en la BD i processarles respostes. Quan ja no es vol treballar m\u00e9s amb la BD, cal tancar la connexi\u00f3. JDBC, igual que moltes altres API en Java, est\u00e0 dissenyat amb la simplicitat enel pensament i intenta que l\u2019ordre de les operacions que ha de fer l\u2019operador siga gen\u00e8ric i, fins a cert punt, l\u00f2gic. Igual que per llegir dades d\u2019un fitxer el que cal fer\u00e9s dir quina \u00e9s la seva ubicaci\u00f3, obrir-lo, llegir o escriure les dades i tancar-lo, enaquest cas la idea \u00e9s similar. Simplement, \u201cllegir-lo o escriure\u2019l\u201d vol dir invocaruna sent\u00e8ncia SQL, enlloc de posicionar un apuntador. Tot i aix\u00ed, cal tenir un cert domini d\u2019SQL per poder fer correctament aquesta feina. Instal\u00b7laci\u00f3 de drivers Per poder connectar-nos a una base de dades utilitzant JDBC primer hem d'instal\u00b7lar els drivers i afegir-los al classpath per tal que siguen accessibles. Cada fabricant de sistemes gestors de bases de dades ofereix el connector JDBC per a la seua base de dades, aix\u00f2 vol dir que si la nostra aplicaci\u00f3 s'ha de connectar a una base de dades mysql, ser\u00e0 des del lloc web de MySql d'on ens haruem de descarregar el driver, mentre que si el que volem \u00e9s accedir a una base de dades Oracle, haurem d'obtenir el driver JDBC des d'Oracle. Descarregar driver A continuaci\u00f3 podeu entrar i descarregar el driver JDBC per a MySql de de la seg\u00fcent p\u00e0gina: https://dev.mysql.com/downloads/connector/j/ $ > apt install ./mysql-connector-java_8.0.24-1ubuntu20.04_all.deb $ > dpkg -i mysql-connector-java_8.0.24-1ubuntu20.04_all.deb Una vegada executades aquestos commandaments, tindrem didponible el paquest mysql-connector.jar a la ruta /usr/share/java i ara hauriem de podre afegir el paquet al classpath del nostre projecte. Afegir al Classpath All\u00f2 important \u00e9s que el fitxer que cont\u00e9 el driver mysql-connector.jar es trobe dins del classpath del projecte. Ja que anirem a eixe path per carregar-lo i utilitzar-lo al notre programa. La manera m\u00e9s facil d'afegir el paquet al classpath del nostre projecte \u00e9s amb eclipse. Fem clic dret sobre el nostre projecte i seleccionem propietats Al di\u00e0leg que s'ens obre, hem d'anar a Java Build Path i dins de la pestanya Libraries punxar sobre l'opci\u00f3 Classpath per finalment fer clic al bot\u00f3 Add External JARs . Ja nom\u00e9s ens quedaria anar a la carpeta en la qual es troba el fitxer .jar del driver i seleccionar-lo. Finalment premem el bot\u00f3 Aplicar i tancar i ja ho tindriem al path del nostre projecte. Connexi\u00f3 a la base de dades Per tal de podre connectar amb una base de dades utilitzarem els paquets java.sql i javax.sql . Dins d'aquestos paquets disposem d'una s\u00e8rie de classes,interf\u00edcies etc.. que ens serviran per poder interactuar amb el nostre sistema gestor de bases de dades. Els m\u00e9s importants s\u00f3n: la classe DriveManager i les interf\u00edcies: ResultSet , Connection , Statement i DataSource . Per tant primer, importem tant java.sql com javax.sql al nostre projecte. 1 2 import java.sql.* ; import javax.sql.* ; Una vegada ja tenim importats els paquets del driver JDBC, hem d'establir la connexi\u00f3 a la base de dades mitjan\u00e7ant un objecte connexi\u00f3 i aquest objecte connexi\u00f3 estar\u00e0 relacionat amb un String on s'emmagatzemar\u00e0 la cadena de connexi\u00f3 a la base de dades. Veiem alguns exemples de cadenes de connexi\u00f3: jdbc:mysql://localhost:port/BD jdbc:odbc:DSN_BD jdbc:oracle:usuari@servidor:port:BD Cal tindre tamb\u00e9 l'usuari i la contrassenya d'acc\u00e9s a la base de dades. Tamb\u00e9 esl pot donar el cas que es llence una excepci\u00f3, per tant, necessitarem posar el codi dins d'un bloc try..catch. En definitiva per tal d'establir una connexi\u00f3 amb la nostra base de dades en Java ho fariem de la seg\u00fcent forma: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import java.sql.* ; import javax.sql.* ; public class ConnectaBD { private Connection con ; public MySqlConnection () { try { // 1. Establim la connexi\u00f3 amb la base de dades. con = DriverManager . getConnection ( \"jdbc:mysql://localhost:3306/CicleFormatiu\" , \"root\" , \"******\" ); } catch ( Exception e ) { System . out . println ( \"Error Acc\u00e9s BD\" ); } } } I des del main o la classe Test que cont\u00e9 el m\u00e8tode main est\u00e0tic: 1 2 3 4 5 6 7 8 9 10 import java.sql.* ; import javax.sql.* ; public class TestBD { public static void main ( String [] args ) { ConnectaBD m = new ConnectaBD (); } } Arribats a aquest punt ja tindriem establerta la connexio entre la nostra aplicaci\u00f3 i la base de dades Creaci\u00f3 i execuci\u00f3 de sent\u00e8ncies SQL El seg\u00fcent pas, una vegada ja tenim establerta la connexi\u00f3 amb la nostra base de dades hem de crear un objecte Statement des del objecte connexi\u00f3 amb el m\u00e8tode createStatement() que ens retornar\u00e0 un objecte de tipus Statement . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import java.sql.* ; import javax.sql.* ; public class ConnectaBD { private Connection con ; private Statement stat ; public ConnectaBD () { try { // 1. Establim la connexi\u00f3 amb la base de dades. con = DriverManager . getConnection ( \"jdbc:mysql://localhost:3306/CicleFormatiu\" , \"root\" , \"******\" ); // 2. Creem l'objecte Statement. stat = con . createStatement (); } catch ( Exception e ) { System . out . println ( \"Error Acc\u00e9s BD\" ); } } } Ara hauriem de poder executar les sent\u00e8ncies SQL que necessitem. Per poder executar sent\u00e8ncies Sql utilitzarem el m\u00e8tode executeQuery() que \u00e9s un m\u00e8tode que pertany a l'objecte Statement anteriorment creat. Aquest m\u00e8tode ens resornar\u00e0 un ResultSet qu\u00e8 \u00e9s on tindrem la informaci\u00f3 obtesa de la base de dades. En el nostre exemple, crearem un m\u00e8otde nou a la classe MySqlConnection de tipus public al qual se li passar\u00e0 un objecte strQuery de tipus String i ens retornar\u00e0 un ResultSet. Veiem el codi c continuaci\u00f3: 1 2 3 4 5 6 7 8 9 10 11 12 public ResultSet ExecutarSQL ( String strQuery ) { ResultSet rs = null ; if ( strQuery == null ) return null ; try { rs = stat . executeQuery ( strQuery ); } catch ( Exception e ) { System . out . println ( \"Error executant SQL\" ); } return rs ; } Amb aquest codi, des de la nostra classe on es troba el m\u00e8tode main estatic podriem fer el seg\u00fcent: 1 2 3 4 5 6 7 8 9 10 11 import java.sql.* ; import javax.sql.* ; public class TestBD { public static void main ( String [] args ) { ConnectaBD m = new ConnectaBD (); ResultSet rs = m . ExecutarSQL ( \"SELECT * FROM Alumnes;\" ); } } Una vegada executat i comprovat aquest codi, deuriem tindre tots els alumnes de la nostra base de dades al ResultSet rs . Obtenci\u00f3 de dades I ara com llegim els registres de la BD? En el ResultSet que hem obt\u00e9s al pas anterior, el que tindrem ser\u00e0 una esp\u00e8cie de taula on podrem recorrer tota la informaci\u00f3. Per poder accedir a aquest resultSet podem utilitzar els m\u00e8todes getString() i next() de l'objecte resultSet .","title":"10.- Acc\u00e9s a dades"},{"location":"Tema%2010.%20Acc%C3%A9s%20a%20dades/#tema-10-acces-a-dades","text":"","title":"Tema 10. Acc\u00e9s a dades"},{"location":"Tema%2010.%20Acc%C3%A9s%20a%20dades/#introduccio","text":"Fins ara hem estat treballant amb aplicacions que si necessitaven desar informaci\u00f3 o carregar-la, ho feiem utilitzant arxius o la consola d'entrada. En aquest tema veurem com podem connectar una aplicaci\u00f3 Java a una base de dades MySql.","title":"Introducci\u00f3"},{"location":"Tema%2010.%20Acc%C3%A9s%20a%20dades/#jdbc","text":"Java proporciona l\u2019API Java Database Connectivity (connectivitat Java a bases dedades) com a mecanisme per poder generar i invocar sent\u00e8ncies SQL sobre una base de dades relacional mitjan\u00e7ant codi en programes Java. La seva particularitat \u00e9s que, en contrast amb altres sistemes existents, ofereix una interf\u00edcie comuna per a l\u2019acc\u00e9s a qualsevol tipus de BD, independentment del fabricant. Per al desenvolupador, la BD real que hi ha al darrere \u00e9s totalment transparent i obvia la necessitat d\u2019efectuar cap classe de configuraci\u00f3 en la m\u00e0quina on s\u2019executa l\u2019aplicaci\u00f3 que accedeix ales dades. Aquesta biblioteca es troba principalment en els paquets java.sql i javax.sql . Partint de la suposici\u00f3 que ja hi ha una BD correctament configurada i a la qualvolem accedir des del codi d\u2019un programa Java, el resum de passos que cal fer dins l\u2019aplicaci\u00f3 \u00e9s: Importar correctament els packages corresponents Carregar el controlador (driver) per a l\u2019acc\u00e9s a la BD. Aquest dep\u00e8n de la BD a accedir. Establir la connexi\u00f3 a la BD. A partir d\u2019aqu\u00ed, ja es poden executar sent\u00e8ncies SQL en la BD i processarles respostes. Quan ja no es vol treballar m\u00e9s amb la BD, cal tancar la connexi\u00f3. JDBC, igual que moltes altres API en Java, est\u00e0 dissenyat amb la simplicitat enel pensament i intenta que l\u2019ordre de les operacions que ha de fer l\u2019operador siga gen\u00e8ric i, fins a cert punt, l\u00f2gic. Igual que per llegir dades d\u2019un fitxer el que cal fer\u00e9s dir quina \u00e9s la seva ubicaci\u00f3, obrir-lo, llegir o escriure les dades i tancar-lo, enaquest cas la idea \u00e9s similar. Simplement, \u201cllegir-lo o escriure\u2019l\u201d vol dir invocaruna sent\u00e8ncia SQL, enlloc de posicionar un apuntador. Tot i aix\u00ed, cal tenir un cert domini d\u2019SQL per poder fer correctament aquesta feina.","title":"JDBC"},{"location":"Tema%2010.%20Acc%C3%A9s%20a%20dades/#installacio-de-drivers","text":"Per poder connectar-nos a una base de dades utilitzant JDBC primer hem d'instal\u00b7lar els drivers i afegir-los al classpath per tal que siguen accessibles. Cada fabricant de sistemes gestors de bases de dades ofereix el connector JDBC per a la seua base de dades, aix\u00f2 vol dir que si la nostra aplicaci\u00f3 s'ha de connectar a una base de dades mysql, ser\u00e0 des del lloc web de MySql d'on ens haruem de descarregar el driver, mentre que si el que volem \u00e9s accedir a una base de dades Oracle, haurem d'obtenir el driver JDBC des d'Oracle.","title":"Instal\u00b7laci\u00f3 de drivers"},{"location":"Tema%2010.%20Acc%C3%A9s%20a%20dades/#connexio-a-la-base-de-dades","text":"Per tal de podre connectar amb una base de dades utilitzarem els paquets java.sql i javax.sql . Dins d'aquestos paquets disposem d'una s\u00e8rie de classes,interf\u00edcies etc.. que ens serviran per poder interactuar amb el nostre sistema gestor de bases de dades. Els m\u00e9s importants s\u00f3n: la classe DriveManager i les interf\u00edcies: ResultSet , Connection , Statement i DataSource . Per tant primer, importem tant java.sql com javax.sql al nostre projecte. 1 2 import java.sql.* ; import javax.sql.* ; Una vegada ja tenim importats els paquets del driver JDBC, hem d'establir la connexi\u00f3 a la base de dades mitjan\u00e7ant un objecte connexi\u00f3 i aquest objecte connexi\u00f3 estar\u00e0 relacionat amb un String on s'emmagatzemar\u00e0 la cadena de connexi\u00f3 a la base de dades. Veiem alguns exemples de cadenes de connexi\u00f3: jdbc:mysql://localhost:port/BD jdbc:odbc:DSN_BD jdbc:oracle:usuari@servidor:port:BD Cal tindre tamb\u00e9 l'usuari i la contrassenya d'acc\u00e9s a la base de dades. Tamb\u00e9 esl pot donar el cas que es llence una excepci\u00f3, per tant, necessitarem posar el codi dins d'un bloc try..catch. En definitiva per tal d'establir una connexi\u00f3 amb la nostra base de dades en Java ho fariem de la seg\u00fcent forma: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import java.sql.* ; import javax.sql.* ; public class ConnectaBD { private Connection con ; public MySqlConnection () { try { // 1. Establim la connexi\u00f3 amb la base de dades. con = DriverManager . getConnection ( \"jdbc:mysql://localhost:3306/CicleFormatiu\" , \"root\" , \"******\" ); } catch ( Exception e ) { System . out . println ( \"Error Acc\u00e9s BD\" ); } } } I des del main o la classe Test que cont\u00e9 el m\u00e8tode main est\u00e0tic: 1 2 3 4 5 6 7 8 9 10 import java.sql.* ; import javax.sql.* ; public class TestBD { public static void main ( String [] args ) { ConnectaBD m = new ConnectaBD (); } } Arribats a aquest punt ja tindriem establerta la connexio entre la nostra aplicaci\u00f3 i la base de dades","title":"Connexi\u00f3 a la base de dades"},{"location":"Tema%2010.%20Acc%C3%A9s%20a%20dades/#creacio-i-execucio-de-sentencies-sql","text":"El seg\u00fcent pas, una vegada ja tenim establerta la connexi\u00f3 amb la nostra base de dades hem de crear un objecte Statement des del objecte connexi\u00f3 amb el m\u00e8tode createStatement() que ens retornar\u00e0 un objecte de tipus Statement . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import java.sql.* ; import javax.sql.* ; public class ConnectaBD { private Connection con ; private Statement stat ; public ConnectaBD () { try { // 1. Establim la connexi\u00f3 amb la base de dades. con = DriverManager . getConnection ( \"jdbc:mysql://localhost:3306/CicleFormatiu\" , \"root\" , \"******\" ); // 2. Creem l'objecte Statement. stat = con . createStatement (); } catch ( Exception e ) { System . out . println ( \"Error Acc\u00e9s BD\" ); } } } Ara hauriem de poder executar les sent\u00e8ncies SQL que necessitem. Per poder executar sent\u00e8ncies Sql utilitzarem el m\u00e8tode executeQuery() que \u00e9s un m\u00e8tode que pertany a l'objecte Statement anteriorment creat. Aquest m\u00e8tode ens resornar\u00e0 un ResultSet qu\u00e8 \u00e9s on tindrem la informaci\u00f3 obtesa de la base de dades. En el nostre exemple, crearem un m\u00e8otde nou a la classe MySqlConnection de tipus public al qual se li passar\u00e0 un objecte strQuery de tipus String i ens retornar\u00e0 un ResultSet. Veiem el codi c continuaci\u00f3: 1 2 3 4 5 6 7 8 9 10 11 12 public ResultSet ExecutarSQL ( String strQuery ) { ResultSet rs = null ; if ( strQuery == null ) return null ; try { rs = stat . executeQuery ( strQuery ); } catch ( Exception e ) { System . out . println ( \"Error executant SQL\" ); } return rs ; } Amb aquest codi, des de la nostra classe on es troba el m\u00e8tode main estatic podriem fer el seg\u00fcent: 1 2 3 4 5 6 7 8 9 10 11 import java.sql.* ; import javax.sql.* ; public class TestBD { public static void main ( String [] args ) { ConnectaBD m = new ConnectaBD (); ResultSet rs = m . ExecutarSQL ( \"SELECT * FROM Alumnes;\" ); } } Una vegada executat i comprovat aquest codi, deuriem tindre tots els alumnes de la nostra base de dades al ResultSet rs .","title":"Creaci\u00f3 i execuci\u00f3 de sent\u00e8ncies SQL"},{"location":"Tema%2010.%20Acc%C3%A9s%20a%20dades/#obtencio-de-dades","text":"I ara com llegim els registres de la BD? En el ResultSet que hem obt\u00e9s al pas anterior, el que tindrem ser\u00e0 una esp\u00e8cie de taula on podrem recorrer tota la informaci\u00f3. Per poder accedir a aquest resultSet podem utilitzar els m\u00e8todes getString() i next() de l'objecte resultSet .","title":"Obtenci\u00f3 de dades"}]}